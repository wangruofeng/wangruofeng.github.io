{"meta":{"title":"王若风的技术博客","subtitle":"世界尽头の冷酷仙境","description":"王若风的技术博客","author":"王若风","url":"https://blog.wangruofeng007.com","root":"/"},"pages":[{"title":"分类","date":"2024-11-02T05:43:56.000Z","updated":"2024-11-02T05:46:10.309Z","comments":true,"path":"categories/index.html","permalink":"https://blog.wangruofeng007.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-11-02T05:44:19.000Z","updated":"2024-11-02T05:46:14.793Z","comments":true,"path":"tags/index.html","permalink":"https://blog.wangruofeng007.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hexo 升级到 V7.3","slug":"Hexo-升级到-V7-3","date":"2024-11-02T06:04:25.000Z","updated":"2024-11-02T06:28:43.336Z","comments":true,"path":"2024/11/02/Hexo-升级到-V7-3/","permalink":"https://blog.wangruofeng007.com/2024/11/02/Hexo-%E5%8D%87%E7%BA%A7%E5%88%B0-V7-3/","excerpt":"最近换了台 Apple M2 电脑，整个软件都进行重装，Hexo 年久失修，在设置的时候出现很多警告 ⚠️，看了一下日志主要原因是以前版本依赖的 node 版本太低了，还有相关依赖库因为太旧有不少安全漏洞，查了一下 Hexo 最新发布的为 7.3 版本 ，于是打算整体迁移一下。","text":"最近换了台 Apple M2 电脑，整个软件都进行重装，Hexo 年久失修，在设置的时候出现很多警告 ⚠️，看了一下日志主要原因是以前版本依赖的 node 版本太低了，还有相关依赖库因为太旧有不少安全漏洞，查了一下 Hexo 最新发布的为 7.3 版本 ，于是打算整体迁移一下。 安装 Hexo 7.3首先 Hexo 的安装可以用 brew 了。使用 brew install hexo 安装，安装好之后 Hexo 在 /opt/homebrew/Cellar/hexo/7.3.0 下。 使用 Hexo 的如下指令完成建站 123hexo init blogcd blognpm install 当前环境配置如下： 1234hexo: 7.3.0node：v22.11.0npm：10.9.0brew：4.4.2 基本配置资源迁移：建完站之后，把之前的文章（source&#x2F;_posts）和静态资源（例如图片 source&#x2F;images）都迁移过去。 如果博客有映射自己的域名，记得把 CNAME 文件也迁移一下 配置主题：由于我定制过 Next 主题，就直接把旧项目的主题直接拷贝到新项目的 themes&#x2F;next 目录即可。如果是第一次建站需要在 themes 目录下把 Next clone 下来： 1git clone https://github.com/next-theme/hexo-theme-next.git next 配置 _config.yml 主题为 next： 1theme: next 配置语言：在_config.yml中更新博客语言配置，默认为英语 1language: zh-CN 配置链接风格：修改 _config.yml 的 permalink 生成格式，这里配置成短链风格，如下内容： 12345# 默认风格# permalink: :year/:month/:day/:title/# 将文章 url 风格调整成短链风permalink: posts/:abbrlink/ 配置分类这步配置可以参考这个帖子 打开命令行，进入博客项目所在的文件夹下，执行以下命令 1hexo new page categories 成功会有提示 1INFO Created: ~/path_to_blog/source/categories/index.md 这样我们就创建好了分类页面了。但是这个时候主题还不会识别这个页面为分类页；所以我们需要编辑这个新建的页面，让主题识别这个页面，并自动为这个页面显示分类。 编辑index.md在文件中添加 type: “categories” 12345---title: 分类date: 2024-11-02 13:43:56type: &quot;categories&quot;--- 配置标签同理 配置 tags 1hexo new page tags 成功会有提示 1INFO Created: ~/path_to_blog/source/tags/index.md 编辑index.md在文件中添加 type: “tags” 12345---title: 标签date: 2024-11-02 13:44:19type: &quot;tags&quot;--- 安装插件站内搜索安装 hexo-generator-searchdb 插件 1npm install hexo-generator-searchdb --save 在 _config.yml 中添加配置： 123456# searchsearch: path: search.json field: post format: html limit: 1000 字数统计安装 npm install hexo-word-counter 插件 , 参考 12npm install hexo-word-counterhexo clean 发布插件然后需要在 blog 根目录下安装以下插件： 1npm install hexo-deployer-git --save 因为我在 config.yml 中配置好了 deploy 信息： 1234567# Deploymentdeploy: type: git message: &quot;Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm&#x27;) &#125;&#125;&quot; repo: github: git@github.com:wangruofeng/wangruofeng.github.io.git branch: master 常用命令1234567891011121314# 发布新文章hexo new &quot;My New Post&quot;# 预览hexo s# 生成文件到 public 目录hexo g# 发布到 Github Pageshexo d# 清除缓存hexo clean 需要注意，如果改了文件发布的话，要先 hexo g ，然后再 hexo d 。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://blog.wangruofeng007.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.wangruofeng007.com/tags/Hexo/"}]},{"title":"物联网通讯协议","slug":"物联网通讯协议","date":"2024-02-24T04:16:29.000Z","updated":"2024-11-02T03:36:52.416Z","comments":true,"path":"2024/02/24/物联网通讯协议/","permalink":"https://blog.wangruofeng007.com/2024/02/24/%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/","excerpt":"物联网协议分类： 接入协议、通讯协议 接入协议：一般负责子网内设备间的组网及通信。 通讯协议：主要是运行在传统互联网TCP&#x2F;IP协议之上的设备通讯协议，负责设备通过互联网进行数据交换及通信。","text":"物联网协议分类： 接入协议、通讯协议 接入协议：一般负责子网内设备间的组网及通信。 通讯协议：主要是运行在传统互联网TCP&#x2F;IP协议之上的设备通讯协议，负责设备通过互联网进行数据交换及通信。 一、物理层、数据链路层协议1. 远距离蜂窝通讯 2G、3G、4G通讯协议 NB-loT (Narrow Brand Internet of Things) 窄带物联网 5G 2. 远距离非蜂窝通讯 WiFi ZigBee LoRa（LongRange） 3. 近距离通讯 RFID（Radio Frequency Identification）射频识别 NFC Bluetooth（BLE） UWB （Ultra Wideband）无载波无线通讯技术 4. 有线通信 USB（Universal Series Bus）通用串行总线 串口通讯协议，RS-232、RS-422 和 RS-485 以太网 MBus（symphonic mbus）远程抄表系统 二、网络层、传输协议 IPv4 IPv6 TCP（Transmission Control Protocol）传输控制协议 6LowPAN 三、应用层协议 MQTT（Message Queue Telemetry Transport）遥测传输协议 CoAP（Constrained Application Protocol）协议 REST &#x2F; HTTP协议 DDS（Data Distribution Service）分布式实时数据分发服务中间件协议 AMQP（Advanced Message Queuing Protocol）高级消息队列协议 XMPP（Extensible messaging and presence protocol 基于XML协议）可扩展通讯和表示协议 四、部分协议比较1. NB-IoT协议和LoRa协议比较第一，频段。LoRa 工作在 1GHz 以下的非授权频段，在应用时不需要额外付费，NB-IoT 和蜂窝通信使用 1GHz 以下的频段是2113授权的，是需要收费的。 第二，电池供电寿命。LoRa模块在处理干扰、网络5261重迭、可伸缩性等方面具有独特的特性，但却不能提供像蜂窝协议一样的服务质量4102。NB-IoT出于对服务质量的考虑，不能提供类似LoRa一样的电池寿命。 第三，设备成本。对终端节点来说，LoRa协议比NB-IoT更简单，更容易开发并且1653对于微处理器的适用和兼容性更好。同时低成本、技术相对成熟的LoRa模块已经可以在市场上找到了，并且还会有升级版本陆续出来。 第四，网络覆盖和部署时间表。NB-IoT标准在2016年公布，除回网络部署之外，相应的商业化和产业链的建立还需要更长的时间和努力去探索。LoRa的整个产业链相对已经较为成熟了，产品也处于“蓄势待答发”的状态，同时全球很多国家正在进行或者已经完成了全国性的网络部署。 2. 蓝牙、WiFi、ZigBee协议比较目前来说，WiFi的优势是应用广泛，已经普及到千家万户；ZigBee的优势是低功耗和自组网；UWB无载波无线通信技术的优势是传输速率；蓝牙的优势组网简单。然而，这3种技术，也都有各自的不足，没有一种技术能完全满足智能家居的全部要求。 蓝牙技术的出现使得短距离无线通信成为可能，但其协议较复杂、功耗高、成本高等特点不太适用于要求低成本、低功耗的工业控制和家庭网络。尤其蓝牙最大的障碍在于传输范围受限，一般有效的范围在10米左右，抗干扰能力不强、信息安全问题等问题也是制约其进一步发展和大规模应用的主要因素。 WiFi也是是一种短距离无线传输技术，可以随时接入无线信号，移动性强，比较适合在办公室及家庭的环境下应用。当然WiFi也存在一个致命缺点。由于WiFi采用的是射频技术，通过空气发送和接收数据，使用无线电波传输数据信号，比较容易受到外界的干扰。 ZigBee则是国际通行的无线通讯技术，它的每个网络端口可以最多接入6.5万多个端口，适合家居、工业、农业等多个领域使用，而蓝牙和WiFi网端只能接入10个端口，显然不能适应家庭需要。ZigBee还具有低功耗和低成本优势。 3. MQTT协议和CoAP协议比较MQTT是多对多通讯协议用于在不同客户端之间通过中间代理传送消息，解耦生产者与消费者，通过使得客户端发布，让代理决定路由并且拷贝消息。虽然MQTT支持一些持久化，最好还是作为实时数据通讯总线。 CoAP主要是一个点对点协议，用于在客户端与服务器之间传输状态信息。虽然支持观察资源，CoAP最好适合状态传输模型，不是完全基于事件。 MQTT客户端建立长连接TCP，这通常表示没有问题，CoAP客户端与服务器都发送与接收UDP数据包，在NAT环境中，隧道或者端口转发可以用于允许CoAP，或者像LWM2M，设备也许会先初始化前端连接。 MQTT不提供支持消息打类型标记或者其他元数据帮助客户端理解，MQTT消息可用于任何目的，但是所有的客户端必须知道向上的数据格式以允许通讯，CoAP，相反地，提供内置支持内容协商与发现，允许设备相互探测以找到交换数据的方式。 两种协议各有优缺点，选择合适的取决于自己的应用。 参考 【知识分享】您了解物联网通信协议5G、NB-Iot、LoRa、ZigBee、NFC…….都是啥吗？","categories":[],"tags":[{"name":"物联网","slug":"物联网","permalink":"https://blog.wangruofeng007.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"}]},{"title":"几分钟内本地快速搭建ChatGPT环境","slug":"几分钟内本地快速搭建ChatGPT环境","date":"2023-07-31T15:04:59.000Z","updated":"2024-11-02T03:36:52.416Z","comments":true,"path":"2023/07/31/几分钟内本地快速搭建ChatGPT环境/","permalink":"https://blog.wangruofeng007.com/2023/07/31/%E5%87%A0%E5%88%86%E9%92%9F%E5%86%85%E6%9C%AC%E5%9C%B0%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAChatGPT%E7%8E%AF%E5%A2%83/","excerpt":"简介使用Docker虚拟机，几步在本地快速搭建ChatGPT环境，免API，免翻墙，即可使用纯正OpenAI的全部功能，完全免费！","text":"简介使用Docker虚拟机，几步在本地快速搭建ChatGPT环境，免API，免翻墙，即可使用纯正OpenAI的全部功能，完全免费！ 正文下载安装Docker官网下载地址：https://www.docker.com/ 拉取pandora镜像pandora源码地址：https://github.com/pengzhile/pandora 安装好Docker后，打开Mac终端，输入以下命令 1docker pull pengzhile/pandora 启动pandora镜像等上面镜像下载完成后，输入以下命令 1docker run -e PANDORA_CLOUD=cloud -e PANDORA_SERVER=0.0.0.0:8899 -p 8899:8899 -d pengzhile/pandora 成功运行效果 获取AccessToken通过登录OpenAI官方API，登录成功后，然后访问 这里 即可拿到官方的Access Token（ps：这一步需要翻墙才能完成） 获取成功后效果图 注意：Token目前看有效期是一个月，一个月后需要重新获取 访问本地链接http://127.0.0.1:8899 使用上一步获取的Access Token登录即可 登录成功后，即可使用OpenAI的全部功能，完全免费！🎉🎉🎉","categories":[],"tags":[{"name":"ChatGPT, OpenAI, AIGC","slug":"ChatGPT-OpenAI-AIGC","permalink":"https://blog.wangruofeng007.com/tags/ChatGPT-OpenAI-AIGC/"}]},{"title":"Flutter最佳实践整理","slug":"Flutter最佳实践整理","date":"2021-03-28T04:10:21.000Z","updated":"2024-11-02T03:36:52.414Z","comments":true,"path":"2021/03/28/Flutter最佳实践整理/","permalink":"https://blog.wangruofeng007.com/2021/03/28/Flutter%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%95%B4%E7%90%86/","excerpt":"","text":"Text 以字符的方式截断https://github.com/flutter/flutter/issues/52869 在flutter中，Text控件默认的溢出显示模式是TextOverflow.fade ,就是淡出 在iOS或者Android平台默认的文件截断模式一般是…省略，flutter里面对应的截断模式为TextOverflow.ellipsis ,不过这里的截断是英文按照单词来的，这样的模式会导致如果最后一个单词很长时，截断显示会整理省略而不是最后超出的字符省略，导致模块可能有一大块空白。 Dart系统定义的截断模式 1234567891011121314151617/// How overflowing text should be handled.////// A [TextOverflow] can be passed to [Text] and [RichText] via their/// [Text.overflow] and [RichText.overflow] properties respectively.enum TextOverflow &#123; /// Clip the overflowing text to fix its container. clip, /// Fade the overflowing text to transparent. fade, /// Use an ellipsis to indicate that the text has overflowed. ellipsis, /// Render overflowing text outside of its container. visible,&#125; 如何解决英文单词被整体截断呢？ 将单词的每个字符切割开，插入宽度0的占位字符，打破系统默认的机制，这样就可以以字符为单位省略了 需要注意。这种方式相当于修改了文本的内容，一般文本最大一行显示可以用，如果文本支持2行以及以上的显示的话，将会导致换行不再按照字符进行而按照单词进行 下面是Example实现 123456789101112131415extension TextOverflowUtil on String &#123; /// 将flutter系统默认的单词截断模式转换成字符截断模式 /// 通过向文本中插入宽度为0的空格实现 static String toCharacterBreakStr(String word) &#123; if (word == null || word.isEmpty) &#123; return word; &#125; String breakWord = &#x27;&#x27;; word.runes.forEach((element) &#123; breakWord += String.fromCharCode(element); breakWord += &#x27;\\u200B&#x27;; &#125;); return breakWord; &#125;&#125; 文本划线通过Text的decoration属性来实现划线 TextDecoration.none 没有 TextDecoration.underline 下划线 TextDecoration.overline 上划线 TextDecoration.lineThrough 中间的线（删除线） &#x2F;&#x2F; 划线相关的属性设置decorationColor decoration划线的颜色decorationStyle decoration划线的样式 TextDecorationStyle.solid 实线 TextDecorationStyle.double 画两条线 TextDecorationStyle.dotted 点线（一个点一个点的） TextDecorationStyle.dashed 虚线（一个长方形一个长方形的线） TextDecorationStyle.wavy 正玄曲 效果图如下 VS Code实现保存时自动代码格式化VS Code中代码格式化默认快捷键：【Shift】+【Alt】+ F 实现手动保存（Ctril + S）时自动触发代码格式化： 1）Code → Perference → Settting 点击右上角（Open Setting(JSON) ） 2）在settings.json下的【工作区设置】中添加以下语句： 12&quot;editor.formatOnType&quot;: true,&quot;editor.formatOnSave&quot;: true 解决 setState() called after diapose()网络请求成功前退出了页面，该 State 被从对象树卸载掉，而这时回调了网络请求的方法，方法中带有 setState 的调用，也就导致了该问题。 12345if (mounted) &#123; setState(() &#123; this._books = dataModel.books; &#125;);&#125; Waiting for another flutter command to release the startup lock…等待另一个flutter命令释放启动锁 退出 VS Code。 打开 flutter 安装目录 如：…\\flutter\\flutter\\bin\\cache 删除里面的 lockfile。 重启打开VS Code。 原因：当你的项目异常关闭，下次启动就会出现上面的一行话，此时需要打开 flutter&#x2F;bin&#x2F;cache&#x2F;lockfile，删除就行了，或者直接用下面的命令：rm .&#x2F;flutter&#x2F;bin&#x2F;cache&#x2F;lockfile。 在Stateless控件内部或者浮层内部刷新，可以使用StatefullBuilder123456789101112131415161718192021222324showDialog&lt;void&gt;( context: context, builder: (BuildContext context) &#123; int selectedRadio = 0; return AlertDialog( content: StatefulBuilder( builder: (BuildContext context, StateSetter setState) &#123; return Column( mainAxisSize: MainAxisSize.min, children: List&lt;Widget&gt;.generate(4, (int index) &#123; return Radio&lt;int&gt;( value: index, groupValue: selectedRadio, onChanged: (int value) &#123; setState(() =&gt; selectedRadio = value); &#125;, ); &#125;), ); &#125;, ), ); &#125;,); 这里通过selectedRadio变量记录Radio的是否选中的状态 平台相关的判断只关心是否是iOS和Android的情况下不需要依赖context，优先使用Platform 12Platform.isAndroidPlatform.isIOS 需要详细知道具体哪个平台才使用TargetPlatform 这个API的缺点是需要依赖context这个参数 1234567final platform = Theme.of(context).platform;if (platform == TargetPlatform.android) &#123; ...&#125; else if (platform == TargetPlatform.iOS) &#123; ...&#125; ScrollView 滑动隐藏键盘https://stackoverflow.com/questions/55306855/hide-keyboard-on-scroll-in-flutter 使用ScrollView的keyboardDismissBehavior属性 123ListView( keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag) 回调写法a.无参数回调VoidCallback b.有一个参数回调ValueChanged c.参数大于一个可以通过typedef自定义一个函数 下面是Example用法 123final VoidCallback onPressed;final ValueChanged&lt;T&gt; onSelectHandler;typedef ImageSwiperOnTap = void Function(int index, List&lt;String&gt; imgUrls); flutter pub get is stuck可以通过切换flutter镜像到中文站点来解决 使用系统shell，请编辑 使用oh_my_zsh, 需要编辑.zshrc 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 保存文件后，关闭，下次重新打开终端生效 再执行flutter pub get 查看速度是否正常","categories":[{"name":"dart","slug":"dart","permalink":"https://blog.wangruofeng007.com/categories/dart/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"Flutter精华资料收集","slug":"flutter精华资料收集","date":"2020-10-19T13:16:37.000Z","updated":"2024-11-02T03:36:52.415Z","comments":true,"path":"2020/10/19/flutter精华资料收集/","permalink":"https://blog.wangruofeng007.com/2020/10/19/flutter%E7%B2%BE%E5%8D%8E%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/","excerpt":"","text":"说明此文用于记录日常flutter开发中使用到或者看到的精华文章或者资源，方便日后查阅 文章Flutter进阶 让Flutter真正支持View级别的混合开发 Dart Souls -《Dart 之魂》 Flutter完整开发实战详解系列 深入理解Flutter Platform Channel Flutter 布局控件完结篇 超详解析Flutter渲染引擎|业务想创新，不了解底层原理怎么行？ – from 淘系技术 深入理解Flutter引擎线程模式 Flutter 的性能分析、工程架构与细节处理 – from有道云 Flutter 图片控件适配之路 – from 网易云音乐 业界动态 Flutter 在哈啰出行 B 端创新业务的实践 Flutter在PLUS业务中的探索和实践 &quot;零&quot;学习成本：使用 Web 标准开发动态化 Flutter 应用 京东技术中台的 Flutter 实践之路 打破重重阻碍，Flutter 和 Web 生态如何对接？ 性能优化 Flutter性能优化实践 —— UI篇 Flutter 动态 Dart: 健全的空安全概览 深入理解 Dart 空安全 nullsafety dartpad 观摩！Flutter 1.22 正式发布 网站 Flutter 官网 Flutter 中文网 Flutter 中文开发文档 Flutter教程网 视频 Introducing Widget of the Week! Flutter by Google AliFlutter第二期直播回放 阿里巴巴闲鱼技术团队客户端负责人一起探讨Flutter的行业现状与未来 博客 咸鱼技术 - Flutter Loki的博客 — 目前就职于北京腾讯，博客里面有很flutter总结的文章 老孟flutter — 整理了几乎所有的widget，包含使用的例子，还有部分实战项目 GuruMeditation — 有一些关于flutter架构方面的文章 掘金博主 Vadaski 张风捷特烈 YYDev 老孟Flutter 闲鱼技术 电子书 Flutter 实战 — 来自duwen 是dio、fly、dsBridge等多个知名开源项目作者 工具 flutter在线编辑工具CodePen Dart 在线编辑工具 DartPad 在线JSON To Dart 代码生成 Json to Dart built_value class converter 2020年20个Flutter最漂亮的UI库和项目 优秀项目 &amp; App GSYGithubAppFlutter — 大型flutter项目， Star 10.8k Developer_quest — Google 官方演示游戏Demo，Star 2.6k Flutter Go — Ali开发的flutter组件demo演示和新闻资讯 Flutter Samples — Flutter 官方 Demo，Star 7.3k awesome-flutter — Flutter 相关的资料集合，Star 28.3k Flutter-Notebook — FlutterDemo合集, Star 5.7k FlutterUnit — 组件演示项目， Star 1.8k flutter-samples — Flutter 演示项目，很多动画效果 , Star 1.5k flutter_deer — Flutter 练手项目 ,功能很丰富， Star 4.1k FlutterExampleApps — Flutter 示例App，包含常见流行作品（WhatsApp，Instagram等）, Star 13.8k PPT AliFlutter图片解决方案与优化 UC Flutter技术实践分享","categories":[{"name":"dart","slug":"dart","permalink":"https://blog.wangruofeng007.com/categories/dart/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"},{"name":"flutter","slug":"flutter","permalink":"https://blog.wangruofeng007.com/tags/flutter/"}]},{"title":"Flutter 开发Tips （第二期）","slug":"Flutter-开发Tips-（第二期）","date":"2020-09-16T18:51:21.000Z","updated":"2024-11-02T03:36:52.414Z","comments":true,"path":"2020/09/17/Flutter-开发Tips-（第二期）/","permalink":"https://blog.wangruofeng007.com/2020/09/17/Flutter-%E5%BC%80%E5%8F%91Tips-%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%9C%9F%EF%BC%89/","excerpt":"","text":"提高flutter attach的成功率方案1断开wifi，执行flutter attach，attach成功后再链接wifi 方案2通过指定设备uuid进行attach 通过flutter devices查找已链接设备列表，获取链接设备的uuid flutter attach -d &lt;#uuid#&gt; 指定想要attach的设备进行连接，例如flutter attach -d AE5D772C-6D56-43AD-83F2-0554257B16C4 方案3通过指定应用的app-id进行attach 同一wifi环境下如果有多台相同项目设备连接中，找到你需要attach的app-id进行连接 执行：flutter attach --app-id &lt;#app_id#&gt; 例如：flutter attach --app-id com.xxx.xxx 从package中加载json文件背景例如我这里有一个flutter的demo项目叫flutter_demo_package_json_load，在根目录通过命令：flutter create --template=package json_test_package,创建了一个名为json_test_package的package，在package的assets中有一个为test2.json文件，现在需要在package中加载到改文件。 从工程加载json对于普通项目的json文件，加载方式如下： 在项目中添加json文件，例如项目的assets下有一个名为test1.json的文件 我们在yaml中添加如下依赖 12345678# 只加载assets下的test1.json文件assets: - assets/test1.json# 或者# 加载assets下的所有文件 assets: - assets/ 通过rootBundle加载 1234Future&lt;String&gt; _loadFromProjectAsset() async &#123; // json file in project,is ok return rootBundle.loadString(&quot;assets/test1.json&quot;);&#125; 但是对于package下面json文件上面的方法失效了，使用上面的方法加载将会报错，错误信息如下： 错误原因是资源路径不对，加载不到，因为rootBundle类没有提供package name的参数，我们只能把package name信息放在资源路径里面。 从package加载json灵感来自https://pub.dev/packages/lottie库的`Lottie.asset(“assetsPath”,package: “package_name”)&#96;方法，因为lottie实现动画的原理也是加载一份json配置，不过这个方法支持指定package配置。 这里的keyName就是我们rootBundle类里面需要用的资源路径，包含带package的情况。 正确的方式如下： 第一步和上面一样，将json文件添加到工程中，假如这里我们package里面的json文件名为test2.json 在yaml中添加如下依赖12345678# 只加载assets下的test2.json文件assets: - assets/test2.json# 或者# 加载assets下的所有文件assets: - assets/ 通过rootBundle加载，但是path的格式为 packages/&lt;#package_name#&gt;/&lt;#file_path#&gt; 这里为 123456// json file in package,this is workFuture&lt;String&gt; _loadFromPackageAsset() async &#123; // 【importance】 packag json file need use this formate: // `packages/$package/$assetName` return rootBundle.loadString(&quot;packages/json_test_package/assets/test2.json&quot;);&#125; 通过DefaultAssetBundle也是一样可以 1234567// This is work too.Future&lt;String&gt; testLoadJsonFileByDefaultAssetBundle(BuildContext context) &#123; // 【importance】 packag json file need use this formate: // `packages/$package/$assetName` return DefaultAssetBundle.of(context) .loadString(&#x27;packages/json_test_package/assets/test2.json&#x27;);&#125; Demo链接 flutter analyse配置步骤 在项目更目录添加analysis_options.yaml文件可以配置lint规则和analyzer行为 具体支持的lint规则参考https://dart-lang.github.io/linter/lints/ 目前有3类已经定义的常用规则 Many lints are included in various predefined rulesets: pedantic for rules enforced internally at Google effective_dart for rules corresponding to the Effective Dart style guide flutter for rules used in flutter analyze 推荐使用google团队内部的规则库pedantic 在yaml里面添加依赖 pedantic: ^1.8.0+1 在analysis_options.yaml里面引入使用 include: package:pedantic/analysis_options.1.8.0.yaml 使用配置好analysis_options.yaml文件的规则后,执行flutter analyse命令将对你整个项目或者package的代码进行静态分析 修复 根据提示修复 点击提示的规则，就会跳转到需要修复位置，按照lint规则的说明和例子就可以修正了。 利用VSCode快速修复 在提示有问题的代码的地方Ctrl +., 就会自动弹出快速修复，比如图中为增加const标识。 是不是快多了。 参考配置当然你还可以根据你的需要定制自己的静态分析规则，下面是最近使用的一套配置，仅供你参考： analysis_options.yaml参考配置 dartfmt 命令 dartfmt ./ -w 静态分析代码，并尝试自动修复 dartfmt ./ -n 静态分析代码，不会修复代码 DevTool介绍flutter提供了一个devTool系列工具，方便开发者进行调试，查看日志，网络请求，性能等信息，更多信息请参考DevTools Install DevTools Install from command line Install and run DevTools from Android Studio Install from VS Code Launch the DevTools application server启动本地web服务 1pub global run devtools # If you have `pub` on your path. or 1flutter pub global run devtools # If you have `flutter` on your path. 在命令行，你应该看到类似下面输出，表明服务启动成功 1Serving DevTools at http://127.0.0.1:9100 Start an application to debug运行app 12cd path/to/flutter/appflutter run 一旦你成功运行起来你的app，你将在终端控制台看到如下类似的信息 用浏览器打开里面的地址，格式如下 http://127.0.0.1:59681/fVO-_3yziG8=/ 打开将会看到下面的调试面板，可以根据自己的需要进行调试 这里有一个很有用的功能，【debug】 打开页面可以查看断点的帧和控制台的日志。 Open DevTools and connect to the target app一旦工程运行起来了，在浏览器打开http://localhost:9100，打开DevTools完整版本 输入上面的地址，点击Connect，跳转到完整devTools 这里的功能非常强大和具体使用可以参考官方文档 flutter 调试这里以VSCode为例 纯flutter项目纯flutter项目比较简单，VSCode支持各种devtool，使用debug模式运行app，或者直接按F5 运行成功后会出现一下工具条 控制台输出以下内容 例如这里我们在这个文件107行直接下一个断点，代码执行到时会触发断点 此时工具栏变成下面的样式 可以通过相关的按钮进行断点调试 混合项目(原生+flutter) 打开已经编译运行过的原生端App 通过VSCode打开壳工程，进入壳工程根目录 选择main.dart文件 执行cmd+shift+p,呼出VSCode命令面板，输入&gt;attach to flutter onDevice 选择下面的对应的命令执行 如果attach不上请断开wifi重试 Attach 成功的话会显示下面一条悬浮工具栏和纯flutter相比里面多了一个类似插头的按钮 Debug Console控制台也会输出下面信息 剩下的调试和上面DevTool介绍的流程一致 在这个项目里面可以直接对引用到的代码进行断点调试 参考 analyzer dartfmt Flutter Analysis Options Customizing static analysis How to access assets in package DevTools","categories":[{"name":"dart","slug":"dart","permalink":"https://blog.wangruofeng007.com/categories/dart/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"Flutter 开发Tips （第一期）","slug":"Flutter-开发Tips-（第一期）","date":"2020-09-06T17:00:18.000Z","updated":"2024-11-02T03:36:52.413Z","comments":true,"path":"2020/09/07/Flutter-开发Tips-（第一期）/","permalink":"https://blog.wangruofeng007.com/2020/09/07/Flutter-%E5%BC%80%E5%8F%91Tips-%EF%BC%88%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%89/","excerpt":"","text":"…延展操作符(...)可以对数组或者字典进行操作 12345678910111213141516171819202122// 合并数组test1() &#123; var list = [1, 2, 3]; var list2 = [0, ...list, 4]; print(list2); // [0, 1, 2, 3, 4]&#125;// 合并字典test2() &#123; var map1 = &#123; &quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;, &#125;; var map2 = &#123; &quot;key3&quot;: &quot;value3&quot;, &quot;key4&quot;: &quot;value4&quot;, &#125;; var map3 = &#123;...map1, ...map2&#125;; print(map3); // &#123;key1: value1, key2: value2, key3: value3, key4: value4&#125;&#125; for ()…[]合并widgets到集合中，使用for ()...[]范式，使用延展操作符(...)来合并一个数组的widgets到一个存在的集合中。例如在构造Row或者Column的children时，非常方便。下面是示例： 12345678910111213141516171819202122232425262728293031323334List&lt;Food&gt; foods = [ Food(name: &#x27;apple&#x27;, isVegetarian: true), Food(name: &#x27;nuts&#x27;, isVegetarian: true), Food(name: &#x27;eggs&#x27;, isVegetarian: true), Food(name: &#x27;chicken&#x27;, isVegetarian: false),];class Food &#123; Food(&#123; this.name, this.isVegetarian, &#125;); String name; bool isVegetarian;&#125;class HomePage extends StatelessWidget &#123; const HomePage(&#123;Key key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Container( child: Column( children: [ Container(), for (final food in foods) ...[ if (food.isVegetarian) ListTile(title: Text(food.name)), SizedBox(height: 50.0), ], ], ), ); &#125; () {} ()立即执行一个匿名函数：() &#123;&#125; (),相当于声明一个匿名函数并且里面执行，这种范式在处理一个widget可能有多种输出时特别有用。而不是使用镶嵌的三目运算符或者通过一个函数调用，这个代码跟内联。下面是示例： 123456789101112131415161718192021T getRandomElement&lt;T&gt;(List&lt;T&gt; list) =&gt; list[Random().nextInt(list.length)];Column( children: [ Container( color: () &#123; switch (getRandomElement(foods).name) &#123; case &#x27;apple&#x27;: return Colors.green; case &#x27;nuts&#x27;: return Colors.brown; case &#x27;eggs&#x27;: return Colors.yellow; default: return Colors.transparent; &#125; &#125;(), child: Text(&#x27;Food of the Day&#x27;), ), ], ) 代码静态分析在提交代码时为了提高代码质量，保持团队的代码风格一致，需要进行代码静态分析，一般通过下面2种方法来进行 flutter analyze使用flutter analyze进行代码静态分析,此命令会根据analysis_options.yaml定义的规则进行静态分析 dartfmt使用dartfmt ./ -w对当前目录以及子目录的dart代码进行代码,-w选项会自动重写文件使其符合规范。 使用dartfmt ./ -n显示当前目录以及子目录的dart代码格式可以修改的文件但是不做修改，可以配合ci分析代码格式问题。 更多选项请使用dartfmt --help查看 Push &amp; present &amp; Pop1234567891011121314151617// Push by routeNavigator.pushNamed(context, &#x27;/b&#x27;) // push Navigator.of(context).push(MaterialPageRoute(builder: (BuildContext context) =&gt; MyPage()));// presentNavigator.of(context).push(MaterialPageRoute(builder: (BuildContext context) =&gt; MyPage(),fullscreenDialog: true));// popNavigator.pop(context) // pop + pushNavigator.of(context) ..pop() ..pop() ..pushNamed(&#x27;/settings&#x27;); API 123456789// pushFuture push(BuildContext context, Route route)// popbool pop(BuildContext context, [ result ]) // 下面两种是等效的Navigator.push(BuildContext context, Route route)Navigator.of(context).push(Route route) 获取widget的位置和宽高123final RenderBox box = keyContext.findRenderObject();final size = box.size;final topLeftPosition = box.localToGlobal(Offset.zero); See more How to get a height of a Widget? Flutter : Widget Size and Position Model To JSONjson_serializable 引入 12345678dependencies: # Your other regular dependencies here json_annotation: ^2.0.0dev_dependencies: # Your other dev_dependencies here build_runner: ^1.0.0 json_serializable: ^2.0.0 使用 1234567891011121314151617import &#x27;package:json_annotation/json_annotation.dart&#x27;;// user.g.dart 将在我们运行生成命令后自动生成part &#x27;user.g.dart&#x27;;///这个标注是告诉生成器，这个类是需要生成Model类的@JsonSerializable()class User&#123; User(this.name, this.email); String name; String email; //不同的类使用不同的mixin即可 factory User.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$UserFromJson(json); Map&lt;String, dynamic&gt; toJson() =&gt; _$UserToJson(this);&#125; 单次解析：flutter packages pub run build_runner build 持续集成：flutter packages pub run build_runner watch json_serializable 在线json转dart model工具 Built value 在线json转build value 模板工具 https://charafau.github.io/json2builtvalue/ VSCode built value 插件 Sample code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// interface modelimport &#x27;package:built_value/built_value.dart&#x27;;part &#x27;user.g.dart&#x27;;abstract class User implements Built&lt;User, UserBuilder&gt; &#123; String get name; @nullable String get nickname; User._(); factory User([updates(UserBuilder b)]) = _$User;&#125;// initvar user1 = new User((b) =&gt; b ..name = &#x27;John Smith&#x27; ..nickname = &#x27;Joe&#x27;);// updatevar user2 = user.rebuild((b) =&gt; b ..nickname = &#x27;Jojo&#x27;);// updatevar updatedStructuredData = structuredData.rebuild((b) =&gt; b ..user.update((b) =&gt; b ..name = &#x27;Johnathan Smith&#x27;) ..credentials.phone.update((b) =&gt; b ..country = Country.switzerland ..number = &#x27;555 01234 555&#x27;));// nested buildersabstract class Node implements Built&lt;Node, NodeBuilder&gt; &#123; @nullable String get label; @nullable Node get left; @nullable Node get right; Node._(); factory Node([updates(NodeBuilder b)]) = _$Node;&#125;// new or updatevar node = new Node((b) =&gt; b ..left.left.left.right.left.right.label = &#x27;I’m a leaf!&#x27; ..left.left.right.right.label = &#x27;I’m also a leaf!&#x27;);var updatedNode = node.rebuild((b) =&gt; b ..left.left.right.right.label = &#x27;I’m not a leaf any more!&#x27; ..left.left.right.right.right.label = &#x27;I’m the leaf now!&#x27;); 参考 3 cool Dart patterns built_collection - pub.dev Dart’s built_collection for Immutable Collections dartfmt Customizing static analysis","categories":[{"name":"dart","slug":"dart","permalink":"https://blog.wangruofeng007.com/categories/dart/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"开发Flutter有哪些好用的VSCode插件","slug":"开发Flutter有哪些好用的VSCode插件","date":"2020-07-31T15:18:49.000Z","updated":"2024-11-02T03:36:52.416Z","comments":true,"path":"2020/07/31/开发Flutter有哪些好用的VSCode插件/","permalink":"https://blog.wangruofeng007.com/2020/07/31/%E5%BC%80%E5%8F%91Flutter%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84VSCode%E6%8F%92%E4%BB%B6/","excerpt":"","text":"简介这里整理了日常使用vscode开发flutter相关的插件，也有部分通用类型的插件 Flutter &amp; Dart这2个是flutter官方插件，开发flutter装机必备，不用多说。 Awesome Flutter Snippets Awesome Flutter Snippets is a collection snippets and shortcuts for commonly used Flutter functions and classes 这里面包含Flutter中非常常用的代码片段 Bracket Pair Colorizer 2 A customizable extension for colorizing matching brackets 这个插件可以使成对的括号带上不同颜色，特别适合dart这种嵌套层级很深声明式语言， 这个插件可以很方便的区分括号的开始和截止位置 ![Bracket _Pair_Colorizer_2](&#x2F;images&#x2F;flutter_plugin&#x2F;Bracket _Pair_Colorizer_2.jpg) GitLens Supercharge the Git capabilities built into Visual Studio Code — Visualize code authorship at a glance via Git blame annotations and code lens, seamlessly navigate and explore Git repositories, gain valuable insights via powerful comparison commands, and so much more 最好用的feature是在该行末尾的引人注目的当前行责任注释，可通过悬停获取详细的责任信息，当然还有很多其他的feature，请自行探索。 git相关的右键菜单 Color Highlight Highlight web colors in your editor web颜色高亮，直接将颜色对应的css显示出来，非常直观 Image Preview Shows image preview in the gutter and on hover 单鼠标悬浮在带有图片的超链接上会显示预览图片 pubspec assist Easily add and update dependencies to your Dart and Flutter project. 下面是官方的演示效果，可以直接命令搜索flutter相关库 Material Icon Theme Material Design Icons for Visual Studio Code 针对不同的文件icon和文件夹icon设计了一套主题图标 Error lens Improve highlighting of errors, warnings and other language diagnostics. 增强了语言中的错误高亮效果，使错误提示在代码后面显示 flutter-stylizer Flutter Stylizer organizes your Flutter classes in an opinionated and consistent manner. 使flutter中的代码按照下面的方式排序，方便统一约束团队代码的结构 1234567891011&quot;flutterStylizer.memberOrdering&quot;: [ &quot;public-constructor&quot;, &quot;named-constructors&quot;, &quot;public-static-variables&quot;, &quot;public-instance-variables&quot;, &quot;private-static-variables&quot;, &quot;private-instance-variables&quot;, &quot;public-override-methods&quot;, &quot;public-other-methods&quot;, &quot;build-method&quot;,], 当然这只是默认顺序，具体的顺序可以自行调整,插件安装完成后，通过快捷键格式化当前的文件 RESTClient REST Client for Visual Studio Code 在VSCode里面直接发送请求，能自动识别.http和.rest后缀的文件 点击Send Request开始发送请求。","categories":[{"name":"dart","slug":"dart","permalink":"https://blog.wangruofeng007.com/categories/dart/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"Flutter中Key的作用","slug":"Flutter中Key的作用","date":"2020-07-26T09:44:33.000Z","updated":"2024-11-02T03:36:52.414Z","comments":true,"path":"2020/07/26/Flutter中Key的作用/","permalink":"https://blog.wangruofeng007.com/2020/07/26/Flutter%E4%B8%ADKey%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"","text":"key的定义Key Class官方介绍： A [Key] is an identifier for [Widget]s, [Element]s and [SemanticsNode]s. A new widget will only be used to update an existing element if its key is the same as the key of the current widget associated with the element. {@youtube 560 315 https://www.youtube.com/watch?v=kn0EOS-ZiIc} Keys must be unique amongst the [Element]s with the same parent. Subclasses of [Key] should either subclass [LocalKey] or [GlobalKey]. 翻译过来： 一个Key是Widget，Element以及SemanticsNode的标识。 一个新widget将仅用来更新一个已存在的element假如它的key和当前widget关联的元素一致。 官方介绍视频 https://www.youtube.com/watch?v=kn0EOS-ZiIc 在有着相同父节点的element中，Key必须是唯一的。 Key的子类要么是LocalKey，要么是GlobalKey。 Key 官方介绍： Controls how one widget replaces another widget in the tree. If the runtimeType and key properties of the two widgets are operator&#x3D;&#x3D;, respectively, then the new widget replaces the old widget by updating the underlying element (i.e., by calling Element.updatewith the new widget). Otherwise, the old element is removed from the tree, the new widget is inflated into an element, and the new element is inserted into the tree. In addition, using a GlobalKey as the widget’s key allows the element to be moved around the tree (changing parent) without losing state. When a new widget is found (its key and type do not match a previous widget in the same location), but there was a widget with that same global key elsewhere in the tree in the previous frame, then that widget’s element is moved to the new location. Generally, a widget that is the only child of another widget does not need an explicit key. 翻译过来： 控制一个小部件如何替换树中的另一个小部件。 如果两个widget的runtimeType和key属性分别是相等的(&#x3D;&#x3D;)，则新widget通过更新基础element（即，通过使用新的widget调用Element.update）来替换旧widget。否则，将从树中删除旧element，将新widget放大为一个element，然后将新element插入到树中。 另外，使用GlobalKey作为窗口小部件的key允许该element在树上移动（更改父级）而不会丢失状态。当找到新的widget（其键和类型与相同位置的先前widget不匹配），但是在前一帧的树中其他位置有一个具有相同全局键的widget时，该widget的element将移至新位置。 通常，作为另一个widget的唯一child的widget不需要显式key。 Key的作用大多数时候并不需要使用key。 当需要在一个StatefulWidget集合中进行添加、删除、重排序等操作时，才是key登场的时候。 无状态组件下面这段代码在一个Row中展示了两个彩色方片（StatelessContainer），当点击按钮时，会交换两个方片的位置： 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import &#x27;dart:math&#x27;;import &#x27;package:flutter/material.dart&#x27;;class StatelessContainer extends StatelessWidget &#123; final Color color = Color.fromRGBO( Random().nextInt(256), Random().nextInt(256), Random().nextInt(256), 1); @override Widget build(BuildContext context) &#123; return Container( width: 100, height: 100, color: color, ); &#125;&#125;class Screen extends StatefulWidget &#123; @override _ScreenState createState() =&gt; _ScreenState();&#125;class _ScreenState extends State&lt;Screen&gt; &#123; List&lt;Widget&gt; widgets = [ StatelessContainer(), StatelessContainer(), ]; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Row( mainAxisAlignment: MainAxisAlignment.center, children: widgets, ), ), floatingActionButton: FloatingActionButton( onPressed: switchWidget, child: Icon(Icons.undo), ), ); &#125; switchWidget() &#123; widgets.insert(0, widgets.removeAt(1)); setState(() &#123;&#125;); &#125;&#125; 有状态组件有状态组件的状态信息（如颜色）通常是存储在state中的，而state是存储在element树中的。 那么Key到底应该用到哪呢？我们再来一个例子，我们把色块用Padding包装一下。运行之后会发现，色块并没有交换，而是以随机的形式在变换颜色。为什么呢？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import &#x27;dart:math&#x27;;import &#x27;package:flutter/material.dart&#x27;;class Screen extends StatefulWidget &#123; Screen(&#123;Key key&#125;) : super(key: key); @override _ScreenState createState() =&gt; _ScreenState();&#125;class _ScreenState extends State&lt;Screen&gt; &#123; List&lt;Widget&gt; widgets = [ Padding( padding: const EdgeInsets.all(8.0), child: StatefulContainer(key: UniqueKey()), ), Padding( padding: const EdgeInsets.all(8.0), child: StatefulContainer(key: UniqueKey()), ), ]; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Row( mainAxisAlignment: MainAxisAlignment.center, children: widgets, ), ), floatingActionButton: FloatingActionButton( onPressed: switchWidget, child: Icon(Icons.undo), ), ); &#125; switchWidget() &#123; widgets.insert(0, widgets.removeAt(1)); setState(() &#123;&#125;); print(&#x27;$&#123;widgets[0]&#125;, $&#123;widgets[1]&#125;&#x27;); &#125;&#125;class StatefulContainer extends StatefulWidget &#123; StatefulContainer(&#123;Key key&#125;) : super(key: key); @override _StatefulContainerState createState() =&gt; _StatefulContainerState();&#125;class _StatefulContainerState extends State&lt;StatefulContainer&gt; &#123; final Color color = Color.fromRGBO( Random().nextInt(256), Random().nextInt(256), Random().nextInt(256), 1); @override Widget build(BuildContext context) &#123; return Container( color: color, width: 100, height: 100, ); &#125;&#125; 结合我们上面的理论，我们分析一下这次的Widget Tree 和 Element Tree，当我们交换元素后，Flutter element-to-widget matching algorithm,(元素-组件匹配算法)，开始进行对比，算法每次只对比一层，即Padding这一层。显然，Padding并没有发生本质的变化。 于是开始进行第二层对比，在对比时Flutter发现元素与组件的Key并不匹配，于是，把它设置成不可用状态，但是这里所使用的Key只是本地Key（Local Key），Flutter并不能找到另一层里面的Key（即另外一个Padding Widget中的Key）所以，Flutter就创建了一个新的Widget，而这个Widget的颜色就成了我们看到的『随机色』。 通过上面的示例，我们能明显的看出，我们的Key要设置到组件树的 顶层，而这一层在改变时，才能复用或者更新状态。 修正版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import &#x27;dart:math&#x27;;import &#x27;package:flutter/material.dart&#x27;;class Screen extends StatefulWidget &#123; Screen(&#123;Key key&#125;) : super(key: key); @override _ScreenState createState() =&gt; _ScreenState();&#125;class _ScreenState extends State&lt;Screen&gt; &#123; List&lt;Widget&gt; widgets = [ Padding( key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulContainer(), ), Padding( key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulContainer(), ), ]; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Row( mainAxisAlignment: MainAxisAlignment.center, children: widgets, ), ), floatingActionButton: FloatingActionButton( onPressed: switchWidget, child: Icon(Icons.undo), ), ); &#125; switchWidget() &#123; widgets.insert(0, widgets.removeAt(1)); setState(() &#123;&#125;); print(&#x27;$&#123;widgets[0]&#125;, $&#123;widgets[1]&#125;&#x27;); &#125;&#125;class StatelessContainer extends StatelessWidget &#123; final Color color = Color.fromRGBO( Random().nextInt(256), Random().nextInt(256), Random().nextInt(256), 1); @override Widget build(BuildContext context) &#123; return Container( color: color, width: 100, height: 100, ); &#125;&#125;class StatefulContainer extends StatefulWidget &#123; StatefulContainer(&#123;Key key&#125;) : super(key: key); @override _StatefulContainerState createState() =&gt; _StatefulContainerState();&#125;class _StatefulContainerState extends State&lt;StatefulContainer&gt; &#123; final Color color = Color.fromRGBO( Random().nextInt(256), Random().nextInt(256), Random().nextInt(256), 1); @override Widget build(BuildContext context) &#123; return Container( color: color, width: 100, height: 100, ); &#125;&#125; Key的分类 ValueKey:以一个值为key。 ObjectKey:以一个对象为key。 UniqueKey:生成唯一的随机数作为key。 PageStorageKey:专用于存储页面滚动位置的key。 GlobalKey:见后文。 何时使用keyValueKey如果您有一个 Todo List 应用程序，它将会记录你需要完成的事情。我们假设每个 Todo 事情都各不相同，而你想要对每个 Todo 进行滑动删除操作。 这时候就需要使用 ValueKey！ 1234567return TodoItem( key: ValueKey(todo.task), todo: todo, onDismissed: (direction)&#123; _removeTodo(context, todo); &#125;,); ObjectKey如果你有一个生日应用，它可以记录某个人的生日，并用列表显示出来，同样的还是需要有一个滑动删除操作。 我们知道人名可能会重复，这时候你无法保证给 Key 的值每次都会不同。但是，当人名和生日组合起来的 Object 将具有唯一性。 这时候你需要使用 ObjectKey！ UniqueKey如果组合的 Object 都无法满足唯一性的时候，你想要确保每一个 Key 都具有唯一性。那么，你可以使用 UniqueKey。它将会通过该对象生成一个具有唯一性的 hash 码。 不过这样做，每次 Widget 被构建时都会去重新生成一个新的 UniqueKey，失去了一致性。也就是说你的小部件还是会改变。（还不如不用😂） PageStorageKey当你有一个滑动列表，你通过某一个 Item 跳转到了一个新的页面，当你返回之前的列表页面时，你发现滑动的距离回到了顶部。这时候，给 Sliver 一个 PageStorageKey！它将能够保持 Sliver 的滚动状态。 GlobalKey每个globalkey都是一个在整个应用内唯一的key。 globalkey相对而言是比较昂贵的，如果你并不需要globalkey的某些特性，那么可以考虑使用Key、ValueKey、ObjectKey或UniqueKey。 用途1允许widget在应用程序中的任何位置更改其parent而不丢失其状态。应用场景：在两个不同的屏幕上显示相同的widget，并保持状态相同。 用途2GlobalKey 能够跨 Widget 访问状态。 在这里我们有一个 Switcher 小部件，它可以通过 changeState 改变它的状态。 12345678910111213141516171819202122class SwitcherScreenState extends State&lt;SwitcherScreen&gt; &#123; bool isActive = false; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Switch.adaptive( value: isActive, onChanged: (bool currentStatus) &#123; isActive = currentStatus; setState(() &#123;&#125;); &#125;), ), ); &#125; changeState() &#123; isActive = !isActive; setState(() &#123;&#125;); &#125;&#125; 但是我们想要在外部改变该状态，这时候就需要使用 GlobalKey。 123456789101112131415class _ScreenState extends State&lt;Screen&gt; &#123; final GlobalKey&lt;SwitcherScreenState&gt; key = GlobalKey&lt;SwitcherScreenState&gt;(); @override Widget build(BuildContext context) &#123; return Scaffold( body: SwitcherScreen( key: key, ), floatingActionButton: FloatingActionButton(onPressed: () &#123; key.currentState.changeState(); &#125;), ); &#125;&#125; 这里我们通过定义了一个 GlobalKey 并传递给 SwitcherScreen。然后我们便可以通过这个 key 拿到它所绑定的 SwitcherState 并在外部调用 changeState 改变状态了。 参考资料 何时使用密钥 - Flutter小部件 101 第四集 widgets-intro#keys Flutter | 深入浅出Key Flutter中的Key和GlobalKey","categories":[{"name":"dart","slug":"dart","permalink":"https://blog.wangruofeng007.com/categories/dart/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"},{"name":"flutter","slug":"flutter","permalink":"https://blog.wangruofeng007.com/tags/flutter/"}]},{"title":"Flutter factory 使用总结","slug":"Flutter-factory-使用总结","date":"2020-07-26T08:54:39.000Z","updated":"2024-11-02T03:36:52.413Z","comments":true,"path":"2020/07/26/Flutter-factory-使用总结/","permalink":"https://blog.wangruofeng007.com/2020/07/26/Flutter-factory-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"0x01官方描述 Use the factory keyword when implementing a constructor that doesn’t always create a new instance of its class. For example, a factory constructor might return an instance from a cache, or it might return an instance of a subtype. 当实现并非总是创建其类的新实例的构造函数时，请使用“ factory”关键字。例如，工厂构造函数可能会从缓存返回一个实例，或者可能会返回一个子类型的实例。 0x02使用场景 避免创建过多的重复实例，如果该实例已创建，则直接从缓存获取。 调用子类的构造函数(工厂模式 factory pattern） 实现单例模式(singleton pattern) 0x03 Demo创建缓存实例 引用自 https://dart.dev/guides/language/language-tour#factory-constructors 123456789101112131415161718192021222324252627class Logger &#123; final String name; // 缓存Map static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;&#123;&#125;; factory Logger(String name) &#123; // name对应的key在_cache不存在，执行Logger._internal(name)，否则直接返回 return _cache.putIfAbsent(name, () =&gt; Logger._internal(name)); &#125; // 私有构造函数 Logger._internal(this.name) &#123; print(&#x27;生成新实例:$name&#x27;); &#125;&#125;void main(List&lt;String&gt; args) &#123; var p1 = Logger(&#x27;1&#x27;); var p2 = Logger(&#x27;2&#x27;); var p3 = Logger(&#x27;1&#x27;); print(identical(p1, p2)); print(identical(p1, p3)); // 生成新实例:1 // 生成新实例:2 // false // true&#125; 调用子类的构造函数12345678910111213141516171819202122232425262728293031323334353637383940414243abstract class Animal extends Object &#123; String name; void getNoise(); factory Animal(String type, String name) &#123; switch (type) &#123; case &#x27;cat&#x27;: return Cat(name); break; case &#x27;dog&#x27;: return Dog(name); break; default: throw &quot;The &#x27;$type&#x27; is not an animal&quot;; &#125; &#125;&#125;class Cat implements Animal &#123; String name; Cat(this.name); @override void getNoise() &#123; print(&#x27;$&#123;this.name&#125;:mew~&#x27;); &#125;&#125;class Dog implements Animal &#123; String name; Dog(this.name); @override void getNoise() &#123; print(&#x27;$&#123;this.name&#125;:wang~&#x27;); &#125;&#125;void main(List&lt;String&gt; args) &#123; var cat = Animal(&#x27;cat&#x27;, &#x27;haha&#x27;); var dog = Animal(&#x27;dog&#x27;, &#x27;hehe&#x27;); cat.getNoise(); dog.getNoise(); // haha:mew~ // hehe:wang~&#125; 实现单例模式12345678910111213141516class Singleton &#123; static final Singleton _singleton = Singleton._internal(); factory Singleton() &#123; return _singleton; &#125; Singleton._internal();&#125;void main(List&lt;String&gt; args) &#123; var s1 = Singleton(); var s2 = Singleton(); print(identical(s1, s2)); // true&#125;","categories":[{"name":"dart","slug":"dart","permalink":"https://blog.wangruofeng007.com/categories/dart/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"},{"name":"flutter","slug":"flutter","permalink":"https://blog.wangruofeng007.com/tags/flutter/"}]},{"title":"Flutter ShapeBorder 使用手册","slug":"Flutter-ShapeBorder-使用手册","date":"2020-07-12T11:09:55.000Z","updated":"2024-11-02T03:36:52.413Z","comments":true,"path":"2020/07/12/Flutter-ShapeBorder-使用手册/","permalink":"https://blog.wangruofeng007.com/2020/07/12/Flutter-ShapeBorder-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"简介ShapeBorder 用于设置形状和轮廓，比如圆形，矩形，圆角矩形等。常用于 Container 中。","text":"简介ShapeBorder 用于设置形状和轮廓，比如圆形，矩形，圆角矩形等。常用于 Container 中。 继承结构如下： ShapeBorder【abstract】 BeveledRectangleBorder BoxBorder【abstract】 Border BorderDirectional CircleBorder ContinuousRectangleBorder RoundedRectangleBorder StadiumBorder InputBorder【abstract】 OutlineInputBorder UnderlineInputBorder 其中 ShapeBorder、BoxBorder、InputBorder 是抽象父类。InputBorder 通常用于输入框相关的。 类的关系图 BeveledRectangleBorder斜面圆角矩形 继承关系: BeveledRectangleBorder &gt; ShapeBorder 1234567891011121314151617181920212223Widget _beveledRectangleBorder() &#123; return Center( child: Container( width: 240, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(&#x27;lib/assets/img_flutter.png&#x27;), fit: BoxFit.cover, ), shape: BeveledRectangleBorder( borderRadius: BorderRadius.circular(20), side: BorderSide( width: 2, color: Colors.blue, style: BorderStyle.solid, ), ), ), ), );&#125; 效果如下： BoxBorderBoxBorder主要掌管边线方面的事，自身是abstract，不能直接用 BoxBorder官方说明 Base class for box borders that can paint as rectangles, circles, or rounded rectangles. Border继承关系: Border &gt; BoxBorder &gt; ShapeBorder Border官方说明 A border of a box, comprised of four sides: top, right, bottom, left. 12345678910111213141516171819202122Widget _border() &#123; return Center( child: Container( margin: EdgeInsets.all(16), padding: EdgeInsets.all(16), decoration: ShapeDecoration( color: Colors.orange, shape: Border( top: BorderSide(width: 6.0, color: Colors.black12), left: BorderSide(width: 6.0, color: Colors.black12), right: BorderSide(width: 6.0, color: Colors.black26), bottom: BorderSide(width: 6.0, color: Colors.black26), ), ), child: Text( &quot;Border&quot;, style: TextStyle(color: Colors.white, fontSize: 20), ), ), );&#125; 效果图： BorderDirectional继承关系: BorderDirectional &gt; BoxBorder &gt; ShapeBorder BorderDirectional 通过 top,bottom,start,end分别控制上下左右的边线边线对象BorderSide 12345678910111213141516171819202122232425Widget _borderDirectional() &#123; return Center( child: Container( width: 240, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(&#x27;lib/assets/img_flutter.png&#x27;), fit: BoxFit.cover, ), shape: BorderDirectional( start: BorderSide(color: Colors.black, width: 15), end: BorderSide(color: Colors.black, width: 15), top: BorderSide( color: Colors.black, ), bottom: BorderSide( color: Colors.black, ), ), ), ), );&#125; 效果如下： 只设置左右的BorderSide 12345678910111213141516171819Widget _borderDirectional2() &#123; return Center( child: Container( width: 240, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(&#x27;lib/assets/img_flutter.png&#x27;), fit: BoxFit.cover, ), shape: BorderDirectional( start: BorderSide(color: Colors.black, width: 15), end: BorderSide(color: Colors.black, width: 15), ), ), ), );&#125; 效果如下： CircleBorder圆形边框。 继承关系: CircleBorder &gt; ShapeBorder 123456789101112131415161718Widget _circleBorder1() &#123; return Center( child: Container( width: 120, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(&#x27;lib/assets/img_flutter.png&#x27;), fit: BoxFit.cover, ), shape: CircleBorder( side: BorderSide(), ), ), ), );&#125; 效果如下： 上面的是使用默认参数的效果 通过设置BorderSide来设置边框颜色和宽度，以及是否显示边框 1234567891011121314151617181920212223Widget _circleBorder2() &#123; return Center( child: Container( width: 120, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(&#x27;lib/assets/img_flutter.png&#x27;), fit: BoxFit.cover, ), shape: CircleBorder( side: BorderSide( width: 10, color: Colors.blue, style: BorderStyle.solid, ), ), ), ), );&#125; 效果如下： ContinuousRectangleBorder平滑过渡的矩形边框 继承关系: ContinuousRectangleBorder &gt; ShapeBorder 123456789101112131415161718192021222324Widget _continuousRectangleBorder() &#123; return Center( child: Container( width: 240, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(&#x27;lib/assets/img_flutter.png&#x27;), fit: BoxFit.cover, ), shape: ContinuousRectangleBorder( borderRadius: BorderRadius.circular(40), side: BorderSide( width: 2, color: Colors.blue, style: BorderStyle.solid, ), ), ), ), );&#125; 效果如下： RoundedRectangleBorder圆角矩形。 继承关系: RoundedRectangleBorder &gt; ShapeBorder 1234567891011121314151617181920212223Widget _roundedRectangleBorder() &#123; return Center( child: Container( width: 240, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(&#x27;lib/assets/img_flutter.png&#x27;), fit: BoxFit.cover, ), shape: RoundedRectangleBorder( borderRadius: BorderRadius.circular(20), side: BorderSide( width: 2, color: Colors.blue, style: BorderStyle.solid, ), ), ), ), );&#125; 效果如下： StadiumBorder体育场形状。即两边是半圆。 继承关系: StadiumBorder &gt; ShapeBorder 12345678910111213141516171819202122Widget _stadiumBorder() &#123; return Center( child: Container( width: 240, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(&#x27;lib/assets/img_flutter.png&#x27;), fit: BoxFit.cover, ), shape: StadiumBorder( side: BorderSide( width: 2, color: Colors.blue, style: BorderStyle.solid, ), ), ), ), );&#125; 效果如下： InputBorder继承关系: InputBorder &gt; ShapeBorder 官方说明： Defines the appearance of an [InputDecorator]’s border. An input decorator’s border is specified by [InputDecoration.border]. The border is drawn relative to the input decorator’s “container” which is the optionally filled area above the decorator’s helper, error,and counter. 常用的输入边框，有2个衍生子类OutlineInputBorder 和UnderlineInputBorder OutlineInputBorder继承关系: OutlineInputBorder &gt; InputBorder &gt; ShapeBorder 12345678910111213141516171819Widget _outlineInputBorder() &#123; return Center( child: Container( margin: EdgeInsets.all(16), padding: EdgeInsets.all(16), decoration: ShapeDecoration( color: Colors.orange, shape: OutlineInputBorder( borderSide: BorderSide(width: 2.0, color: Colors.purple), borderRadius: BorderRadius.circular(20.0), ), ), child: Text( &quot;OutlineInputBorder&quot;, style: TextStyle(color: Colors.white, fontSize: 20), ), ), );&#125; 效果如下： UnderlineInputBorder继承关系: UnderlineInputBorder &gt; InputBorder &gt; ShapeBorder 12345678910111213141516171819Widget _underlineInputBorder() &#123; return Center( child: Container( margin: EdgeInsets.all(16), padding: EdgeInsets.all(16), decoration: ShapeDecoration( color: Colors.orange, shape: UnderlineInputBorder( borderSide: BorderSide(width: 2.0, color: Colors.purple), borderRadius: BorderRadius.circular(20.0), ), ), child: Text( &quot;UnderlineInputBorder&quot;, style: TextStyle(color: Colors.white, fontSize: 20), ), ), );&#125; 效果如下：","categories":[{"name":"dart","slug":"dart","permalink":"https://blog.wangruofeng007.com/categories/dart/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"},{"name":"flutter","slug":"flutter","permalink":"https://blog.wangruofeng007.com/tags/flutter/"}]},{"title":"VSCode Snippets 使用手册","slug":"VSCode-Snippets-使用手册","date":"2020-06-13T08:09:53.000Z","updated":"2024-11-02T03:36:52.415Z","comments":true,"path":"2020/06/13/VSCode-Snippets-使用手册/","permalink":"https://blog.wangruofeng007.com/2020/06/13/VSCode-Snippets-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"VSCode Snippets 使用手册前言当我们为了减少模板代码，我们第一个很可能想到使用Code Snippets,很多IDE和文件编辑器已经给我们提供了一个预装的代码片段，当预装的代码片段不能瞒着我们的需求，我们可能会自己定制一些自己的专有代码代码片段，下面就为大家介绍如何在VSCode定制自己的代码片段以及一些小技巧。","text":"VSCode Snippets 使用手册前言当我们为了减少模板代码，我们第一个很可能想到使用Code Snippets,很多IDE和文件编辑器已经给我们提供了一个预装的代码片段，当预装的代码片段不能瞒着我们的需求，我们可能会自己定制一些自己的专有代码代码片段，下面就为大家介绍如何在VSCode定制自己的代码片段以及一些小技巧。 如何添加方法一：通过控制台 打开VSCode,按下快捷键组合shift+command+p呼出控制台 在控制台输入： Configure User Snippets选择 输入new，找到新建代码片段命令，这里可以选择创建全局的或者为某个项目专属的代码片段,这里我们选择New Global Snippets file...。 给片段起一个易于理解的命名，回车 编辑代码片段的内容 例如我们创建一个自己名字的TODO, 类似这样的风格：// TODO(ruofeng): some comment 最终版本如下： 效果图 方法二：通过首选项 Code -&gt; Preferences-&gt;User Snippets 后面的步骤和第一种的4，5一样，这里不再赘述 使用测试新建一个.dart结尾的文件,这里就叫test.dart ,输入todo，出现了我们刚才定义的代码片段 选择todo,出现我们刚才定义的代码片段 常用语法 变量， 格式 $+num, 例如： &quot;console.log(&#39;$1&#39;);&quot; 变量占位描述,格式$&#123;num:desc&#125;,例如： &quot;$&#123;1:label&#125;, $&#123;2:another&#125;;&quot; 缩进，\\t,注意缩进的对称性 变量 为了跟进环境动态定制一些片段，我们可以使用系统提供的一些环境变量，官方介绍 示例： 我们来定义一个Xcode版本的OC默认风格代码片段 新建一个test.dart文件，在里面输入copywright，选择刚才我们的添加的代码片段，效果如下 变量转换语法说明： 1234567891011121314151617181920any ::= tabstop | placeholder | choice | variable | texttabstop ::= &#x27;$&#x27; int | &#x27;$&#123;&#x27; int &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; int transform &#x27;&#125;&#x27;placeholder ::= &#x27;$&#123;&#x27; int &#x27;:&#x27; any &#x27;&#125;&#x27;choice ::= &#x27;$&#123;&#x27; int &#x27;|&#x27; text (&#x27;,&#x27; text)* &#x27;|&#125;&#x27;variable ::= &#x27;$&#x27; var | &#x27;$&#123;&#x27; var &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; var &#x27;:&#x27; any &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; var transform &#x27;&#125;&#x27;transform ::= &#x27;/&#x27; regex &#x27;/&#x27; (format | text)+ &#x27;/&#x27; optionsformat ::= &#x27;$&#x27; int | &#x27;$&#123;&#x27; int &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; int &#x27;:&#x27; &#x27;/upcase&#x27; | &#x27;/downcase&#x27; | &#x27;/capitalize&#x27; &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; int &#x27;:+&#x27; if &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; int &#x27;:?&#x27; if &#x27;:&#x27; else &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; int &#x27;:-&#x27; else &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; int &#x27;:&#x27; else &#x27;&#125;&#x27;regex ::= JavaScript Regular Expression value (ctor-string)options ::= JavaScript Regular Expression option (ctor-options)var ::= [_a-zA-Z] [_a-zA-Z0-9]*int ::= [0-9]+text ::= .* 下面将实现读取文件名称截取掉文件的后缀效果： foo.text &#x3D;&#x3D;&gt; foo 1234567891011$&#123;TM_FILENAME/(.*)\\\\..+$/$1/&#125; | | | | | | | |-&gt; no options | | | | | |-&gt; references the contents of the first | | capture group | | | |-&gt; regex to capture everything before | the final `.suffix` | |-&gt; resolves to the filename Transform Example： Example Output Explanation &quot;$&#123;TM_FILENAME/[\\\\.]/_/&#125;&quot; example-123_456-TEST.js Replace the first . with _ &quot;$&#123;TM_FILENAME/[\\\\.-]/_/g&#125;&quot; example_123_456_TEST_js Replace each . or - with _ &quot;$&#123;TM_FILENAME/(.*)/$&#123;1:/upcase&#125;/&#125;&quot; EXAMPLE-123.456-TEST.JS Change to all uppercase &quot;$&#123;TM_FILENAME/[^0-9^a-z]//gi&#125;&quot; example123456TESTjs Remove non-alphanumeric characters Build value 代码片段插件bvtf 的实现bvtf，是上面变量和变量转换的综合应用，实现了下面功能 自动识别文件名称 将文件名称去掉后缀，转换为大写驼峰法（pascalcase） 源码获取步骤： 去github官网下载它的源码，built-value-snippets 在vscode-&gt;snippets-&gt;snippets.json 找到对应的源码，如下 12345678910111213141516171819&#123;&quot;Built Value Type File&quot;: &#123; &quot;prefix&quot;: &quot;bvtf&quot;, &quot;body&quot;: [ &quot;import &#x27;package:built_collection/built_collection.dart&#x27;;&quot;, &quot;import &#x27;package:built_value/built_value.dart&#x27;;&quot;, &quot;&quot;, &quot;part &#x27;$TM_FILENAME_BASE.g.dart&#x27;;&quot;, &quot;&quot;, &quot;abstract class $&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125; implements Built&lt;$&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125;, $&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125;Builder&gt; &#123;&quot;, &quot; $&#123;2&#125;&quot;, &quot;&quot;, &quot; $&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125;._();&quot;, &quot; factory $&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125;([void Function($&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125;Builder) updates]) = _$$&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125;;&quot;, &quot;&#125;&quot; ], &quot;description&quot;: &quot;Built Value Type File whose name corresponds to the file name&quot; &#125;&#125; 核心的变量如下： 12// file name: home_page.dart =&gt; HomePage&quot;$&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125;&quot; 通过上面的学习我们几乎可能编写我们的日常需要各种代码片段 引用 built-value-snippets Built Value Snippets VSCode 插件 Snippets in Visual Studio Code","categories":[{"name":"dart","slug":"dart","permalink":"https://blog.wangruofeng007.com/categories/dart/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"用Typora的MarkDown绘制Diagrams(图解)","slug":"用Typora的MarkDown绘制Diagrams-图解","date":"2019-11-29T08:38:05.000Z","updated":"2024-11-02T03:36:52.416Z","comments":true,"path":"2019/11/29/用Typora的MarkDown绘制Diagrams-图解/","permalink":"https://blog.wangruofeng007.com/2019/11/29/%E7%94%A8Typora%E7%9A%84MarkDown%E7%BB%98%E5%88%B6Diagrams-%E5%9B%BE%E8%A7%A3/","excerpt":"简介最近在研究软件设计领域常用各种图解，发现Typorad对MarkDown渲染diagrams的支持特别好，于是整理了一下，方便以后查阅使用，目前(测试版本0.9.9.18.1(1088))支持以下几大类图解: Sequence Flowchart Mermaid sequence (时序图) flowchart (流程图) gantt (甘特图)","text":"简介最近在研究软件设计领域常用各种图解，发现Typorad对MarkDown渲染diagrams的支持特别好，于是整理了一下，方便以后查阅使用，目前(测试版本0.9.9.18.1(1088))支持以下几大类图解: Sequence Flowchart Mermaid sequence (时序图) flowchart (流程图) gantt (甘特图) Sequence由js-sequence驱动 Flowchart由flowchart.js驱动 Mermaid由mermaid驱动，支持sequence，flowchart，gantt Sequence – 时序图UML时序图(sequence)12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？ UML时序图复杂(sequence)1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩 UML标准时序图(mermaid)123456789101112%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头sequenceDiagramparticipant 张三participant 李四张三-&gt;王五: 王五你好吗？loop 健康检查王五-&gt;王五: 与疾病战斗endNote right of 王五: 合理 食物 &lt;br/&gt;看医生...李四--&gt;&gt;张三: 很好!王五-&gt;李四: 你怎么样?李四--&gt;王五: 很好! 语法说明： 12345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow flowchart – 流程图横向流程图(mermaid)123456graph LRA[方形] --&gt;B(圆角)B --&gt; C&#123;条件a&#125;C --&gt;|a=1| D[结果1]C --&gt;|a=2| E[结果2]F[横向流程图] 竖向流程图(mermaid)123456graph TBA[方形] --&gt;B(圆角)B --&gt; C&#123;条件a&#125;C --&gt;|a=1| D[结果1]C --&gt;|a=2| E[结果2]F[竖向流程图] 标准流程图(flow)123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op 标准流程图-横向(flow)12345678910st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op 甘特图样例 (gantt)12345678910111213141516171819202122%% 语法示例ganttdateFormat YYYY-MM-DDtitle 软件开发甘特图section 设计需求:done, des1, 2014-01-06,2014-01-08原型:active, des2, 2014-01-09, 3dUI设计: des3, after des2, 5d未来任务: des4, after des3, 5dsection 开发学习准备理解需求 :crit, done, 2014-01-06,24h设计框架 :crit, done, after des2, 2d开发 :crit, active, 3d未来任务 :crit, 5d耍 :2dsection 测试功能测试 :active, a1, after des3, 3d压力测试 :after a1 , 20h测试报告 : 48h 不错的画图工具网站 https://www.processon.com https://www.draw.io 参考资料 Draw Diagrams With Markdown Typora画流程图、时序图(顺序图)、甘特图（转） mermaid mermaid-live-editor","categories":[],"tags":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"},{"name":"Typora","slug":"Typora","permalink":"https://blog.wangruofeng007.com/tags/Typora/"}]},{"title":"[转]Objective-C Runtime 大佬系列文章整理","slug":"转-Objective-C-Runtime-大佬系列文章整理","date":"2019-11-17T16:41:40.000Z","updated":"2024-11-02T03:36:52.416Z","comments":true,"path":"2019/11/18/转-Objective-C-Runtime-大佬系列文章整理/","permalink":"https://blog.wangruofeng007.com/2019/11/18/%E8%BD%AC-Objective-C-Runtime-%E5%A4%A7%E4%BD%AC%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E6%95%B4%E7%90%86/","excerpt":"简介此文转自kangzubin 收集的runtime大佬系列文章，特别鸣谢，方便后续查阅。","text":"简介此文转自kangzubin 收集的runtime大佬系列文章，特别鸣谢，方便后续查阅。 kangzubin最近重新温习了下 Objective-C Runtime 相关的知识，自己整理了两篇水文： Objective-C 1.0 中类与对象的定义 Objective-C 2.0 中类与对象的定义 然后在网上搜罗了一圈，发现很多大佬之前都写了一系列关于 Runtime 的文章，深入浅出，真是让人难以望其项背，收集如下，方便日后学习，欢迎补充。 Greg Parker Classes and metaclasses Matt Gallagher What is a meta-class in Objective-C? 南峰子 Objective-C Runtime 运行时之一：类与对象 Objective-C Runtime 运行时之二：成员变量与属性 Objective-C Runtime 运行时之三：方法与消息 Objective-C Runtime 运行时之四：Method Swizzling Objective-C Runtime 运行时之五：协议与分类 Objective-C Runtime 运行时之六：拾遗 halfrost 神经病院 Objective-C Runtime 入院第一天 —— isa 和 Class 神经病院 Objective-C Runtime 住院第二天 —— 消息发送与转发 神经病院 Objective-C Runtime 出院第三天 —— 如何正确使用 Runtime Objc 对象的今生今世 杨萧玉 Objective-C Runtime Objective-C 引用计数原理 Objective-C 消息发送与转发机制原理 雷纯锋 Objective-C 对象模型 Objective-C +load vs +initialize Objective-C Category 的实现原理 Objective-C Autorelease Pool 的实现原理 Objective-C Method Swizzling 的最佳实践 Objective-C Associated Objects 的实现原理 draveness&#x2F;analyze 从 NSObject 的初始化了解 isa 深入解析 ObjC 中方法的结构 从源代码看 ObjC 中消息的发送 你真的了解 load 方法么？ 自动释放池的前世今生 黑箱中的 retain 和 release 关联对象 AssociatedObject 完全解析 懒惰的 initialize 方法 对象是如何初始化的（iOS） CornBallast Runtime 深度解析以及实用技巧 Runtime 奇技淫巧__带你深入理解 Runtime 特有概念 Runtime 奇技淫巧__不受限制的消息发送 Runtime 奇技淫巧__获取类的实例变量以及属性并强势 与KVC、msgSend 混用 Runtime 奇技淫巧__方法交换 Runtime 奇技淫巧__动态链接对象以及给分类添加属性 Runtime 奇技淫巧__动态添加方法，消息转发改善异常 唐巧 Objective-C对象模型及应用 ibireme Objective-C 中的类和对象 sunnyxx objc 与鸭子对象（上） objc 与鸭子对象（下） 神经病院 objc runtime 入院考试 重识 Objective-C Runtime - Smalltalk 与 C 的融合 重识 Objective-C Runtime - 看透 Type 与 Value 其他此外，在简书、掘金等技术博客平台，以及 Google 上搜索 Objective-C Runtime 关键词，也能找出成千上万相关的文章。","categories":[],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"https://blog.wangruofeng007.com/tags/Runtime/"}]},{"title":"从零开始创建cocoaPods公有库","slug":"从零开始创建cocoaPods公有库","date":"2019-11-17T10:50:41.000Z","updated":"2024-11-02T03:36:52.415Z","comments":true,"path":"2019/11/17/从零开始创建cocoaPods公有库/","permalink":"https://blog.wangruofeng007.com/2019/11/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%88%9B%E5%BB%BAcocoaPods%E5%85%AC%E6%9C%89%E5%BA%93/","excerpt":"简介这篇文章记录了一个公共Pod库 RFSegmentView的创建过程","text":"简介这篇文章记录了一个公共Pod库 RFSegmentView的创建过程 注册CocoaPods账号想要创建一个开源pod库, 首先我们需要注册CocoaPods, 这里使用trunk方式, 那么只需要在终端执行（这里默认你已经安装好CocoaPods环境）: 1pod trunk register 邮箱地址 &#x27;用户名&#x27; --verbose 这里我们一般使用github邮箱和用户名, 然后在你的邮箱中会收到确认邮件,下面是确认邮件的内容： 在浏览器中点击链接确认即注册成功, 成功之后可以终端执行: 1pod trunk me 通过上面的命令查看注册信息，里面会展示该账号下的所有的Pod库，可以用此方式查看自己发布过的Pods 12345678➜ myBlog git:(master) ✗ pod trunk me - Name: wangruofeng - Email: wangruofeng007@gmail.com - Since: November 16th, 12:17 - Pods: - RFSegmentView - Sessions: - November 16th, 12:17 - March 24th, 2020 04:54. IP: 119.123.133.39 创建共享库文件并上传到公有仓库共享库需要三个必不可少的部分: 共享文件夹(文件夹存放着你要共享的内容, 也就是其他人通过pod安装得到的文件, .podspec文件中的source_files需要指定此文件路径及文件类型); LICENSE文件(默认一般选择MIT); 库名.podspec(本库的各项信息描述, 需要提交给CocoaPods, pod通过这个文件查找到你共享的库). 如果没有 podspec 文件可以用下面的命令，初始化 1pod lib create 库名 编辑.podspec文件以 RFSegmentView.podspec 为例： 1234567891011121314151617181920Pod::Spec.new do |spec| spec.name = &quot;RFSegmentView&quot; spec.version = &quot;1.3.0&quot; spec.summary = &quot;Imitate iOS7 style segmented controls, simple, practical！&quot; spec.homepage = &quot;https://github.com/wangruofeng/RFSegmentView&quot; spec.license = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE.md&quot; &#125; spec.author = &#123; &quot;wangruofeng&quot; =&gt;&quot;wangruofeng007@gmail.com&quot; &#125; spec.platform = :ios, &quot;8.0&quot; spec.source = &#123; :git =&gt; &#x27;https://github.com/wangruofeng/RFSegmentView.git&#x27;, :tag =&gt; spec.version.to_s&#125; spec.source_files = &quot;RFSegmentView/RFSegmentView.&#123;h,m&#125;&quot; # spec.exclude_files = &quot;Classes/Exclude&quot; # spec.public_header_files = &quot;Classes/**/*.h&quot; spec.frameworks = &#x27;UIKit&#x27;, &#x27;CoreGraphics&#x27;, &#x27;Foundation&#x27; spec.requires_arc = true # spec.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot; 添加依赖库end 编写完成后, 我们需要验证.podspec文件的合法性, 这里需要终端cd到.podspec文件所在文件夹, 执行: 1pod lib lint RFSegmentView.podspec 如有警告或者错误请重新检查你的编写正确性, 如果没有问题会出现 123-&gt; RFSegmentView (1.3.0) RFSegmentView passed validation. 打tag，发布新版本一切准备就绪后, 我们需要在你的git仓库里面存在一个与.podspec文件中一致的版本, 这里你可以在你的git仓库中的准备一个版本, 也可以在当前文件夹下使用终端命令: 12git tag -m &#x27;first release&#x27; &#x27;1.3.0&#x27;git push --tag #推送tag到远端仓库 成功之后即可在你分支里面看到这个tag的版本. 发布库描述文件下面我们需要发布自己的库描述文件podspec给cocoapods同样在这个文件夹下, 终端执行: 1pod trunk push RFSegmentView.podspec 将你的库文件.podspec文件提交到公有的specs上面, 这一步做的操作是验证你的podspec文件是否合法+提交到specs中+将上传的podspec文件转成json格式文件,如果重复提交会出现下面的信息: 1[!] Unable to accept duplicate entry for: RFSegmentView (1.3.0) 为了测试将RFSegmentView.podspec里面的spec.version修改成1.3.1,成功后会出现Congrats信息: 12345678910111213141516171819➜ RFSegmentView git:(master) pod trunk push RFSegmentView.podspecUpdating spec repo `trunk`Validating podspec -&gt; RFSegmentView (1.3.1) - NOTE | xcodebuild: note: Using new build system - NOTE | [iOS] xcodebuild: note: Planning build - NOTE | [iOS] xcodebuild: note: Constructing build description - NOTE | [iOS] xcodebuild: warning: Skipping code signing because the target does not have an Info.plist file and one is not being generated automatically. (in target &#x27;App&#x27; from project &#x27;App&#x27;)Updating spec repo `trunk`-------------------------------------------------------------------------------- 🎉 Congrats 🚀 RFSegmentView (1.3.1) successfully published 📅 November 17th, 07:08 🌎 https://cocoapods.org/pods/RFSegmentView 👍 Tell your friends!-------------------------------------------------------------------------------- 查找和使用新创建的库成功后需要等待的时间不定, 目前一般比较快, 一般使用pod setup和pod search查看是否已经可以使用, 如果 pod search RFSegmentView 一直搜索不到，尝试删除pod setup成功后生成的~/Library/Caches/CocoaPods/search_index.json文件, 该文是用来查找的索引文件, 终端输入: 1rm ~/Library/Caches/CocoaPods/search_index.json 删除成功后再执行:pod search 库名, 等待输出：Creating search index for spec repo &#39;master&#39;.. Done!稍等片刻就会出现你想要的结果,如果还是没有结果需要等待pod同步，过一段时间再来尝试。 更新维护podspec如果有错误或者需要迭代版本,修改工程文件后推送到远端仓库后, 需要修改podspec中的版本号, 并重新打tag上传, 再进行新一轮的验证和发布。 参考资料 CocoaPods创建公有和私有Pod库方法总结 Podspecs Podspec attributes","categories":[],"tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://blog.wangruofeng007.com/tags/CocoaPods/"}]},{"title":"Pod常用命令","slug":"Pod常用命令","date":"2019-11-14T15:45:42.000Z","updated":"2024-11-02T03:36:52.415Z","comments":true,"path":"2019/11/14/Pod常用命令/","permalink":"https://blog.wangruofeng007.com/2019/11/14/Pod%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"简介介绍Pod常用的几种命令","text":"简介介绍Pod常用的几种命令 pod init第一次调用会初始化项目，如果已经初始化后调用会抛出以下错误。 [!] Existing Podfile found in directory pod install根据podfile.lock文件中指定的pod依赖库的版更新项目的pod依赖库。在首次执行pod install命令时，如果不存在podfile.lock文件会生成该文件，并且同时生成xcworkspace文件和pods文件夹。 pod install执行后，后续的项目需要使用xxx.xcworkspace打开 参数：–no-repo-update 不更新pod仓库，使用此命令可以加快pod install的更新速度。 eg: pod install --no-repo-update pod update这个命令会检查podfile.lock文件中的pod依赖库的版本，并更新，会重新生成一个新podfile.lock文件。 选项：–exclude-pods&#x3D;xxx 只更新xxx之外的仓库。 eg: pod update --exclude-pods=AFNetworking 选项：xxx –no-repo-update 只更新xxx依赖不更新除它之外的其他依赖。 eg: pod update AFNetworking --no-repo-update 一般没有特别必要时不建议使用pod update命令,尽量使用pod install，如果实在不行再使用带上面选项的od update，如果更新失败才使用pod update命名，这样能明显加快更新流程，节约更新依赖的时间。 pod search后面更新依赖库的名称，搜索指定依赖库 eg: pod search AFNetworking 123456789101112131415161718-&gt; AFNetworking (3.2.1) A delightful iOS and OS X networking framework. pod &#x27;AFNetworking&#x27;, &#x27;~&gt; 3.2.1&#x27; - Homepage: https://github.com/AFNetworking/AFNetworking - Source: https://github.com/AFNetworking/AFNetworking.git - Versions: 3.2.1, 3.2.0, 3.1.0, 3.0.4, 3.0.3, 3.0.2, 3.0.1, 3.0.0, 3.0.0-beta.3, 3.0.0-beta.2, 3.0.0-beta.1, 2.7.0, 2.6.3, 2.6.2, 2.6.1, 2.6.0, 2.5.4, 2.5.3, 2.5.2, 2.5.1, 2.5.0, 2.4.1, 2.4.0, 2.3.1, 2.3.0, 2.2.4, 2.2.3, 2.2.2, 2.2.1, 2.2.0, 2.1.0, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 2.0.0-RC3, 2.0.0-RC2, 2.0.0-RC1, 1.3.4, 1.3.3, 1.3.2, 1.3.1, 1.3.0, 1.2.1, 1.2.0, 1.1.0, 1.0.1, 1.0, 1.0RC3, 1.0RC2, 1.0RC1, 0.10.1, 0.10.0, 0.9.2, 0.9.1, 0.9.0, 0.7.0, 0.5.1 [master repo] - Subspecs: - AFNetworking/Serialization (3.2.1) - AFNetworking/Security (3.2.1) - AFNetworking/Reachability (3.2.1) - AFNetworking/NSURLSession (3.2.1) - AFNetworking/UIKit (3.2.1) pod repo查看所有pod 仓库的源 1234master- Type: git (master)- URL: https://github.com/CocoaPods/Specs.git- Path: /Users/wangruofeng/.cocoapods/repos/master 选项：remove xxx eg: pod repo remove xxx 移除xxx repo源 pod try非常棒，却很少有人知道，使您可以在将库添加到项目之前对其进行测试驱动。 选项：try xxx 1pod try AFNetworking pod outdated显示当前 Podfile.lock文件中过期的pods，仅仅是来自spec repos，不包含来自本地和外部的资源。 gem source 操作当前gem源查看 gem source -l 123*** CURRENT SOURCES ***https://gems.ruby-china.com/ 移除指定的gem源 gem source - - remove https://rubygems.org/ 添加指定的gem源 gem source - a https://gems.ruby-china.com/ 更新cocoapod sudo gem install cocoapods","categories":[],"tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://blog.wangruofeng007.com/tags/CocoaPods/"},{"name":"Skill","slug":"Skill","permalink":"https://blog.wangruofeng007.com/tags/Skill/"}]},{"title":"从Octopress迁移博客到hexo","slug":"从Octopress迁移博客到hexo","date":"2019-11-10T10:16:11.000Z","updated":"2024-11-02T06:08:23.409Z","comments":true,"path":"2019/11/10/从Octopress迁移博客到hexo/","permalink":"https://blog.wangruofeng007.com/2019/11/10/%E4%BB%8EOctopress%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%88%B0hexo/","excerpt":"","text":"简介最近准备更新博客（以前的基于Octopress），去写的时候突然发现以前的博客跑不起来了。。。倒腾了一下，在执行博客更新时rake generate，一直报错，错误出现在高亮解析模块 Pygments，尝试升级jekyll但是和它相关的依赖模块还是有问题。 1234567➜ Octopress git:(source) ✗ rake generate## Generating Site with JekyllConfiguration file: /Users/wangruofeng/Documents/Git Repositories/Octopress/_config.yml Source: source Destination: public Generating... jekyll 2.5.3 | Error: Pygments can&#x27;t parse unknown language: objective-c. 后面去Octopress官网查了了，发现上次更新还是2015.01.15的事了，后续也没有更新，于是觉得这个不太靠谱，准备换一个，调研了一下，发现使用hexo的挺多，于是开始捣腾起来。。。 准备环境\b准备 node 和 git 环境， 首先，安装 NodeJS，因为 Hexo 是基于 Node.js 驱动的一款博客框架。 在命令行中输入相应命令验证是否成功，如果成功会有相应的版本号。 123456➜ myBlog git:(master) ✗ git versiongit version 2.24.0➜ myBlog git:(master) ✗ node -vv12.13.0➜ myBlog git:(master) ✗ npm -v6.12.0 安装Hexo如果以上环境准备好了就可以使用 npm 开始安装 Hexo 了。也可查看 Hexo 的详细文档。 在命令行输入执行以下\b命令： 1npm install -g hexo-cli 没有权限的话可能会出现下面的错误信息: 12345678910111213npm ERR! code EACCESnpm ERR! syscall mkdirnpm ERR! path /Users/wangruofeng/.npm/_cacache/content-v2/sha512/0b/8anpm ERR! errno -13npm ERR! npm ERR! Your cache folder contains root-owned files, due to a bug innpm ERR! previous versions of npm which has since been addressed.npm ERR! npm ERR! To permanently fix this problem, please run:npm ERR! sudo chown -R 501:20 &quot;/Users/wangruofeng/.npm&quot;npm ERR! A complete log of this run can be found in:npm ERR! /Users/wangruofeng/.npm/_logs/2019-11-10T07_21_42_135Z-debug.log 报错的话加上 sudo重试一次或者执行sudo chown -R 501:20 “&#x2F;Users&#x2F;wangruofeng&#x2F;.npm” 1234➜ Git Repositories sudo npm install -g hexo-cli/usr/local/Cellar/node/5.7.0/bin/hexo -&gt; /usr/local/Cellar/node/5.7.0/lib/node_modules/hexo-cli/bin/hexo+ hexo-cli@3.1.0added 67 packages from 317 contributors in 27.347s 安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123hexo init myBlogcd myBlognpm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 ├── package.json├── scaffolds # 模版文件夹├── source # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹| ├── _drafts # 草稿文件| └── _posts # 文章Markdowm文件 └── themes # 主题文件夹 好了，如果上面的\b命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的\b缩写，在浏览器中输入 http://localhost:4000 回车就可以预览效果了。 1hexo s 至此，你本地的博客就已经搭建成功，接下来就是部署到 Github Page 了。 部署到GitHub此时，本地和Github的工作做得差不了，是时候把它们两个连接起来了。你\b也可以查看官网的部署教程。 先不着急，部署之前还需要修改配置和安装部署插件。 第一：打开项目根目录下的 _config.yml 配置文件\b配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）： 1234567# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repo: github: https://github.com/wangruofeng/wangruofeng.github.io.git branch: master 第二：要安装一个部署\b插件 hexo-deployer-git。 1npm install hexo-deployer-git --save 最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写 1hexo g -d 稍等一会，在浏览器访问网址： https:&#x2F;&#x2F;你的用户名.github.io 就会看到你的博客啦！！ 开始写作博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档可以看 hexo 官网。 新建文章，输入以下命令即可 1hexo new &#x27;文章标题&#x27; 执行完成后可以在 &#x2F;source&#x2F;_posts 下看到一个“文章标题.md”的文章文件啦。.md 就是 Markdown 格式的文件，具体用法可以在网上找一下，语法还是比较简单的。 在 Markdown 文章里面输入你的文章内容 再执行一下以下命令 12hexo g # 生成相关文件hexo s # 部署到本地 最后，只要部署到你的 Github 上就可以了！ 12hexo cleanhexo g -d 部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 另外，如果你的文章暂时不发布可以先保存在草稿里面。生成草稿的方法和文章差不多 hexo new draft “文章标题”，生成后会在 &#x2F;source&#x2F;_drafts 里看到你的草稿文章。当你想发布时只要执行 publish 命令即可发布到博客。 1hexo publish [layout] &lt;filename&gt; 遇到的坑1. Hexo: TypeError: Cannot set property ‘lastIndex’ of undefined解决方案是 将你工程下的 _config.yml (这个不是主题的_config.yml) 文件里面的 auto_detect 设置为 false。 12345highlight: enable: true line_number: true auto_detect: false tab_replace: 2.修改完 hexo 目录下的 _config.yml 文件 重新 generate 文件不生效使用 hexo 的命令 hexo clean,清除一下。 参考链接 运行 hexo g 出错 #1913 有哪些好看的 Hexo 主题？ 超详细Hexo+Github Page搭建技术博客教程【持续更新】","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://blog.wangruofeng007.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.wangruofeng007.com/tags/Hexo/"}]},{"title":"NSNumber转NSString丢精问题","slug":"2017-10-14-nsnumberzhuan-nsstringdiu-jing-wen-ti","date":"2017-10-14T12:53:01.000Z","updated":"2024-11-02T03:36:52.412Z","comments":true,"path":"2017/10/14/2017-10-14-nsnumberzhuan-nsstringdiu-jing-wen-ti/","permalink":"https://blog.wangruofeng007.com/2017/10/14/2017-10-14-nsnumberzhuan-nsstringdiu-jing-wen-ti/","excerpt":"","text":"问题引出在开发中，涉及价格金额处理，后台会返回Number类型的数据，打印或者经过Json转Model后的NSString可能出现精度丢失的问题，如果涉及到金额的加减乘除运算问题将暴露得更为明显。这里就iOS数据精度处理做一个总结。 问题复现NSNumber转NSSting12345678910111213141516171819202122232425262728293031323334NSArray *numbers = @[ @99.00, @99.09, @99.19, @99.29, @99.39, @99.49, @99.59, @99.69, @99.79, @99.89, @99.99, ];for (int i = 0; i &lt; numbers.count; i++) &#123; NSNumber *number = numbers[i]; NSString *strValue = [number stringValue]; NSLog(@&quot;strValue:%@&quot;,strValue);&#125;/* oldVlue:99.00 strValue:99 oldVlue:99.09 strValue:99.09 oldVlue:99.19 strValue:99.19 oldVlue:99.29 strValue:99.29000000000001 oldVlue:99.39 strValue:99.39 oldVlue:99.48 strValue:99.48999999999999 oldVlue:99.59 strValue:99.59 oldVlue:99.69 strValue:99.69 oldVlue:99.79 strValue:99.79000000000001 oldVlue:99.89 strValue:99.89 oldVlue:99.99 strValue:99.98999999999999 */ 在这里我们发现将NSNumber转换成NSSting的过程中可能会出现精度丢失。 Json到Model12345678910111213141516171819//出现BUG的条件必须是两位数，且带两位小数，类型还必须是float//两位数：十位必须是7、8、9；个位数随意//两位小数：个位数随意；十位数必须是0NSString *jsonStr = @&quot;&#123;\\&quot;71.40\\&quot;:71.40, \\&quot;97.40\\&quot;:97.40, \\&quot;80.40\\&quot;:80.40, \\&quot;188.40\\&quot;:188.40&#125;&quot;;NSLog(@&quot;json:%@&quot;, jsonStr);NSData *jsonData = [jsonStr dataUsingEncoding:NSUTF8StringEncoding];NSError *jsonParsingError = nil;NSDictionary *dic = [NSMutableDictionary dictionaryWithDictionary:[NSJSONSerialization JSONObjectWithData:jsonData options:0 error:&amp;jsonParsingError]];NSLog(@&quot;dic:%@&quot;, dic);/*2017-10-14 18:29:19.434 FloatTransferDemo[62722:3093992] dic:&#123; &quot;188.40&quot; = &quot;188.4&quot;; &quot;71.40&quot; = &quot;71.40000000000001&quot;; &quot;80.40&quot; = &quot;80.40000000000001&quot;; &quot;97.40&quot; = &quot;97.40000000000001&quot;;&#125;*/ 在这里我们发现将Json解析成Model的过程中可能会出现精度丢失。 问题分析因为浮点数在计算机中是采用IEEE规定的标准浮点格式，即二进制科学表示法。在这种表示法中，一个数 S = M * 2 ^ N。 其中N表示阶码，M表示位数(有效数字位)。例如一个float类型的浮点，在32bit位上，占4个字节，字节表示为 【31】N:【30 ~ 23】 M:【22~0】 31位表示符号位: 0正，1负 中间8位是阶码位: 表示范围【-128 ~ 127】,对于float类型数据规定其偏移量为127 后面23位是有效数字位: 因为科学计数法，整数位定死了是1，所以这里记录的是小数点后面的二进制为 指数N决定它的范围，因为M总是一个以1开头的小数，以float来说即是：-2 ^ 128 ~ 2 ^ 128,即float能表示的数的大小的范围。 而它的精度是由位数(也就是有效的数据位)来决定的， 2 ^ 23 &#x3D; 8388608，总共7位，表示最多能用7位有效数字，最多能表示到.8388708即小数点后7位，由于不能完全表示全部的7位数，所以它的精度范围是6位~7位。 同理可得double的精度是2 ^ 52 &#x3D; 4503599627370496， 共16位，所以精度为15 ~ 16位。 总结：float&#x2F;double类型的范围和精度的计算方式不同机器字节序的规定 公式： S = M * 2 ^ N 二进制在内存中是以补码形式存储，负数要对其二进制绝对值按位取反再加一，正数的补码与原码形式相同 也就是说float和doublel类型数据在计算机中存储可能是不精确的。当我们需要转换成浮点类型是数据时，最好用double，因为double的精度更高，出现丢精度的概率相对是较小的。 在iOS中提供一个专用的类来处理浮点数据相关的运算：NSDecimalNumber 解决方案使用NSDecimalNumber来进行浮点数处理。我们给NSString添加一个分类来处理浮点运算问题 1234567891011121314151617181920212223242526272829///.h@interface NSString (DecimalNumber)+ (NSString *)decimalNumberWithNSNumber:(NSNumber * )number;+ (NSString *)decimalNumberWithDouble:(double)conversionValue;@end///.m#import &quot;NSString+DecimalNumber.h&quot;@implementation NSString (DecimalNumber)+ (NSString *)decimalNumberWithNSNumber:(NSNumber * )number&#123; double conversionValue = [number doubleValue]; NSString *doubleString = [NSString stringWithFormat:@&quot;%lf&quot;, conversionValue]; NSDecimalNumber *decNumber = [NSDecimalNumber decimalNumberWithString:doubleString]; return [decNumber stringValue];&#125;+ (NSString *)decimalNumberWithDouble:(double)conversionValue&#123; NSString *doubleString = [NSString stringWithFormat:@&quot;%lf&quot;, conversionValue]; NSDecimalNumber *decNumber = [NSDecimalNumber decimalNumberWithString:doubleString]; return [decNumber stringValue];&#125;@end 如何使用12345678910111213141516171819202122232425262728293031323334NSArray *numbers = @[ @99.00, @99.09, @99.19, @99.29, @99.39, @99.49, @99.59, @99.69, @99.79, @99.89, @99.99, ];for (int i = 0; i &lt; numbers.count; i++) &#123; NSNumber *number = numbers[i]; NSString *strValue = [NSString decimalNumberWithNSNumber:number]; NSLog(@&quot;strValue:%@&quot;,strValue);&#125;/* oldVlue:99.00 strValue:99 oldVlue:99.09 strValue:99.09 oldVlue:99.19 strValue:99.19 oldVlue:99.29 strValue:99.29 oldVlue:99.39 strValue:99.39 oldVlue:99.48 strValue:99.49 oldVlue:99.59 strValue:99.59 oldVlue:99.69 strValue:99.69 oldVlue:99.79 strValue:99.79 oldVlue:99.89 strValue:99.89 oldVlue:99.99 strValue:99.99 */ 问题得以解决。☕️ 参考资料： https://developer.apple.com/documentation/foundation/nsdecimalnumber http://www.jianshu.com/p/4703d704c953 https://eezytutorials.com/ios/nsdecimalnumber-by-example.php http://www.skyfox.org/ios-nsdecimalnumber-use.html https://stackoverflow.com/questions/421463/should-i-use-nsdecimalnumber-to-deal-with-money","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"NSSortDescriptor正确的打开方式","slug":"2017-06-07-nssortdescriptorzheng-que-de-da-kai-fang-shi","date":"2017-06-06T16:09:44.000Z","updated":"2024-11-02T03:36:52.412Z","comments":true,"path":"2017/06/07/2017-06-07-nssortdescriptorzheng-que-de-da-kai-fang-shi/","permalink":"https://blog.wangruofeng007.com/2017/06/07/2017-06-07-nssortdescriptorzheng-que-de-da-kai-fang-shi/","excerpt":"","text":"排序是应用常见需求之一，如何正确优雅的实现一个排序，NSSortDescriptor或许是一个非常好的选择。 NSSortDescriptor由3个参数组成： key(键):对于一个给定的集合，将对集合种的每个对象按照该键来进行排序 ascending(升序):指定集合按照升序(YES)还是降序(NO)进行排序 selector(方法子):排序时的比较函数，当对字符串进行排序时，应当加入localizedStandardCompare:选择器，它将根据语言规则进行排序(例如大小写，变音符号等等的顺序) 如何使用NSSortDescriptor主要针对各种集合排序,NSArray,NSMutableArray,NSSet,NSOrderedSet,NSMutableOrderedSet 如果集合是可变的，则对集合本身排序例如 NSMutableOrderedSet的sortUsingDescriptors: NSMutableArray的sortUsingDescriptors: 如果集合是可变的，则返回一个排好序的新集合例如 NSArray的sortedArrayUsingDescriptors: NSSet的sortedArrayUsingDescriptors: NSOrderedSet的sortedArrayUsingDescriptors: 注意排序描述是一个数组，也就是排序可以支持按照多个描述综合排序。如果存在多个规则先满足前面的规则再满足后面的规则。例如两个元素按照第一天规则顺序一致，那么如果还存在第二天规则，它们将按照第二条规则继续排序，如果前面的规则已经区分出顺序后面的规则将失效。 实例说明为了更好的描述，假如我们有一个Person对象，它有**NSString * **类型的姓和名属性，以及一个NSNumber类型的年龄属性。 1234567@interface Person : NSObject@property (nonatomic, copy ) NSString *firstName;@property (nonatomic, copy ) NSString *lastName;@property (nonatomic, strong) NSNumber *age;@end 给定以下数据集： index 0 1 2 3 4 firstName Alice Bod Charlie Quentin lastName Smith Jones Smith Alberts age 24 27 33 31 19 使用不同的NSSortDescriptor的不同组合来将它们排序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051NSArray *firstNames = @[@&quot;Alice&quot;, @&quot;Bod&quot;, @&quot;Charlie&quot;, @&quot;Quentin&quot;, @&quot;&quot;];NSArray *lastNames = @[@&quot;Smith&quot;, @&quot;Jones&quot;, @&quot;Smith&quot;, @&quot;&quot;, @&quot;Alberts&quot;];NSArray *ages = @[@24, @27, @33, @31, @12];NSMutableArray *people = [NSMutableArray array];[firstNames enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; Person *person = [[Person alloc] init]; person.firstName = [firstNames objectAtIndex:idx]; person.lastName = [lastNames objectAtIndex:idx]; person.age = [ages objectAtIndex:idx]; [people addObject:person];&#125;];NSSortDescriptor *firstNameSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;firstName&quot; ascending:YES selector:@selector(localizedStandardCompare:)];NSSortDescriptor *lastNameSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;lastName&quot; ascending:YES selector:@selector(localizedStandardCompare:)];NSSortDescriptor *ageSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;age&quot; ascending:NO];NSLog(@&quot;By age: %@&quot;,[people sortedArrayUsingDescriptors:@[ageSortDescriptor]]);/* 2017-06-06 23:15:02.101 NSSort​Descriptor_Demo[9103:1255482] By age: ( &quot;Charlie Smith 33&quot;, &quot;Quentin 31&quot;, &quot;Bod Jones 27&quot;, &quot;Alice Smith 24&quot;, &quot; Alberts 12&quot; ) */NSLog(@&quot;By first name: %@&quot;,[people sortedArrayUsingDescriptors:@[firstNameSortDescriptor]]);/* 2017-06-06 23:15:02.102 NSSort​Descriptor_Demo[9103:1255482] By first name: ( &quot; Alberts 12&quot;, &quot;Alice Smith 24&quot;, &quot;Bod Jones 27&quot;, &quot;Charlie Smith 33&quot;, &quot;Quentin 31&quot; )*/ NSLog(@&quot;By last name, first name: %@&quot;,[people sortedArrayUsingDescriptors:@[lastNameSortDescriptor ,firstNameSortDescriptor]]);/* 2017-06-06 23:15:02.102 NSSort​Descriptor_Demo[9103:1255482] By last name, first name: ( &quot;Quentin 31&quot;, &quot; Alberts 12&quot;, &quot;Bod Jones 27&quot;, &quot;Alice Smith 24&quot;, &quot;Charlie Smith 33&quot; ) */ 注意事项 空字符是排在普通字符之前的 基本数据类型需要包装成NSNumber对象来排序 字符串类型排序需要加入localizedStandardCompare:选择器 参考链接 NSSort​Descriptor – NSHipster","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"从OC到Swift你要知道的事","slug":"2017-03-10-cong-ocdao-swiftni-yao-zhi-dao-de-shi","date":"2017-03-10T15:04:24.000Z","updated":"2024-11-02T03:36:52.412Z","comments":true,"path":"2017/03/10/2017-03-10-cong-ocdao-swiftni-yao-zhi-dao-de-shi/","permalink":"https://blog.wangruofeng007.com/2017/03/10/2017-03-10-cong-ocdao-swiftni-yao-zhi-dao-de-shi/","excerpt":"","text":"枚举概述Swift中枚举和结构体也上升到对象的位置，但是却不具备完整的对象特征，比如说他们不能继承。 在OC中枚举本质其实是整数类型，只是给他们取了一些意义直观的名称而已，而Swift完全摆脱以前的思想的束缚编的更自由，拥有了以下特征。 类型更广，不限于整形，可以是Character，String，Float，Double等，这些叫做原始值 可以拥有自己的静态成员变量来储存一些常量 可以拥有自己的方法和变量 case条件匹配可以定义参数，可以使用where来过滤 通过rawValue可以拿到枚举的原始值 原始值如果提供了原始值，就可以在case声明成员时提供默认值，这样跟OC的枚举在结构上一些类似 1234567enum WeekDays : Int &#123; case Monday = 0 case Tuesday = 1 case Wednesday = 2 case Thursday = 3 case Friday = 4&#125; 1.声明一个枚举值 1let monday = WeekDays.Monday 2.获取原始值 1let rawVlaue = WeekDays.Tuesday.rawValue 3.通过原始值构造某个枚举变量 1let wednesday = WeekDays.init(rawValue: 2) 相关值和C的联合体有点类似 1.声明 1234enum Figure &#123; case Rectangle(Int, Int) case Circle(Int)&#125; 2.使用 123456789101112131415func printFigure(figure: Figure) &#123; switch figure &#123; case .Rectangle(let width, let height): print(&quot;width:\\(width), height:\\(height)&quot;) case .Circle(let radius): print(&quot;the circle&#x27;s radius is:\\(radius)&quot;) &#125;&#125;var figure = Figure.Rectangle(1024, 768)printFigure(figure)figure = .Circle(600)printFigure(figure) OC与Swift中Options枚举的不同定义OC版本NS_OPTIONS123456789typedef NS_OPTIONS(NSUInteger, NSVolumeEnumerationOptions) &#123; /* The mounted volume enumeration will skip hidden volumes. */ NSVolumeEnumerationSkipHiddenVolumes = 1UL &lt;&lt; 1, /* The mounted volume enumeration will produce file reference URLs rather than path-based URLs. */ NSVolumeEnumerationProduceFileReferenceURLs = 1UL &lt;&lt; 2&#125; Swift版本OPTIONS12345struct NSVolumeEnumerationOptions : OptionSetType &#123; init(rawValue rawValue: UInt) static var SkipHiddenVolumes: NSVolumeEnumerationOptions &#123; get &#125; static var ProduceFileReferenceURLs: NSVolumeEnumerationOptions &#123; get &#125;&#125; 使用12345UIView.animateWithDuration(0.3, delay: 0.0, options: [.CurveEaseIn, .AllowUserInteraction], animations: &#123;&#125;, completion: nil) 结构体Swift中加强了结构体的能力，可以定义和使用属性，方法，下标，构造器等，但是不能被继承，没有强制类型抓换，使用析构器和引用计数等能力 通常使用结构体来充当数据模型，常量可以使用静态关键词static标示 循环引用Swift中解决循环强引用的方式 弱引用 – weak 无主引用 – unowned 解决闭包中循环引用[unowned 捕获对象]或者[weak 捕获对象] 使用实例 123456789101112131415161718192021222324252627class Person &#123; let name: String // 写法1// lazy var printName: () -&gt;() = &#123;// [weak self] in if let strongSelf = self &#123;// print(&quot;The name is \\(strongSelf.name)&quot;)// &#125;// &#125; // 写法2 lazy var printName: () -&gt;() = &#123; [unowned self] in print(&quot;The name is \\(self.name)&quot;) &#125; init(personName: String) &#123; name = personName &#125; deinit &#123; print(&quot;Person deinit \\(self.name)&quot;) &#125;&#125;var xiaoMing: Person? = Person(personName: &quot;xiaoMing&quot;)xiaoMing!.printNamexiaoMing = nil 二者的区别如果我们可以确定在整个过程中 self 不会被释放的话，我们可以将上面的 weak 改为 unowned，这样就不再需要 strongSelf 的判断。但是如果在过程中 self 被释放了而 printName 这个闭包没有被释放的话 (比如 生成 Person 后，某个外部变量持有了 printName，随后这个 Persone 对象被释放了，但是 printName 已然存在并可能被调用)，使用 unowned 将造成崩溃。在这里我们需要根据实际的需求来决定是使用 weak 还是 unowned。 OC和Swift中常用数据类型字符串 OC： NSString， NSMutableString Swift： String NSString和String的关系：在Swift中，使用字符串可以使用Foundatio中的NSString和Swift中的String。 Swift在底层能够将String与NSString无缝地桥接起来，String可以调用NSString的全部API。 数组类 OC： NSArray, NSMutableArray Swift： Array [AnyObject] NSArray和Array的关系：Swift能在底层将他们自动桥接起来，一个NSArray对象桥接后的结果是[AnyObject]。 字典 OC： NSDictionary， NSMutableDictionary Swift： Dictionary [Object: AnyObject] NSDictionary和Dictionary的关系： 底层自动桥接，一个NSDictionary对象桥接后的结果是[Object: AnyObject]。 类型转换类的转换使用 as数据类型加括号 Int() OC使用 （新的类型）原来的变量 类型判断is关键词 相当于OC的isKindofClass: 辅助命令 #file –&gt; _FILE_ #line –&gt; _LINE_ #function –&gt; _func_ 或者 _FUNCTION_ 退出程序 C: exit（0） Swift: fatalError() 或者 fatalError(message: String) 断言 OC: NSAssert Swift: assert()","categories":[{"name":"Swift","slug":"Swift","permalink":"https://blog.wangruofeng007.com/categories/Swift/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"Layer Animations Tips","slug":"2017-03-10-layer-animations-tips","date":"2017-03-10T14:49:01.000Z","updated":"2024-11-02T03:36:52.412Z","comments":true,"path":"2017/03/10/2017-03-10-layer-animations-tips/","permalink":"https://blog.wangruofeng007.com/2017/03/10/2017-03-10-layer-animations-tips/","excerpt":"","text":"beginTime的妙用创建一个动画，添加到不同的图层上，可以实现复用，通过调节beginTime可以调节动画开始执行的时间。 例如，我们创建一个水平位移动画，添加到不同的图层对象上，并且让他们轮流执行。 1234567891011121314151617let flyRight = CABasicAnimation(keyPath: &quot;position.x&quot;)flyRight.fromValue = 0flyRight.toValue = 100flyRight.duration = 0.5flyRight.fillMode = kCAFillModeBothfirstView.layer.addAnimation(flyRight, forKey: nil)// make secondView perform animation on delay 0.3 seconds.flyRight.beginTime = CACurrentMediaTime() + 0.3secondView.layer.addAnimation(flyRight, forKey: nil)secondView.layer.position.x = 100// make thirdView perform animation on delay 0.4 seconds.flyRight.beginTime = CACurrentMediaTime() + 0.4thirdView.layer.addAnimation(flyRight, forKey: nil)thirdView.layer.position.x = 100 动画的beginTime属性可以设置将要执行的动画的绝对开始时间，通过CACurrentMediaTime()函数获取当前时间再加上你想要延迟执行的时间的，单位秒。 动画代理动画代理可以监听动画的进行状态，在动画开始和结束的时候回通知代理.也就是会调用以下两个函数： 12func animationDidStart(anim: CAAnimation)func animationDidStop(anim: CAAnimation, finished flag: Bool) CAAnimationCAAnimation和它的子类遵循KVO，也就意味着你可以把它们当成字典一样使用来添加新的接口在运行时。 例如你可以使用这种机制来给某个动画指定一个名字，以便你能够把它和其它动画区分开。 1flyRight.setValue(&quot;somename&quot;, forKey: &quot;name&quot;) CASpringAnimation Property Default Value damping 10.0 mass 1.0 stiffness 100.0 initialVelocity 0.0 参数说明： damping - 应用给系统的阻尼 mass - 在系统中重物的质量 stiffness - 附加在重物上的弹簧的硬度 initialVelocity - 附加在重物上的初始速度 使用实例： 12345678910let jump = CASpringAnimation(keyPath: &quot;position.y&quot;)jump.initialVelocity = 100.0jump.mass = 10.0jump.stiffness = 1500.0jump.damping = 50.0jump.fromValue = textField.layer.position.y + 1.0jump.toValue = textField.layer.position.yjump.duration = jump.settlingDurationtextField.layer.addAnimation(jump, forKey: nil) 备注：此动画的duration参数可以通过前面几个参数自动计算得出 jump.duration = jump.settlingDuration 使用CAGradientLayer的locations实现滑动解锁对CAGradientLayer的locations属性做动画轻松的实现iPhone自带的滑动解锁效果 a.创建一个渐变图层 123456789101112131415161718192021222324let gradientLayer: CAGradientLayer = &#123; let gradientLayer = CAGradientLayer() // Configure the gradient here gradientLayer.startPoint = CGPoint(x: 0.0, y: 0.5) gradientLayer.endPoint = CGPoint(x: 1.0, y: 0.5) let colors = [ UIColor.blackColor().CGColor, UIColor.whiteColor().CGColor, UIColor.blackColor().CGColor ] gradientLayer.colors = colors let locations = [ 0.25, 0.5, 0.75 ] gradientLayer.locations = locations return gradientLayer&#125;() b.创建一个文本样式字典 123456789let textAttributes : [String: AnyObject] = &#123; let style = NSMutableParagraphStyle() style.alignment = .Center return [ NSFontAttributeName:UIFont(name: &quot;HelveticaNeue-Thin&quot;, size: 28.0)!, NSParagraphStyleAttributeName:style ]&#125;() c.当设置文本时绘制内容，添加@IBInspectable方便看实时效果 1234567891011121314151617@IBInspectable var text: String! &#123;didSet &#123; setNeedsDisplay() UIGraphicsBeginImageContextWithOptions(frame.size, false, 0) text.drawInRect(bounds, withAttributes: textAttributes) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() let maskLayer = CALayer() maskLayer.backgroundColor = UIColor.clearColor().CGColor maskLayer.frame = CGRectOffset(bounds, bounds.size.width, 0) maskLayer.contents = image.CGImage gradientLayer.mask = maskLayer &#125;&#125; d.重新布局gradientLayer 1234567override func layoutSubviews() &#123; gradientLayer.frame = CGRect( x: -bounds.size.width, y: bounds.origin.y, width: 3 * bounds.size.width, height: bounds.size.height)&#125; e.添加到window时向渐变层添加动画 12345678910111213override func didMoveToWindow() &#123; super.didMoveToWindow() layer.addSublayer(gradientLayer) let gradientAnimation = CABasicAnimation(keyPath: &quot;locations&quot;) gradientAnimation.fromValue = [0.0, 0.0, 0.25] gradientAnimation.toValue = [0.75, 1.0, 1.0] gradientAnimation.duration = 3.0 gradientAnimation.repeatCount = Float.infinity gradientLayer.addAnimation(gradientAnimation, forKey: nil)&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"VFL深入浅出","slug":"2017-03-02-vflshen-ru-qian-chu","date":"2017-03-02T13:19:49.000Z","updated":"2024-11-02T03:36:52.411Z","comments":true,"path":"2017/03/02/2017-03-02-vflshen-ru-qian-chu/","permalink":"https://blog.wangruofeng007.com/2017/03/02/2017-03-02-vflshen-ru-qian-chu/","excerpt":"","text":"使用场景给视图对象快速创建约束，可以使用比较冷门的VFL(Visual Format Language),本质是是基于自动布局(AutoLayout)。 解决的问题以一种直观的方式，为视图创建约束 怎样解决核心方法： 1234+ (NSArray&lt;__kindof NSLayoutConstraint *&gt; *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(nullable NSDictionary&lt;NSString *,id&gt; *)metrics views:(NSDictionary&lt;NSString *, id&gt; *)views; Example: 1234[NSLayoutConstraint constraintsWithVisualFormat:@&quot;|-[button1]-[button2]-[textField(&gt;=20)]-|&quot; options:0 metrics:metrics views:views] 参数： format:指定约束的格式。更多信息，在Auto Layout Guide查看Visual Format Language。 opts:描述在视觉格式化字符串中的布局属性和方向 metrics:将出现在视觉格式化字符串的常量字典。字典的Keys必须是在出现在视觉格式化字符串的字符串类型，对应的values必须是NSNumber对象。 views:出现的视觉格式化字符串的字典view，所有的Keys必须是使用在视觉格式化字符串的字符串类型，对应的values必须是view对象。 返回值： 一个约束组合的数组，像视觉格式化字符串描述的一样表述了在提供的视图和它们的父视图之间的关系。所有的约束以在视觉格式化字符串被指定的约束顺序一致。 效率和可维护性需要对VFL理解比较全面和深入，有一定的学习成本，维护起来比较困难，但是如果理解的比较深刻，对于简单的布局效率非常高，比直接创建约束要直观。 最佳实践 每条约束格式字符串分水平(H，可省略)和垂直方向(V)。 | 代表父视图。 - 代表标准间距，两个子视图直接的值是8，与父视图之间的值是16。 [view] 每个视图必须用[]包裹起来，否则语法错误。 [view(&gt;=44)] 可以为每个视图设置一些属性或者关系，写一个紧跟view后的括号集合，支持宽高，优先级，和其它视图之间的关系。 [view@20] 可以设置视图的约束的优先级，以@开头，取值范围(0 1000]。 [view1]-20-[view2] 可以指定view之间的水平或者垂直间距，写在一对 - 即可。 [view1][view2] 如果 - 省略则他们之间的距离为0。 [flexibleButton(&gt;=70,&lt;=100)] 多个条件之间用,连接并且之间不能有空格。 其它方案 使用NSLayoutConstraint的类方法创建(iOS96.0及以上可用) 1234567+ (instancetype)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(nullable id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c; 使用NSLayoutAnchor的工厂方法创建(iOS9.0及以上可用) 1234567- (NSLayoutConstraint *)constraintEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor;- (NSLayoutConstraint *)constraintGreaterThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor;- (NSLayoutConstraint *)constraintLessThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor;- (NSLayoutConstraint *)constraintEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor constant:(CGFloat)c;- (NSLayoutConstraint *)constraintGreaterThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor constant:(CGFloat)c;- (NSLayoutConstraint *)constraintLessThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor constant:(CGFloat)c; 使用注意事项 使用时，必须把view的translatesAutoresizingMaskIntoConstraints属性设置为NO，否则约束可能更预期不一致。这是一个历史遗留的问题，由于在AutoLayout诞生以前一直使用Autoresizing来控制布局. 重写updateConstraints()方法，在里面计算约束，然后调用setNeedsUpdateConstraints()触发更新约束。 系统计算布局顺序: updateConstraints() layoutSubviews() drawRect(_:) 系统计算布局顺序参考 具体使用示例，查看下面的Demo，样品工程 Demo地址：VFLDemo 参考链接 coding-auto-layout Visual Format Language","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"UIActivity​View​Controller 详解","slug":"2017-02-23-uiactivityviewcontroller-xiang-jie","date":"2017-02-23T15:23:12.000Z","updated":"2024-11-02T03:36:52.411Z","comments":true,"path":"2017/02/23/2017-02-23-uiactivityviewcontroller-xiang-jie/","permalink":"https://blog.wangruofeng007.com/2017/02/23/2017-02-23-uiactivityviewcontroller-xiang-jie/","excerpt":"","text":"翻译自NSHipster的UIActivity​View​Controller 一直非常好奇代码和数据之间的联系。 某些编程语言，例如Lisp，Io和Mathematica他们是同型性(代码即数据)，那就意味着它们的代码是原始数据的呈现形式，它们本身在代码中也能够被维护。然而大多数其它语言，包括Objective-C，然而，在这两者之间有严格的边界，避免eval()和其它有动态引导加载的潜在危险方法。 当数据出现太大和呈现一些东西过于笨重除了使用二进制流的问题时代码和数据之间的不安被推向到了一个全新的高度。自从第一个操作系统出现开始，怎样编码，解码，解释二进制代表的图片，文档，和媒体一直是一个问题。 在OS X上的核心服务框架和iOS上提供标识功能和通过文件拓展和MIMIE type–根据通用数据标示，给数据类型的分类核心服务框架。UTIs提供了一种可拓展，阶梯分层系统，这给开发者在处理大量不同的文件类型提供了巨大的灵活性。例如，一个Ruby的源文件(.rb)被归类为：Ruby Source Code &gt; Source Code &gt; Text &gt; Content &gt; Data；一个QuickTime电影文件(.mov)被归类为 Video &gt; Movie &gt; Audiovisual Content &gt; Content &gt; Data。 UTIs表现得非常好在桌面的抽象文件系统中。然而，在一个移动范例中这就崩溃得很快，因为文件和目录是对用户隐藏的。还有，随着云服务和社交媒体扮演着越来越重要的角色在远程实体通过本地文件。因此，UTIs和URLs之间很紧张。 我们非常清楚我们需要一些别的东西。UIActivityViewController能否成为我们正在急切寻找的解决方案呢? UIActivityViewController，在iOS6中被引入，提供了一套分享和在应用内执行数据操作的统一服务界面。 考虑到可操作的数据集合，一个UIActivityViewController实例通过如下方式创建： 12345678910NSString *string = ...;NSURL *URL = ...;UIActivityViewController *activityViewController = [[UIActivityViewController alloc] initWithActivityItems:@[string, URL] applicationActivities:nil];[navigationController presentViewController:activityViewController animated:YES completion:^&#123; // ...&#125;]; 这将在屏幕底部呈现如下界面： 默认情况下，UIActivityViewController将会显示所有支持的可用服务类型，但是某些活动类型也可以排除： 1activityViewController.excludedActivityTypes = @[UIActivityTypePostToFacebook]; 活动类型被划分“动作”(action)和“分享”(share)类型： UIActivityCategoryAction UIActivityTypePrint UIActivityTypeCopyToPasteboard UIActivityTypeAssignToContact UIActivityTypeSaveToCameraRoll UIActivityTypeAddToReadingList UIActivityTypeAirDrop UIActivityCategoryShare UIActivityTypeMessage UIActivityTypeMail UIActivityTypePostToFacebook UIActivityTypePostToTwitter UIActivityTypePostToFlickr UIActivityTypePostToVimeo UIActivityTypePostToTencentWeibo UIActivityTypePostToWeibo 每种活动类型，支持一系列不同的数据类型。例如，一个Tweet可能由一个NSString并附带一个image和或者URL。 不同活动类型支持的数据类型 Activity Type String Attributed String URL Data Image Asset Other Post To Facebook ✓ ✓ ✓ ✓ Post To Twitter ✓ ✓ ✓ ✓ Post To Weibo ✓ ✓ ✓ ✓ ✓ Message ✓ ✓ ✓* ✓* ✓ sms:&#x2F;&#x2F; NSURL Mail ✓+ ✓+ ✓+ Print ✓+ ✓+ UIPrintPageRenderer, UIPrintFormatter, &amp; UIPrintInfo Copy To Pasteboard ✓ ✓ ✓ UIColor, NSDictionary Assign To Contact ✓ Save To Camera Roll ✓ ✓ Add To Reading List ✓ Post To Flickr ✓ ✓ ✓ ✓ Post To Vimeo ✓ ✓ ✓ ✓ ✓ Post To Tencent Weibo ✓ ✓ ✓ ✓ ✓ AirDrop ✓ ✓ ✓ ✓ ✓ UIActivityItemSource &amp; UIActivityItemProvider当必要时和一个粘贴板项目能用来提供的数据类似，为了避免过度的内测开销或处理时间，活动类型可以是一种自定义类型。 任何遵循&lt;UIActivityItemSource&gt;协议的对象，包括内构UIActivityItemProvider类，可以用来动态提供不同类型的数据根据活动的类型。 UIActivityItemSource获取数据项目： activityViewControllerPlaceholderItem: activityViewController:itemForActivityType: 提供数据项目信息： activityViewController:subjectForActivityType: activityViewController:dataTypeIdentifierForActivityType: activityViewController:thumbnailImageForActivityType:suggestedSize: 下面是一个例子，根据是否分享到FaceBook或者Twitter来展示自定义一条消息是怎样使用的: 1234567891011- (id)activityViewController:(UIActivityViewController *)activityViewController itemForActivityType:(NSString *)activityType&#123; if ([activityType isEqualToString:UIActivityTypePostToFacebook]) &#123; return NSLocalizedString(@&quot;Like this!&quot;); &#125; else if ([activityType isEqualToString:UIActivityTypePostToTwitter]) &#123; return NSLocalizedString(@&quot;Retweet this!&quot;); &#125; else &#123; return nil; &#125;&#125; 创建一个自定义UIActivity除了上述的系统提供的活动，你也可以创建你自己的活动。 例如，让我们创建一个自定义活动类型，它能使一个URL中的图片添加上胡须通过使用mustache.me。 Before: After: 首先，我们定义一个反向域名解析的标识符给活动类型： 1static NSString * const HIPMustachifyActivityType = @&quot;com.nshipster.activity.Mustachify&quot;; 然后指定它的分类为UIActivityCategoryAction并且提供一个本地化标题和iOS版本相应的图片： 123456789101112131415161718192021#pragma mark - UIActivity+ (UIActivityCategory)activityCategory &#123; return UIActivityCategoryAction;&#125;- (NSString *)activityType &#123; return HIPMustachifyActivityType;&#125;- (NSString *)activityTitle &#123; return NSLocalizedString(@&quot;Mustachify&quot;, nil);&#125;- (UIImage *)activityImage &#123; if (NSFoundationVersionNumber &gt; NSFoundationVersionNumber_iOS_6_1) &#123; return [UIImage imageNamed:@&quot;MustachifyUIActivity7&quot;]; &#125; else &#123; return [UIImage imageNamed:@&quot;MustachifyUIActivity&quot;]; &#125;&#125; 下一步，我们创建一个辅助函数，HIPMatchingURLsInActivityItems，通过它返回一个支持类型的图片URL的数组。 123456789101112static NSArray * HIPMatchingURLsInActivityItems(NSArray *activityItems) &#123; return [activityItems filteredArrayUsingPredicate:[NSPredicate predicateWithBlock: ^BOOL(id item, __unused NSDictionary *bindings) &#123; if ([item isKindOfClass:[NSURL class]] &amp;&amp; ![(NSURL *)item isFileURL]) &#123; return [[(NSURL *)item pathExtension] caseInsensitiveCompare:@&quot;jpg&quot;] == NSOrderedSame || [[(NSURL *)item pathExtension] caseInsensitiveCompare:@&quot;png&quot;] == NSOrderedSame; &#125; return NO; &#125;]];&#125; 这个函数让后被用在-canPerformWithActivityItems:和prepareWithActivityItems:来获取小胡子的第一张PNG或JPEG图片的URL，假如有的话。 123456789- (BOOL)canPerformWithActivityItems:(NSArray *)activityItems &#123; return [HIPMatchingURLsInActivityItems(activityItems) count] &gt; 0;&#125;- (void)prepareWithActivityItems:(NSArray *)activityItems &#123; static NSString * const HIPMustachifyMeURLFormatString = @&quot;http://mustachify.me/%d?src=%@&quot;; self.imageURL = [NSURL URLWithString:[NSString stringWithFormat:HIPMustachifyMeURLFormatString, self.mustacheType, [HIPMatchingURLsInActivityItems(activityItems) firstObject]]];&#125; 我们的网站服务提供了各种胡须选项，它被定义在一个枚举中： 12345678typedef NS_ENUM(NSInteger, HIPMustacheType) &#123; HIPMustacheTypeEnglish, HIPMustacheTypeHorseshoe, HIPMustacheTypeImperial, HIPMustacheTypeChevron, HIPMustacheTypeNatural, HIPMustacheTypeHandlebar,&#125;; 最终，我们提供了一个UIViewController来显示图片。在这个例子中，一个简单的UIWebView控制器就够用了。 123456789101112@interface HIPMustachifyWebViewController : UIViewController &lt;UIWebViewDelegate&gt;@property (readonly, nonatomic, strong) UIWebView *webView;@end- (UIViewController *)activityViewController &#123; HIPMustachifyWebViewController *webViewController = [[HIPMustachifyWebViewController alloc] init]; NSURLRequest *request = [NSURLRequest requestWithURL:self.imageURL]; [webViewController.webView loadRequest:request]; return webViewController;&#125; 为了使用我们加了新胡须的活动，我们简单把它传递到UIActivityViewController构造器中： 1234HIPMustachifyActivity *mustacheActivity = [[HIPMustachifyActivity alloc] init];UIActivityViewController *activityViewController = [[UIActivityViewController alloc] initWithActivityItems:@[imageURL] applicationActivities:@[mustacheActivity]]; 手动执行动作现在是一个提醒的好时机，当UIActivityViewController允许用户执行他们选择的动作，分享也能通过手动执行，当场景出现时。 所有为了完整性，下面是怎样手动执行这些动作示例： Open URL12NSURL *URL = [NSURL URLWithString:@&quot;http://nshipster.com&quot;];[[UIApplication sharedApplication] openURL:URL]; 系统支持的URL协议包括：mailto:， tel:，sms:和maps:。 添加到Safari阅读列表1234567@import SafariServices;NSURL *URL = [NSURL URLWithString:@&quot;http://nshipster.com/uiactivityviewcontroller&quot;];[[SSReadingList defaultReadingList] addReadingListItemWithURL:URL title:@&quot;NSHipster&quot; previewText:@&quot;...&quot; error:nil]; 保存到相册12345UIImage *image = ...;id completionTarget = self;SEL completionSelector = @selector(didWriteToSavedPhotosAlbum);void *contextInfo = NULL;UIImageWriteToSavedPhotosAlbum(image, completionTarget, completionSelector, contextInfo); 发送 SMS123456789@import MessageUI;MFMessageComposeViewController *messageComposeViewController = [[MFMessageComposeViewController alloc] init];messageComposeViewController.messageComposeDelegate = self;messageComposeViewController.recipients = @[@&quot;mattt@nshipster•com&quot;];messageComposeViewController.body = @&quot;Lorem ipsum dolor sit amet&quot;;[navigationController presentViewController:messageComposeViewController animated:YES completion:^&#123; // ...&#125;]; 发送 Email12345678910@import MessageUI;MFMailComposeViewController *mailComposeViewController = [[MFMailComposeViewController alloc] init];mailComposeViewController.mailComposeDelegate = self;[mailComposeViewController setToRecipients:@[@&quot;mattt@nshipster•com&quot;]];[mailComposeViewController setSubject:@&quot;Hello&quot;];[mailComposeViewController setMessageBody:@&quot;Lorem ipsum dolor sit amet&quot; isHTML:NO];[navigationController presentViewController:mailComposeViewController animated:YES completion:^&#123; // ...&#125;]; 发送 Tweet123456789@import Social;SLComposeViewController *tweetComposeViewController = [SLComposeViewController composeViewControllerForServiceType:SLServiceTypeTwitter];[tweetComposeViewController setInitialText:@&quot;Lorem ipsum dolor sit amet.&quot;];[self.navigationController presentViewController:tweetComposeViewController animated:YES completion:^&#123; // ... &#125;]; IntentKit当所有的这些都是印象深刻和非常有用，它在iOS中的活动范例特别缺乏，当和在Android中的丰富的Intents Model相比。 在Android中，apps能够注册不同的intents，来指示它们能够用在Maps，或者充当一个浏览器，能够被涉及到相关活动的默认app选中，比如指引方向，或者一个书签的URL。 然而iOS缺乏来支持这些的可拓展的基础架构，有一个叫IntentKit第三方库，作者@lazerwalker(因f*ingblocksyntax.com成名)，这是一个有趣的例子关于我们怎样缩小这方面的差距。 通常，一个开发者可能已经做了很多第一步的工作，来决定是否某个app是否安装，然后怎样构造一个URL来支持某个特殊的活动。 IntentKit加强了连结到大多数流行的Web，Maps,Mail,Twitter,Facebook,和Google+客户的的逻辑，以和UIActivityViewController相似的UI。 任何寻找提升他们的分享体验到下一个级别的人都应该仔细看看这个。 – 在iOS长期生存能力作为一个平台取决于像UIActivityViewController类型的分享机制存上在很大的争论。正如俗语所言：“资讯应该免费”。任何阻碍方式统一的东西，最终都会失去一些没有的东西。 将来的景象是公共的远程视图控制器APIs带给我希望，对于将来在iOS平台上的分享功能。然而现在我们做的和UIActivityViewController相比糟糕得多。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://blog.wangruofeng007.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Favorite","slug":"Favorite","permalink":"https://blog.wangruofeng007.com/tags/Favorite/"},{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"2016个人年度总结","slug":"2017-01-10-2016ge-ren-nian-du-zong-jie","date":"2017-01-09T15:48:07.000Z","updated":"2024-11-02T03:36:52.411Z","comments":true,"path":"2017/01/09/2017-01-10-2016ge-ren-nian-du-zong-jie/","permalink":"https://blog.wangruofeng007.com/2017/01/09/2017-01-10-2016ge-ren-nian-du-zong-jie/","excerpt":"","text":"前言2016对于我来说的意义，就像10年前的今天，iPhone之余乔布斯，iPhone发布后10年后的今天，小程序之余张小龙。它跨越了一道深深的鸿沟，并向自己理想的方向坚定前行。 一直相信努力就会有回报，付出就会有收获，是金子总会发光。 2016是我加入客路一周年的时间，认识了很多有趣的朋友和同事的一 2016是我迈出自我，走出中国探索未知的世界的一年。 2016是旅行，工作，生活，学习，社交一样都没落下的一年。 曾经的铁哥们也即将回归东莞，这样我们的距离又进了一步，以后有更多的时间聊理想谈人生，想想突然好激动。 业绩2016-2017年间一共发布17个版本，多次被Apple推荐，崩溃率小于0.2%，这就是给自己和公司交出最满意的答卷。 下面是Klook App上Apple的推荐页截图： 下面是Klook iMessage App上Apple的推荐页截图： 有时发现互联网真的很奇妙，他能让很多人迅速积累大量的财富成名走上人生的巅峰，过上自己想要的生活，只要你一个好的idea和一个强大的执行力。 这一年来个人技术博客一共写了46遍文章，也算一点小积蓄，希望来年继续坚持，能够影响和帮助更多的人，因为技术这条道路上坑实在是太多。 Github上405次commit还算中规中矩，希望来年分享更多的有价值的东西给有需要的小伙伴，也留给自己方便以后查阅。 ![github 2016 commit record](&#x2F;images&#x2F;2016_year_end_review&#x2F;github 2016 commit record.png) 当然现在Github上的内容Fork和博客居多，原创开源项目还比较少，希望来年多输出一点东西。 未来愿望这东西还真神奇，许一个试试吧，或许它真的实现了呢，就非常有趣了。给自己定下的旅行清单，学习清单，阅读清单，电影清单基本都完成，这是一件非常棒的事情，为自己点个赞。单反已经从风光转人像，希望来年多出点片，新年即将来临，希望自己坚持一周2次的锻炼，保持精力充沛以便好投入到感情，生活中以及学习中，毕竟互联网是一门终生学习的职业，也是容易产生奇迹的职业，说不定一下个就是你呢。 来年希望和自己喜欢的人旅拍，多尝试一些没尝试过的事情，交更多有趣的朋友。干巴爹😁😁😁","categories":[{"name":"生活","slug":"生活","permalink":"https://blog.wangruofeng007.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"Favorite","slug":"Favorite","permalink":"https://blog.wangruofeng007.com/tags/Favorite/"}]},{"title":"视频播放Tips","slug":"2016-12-08-shi-pin-bo-fang-tips","date":"2016-12-08T15:44:02.000Z","updated":"2024-11-02T03:36:52.411Z","comments":true,"path":"2016/12/08/2016-12-08-shi-pin-bo-fang-tips/","permalink":"https://blog.wangruofeng007.com/2016/12/08/2016-12-08-shi-pin-bo-fang-tips/","excerpt":"","text":"主要涉及到Tips： 获取设备音量 静音模式失效 监听音量改变 设置设备音量 监听静音按钮 监听耳机拔插 获取设备音量播放音频可以通过： 12MPMusicPlayerController *iPod = [MPMusicPlayerController systemMusicPlayer];float volumeLevel = iPod.volume; 播放视频可以通过： 1float outputVolume = [[AVAudioSession sharedInstance] outputVolume]; 推荐下面的方法，上面的在某些版本可能有问题，下面的方法兼容iOS6及以上。 静音模式失效通过设置音频会话的category实现： 12345NSError *setCategoryError = nil;BOOL success = [[AVAudioSession sharedInstance] setCategory: AVAudioSessionCategoryPlayback error: &amp;setCategoryError]; if (!success) &#123; /* handle the error in setCategoryError */ &#125; 这样App就不会随着手机静音键打开而静音，可在手机静音下播放声音😁 监听音量改变监听音频改变私有通知： 1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(volumeChanged:) name:@&quot;AVSystemController_SystemVolumeDidChangeNotification&quot; object:nil]; 实现通过回调： 1234567- (void)volumeChanged:(NSNotification *)notification&#123; float volume = [[[notification userInfo] objectForKey:@&quot;AVSystemController_AudioVolumeNotificationParameter&quot;] floatValue]; // do something&#125; 设置设备音量使用MPVolumeView类，便利它的子views找到类为MPVolumeSlider的滑竿。 12345678MPVolumeView *volumeView = [[MPVolumeView alloc] init];UISlider *volumeViewSlider = nil; for (UIView *view in [volumeView subviews])&#123; if ([view.class.description isEqualToString:@&quot;MPVolumeSlider&quot;]) &#123; volumeViewSlider = (UISlider *)view; break; &#125; &#125; 然后再通过设置volumeViewSlider的value即可。 1_volumeViewSlider.value = someVolume; 监听静音按钮参考Sound Switch - Sharkfood的实现。 使用很简单，判断是否为静音模式： 123if ([SharkfoodMuteSwitchDetector shared].isMute) &#123; // do something&#125; 动态监听，通过block回调： 123[SharkfoodMuteSwitchDetector shared].silentNotify = ^(BOOL silent)&#123; // do something&#125;; 监听耳机拔插监听AVAudioSessionRouteChangeNotification通知： 123[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(audioRouteChangeListenerCallback:) name:AVAudioSessionRouteChangeNotification object:nil]; 实现回调： 1234567891011121314151617181920- (void)audioRouteChangeListenerCallback:(NSNotification*)notification&#123; NSDictionary *interuptionDict = notification.userInfo; NSInteger routeChangeReason = [[interuptionDict valueForKey:AVAudioSessionRouteChangeReasonKey] integerValue]; switch (routeChangeReason) &#123; case AVAudioSessionRouteChangeReasonNewDeviceAvailable: // 耳机插入 break; case AVAudioSessionRouteChangeReasonOldDeviceUnavailable: // 耳机拔掉 break; case AVAudioSessionRouteChangeReasonCategoryChange: // called at start - also when other audio wants to play NSLog(@&quot;AVAudioSessionRouteChangeReasonCategoryChange&quot;); break; &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"音视频","slug":"音视频","permalink":"https://blog.wangruofeng007.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"}]},{"title":"动画切换Image最佳实践","slug":"2016-11-26-dong-hua-qie-huan-imagezui-jia-shi-jian","date":"2016-11-26T12:42:40.000Z","updated":"2024-11-02T03:36:52.410Z","comments":true,"path":"2016/11/26/2016-11-26-dong-hua-qie-huan-imagezui-jia-shi-jian/","permalink":"https://blog.wangruofeng007.com/2016/11/26/2016-11-26-dong-hua-qie-huan-imagezui-jia-shi-jian/","excerpt":"","text":"前言UIImageView应该是iOS中使用最频换的控件，就如日常吃饭一样，天天都在重复，有时或许应该反思一下，怎么使用这个控件，达到低能耗，最佳用户体验。 针对单张图片来说，常见的处理是在图片准备显示时增加一个淡出动画，能使图片显示闲的很平滑。 多张图片也一样，在第一张图片的基础上淡出原来的图片，淡入新的图片。也可以说是溶解效果。 很多人喜欢对图片的alpha做淡出动画，使alpha从0到1动画改变。这种动画有一点不好的是，在动画结束后，图片会明显的出现一闪，这样使动画看起来有点突兀。比较好的做法时，在将要显示时给图片做一个转场动画。 淡出动画实现下面是其中一种简单的实现： 12345678910111213@implementation UIImageView (RFWebImage)- (void)animatedChangeToImage:(UIImage *)img&#123; [UIView transitionWithView:self duration:0.3f options:UIViewAnimationOptionTransitionCrossDissolve animations:^&#123; self.image = img; &#125; completion:NULL];&#125;@end 思路：在ImageView将要显示是使用转场动画函数来实现淡出动画效果，体验应该是是各种动画中最好的了，而且使用起来很简单。 在淡出显示的动画基础上，我们引出今天的主角，动画切换Image。 思路：单张图片淡出我们已经实现，现在做的就是在切换一张新的图片时同时再加入淡出或者说溶解效果即可。 动画切换Image比较常见的有下面3种实现： CATransition类实现 UIView动画转场API实现 CABasicAnimation类实现 CATransition实现CATransition类是iOS中很好用的控制转场动画的类，通过简单的配置可以实现常见而炫酷的动画效果，变换类型通过type字段控制，subtype可以很细化控制动画的方向（比如动画开始的上下左右方向）。CATransition继承至CAAnimation可以对动画设置动画曲线（timingFunction），可以通过代理获取动画状态（是已经开始，还是已经停止，已经是否完成）。 type支持四种类型： kCATransitionFade &#x2F;&#x2F; 淡入淡出 kCATransitionMoveIn &#x2F;&#x2F; 从某个方向向终点平移知道覆盖在上方 kCATransitionPush &#x2F;&#x2F; 把原来的推出去，自己推出去 kCATransitionReveal &#x2F;&#x2F; 把原来的从正上方解开，自己在下面 下面是样板代码： 12345678910111213- (void)animatedSwichImageMethodOne &#123; UIImage *toImage = [self getRadomImage]; CATransition *transition = [CATransition animation]; transition.duration = 0.3f; transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; transition.type = kCATransitionFade; transition.subtype = kCATransitionFromTop; [self.imageViewOne.layer addAnimation:transition forKey:nil]; [self.imageViewOne setImage:toImage];&#125; UIView动画转场1+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0); 通过上面的函数实现，其实是对第一种的高级封装。通过设置options为UIViewAnimationOptionTransitionCrossDissolve即可。 下面是样板代码： 1234567891011- (void)animatedSwichImageMethodTwo &#123; UIImage *toImage = [self getRadomImage]; [UIView transitionWithView:self.imageViewTwo duration:0.3f options:UIViewAnimationOptionTransitionCrossDissolve | UIViewAnimationOptionCurveEaseInOut animations:^&#123; self.imageViewTwo.image = toImage; &#125; completion:nil];&#125; CABasicAnimation实现CABasicAnimation是核心动画一个重要的类，继承至CAPropertyAnimation，可以对所有的可动画属性做动画，可以通过fromValue，toValue，byValue字段控制动画的进度。在这里我们是对CALayer的contents属性做动画，在改变图片时，创建一个CABasicAnimation对象添加到ImageView的图层上即可。 下面是样板代码： 1234567891011- (void)animatedSwichImageMethodThree &#123; UIImage *toImage = [self getRadomImage]; CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@&quot;contents&quot;]; animation.toValue = toImage; animation.duration = 0.3f; [self.imageViewThree.layer addAnimation:animation forKey:@&quot;contentsAnimationKey&quot;]; [self.imageViewThree setImage:toImage];&#125; 更多内容请下载Demo查看（🤔Bonus： Flip效果🤔）","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"动画","slug":"动画","permalink":"https://blog.wangruofeng007.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"iOS无缝桥接【翻译Apple官方文档】","slug":"2016-11-17-ioswu-feng-qiao-jie","date":"2016-11-17T15:52:46.000Z","updated":"2024-11-02T03:36:52.410Z","comments":true,"path":"2016/11/17/2016-11-17-ioswu-feng-qiao-jie/","permalink":"https://blog.wangruofeng007.com/2016/11/17/2016-11-17-ioswu-feng-qiao-jie/","excerpt":"","text":"Toll-Free Bridged Types在Core Foundation框架和Foundation 框架中有很多数据类型可以交替转换。能够被交替转换的数据类型也被叫做Toll-Free Bridged数据类型。这意味着你能像参数一样使用相同的数据结构对一个Core Foundation的函数进行调用，或者像Objective-C的消息接受模式一样执行。例如，NSLocale（查看NSLocale Class Reference）可以与在Core Foundation中对应的CFLocale （查看CFLocale Reference）之间互相转换。 不是所有数据类型都是Toll-Free Bridged,即使它们的名字可能让你认为它们是。例如，NSRunLoop是没有对应的桥接类型CFRunLoop,NSBundle也没有对应的桥接类型CFBundle，NSDateFormatter同样没有对应的桥接类型CFDateFormatter。 文章末尾表1提供了一份支持无缝桥接的数据类型的列表。 注意：假如你使用一个自定义回调在一个Core Foundation框架的集合中，包含一个NULL回调，当使用Objective-C的方式接入它，它的内存管理方式是未定义的。 类型转换和对象语义周期声明通过无缝桥接技术，在一个你以NSLocale *做为一个参数的方法的例子中，你能传递一个CFLocaleRef结构体，并且当你看到有一个CFLocaleRef 参数的函数中，你能够传递一个NSLocale实例对象。当然你也必须提供给编译器相关的一些其它信息:第一，你必须转换一种类型成其它；第二，你可能必须指明对象的语义生命周期。 编译器理解Objective-C的方法并且返回Core Foundation数据类型，下面是Cocoa命名转换的历史（查看Advanced Memory Management Programming Guide）。例如，编译器知道，在iOS中，通过UIColor 的CGColor方法返回的CGColor并不应该被持有。你必须使用恰当的类型转换，像下面例子演示的那样： 12NSMutableArray *colors = [NSMutableArray arrayWithObject:(id)[[UIColor darkGrayColor] CGColor]];[colors addObject:(id)[[UIColor lightGrayColor] CGColor]]; 编译器并不会自动管理Core Foundation对象的生命周期。你必须告诉编译器对象的语义所属关系通过使用一种转换（定义在objc&#x2F;runtime.h）或者Core Foundation风格的宏（定义在 NSObject.h）： __bridge关键字表示转换指针在Objective-C和Core Foundation之间而不会转换所属关系。 __bridge_retained 关键字或者CFBridgingRetain 表示转换指针在Objective-C和Core Foundation之间并且把所属权交给你。你负责调用CFRelease或者相关的函数来交出对象的所属权。 __bridge_transfer关键字或者CFBridgingRelease表示转换一个非Objective-C的指针到Objective-C并且转换所属权给ARC。ARC负责交出对象的所属权。 下面是一些例子： 1234567891011NSLocale *gbNSLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_GB&quot;];CFLocaleRef gbCFLocale = (__bridge CFLocaleRef)gbNSLocale;CFStringRef cfIdentifier = CFLocaleGetIdentifier(gbCFLocale);NSLog(@&quot;cfIdentifier: %@&quot;, (__bridge NSString *)cfIdentifier);// Logs: &quot;cfIdentifier: en_GB&quot; CFLocaleRef myCFLocale = CFLocaleCopyCurrent();NSLocale *myNSLocale = (NSLocale *)CFBridgingRelease(myCFLocale);NSString *nsIdentifier = [myNSLocale localeIdentifier];CFShow((CFStringRef)[@&quot;nsIdentifier: &quot; stringByAppendingString:nsIdentifier]);// Logs identifier for current locale 下面的例子显示了使用口述的Core Foundation内存管理规则来管理Core Foundation内存： 123456789101112131415- (void)drawRect:(CGRect)rect &#123; CGContextRef ctx = UIGraphicsGetCurrentContext(); CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray(); CGFloat locations[2] = &#123;0.0, 1.0&#125;; NSMutableArray *colors = [NSMutableArray arrayWithObject:(id)[[UIColor darkGrayColor] CGColor]]; [colors addObject:(id)[[UIColor lightGrayColor] CGColor]]; CGGradientRef gradient = CGGradientCreateWithColors(colorSpace, (__bridge CFArrayRef)colors, locations); CGColorSpaceRelease(colorSpace); // Release owned Core Foundation object. CGPoint startPoint = CGPointMake(0.0, 0.0); CGPoint endPoint = CGPointMake(CGRectGetMaxX(self.bounds), CGRectGetMaxY(self.bounds)); CGContextDrawLinearGradient(ctx, gradient, startPoint, endPoint, kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation); CGGradientRelease(gradient); // Release owned Core Foundation object.&#125; 无缝桥接类型表1提供了一个在Core Foundation和Foundation中可以交替转换数据类型列表。对每一对桥接类型，表也列举出了这些无缝桥接类型在OS X中的可用版本。 Core Foundation 类型 Foundation 类型 可用性 CFArrayRef NSArray OS X v10.0 CFAttributedStringRef NSAttributedString OS X v10.4 CFCalendarRef NSCalendar OS X v10.0 CFCharacterSetRef NSCharacterSet OS X v10.4 CFDataRef NSData OS X v10.0 CFDateRef NSDate OS X v10.4 CFDictionaryRef NSDictionary OS X v10.0 CFErrorRef NSError OS X v10.4 CFLocaleRef NSLocale OS X v10.0 CFMutableArrayRef NSMutableArray OS X v10.4 CFMutableAttributedStringRef NSMutableAttributedString OS X v10.0 CFMutableCharacterSetRef NSMutableCharacterSet OS X v10.4 CFMutableDataRef NSMutableData OS X v10.0 CFMutableDictionaryRef NSMutableDict OS X v10.4 CFMutableSetRef NSMutableSet OS X v10.0 CFMutableStringRef NSMutableString OS X v10.4 CFNumberRef NSNumber OS X v10.0 CFReadStreamRef NSInputStream OS X v10.4 CFRunLoopTimerRef NSTimer OS X v10.0 CFSetRef NSSet OS X v10.4 CFStringRef NSString OS X v10.0 CFTimeZoneRef NSTimeZone OS X v10.4 CFURLRef NSURL OS X v10.0 CFWriteStreamRef NSOutputStream OS X v10.4 表1 参考资料 Toll-Free Bridged Types","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://blog.wangruofeng007.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Favorite","slug":"Favorite","permalink":"https://blog.wangruofeng007.com/tags/Favorite/"},{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"block备忘录","slug":"2016-11-17-blockbei-wang-lu","date":"2016-11-17T15:10:08.000Z","updated":"2024-11-02T03:36:52.410Z","comments":true,"path":"2016/11/17/2016-11-17-blockbei-wang-lu/","permalink":"https://blog.wangruofeng007.com/2016/11/17/2016-11-17-blockbei-wang-lu/","excerpt":"","text":"前言随著block在iOS4.0和OS X 10.6的引入，给事件传递一种新的方式实现，在开发中用得最多的场景莫过于事件回调。使用block相对与delegate的优势在于，业务集中，可读性强，代码内联，不像代理需要实现很多函数，在适当的场景选择这种方式实现事件传递或者传参效果非常好，现在很多开源项目都实现了两种方法的事件回调。 block用起来虽然很爽，但也有它的不足，存在循环引用，轻者内存泄露，甚至导致App崩溃，不易调试追溯，因此使用它使一定要小心。鉴于实践中的踩过各种坑，总结下来，方便自己和他人以后查阅，这就是block备忘录写作的初衷。 block的本质block实际上是指向结构体的指针，编译时，block的内部代码生产对应的函数。 具体结构如下： 与C语言的函数指针的区别 block的代码是内联的，效率高于函数调用 block对于外部变量默认是只读属性 block被Objective-C看成是对象处理 block声明 作为property @property (nonatomic, copy) returnType (^blockName)(parameterTypes); 作为方法参数 - (void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName; 作为一个方法调用参数 [someObject someMethodThatTakesABlock:^returnType (parameters) {…}]; 作为一个typedef typedef returnType (^TypeName)(parameterTypes); TypeName blockName &#x3D; ^returnType(parameters) {…}; 作为函数参数 int (^sumOfNumbers)(int a, int b) &#x3D; ^(int a, int b) { return a + b; }; SDWebImage中使用的block示例：12345typedef void(^SDWebImageCompletionBlock)(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL);typedef void(^SDWebImageCompletionWithFinishedBlock)(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL);typedef NSString *(^SDWebImageCacheKeyFilterBlock)(NSURL *url); block调用跟C函数类似使用（），括号里面还可以带一个或者多个参数 12345678910// block声明（void）(^loggerBlock)(void); // block定义loggerBlock = ^&#123; NSLog(&quot;hello world&quot;)&#125;;// block调用loggerBlock(); block内存管理默认情况下，block是在栈内存中，它不会对所引用的对象进行任何操作；如果对block进行一次copy操作，block就会在堆内存中，并且它会它所有的引用的对象做一次retain操作 对于block外的变量引用，block 默认是将其复制到其数据结构中来实现访问的 对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的 而block会捕获代码外的局部变量，并且仅限于只读操作 在block中希望修改的外界局部对象，必须加上__block关键词 ARC 如果对象使用`__unsafe_unretained`或`__weak`修饰，就不会对其做`retain`操作 MRC 如果对象使用了`__block`修饰, 就不会对其做`retain`操作 为了防止block中的循环引用，可以用__weak关键词把相应的对象声明为弱引用,在block快内部需要多次访问，防止该对象被释放，可以用__strong关键词将声明为强引用： 123456789__weak __typeof__(self) weakSelf = self;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; __strong __typeof(self) strongSelf = weakSelf; [strongSelf doSomething]; [strongSelf doOtherThing];&#125;); 参考链接 谈Objective-C block的实现 A look inside blocks: Episode 1 A look inside blocks: Episode 2 A look inside blocks: Episode 3 对 Objective-C 中 Block 的追探 LLVM 中 block 实现源码 objective-c-blocks-quiz Blocks iOS开发-由浅至深学习block","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"Favorite","slug":"Favorite","permalink":"https://blog.wangruofeng007.com/tags/Favorite/"},{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"App常见崩溃问题分析","slug":"2016-10-23-appchang-jian-beng-kui-wen-ti-fen-xi","date":"2016-10-23T15:18:01.000Z","updated":"2024-11-02T03:36:52.409Z","comments":true,"path":"2016/10/23/2016-10-23-appchang-jian-beng-kui-wen-ti-fen-xi/","permalink":"https://blog.wangruofeng007.com/2016/10/23/2016-10-23-appchang-jian-beng-kui-wen-ti-fen-xi/","excerpt":"","text":"前言此文是基于这些年工作中项目里面常见崩溃的一些总结，整理出来方便查阅，希望对大家都有所帮助。 App常见崩溃 数组下标越界 字典构造与修改 NSAttributedString相关 呈现一个空控制器 unrecognized selector 操作tableView数据 Push到同一个控制器多次 1.数组下标越界示例代码： 12345- (void)testArrayOutOfBounds&#123; NSArray *testArray = @[@1,@2,@3]; NSNumber *num = testArray[3];&#125; 异常现象： Terminating app due to uncaught exception ‘NSRangeException’, reason: ‘** -[__NSArrayI objectAtIndex:]: index 3 beyond bounds [0 .. 2]’* 预防方案： 在数组中取值时需要先进组下标索引边界检查，如果没有越界方可取值。 2.字典构造造与修改示例代码： 12345678- (void)testDicSetNilValueCrash&#123; // 构造不可变字典时 key和value都不能为空 NSString *nilValue = nil; NSString *nilKey = nil; NSDictionary *dic1 = @&#123;@&quot;key&quot; : nilValue&#125;; NSDictionary *dic2 = @&#123;nilKey : @&quot;value&quot;&#125;;&#125; 异常现象： Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘** -[__NSPlaceholderDictionary initWithObjects:forKeys:count:]: attempt to insert nil object from objects[0]’* 预防方案： 在我们使用字面量快速创建一个字典的时候需要特别小心，因为很可能字典的键和值不能保证同时不为空。有潜在崩溃的风险，这种崩溃非常容易出现，需要特别小心，但是当你留心的话也非常好避免，就是设置字典的键或者值的时候判断是否非空，可变字典设置某个键的值是可以为空，相当于删除字典中的某个键值。为了使App保持健壮推荐使用KVO或者字面量的方式来设置字典的值 1234567891011121314- (void)testMutableDicSetNilValueCrash&#123; NSString *value = nil; NSMutableDictionary *mDic = [NSMutableDictionary dictionary]; // via Dic set, leading crash [mDic setObject:value forKey:@&quot;key&quot;]; // via KVO set, it&#x27;s safe [mDic setValue:value forKey:@&quot;key&quot;]; // or via literal set, it&#x27;s safe mDic[@&quot;key&quot;] = value;&#125; 3.NSAttributedString相关示例代码： 1234567891011121314- (void)testAttributedStringInitCrash&#123; NSString *nilStr = nil; NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:nilStr];&#125;- (void)testAttributedStringAddAttributeCrash&#123; NSString *nonnullStr = @&quot;str&quot;; NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:nonnullStr]; NSString *nilValue = nil; [attributedStr addAttribute:NSAttachmentAttributeName value:nilValue range:NSMakeRange(0, 1)];&#125; 异常现象： Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘NSConcreteMutableAttributedString initWithString:: nil value’ 预防方案： 在构造NSMutableAttributedString或者NSAttributedString需要留意，设置的属性的值是否有可能存在nil的情况。这个很容易被人忽视，值得注意。 4.呈现一个空控制器示例代码： 1234567- (void)testPresentNilControllerCrash&#123; UIViewController *someVC = [UIViewController new]; UIViewController *presentVC = nil; [someVC presentViewController:presentVC animated:YES completion:nil];&#125; 异常现象： present一个空的控制器导致App crash 预防方案： present一个新控制器时，判断是否存在，存在才执行，否则直接返回 123456789- (void)testPresentNilControllerCrashFixed&#123; UIViewController *someVC = [UIViewController new]; UIViewController *presentVC = [UIViewController new]; if (presentVC) &#123; [someVC presentViewController:presentVC animated:YES completion:nil]; &#125;&#125; 5.unrecognized selector示例代码： 1234- (void)testUnrecogernizedSelectorCash&#123; [self performSelector:@selector(testSel) withObject:nil afterDelay:0];&#125; 异常现象： Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘-[ViewController testSel]: unrecognized selector sent to instance 0x7ffd41609d10’ 预防方案： 此类崩溃经常出现，特别是当服务器数据放回异常时，比如本来应该返回一个NSString类型字符串，结果返回NULL,当你调用字符串的length方式时，导致App崩溃。预防方法，重要的地方对类型进行判断再调用该类的相关方法，或者写一个分类统一处理此类逻辑。 6.操作tableView数据示例代码： 12345678910111213141516- (void)testTableViewUpdateCrash&#123; NSIndexPath *insertIndexPath = [NSIndexPath indexPathForRow:0 inSection:0]; NSIndexPath *deleteIndexPath = [NSIndexPath indexPathForRow:1 inSection:0]; NSIndexPath *reloadIndexPath = [NSIndexPath indexPathForRow:2 inSection:0]; NSIndexPath *moved1IndexPath = [NSIndexPath indexPathForRow:3 inSection:0]; NSIndexPath *moved2IndexPath = [NSIndexPath indexPathForRow:4 inSection:0]; [self.tableView beginUpdates]; [self.tableView insertRowsAtIndexPaths:@[insertIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic]; [self.tableView deleteRowsAtIndexPaths:@[deleteIndexPath]withRowAnimation:UITableViewRowAnimationAutomatic]; [self.tableView reloadRowsAtIndexPaths:@[reloadIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic]; [self.tableView moveRowAtIndexPath:moved1IndexPath toIndexPath:moved2IndexPath]; [self.tableView endUpdates];&#125; 异常现象： Fatal Exception: NSInternalInconsistencyException Invalid update: invalid number of sections. The number of sections contained in the table view after the update (1) must be equal to the number of sections contained in the table view before the update (1), plus or minus the number of sections inserted or deleted (1 inserted, 0 deleted). 预防方案： 当需要动态更新tableView的数据时，计算好模型的数据使模型的数据和更新tableView的后的数据保持同步。 7.Push到同一个控制器多次异常现象： Fatal Exception: NSInvalidArgumentException Pushing the same view controller instance more than once is not supported (&lt;PPSelectPayMethodViewControllerIOS7: 0x10d7e7f10&gt;) 参考链接： 防止点击 Cell 时 ViewController 被重复 Push 以上就是工作中常见的异常崩溃以及处理方案，下面的异常分类内容来自Apple的官方文档，有兴趣的可以查阅。☕️ Apple官方常见异常类型(Exception types) 访问一块坏内存[EXC_BAD_ACCESS] // SIGSEGV // SIGBUS] 异常退出[EXC_CRASH // SIGABRT] 追踪受限[EXC_BREAKPOINT // SIGTRAP] 非法指令[EXC_BAD_INSTRUCTION // SIGILL] 被保护的资源遭到侵害[EXC_GUARD] 资源限制[EXC_RESOURCE] 其他异常类型 1.访问一块坏内存(Bad Memory Access)当程序试图接入无效内容或者尝试以不被允许的方式接入由于内存的保护等级(例如，尝试写入只读的内存)。Exception Subtype字段包含一个kern_return_t结构体用来描述错误和不正确接入的内存地址。 下面是一些调试坏内存接入导致崩溃的建议： 假如objc_msgSend或者objc_release在崩溃线程回溯(Backtraces)的顶部附近,这个线程可能尝试给一个释放的对象发消息。你应该profile应用使用Zombies instrument来更好的理解这个崩溃发生的条件。 假如gpus_ReturnNotPermittedKillClient在崩溃线程回溯(Backtraces)的顶部附近，线程被终结因为它尝试用OpenGL ES或者Metal执行渲染当程序处于后台时。查看QA1766: How to fix OpenGL ES application crashes when moving to the background 打开Address Sanitizer运行你的应用。Address Sanitizer添加了额外的说明在内容接入当你编译代码的时候。随着你应用的运行，Xcode将⚠️你假如内存以一种可能导致崩溃的方式接入。 2.异常退出（Abnormal Exit）程序异常退出，是最常见导致这类异常崩溃的原因是捕获到Objective-C/C++异常和调用了abort()函数。 App Extensions将被终结发生这种类型的异常，假如他们初始化花费太多的时间(watchdog终结)。假如一个extension由于载入时间太长被终结，产生崩溃报告的Exception Subtype将是LAUNCH_HANG。因为extensions并没有一个main函数，任何花销在初始化的时间都发生在static constructors和呈现在你的extensions和依赖库的+load方法。你应该尽可能的延迟做这些工作。 3.追踪受限（Trace Trap）和异常退出类似，这种异常的目的是给一个追加的调试器，让它有机会来打断在一个当它执行时候指定的点的进程。你可以使用__builtin_trap()函数在你的代码中来触发这个异常。假如没有调试器追加的话，线程将被终结并且产生一个崩溃报告。 低等级的库（例如libdispatch）将受限这个进程一旦遇到一个重大的错误。关于错误的额外信息可以在Additional Diagnostic Information章节中的崩溃报告找到，或者在设备的控制台。 假如在runtime遇到诸如下面的一个意外的条件，Swift代码将终结出现这种类型的异常： 非可选类型带有一个nil值 错误的强制类型转换 查看Backtraces来决发生定异常条件的位置。额外的信息可能已经在设备的控制台打印出来了。你应该修改崩溃处的代码来优雅的处理runtime错误。例如，使用Optional Binding而不是强制解包一个可选变量。 4.非法指令（Illegal Instruction）进程尝试执行一个非法或者未定义的指令。进程可能已经尝试跳进到一个无效的地址通过一个配置错误的函数指针。在Intel处理器中，ud2操作码导致一个EXC_BAD_INSTRUCTION异常，但是它通常被用来困住进程达到调试的目的。Swift代码在Intel处理器中将以这种异常终结，假如在runtime位置条件发生。更多详情查看Trace Trap。 5.被保护的资源遭到侵害（Guarded Resource Violation）进程侵犯一个被保护的资源。系统库可能某个文件的描述器成guarded，在那以后，所有不正常的操作在这些描述器上都将触发一个EXC_GUARD异常（当它想操作在这些文件描述器上，系统可以使用特殊的guarded标记的私有APIs）。这可以帮你向下快速追踪问题，例如关闭一个已经被系库打开的文件描述器。例如，假如一个app关闭文件秒杀器通过使用截图SQLite文件到一个Core Data存储，Core Data将会在随后诡异的崩溃。guard exception将让这些问题尽早引起你的注意，这样也让他们变得更容易调试。 崩溃报告来自新版的iOS包含了人类可读的详细信息关于引起EXC_GUARD异常的操作在Exception Subtype和Exception Message字段中。在来自macOS或者老版本的iOS的崩溃报告中，这些信息被编码到第一个 Exception Code就像一个分解成如下的位段： [63:61] - Guard Type：被保护的资源类型。0x2代表一个文件描述器资源。 [60:32] - Flavor：侵害被处罚时的条件 假如第一个(1 &lt;&lt; 0)位被设置，进程尝试执行close()函数在一个受保护的文件描述器。 假如第二个(1 &lt;&lt; 1)位被设置，进程尝试执行dup()，dup2()，或者fcntl()带F_DUPFD或者F_DUPFD_CLOEXEC命令在一个受保护的文件描述器。 假如第三个(1 &lt;&lt; 2)位被设置，进程尝试通过一个socket发送给一个受保护的文件描述器。 假如第三个(1 &lt;&lt; 3)位被设置，进程尝试写入到一个受保护的文件描述器。 [31:0] - File Descriptor：进程尝试修改的受保护的文件描述器。 6.资源限制（Resource Limit）进程超出了一个资源消耗的限制。这是一个来自操作系统通知，告诉进程正在使用的资源过多。精确的资源列在Exception Subtype字段中。假如Exception Note字段包含NON-FATAL CONDITION，进程不会被终结即使产生了一个崩溃报告。 异常子类型MEMORY表明进程已经越过系统应用的内存限制。这可能是一个终结的先兆由于超额的使用内存。 异常子类型WAKEUPS表明在进程中的线程每秒被唤醒太多次，这强制CPU非常频繁的唤醒消耗电池寿命。 典型的，这个通过由线程与线程的通信产生（通常是使用peformSelector:onThread:或dispatch_async）,那样无意的发生了远远超出它正常应该的切换频率。因为通信的协调发生得非常频繁而出发此类的异常，这个通常和多个后台线程有着相似Backtraces – 表明那些地方发生过通信。 7.其他异常类型（Other Exception Types）一些崩溃报告可能含有一个未命名的Exception Type，将以一个16进制的值（例如，00000020）的形式打印。假如你的设备收到了一个这样的崩溃报告，直接查看Exception Codes字段寻找更多的信息。 异常代码0xbaaaaaad表明记录是整个系统的stackshot，不是一个崩溃报告。为了获得一个stackshot，按Home键和任意音量键。这些记录经常被用户偶然创建，并不表明是一个错误。 异常代码0xbad22222表明一个VoIP应用已经被iOS终结，因为它启动得太频繁。 异常代码0x8badf00d表明应用已经被iOS终结因为发生watchdog超时。应用花费太长时间启动，终结，或者响应系统事件。通常导致这歌问题是做了在主线程执行了同步的网络请求。无论什么操作在Thread 0都需要移动到后台线程，或者异步处理，以免它阻塞主线程。 异常代码0xc00010ff表明引用被操作系统终结为了响应一个发热事件。这个可能由于一个发生崩溃的特定的设备的问题或者环境被操作导致。为了使你的应用更高效运行的建议，查看WWDC session iOS Performance and Power Optimization with Instruments。 异常代码0xdead10cc表明应用被iOS终结，由于当在后台运行时它持有了一个系统的资源（像通信录数据库）。 异常代码0xdeadfa11表明应用被用户强制退出。强制退出发生在当用户第一次按下开关机按钮直到”滑动来关机”出现，然后在按下Home键。这是合理的假如用户这样做了，因为应用已经变得不可响应，但是这并不能保证 - 强制退出任何正在运行的任务。 注意：终结一个挂起的app通过从多任务关系面板中移除并不会产生一个崩溃报告。一旦一个app被挂起，iOS它有资格在任何时候终结它，所有没有崩溃报告产生。 参考资料 Understanding and Analyzing Application Crash Reports Analyzing Crash Reports","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"快速封装Airbnb风格Loadingview","slug":"2016-09-10-kuai-su-feng-zhuang-airbnbfeng-ge-loadingview","date":"2016-09-10T05:54:15.000Z","updated":"2024-11-02T03:36:52.409Z","comments":true,"path":"2016/09/10/2016-09-10-kuai-su-feng-zhuang-airbnbfeng-ge-loadingview/","permalink":"https://blog.wangruofeng007.com/2016/09/10/2016-09-10-kuai-su-feng-zhuang-airbnbfeng-ge-loadingview/","excerpt":"","text":"前言一直在观察各种App的LoadingView，比较有代表性的是MBProgressVHUD，SVProgressHUD，这两个使用得非常广泛，大到QQ，支付宝，小到各种不知道名的App，长时间的迭代让它们的逻辑非常完善，同时也导致了有些累赘，如果把它们当一个产品来分析，可以看出，它们在不断地增加需求和使用场景，有没有一个非常简洁的HUD没有我们不需要的那些多余的逻辑只是负责显示指示和隐藏呢？ 好像没有，所有今天动手准备自己封装一个LoadingView，灵感来自Airbnb，用过Airbnb的同学都知道，它的LoadingView很有风格,Airbnb是几张图片循环翻转切换，当然我不准备复制他们的idea，我准备做一个循环左右上下切换的LoadingView。 废话不多说，先来看一下，最终效果的原型图 思路分析一下思路： 四条虚线交叉形成的区域就是我们能够看到的图片 首先准备两张图片，位置 中+上 开始第一段动画，向下切换，位置 变成 中+下 第一段动画结束，将下面的图片移动到右边，准备开始第二段动画 第二动画跟第一段类似，只是方向是从右向左，动画结束后 位置变成 中+左 将左边的图片移动到上方位置，完成一个循环 为了使动画更流畅不至于生硬，我们使用iOS7推出的带弹簧效果的API 123 + (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0); API接口在API接口设计上，我希望尽量简单实用，封装了两个方法，一个用来显示，一个用来隐藏，可以指定显示到某个view，以及指定显示和隐藏时是否使用动画。 1234 + (void)showViewAddedTo:(UIView *)view animated:(BOOL)animated;+ (void)hideViewForView:(UIView *)view animated:(BOOL)animated; API实现根据刚才的分析，核心的动画实现已经有了思路，现在就是怎么设计内部代码实现，为了方便显示蒙版阻止加载的时候用户交互，我把view的背景颜色设置了一个淡灰色，view的中间有三个子view，一个是位于中间的容器centralView,负责显示我们所看到的区域，方便实现圆角和动画效果，里面加入两个子view，firstView和secondView用于显示动画切换的图片。 内部接口大概这样 12345@property (nonatomic, strong) UIView *centralView;@property (nonatomic, strong) UIImageView *firstView;@property (nonatomic, strong) UIImageView *secondView; 为了防止多次添加LoadingView，在每次添加前，我们会查找该view是否存在，如果不存在，创建一个新的对象，如果存在直接跳过添加操作。反向遍历，快速查找。 12345678910111213+ (RFLoadingView *)loadingViewForView:(UIView *)view&#123; NSEnumerator *subviewsEnum = [view.subviews reverseObjectEnumerator]; for (UIView *subview in subviewsEnum) &#123; if ([subview isKindOfClass:self]) &#123; return (RFLoadingView *)subview; &#125; &#125; return nil;&#125; 动画核心实现,两端动画，封装成两个方法 - (void)animatedImageFromTopToBottom - (void)animatedImageFromTopToBottom 具体实现如下 123456789101112131415161718192021222324252627282930313233- (void)animatedImageFromTopToBottom&#123; [UIView animateWithDuration:0.3 delay:0.5 usingSpringWithDamping:0.7 initialSpringVelocity:0 options:UIViewAnimationOptionCurveEaseInOut animations:^&#123; _firstView.centerY += kCenterViewSize; _secondView.centerY += kCenterViewSize; &#125; completion:^(BOOL finished) &#123; _firstView.centerX += kCenterViewSize; _firstView.centerY -= kCenterViewSize; [self changeFirstImage]; [self animatedImageFromRightToLeft]; &#125;];&#125;- (void)animatedImageFromRightToLeft&#123; [UIView animateWithDuration:0.3 delay:0.5 usingSpringWithDamping:0.7 initialSpringVelocity:0 options:UIViewAnimationOptionCurveEaseInOut animations:^&#123; _firstView.centerX -= kCenterViewSize; _secondView.centerX -= kCenterViewSize; &#125; completion:^(BOOL finished) &#123; _secondView.centerX += kCenterViewSize; _secondView.centerY -= kCenterViewSize; if (self.alpha &amp;&amp; self) &#123; [self changeSecondImage]; [self animatedImageFromTopToBottom]; &#125; &#125;];&#125; 需要非常注意的是，一定要写上终止动画的条件，不然会无限循环，影响性能 show和hide123456789101112131415161718192021222324- (void)showAnimated:(BOOL)animated&#123; RFMainThreadAssert(); self.alpha = 1; [UIView animateWithDuration:animated ? 0.3 : 0 animations:^&#123; _centralView.alpha = 1; &#125; completion:^(BOOL finished) &#123; [self animatedImageFromTopToBottom]; &#125;];&#125;- (void)hideAnimated:(BOOL)animated&#123; RFMainThreadAssert(); [UIView animateWithDuration:animated ? 0.3 : 0 animations:^&#123; self.alpha = 0; &#125; completion:^(BOOL finished) &#123; [self removeFromSuperview]; &#125;];&#125; 最终效果 Github Demo地址:RFLoadingViewDemo","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"iOS第三方库汇总","slug":"2016-04-15-iosdi-san-fang-ku-hui-zong","date":"2016-04-15T09:23:38.000Z","updated":"2024-11-02T03:36:52.407Z","comments":true,"path":"2016/04/15/2016-04-15-iosdi-san-fang-ku-hui-zong/","permalink":"https://blog.wangruofeng007.com/2016/04/15/2016-04-15-iosdi-san-fang-ku-hui-zong/","excerpt":"","text":"简介此文用于总结，本人使用过或者收藏过的Github第三方类库，以便日后查阅，也便他人借鉴。 资料整理中不定期更新。。。 开源项目 CodeHub browse and maintain your GitHub repositories on any iOS device! Open-Source iOS Apps 开源iOS apps列表 APP相关 iVersion 提示版本更新 BonMot 字体相关的库，设置字体样式 FontAwesomeKit FontAwesomeKit 提供一些简单的助手类用来帮助在iOS上使用FontAwesome Font-Awesome The iconic font and CSS toolkit JMHoledView 首次启动APP的新手指引 自动布局 Masonry 最优雅的自动布局解决方案，支持链式编程 PureLayout 又一强大的自动布局解决方案 网络请求 AFNetworking 地球人都在用 CocoaAsyncSocket 封装最完善的Socket类库 RxAlamofire 封装Alamofire 基础工具类以及Category sstoolkit 一个不错的工具包，提供各种比如编码、加密、字符串处理等等东西 BFKit Swift版本 国外的一个大神写的很好用的分类，比较齐全 YYKit ibireme用心之作 BlocksKit 为基础类提供Block支持，很好用 DateTools 非常强大的日期处理工具 FlatUIKit 扩展Foundation基本UI主件，扁平化风格 iOS-Categories iOS Objective-C Category, a collection of useful Objective-C Categories extending iOS Frameworks such as Foundation,UIKit,CoreData,QuartzCore,CoreLocation,MapKit Etc. PinYin4Objc 拼音解析 ZipArchive 解压缩 Chameleon 扁平颜色框架，可以创建非常漂亮的颜色 CYLTabBarController 低耦合集成TabBarController RKNotificationHub 在右上方显示通知小角标 Material-Controls-For-iOS Google风格的控件 YYKit A collection of iOS components. 弹框 TYAlertController 各种风格的弹框，满足你的各种需求 JKPopMenuView 简单的弹出菜单 MMPopupView 精简的弹框，非常漂亮，和喜欢 MJPopupViewController A UIViewController Category to display a ViewController as a popup with different transition effects. QBPopupMenu 自定义popup menu，外观和iOS7上的UIMenuController类似 CWStatusBarNotification 状态栏通知 DOPDropDownMenu 下拉列表菜单 KLCPopup 非常漂亮的弹出控件 动画 JHChainableAnimations 链式动画编程，有点Masonry的味道 Canvas 非常强大的动画框架 VCTransitionsLibrary 转场动画库 iCarousel 各种3D变换的动画，以前用过，炫酷得没朋友 tapkulibrary Tapku remain home to the things like the calendar UIs, coverflow, and any legacy classes, ect. TBIconTransitionKit 点击按钮过渡动画 + –&gt; x - –&gt; + Spring A library to simplify iOS animations in Swift awesome-iOS-animation iOS动画库整理收集 FeSpinner Rocket Loader Collection for iOS app,有一些非常有趣的loading动画 SDECollectionViewAlbumTransition CollectionView相册自定义转场 RZTransitions A library of custom iOS View Controller Animations and Interactions. AnimatedTransitionGallery 各种自定义转场动画收集，非常值得学习 StarWars.iOS 非常炫酷的CAShapeLayer动画，非常炫酷😘 Animations 来自极客学院的YouXianMing的一些动画收集 ZFDragableModalTransition Custom animation transition for present modal view controller Gif引擎 FLAnimatedImage Flipboard开源的Gif引擎 缓存 RENCache 简单的缓存解决方案 RNCachingURLProtocol webView离线缓存库 HanekeSwift Swift语言书写的轻量级图片缓存框架 FastImageCache Path官方开源的图片缓存框架 Kingfisher 猫神用Swift实现图片下载缓存框架 文本相关 TTTAttributedLabel 非常强大的Label，支持属性，数据诊断和链接 SlackTextViewController Slack开源的drop-in UIViewController subclass with a growing text input view and other useful messaging features RTLabel 可以展示Html的Label TYAttributedLabel 强大的属性文本控件(无需了解CoreText)，支持图文混排显示，支持添加链接，image和UIView控件，支持自定义排版显示 CSGrowingTextView 文本框会随着输入字数改变高度 LTMorphingLabel 效果非常炫的文本框 TextFieldEffects 动效非常不错的文本输入框 DDRichText 图文混排 BMLine 为你的View增加线条 UITextView-Placeholder A missing placeholder for UITextView. 加载进度 DACircularProgress 各种圆形和圆环型进度指示 NJKWebViewProgress UIWebView progress interface MBProgressHUD 这个不用讲，基本上都会用 SVProgressHUD 又一个进度指示 Toast 和MBProgressHUD差不多 LCProgressHUD 对MBProgressHUD的简单封装，非常实用 TSMessages 消息通知提醒框，非常好用 PINRemoteImage Pinterest抓取远程图片类 SDWebImage 最广泛使用的图片缓存框架 AlamofireImage Swift版本的SDWebImage 键盘类 DAKeyboardControl 一个键盘管理框架 IQKeyboardManager 全局键盘管理 TPKeyboardAvoiding 使用时设置scrollView的类为TPKeyboardAvoidingScrollView即可支持xib RDRStickyKeyboardView 作者已经停止维护。。。 抽屉 ViewDeck 功能强大的抽屉效果 MMDrawerController 又一个抽屉 SWRevealViewController A UIViewController subclass for revealing a rear (left and&#x2F;or right) view controller behind a front controller, inspired by the Facebook app, done right! MSDynamicsDrawerViewController Container view controller that leverages UIKit Dynamics to provide a realistic drawer navigation paradigm. PKRevealController 安装简便，高度定制且对手势识别良好 NavigationBar AMScrollingNavbar Swift语言编写上下滑动时动态隐藏标题栏 LTNavigationbar 导航栏颜色动态改变 JZNavigationExtension Navigation的扩展，推荐 ScrollView相关 SwipeView SwipeView is a class designed to simplify the implementation of horizontal, paged scrolling views on iOS. It is based on a UIScrollView, but adds convenient functionality such as a UITableView-style dataSource&#x2F;delegate interface for loading views dynamically, and efficient view loading, unloading and recycling. SWTableViewCell 自定义Cell侧滑动作 MGSwipeTableCell 自定义Cell侧滑动作，效果多样 CHTCollectionViewWaterfallLayout 瀑布流布局 TYSlidePageScrollView An easy solution to page views or controllers with header and page tabbar,footer XLPagerTabStrip Android PagerTabStrip for iOS. nice MJ系列 MJExtension model &lt;–&gt; dic &lt;–&gt; json 框架 MJRefresh 刷新控件 数据库 realm-cocoa 跨平台轻量级数据库解决方案,励志取代Core Data &amp; SQLite fmdb 对sqlite实现面向对象的封装 图标库 PNChart 提供各种图标样式，性能还非常不错 Charts Beautiful charts for iOS&#x2F;tvOS&#x2F;OSX! The Apple side of the crossplatform MPAndroidChart. 图片处理以及展示相关 GPUImage 开源基于GPU的图片渲染引擎，带有很多款滤镜 FXBlurView 背景模糊 IDMPhotoBrowser 照片浏览器 AGImagePickerController 相册选择 DNImagePicker 仿照微信的照片选取器 JFImagePickerController 又一个照片选取器 Nuke Image loading, processing, caching and preheating 日历选择 FSCalendar iOS7+风格的日历控件，非常漂亮 音频&#x2F;视频 KRVideoPlayer 36氪开源的视频播放器 DOUAudioStreamer 豆瓣开源的音频播放器 内购&#x2F;推广 IAPHelper in app purchases helper for iOS DAAppsViewController 应用推广界面，填写合作app的appleId即可 TAPromotee 交叉推广应用是你可以免费实现的最佳市场推广策略之一。 存储相关 SSKeychain 钥匙串存储 PINCache Pinterest出品的非阻塞式异步缓存工具 TMCache tumblr出品的对象快速异步缓存，支持iOS和OS X MagicalRecord 简化Core Data抓取数据的逻辑，推荐 KeychainAccess Simple Swift wrapper for Keychain that works on iOS and OS X UICKeyChainStore UICKeyChainStore的简单封装 实用控件 HCSStarRatingView 简单的评分控件 LNNotificationsUI 模仿iOS标准通知界面，可以以假乱真 SCLAlertView-Swift 非常漂亮的动画Alert View，使用Swift书写 Wonderful 跑马灯,彩色标签,渐变等。。。 VVeboTableViewDemo VVebo剥离的TableView绘制 FXForms 快速创建表单,设置页,用户数据任务,非常棒 SVPullToRefresh 一行代码实现UIScrollView下拉刷新或者无限滚动 辅助类 Surge 利用Accelerate高性能数学计算框架 KMCGeigerCounter 显示当前动画的帧率 XNGMarkdownParser Markdown解析器，将Markdown格式的字符串解析成NSAttributedString格式的字符串 TransformerKit 封装了一些常用的NSValueTransformer类 RuntimeBrowser Objective-C Runtime Browser, for Mac OS X and iOS iOS-Runtime-Headers iOS Objective-C headers as derived from runtime introspection appledoc Objective-C代码，苹果风格文档生成器 Markingbird Markdown processor written in Swift (translation of MarkdownSharp) Swift 30DaysofSwift allenwong自学Swift的30个工程 👍 SwiftGuide 这份指南汇集了Swift语言主流学习资源，并以开发者的视角整理编排 swift-package-manager Swift包管理工具 Carthage Swift依赖管理工具，类似OC的CocoaPods swift-style-guide raywenderlich.com官方Swift编程风格规 RxSwift Reactive Programming in Swift 其它 FreeCodeCamp The https://FreeCodeCamp.com open source codebase and curriculum. Learn to code and help nonprofits. libextobjc 拓展了一些Cocoa类库 ParseSourceCodeStudy Facebook开源的Parse源码分析【系列】 hugo 使用Google Go语言书写的静态博客网站生成器 CocoaPods Cocoa包依赖管理工具 MDCSwipeToChoose 实现某App，左滑不喜欢，右滑喜欢的卡片堆叠功能 Dash-Plugin-for-Xcode Xcode的一个插件，整合Dash，方便快速查阅文档 iOS 开发面试问题 汇总一些常见的iOS面试问题 XMPPFramework XMPP即时通信协议框架 WebViewJavascriptBridge Objective-C与JavaScript在UIWebViews&#x2F;WKWebView之间交互解决方案 articles-1 Articles for objccn.io. objc.io的完整、准确、优雅的中文翻译版本 articles Weekly articles for NSHipster.com ebook 收集了一些coding相关的电子书 dev-blog nixzhu的一些 iOS &#x2F; Web 开发相关的翻译或原创博客文章 KVOController Simple, modern, thread-safe key-value observing for iOS and OS X. LBXScan 二维码、扫码、扫一扫、ZXing和ios系统自带扫码封装，扫码界面效果封装 参考链接： iOS学习资源汇总 – 鹏威の博客博客","categories":[{"name":"资料收集","slug":"资料收集","permalink":"https://blog.wangruofeng007.com/categories/%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"Favorite","slug":"Favorite","permalink":"https://blog.wangruofeng007.com/tags/Favorite/"},{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"如何利用LLDB来Debug","slug":"2016-04-15-ru-he-li-yong-lldblai-debug","date":"2016-04-15T02:58:26.000Z","updated":"2024-11-02T03:36:52.409Z","comments":true,"path":"2016/04/15/2016-04-15-ru-he-li-yong-lldblai-debug/","permalink":"https://blog.wangruofeng007.com/2016/04/15/2016-04-15-ru-he-li-yong-lldblai-debug/","excerpt":"","text":"介绍鉴于现在调试的频繁性和重要性，此文记录了一些基本的LLDB调试命令，方便日后查阅。 常用命令 p、po、call、print123456789101112p -- (&#x27;expression --&#x27;) Evaluate an expression (ObjC++ or Swift) in the current program context, using user defined variables and variables currently in scope.po -- (&#x27;expression -O -- &#x27;) Evaluate an expression (ObjC++ or Swift) in the current program context, using user defined variables and variables currently in scope.print -- (&#x27;expression --&#x27;) Evaluate an expression (ObjC++ or Swift) in the current program context, using user defined variables and variables currently in scope.call -- (&#x27;expression --&#x27;) Evaluate an expression (ObjC++ or Swift) in the current program context, using user defined variables and variables currently in scope. 从官方的描述来看，p、print、call是一样的，但是po就不太一样了，输入一样但是输出不一样。po的输出的是具体对象的内容。 如果想要按照特定的格式来打印，如下： 12345678910(lldb) p/s self.title(__NSCFString *) $0 = @&quot;目的地&quot;(lldb) p self.title(__NSCFString *) $1 = 0x00007fe0c0d4d230 @&quot;目的地&quot;(lldb) p/x self.title(__NSCFString *) $2 = 0x00007fe0c0d4d230 @&quot;目的地&quot;(lldb) p/t self.title(__NSCFString *) $3 = 0b0000000000000000011111111110000011000000110101001101001000110000 @&quot;目的地&quot;(lldb) p/a self.title(__NSCFString *) $4 = 0x00007fe0c0d4d230 -&gt; 0x000000010d2fd2c8 (void *)0x000000010d2fd278: __NSCFString @&quot;目的地&quot; 打印输出格式化 name description x Regard the bits of the value as an integer, and print the integer in hexadecimal. d Print as integer in signed decimal. u Print as integer in unsigned decimal. o Print as integer in octal. t Print as integer in binary. The letter ‘t’ stands for “two”. a Print as an address, both absolute in hexadecimal and as an offset from the nearest preceding symbol. You can use this format used to discover where (in what function) an unknown address is located:(gdb) p&#x2F;a 0x54320 $3 &#x3D; 0x54320 &lt;_initialize_vx+396&gt; c Regard as an integer and print it as a character constant. This prints both the numerical value and its character representation. The character representation is replaced with the octal escape ‘\\nnn’ for characters outside the 7-bit ascii range.Without this format, gdb displays char, unsigned char, and signed char data as character constants. Single-byte members of vectors are displayed as integer data. f Regard the bits of the value as a floating point number and print using typical floating point syntax. s Regard as a string, if possible. With this format, pointers to single-byte data are displayed as null-terminated strings and arrays of single-byte data are displayed as fixed-length strings. Other values are displayed in their natural types.Without this format, gdb displays pointers to and arrays of char, unsigned char, and signed char as strings. Single-byte members of a vector are displayed as an integer array. z Like ‘x’ formatting, the value is treated as an integer and printed as hexadecimal, but leading zeros are printed to pad the value to the size of the integer type. r Print using the ‘raw’ formatting. By default, gdb will use a Python-based pretty-printer, if one is available (see Pretty Printing). This typically results in a higher-level display of the value’s contents. The ‘r’ format bypasses any Python pretty-printer which might exist. 格式： p/x $pc 参考链接：打印输出格式化 lldb声明变量123(lldb) e NSString *$str = @&quot;http://www.baidu.com&quot;(lldb) po $strhttp://www.baidu.com 我们使用e开头声明了变量 调用变量的API1(lldb) po [self.title uppercaseString] 强转返回值类型1234567891011121314(lldb) po [self.title characterAtIndex:0]U+76ee u&#x27;目&#x27;(lldb) po (unsigned int)[self.title characterAtIndex:0]30446(lldb) po (char)[self.title characterAtIndex:0]&#x27;\\xee&#x27;(lldb) po (NSString *)[self.title characterAtIndex:0]0x00000000000076ee(lldb) po (unichar)[self.title characterAtIndex:0]U+76ee u&#x27;目&#x27; 添加断点12b 120b [KLNewDestinationVC setupUI] b命令后面加行号，或者指定某个对象调用的方法 设置断点触发条件右键断点处,在condition处编辑，如果设置了条件，只要当条件满足时，才会进入断点，也可以设置条件满足时发出声音和打印提示语。 常用打印视图层次结构1(lldb) po [self.view recursiveDescription] 临时刷新界面UI123(lldb) e ((UIButton *)sender).backgroundColor = [UIColor redColor](UICachedDeviceRGBColor *) $41 = 0x00007fdd10715b00(lldb) e (void)[CATransaction flush]","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"},{"name":"Debug","slug":"Debug","permalink":"https://blog.wangruofeng007.com/tags/Debug/"}]},{"title":"使用facebook的chisel来调试","slug":"2016-04-15-shi-yong-facebookde-chisellai-diao-shi","date":"2016-04-15T02:23:44.000Z","updated":"2024-11-02T03:36:52.409Z","comments":true,"path":"2016/04/15/2016-04-15-shi-yong-facebookde-chisellai-diao-shi/","permalink":"https://blog.wangruofeng007.com/2016/04/15/2016-04-15-shi-yong-facebookde-chisellai-diao-shi/","excerpt":"","text":"介绍chisel是facebook开源的调试框架，封装了很多方便的LLDB命令便于调试iOS App，今天介绍一下使用心得以及一些常用的命令，希望对你有写帮助。 测试环境： Xcode 7.3 and iOS 9.3 simulator.OS:OSX 10.11.4 pviews and presponder doesn’t work and no output. Chisel issue on Xcode 7.3 #149 作者正在努力修复中。。。 Xcode7.2版本没有问题 安装brew update brew install chisel 创建~/.lldbinit 假如不存在编辑内容: command script import &#x2F;usr&#x2F;local&#x2F;opt&#x2F;chisel&#x2F;libexec&#x2F;fblldb.py 查看命令（lldb）help 查看具体怎样使用(lldb) help border 常用命令说明 Command Description pviews Print the recursive view description for the key window. pvc Print the recursive view controller description for the key window. visualize Open a UIImage, CGImageRef, UIView, CALayer, NSData (of an image), UIColor, CIColor, or CGColorRef in Preview.app on your Mac. fv Find a view in the hierarchy whose class name matches the provided regex. fvc Find a view controller in the hierarchy whose class name matches the provided regex. show&#x2F;hide Show or hide the given view or layer. You don’t even have to continue the process to see the changes! mask&#x2F;unmask Overlay a view or layer with a transparent rectangle to visualize where it is. border&#x2F;unborder Add a border to a view or layer to visualize where it is. caflush Flush the render server (equivalent to a “repaint” if no animations are in-flight). bmessage Set a symbolic breakpoint on the method of a class or the method of an instance without worrying which class in the hierarchy actually implements the method. wivar Set a watchpoint on an instance variable of an object. presponder Print the responder chain starting from the given object. Tips：直接点控制台上方第三个按钮呼出LLDB。 pviews(暂不可用)显示view的层级。 border&amp;unborderborder:给view或者layer添加边框颜色和边框的宽度。 使用如下： (lldb) border 0x7ffc017b2970 -c green -w 10 标示设置0x7ffc017b2970视图或者图层一个宽度为2的绿色边框。 unborder:去掉view或者layer的边框颜色和边框宽度。 使用如下： unborder 0x7ffc017b2970 pinternals这个命令就是打印出来的一个控件（id）类型的内部结构。 使用如下： pinternals 0x7ffc017b2970 presponder（暂不可用）打印出一个继承于UIResponder控件的消息传递链。 visualize可以使用mac下的预览app打开我们的图片UIImage, CGImageRef格式的图片，甚至view和layer的图片。 使用如下： visualize 0x79ec3140//或者变量名，此地址是id类型的 pclasspclass可以打印出一个对象的继承关系。 使用如下： pclass 0x7fcd15108800 taplog这个命令是模拟敲击一下屏幕，并且打印出你敲击屏幕时候事件接收的对象。 hide&amp;showhide命令可以直接隐藏一个对象,移除当前遮挡的对象便于你观察后面的对象。show命令会让它再次显示出来。 bmessage这个命令就是LLDB添加一个断点，譬如-viewWillAppear:这个方法，在当前控制器中你没有实现它，但是你又想在调用它的时机触发中断。 这个我就不解释了，需要补充一点的是Objectiv-c的方法是带：的。 pvc打印出当前的控制器层级。 wivar这个命令是加watchPoint。 参考链接： Chisel常用命令总结 – 简书 与调试器共舞 - LLDB 的华尔兹 – objccn.io Dancing in the Debugger — A Waltz with LLDB – objc.io","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"},{"name":"Debug","slug":"Debug","permalink":"https://blog.wangruofeng007.com/tags/Debug/"}]},{"title":"Associated Objects 关联对象","slug":"2016-04-14-associated-objects-guan-lian-dui-xiang","date":"2016-04-14T15:56:39.000Z","updated":"2024-11-02T03:36:52.407Z","comments":true,"path":"2016/04/14/2016-04-14-associated-objects-guan-lian-dui-xiang/","permalink":"https://blog.wangruofeng007.com/2016/04/14/2016-04-14-associated-objects-guan-lian-dui-xiang/","excerpt":"","text":"Associated Objects 介绍&lt;objc/runtime.h&gt;中的函数号称是iOS中最后一把神兵利刃，具有其他方式做不到的，能为应用和框架提供强大功能的能力。但使用不当也可能废掉代码的,一切代码和逻辑都可能被异常糟糕的副作用影响。 就像和魔鬼做交易一样常常让人怀着巨大的恐惧。 历史对象关联（或称为关联引用）本来是Objective-C 2.0运行时的一个特性，起始于OS X Snow Leopard和iOS4。 核心函数3个 – 允许将任何键值在允许时关联到对象上 objc_setAssociatedObject objc_getAssociatedObject objc_removeAssociatedObjects 这有什么用呢？这允许开发者对已经存在的类在扩展中添加自定义的属性 实现的3种方式 static char selector _cmd_ 使用 static char 实现NSObject+AssociatedObject.h 123@interface NSObject (AssociatedObject)@property (nonatomic, strong) id associatedObject;@end NSObject+AssociatedObject.m 123456789101112131415@implementation NSObject (AssociatedObject)static char kAssociatedObjectKey;- (id)associatedObject&#123; return objc_getAssociatedObject(self,&amp;kAssociatedObjectKey);&#125;- (void)setAssociatedObject:(id)associatedObject&#123; objc_setAssociatedObject(self, &amp;kAssociatedObjectKey, associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 使用 selector 实现NSObject+AssociatedObject.h 123@interface NSObject (AssociatedObject)@property (nonatomic, strong) id associatedObject;@end NSObject+AssociatedObject.m 12345678910111213@implementation NSObject (AssociatedObject)- (id)associatedObject&#123; return objc_getAssociatedObject(self, @selector(associatedObject));&#125;- (void)setAssociatedObject:(id)associatedObject&#123; objc_setAssociatedObject(self, @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 使用 _cmd_ 实现NSObject+AssociatedObject.h 123@interface NSObject (AssociatedObject)@property (nonatomic, strong) id associatedObject;@end NSObject+AssociatedObject.m 12345678910111213@implementation NSObject (AssociatedObject)- (id)associatedObject&#123; return objc_getAssociatedObject(self, _cmd_);&#125;- (void)setAssociatedObject:(id)associatedObject&#123; objc_setAssociatedObject(self, @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 关联对象的行为属性根据枚举类型objc_AssociationPolicy来决定被关联在对象上的行为： Behavior 与之等效的@property OBJC_ASSOCIATION_ASSIGN @property (assign) 或@property (unsafe_unretained) OBJC_ASSOCIATION_RETAIN_NONATOMIC @property (nonatomic, strong) OBJC_ASSOCIATION_COPY_NONATOMIC @property (nonatomic, copy) OBJC_ASSOCIATION_RETAIN @property (atomic, strong) OBJC_ASSOCIATION_COPY @property (atomic, copy) OBJC_ASSOCIATION_ASSIGN类型关联对象的弱引用不代表weak的弱引用，行为上更像unsafe_unretained属性。 对象销毁时间被关联的对象在声明周期内比对象本身释放要晚很多，在对象调用-dealloc中的object_dispose()中释放。 删除属性你或许想要使用objc_removeAssociatedObjects（）来进行删除操作，但官方文档不建议手动调用这个函数。 这个函数可能会把其他用户对其添加的属性也移除了，正确的方式是调用objc_setAssociatedObject方法，传入nil值来清楚一个关联。 优秀样例 添加私有属性用于更好地去实现细节。 添加public属性来增强category的功能。 创建一个用于KVO的关联观察者。 应用举例UIImagePickerController 图片选择回调关联一个block实现完成选择图片后的回调。 UIImagePickerController+RFBlocks.h123456789@interface UIImagePickerController (RFBlocks)&lt;UIImagePickerControllerDelegate, UINavigationControllerDelegate&gt;typedef void(^RFImagePickerFinishBlock)(NSDictionary *info);@property (nonatomic, copy) RFImagePickerFinishBlock rf_finishBlock;+ (UIImagePickerController *)rf_imagePickerWithFinishBlock:(RFImagePickerFinishBlock)finishBlock;@end UIImagePickerController+RFBlocks.m123456789101112131415161718192021222324252627282930313233343536static const char kFinishBlockKey;@implementation UIImagePickerController (RFBlocks)+ (UIImagePickerController *)rf_imagePickerWithFinishBlock:(RFImagePickerFinishBlock)finishBlock&#123; UIImagePickerController *picker = [[UIImagePickerController alloc] init]; picker.rf_finishBlock = finishBlock; return picker;&#125;- (RFImagePickerFinishBlock)rf_finishBlock &#123; return objc_getAssociatedObject(self, &amp;kFinishBlockKey);&#125;- (void)setRf_finishBlock:(RFImagePickerFinishBlock)rf_finishBlock &#123; self.delegate = self; objc_setAssociatedObject(self, &amp;kFinishBlockKey, rf_finishBlock, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;#pragma mark - UIImagePickerControllerDelegate- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info&#123; RFImagePickerFinishBlock block = self.rf_finishBlock; if (block) block(info); [self dismissViewControllerAnimated:YES completion:nil]; self.rf_finishBlock = nil;&#125;@end 使用： 123456789__weak typeof(self)weakSelf = self;UIImagePickerController *picker = [UIImagePickerController rf_imagePickerWithFinishBlock:^(NSDictionary *info) &#123; NSLog(@&quot;finish picke image\\n info:%@&quot;,info); UIImage *img = info[@&quot;UIImagePickerControllerOriginalImage&quot;]; weakSelf.view.layer.contents = (id)img.CGImage; &#125;];[self presentViewController:picker animated:YES completion:nil]; 或者 12345678910111213UIImagePickerController *picker = [[UIImagePickerController alloc] init]; __weak typeof(self)weakSelf = self;picker.rf_finishBlock = ^(NSDictionary *info) &#123; NSLog(@&quot;finish picke image\\n info:%@&quot;,info); UIImage *img = info[@&quot;UIImagePickerControllerOriginalImage&quot;]; weakSelf.view.layer.contentsGravity = kCAGravityResizeAspect; weakSelf.view.layer.contents = (id)img.CGImage;&#125;;[self presentViewController:picker animated:YES completion:nil]; UIButton 按钮事件回调关联一个按钮事件block，当触发按钮UIControlEventTouchUpInside事件时回调。 UIButton+RFBlcoks.h1234567@interface UIButton (RFBlcoks)typedef void(^RFButtonClickBlock)(UIButton *button);@property (nonatomic, copy) RFButtonClickBlock rf_buttonClickBlock;@end UIButton+RFBlcoks.m123456789101112131415161718192021222324static char kButttonClickBlockKey;@implementation UIButton (RFBlcoks)- (RFButtonClickBlock)rf_buttonClickBlock&#123; return objc_getAssociatedObject(self, &amp;kButttonClickBlockKey);&#125;- (void)setRf_buttonClickBlock:(RFButtonClickBlock)rf_buttonClickBlock&#123; objc_setAssociatedObject(self, &amp;kButttonClickBlockKey, rf_buttonClickBlock, OBJC_ASSOCIATION_COPY_NONATOMIC); [self addTarget:self action:@selector(buttonClicked) forControlEvents:UIControlEventTouchUpInside];&#125;- (void)buttonClicked&#123; if (self.rf_buttonClickBlock) &#123; self.rf_buttonClickBlock(self); &#125;&#125;@end 使用： 123self.button.rf_buttonClickBlock = ^(UIButton *button)&#123; NSLog(@&quot;%@ clicked&quot;,button);&#125;; Demo地址： AssociatedObjectDemo 参考资料： Associated Objects – NSHipster Objective-C Associated Objects – King’s Cocoa Objective-C Associated Objects 的实现原理– 雷纯峰的技术博客 Associated Objects by Example – Sebastian Rehnby","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"玩转iOS剪切板","slug":"2016-04-14-wan-zhuan-iosjian-qie-ban","date":"2016-04-14T14:20:52.000Z","updated":"2024-11-02T03:36:52.407Z","comments":true,"path":"2016/04/14/2016-04-14-wan-zhuan-iosjian-qie-ban/","permalink":"https://blog.wangruofeng007.com/2016/04/14/2016-04-14-wan-zhuan-iosjian-qie-ban/","excerpt":"","text":"前言移动应用风靡的今天，大家越来越觉得，一个App的处理事情的效率至关重要，包括一些细节处理，像本地化（localization）和辅助功能（accessibility）的支持是高品质的应用和其它应用区分开的两个特性，今天我们来聊聊一个增加用户体验和效率的功能–编辑操作 编辑操作标准编辑动作处理复制，剪切，删除和粘贴命令 复制（**copy:**） 剪切（**cut:**） 删除（**delete:**） 粘贴（**paste:**） 处理选择命令 选择（**select:**） 全选（**selectAll:**） 富文本编辑命令 加粗（**toggleBoldface:**） 斜体（**toggleItalics:**） 下划线（**toggleUnderline:**） 改变书写方向命令 书写方向左到右（**makeTextWritingDirectionLeftToLeft:**） 书写方向右到左（**makeTextWritingDirectionRightToLeft:**） 改变文本尺寸命令 变大（**increaseSize:**） 变小（**decreaseSize:**） 实现label的复制粘贴功能1234567891011121314151617181920212223242526272829// RFLabel.h@interface RFLabel : UILabel@end// RFLabel.m@implementation RFLabel- (BOOL)canBecomeFirstResponder &#123; return YES;&#125;- (BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; return (action == @selector(copy:) || action == @selector(paste:));&#125;#pragma mark - UIResponderStandardEditActions- (void)copy:(id)sender &#123; [[UIPasteboard generalPasteboard] setString:self.text];&#125;- (void)paste:(id)sender &#123; NSString *toBePastedString = [[UIPasteboard generalPasteboard] string]; self.text = toBePastedString;&#125;@end 在控制器中使用它： 1234567891011121314151617181920212223242526272829303132333435363738#import &quot;ViewController.h&quot;#import &quot;RFLabel.h&quot;@interface ViewController ()@property (weak, nonatomic) IBOutlet RFLabel *topLabel;@property (weak, nonatomic) IBOutlet RFLabel *bottomLabel;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.topLabel.userInteractionEnabled = YES; self.bottomLabel.userInteractionEnabled = YES; UIGestureRecognizer *gestureRecognizer1 = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handleLongPressGesture:)]; UIGestureRecognizer *gestureRecognizer2 = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handleLongPressGesture:)]; [self.topLabel addGestureRecognizer:gestureRecognizer1]; [self.bottomLabel addGestureRecognizer:gestureRecognizer2];&#125;- (void)handleLongPressGesture:(UIGestureRecognizer *)recognizer&#123; if (recognizer.state == UIGestureRecognizerStateRecognized) &#123; [recognizer.view becomeFirstResponder]; UIMenuController *menuController = [UIMenuController sharedMenuController]; [menuController setTargetRect:recognizer.view.frame inView:recognizer.view.superview]; [menuController setMenuVisible:YES animated:YES]; &#125;&#125;@end 总结一下，为了能够支持复制粘贴一个label的文字，需要完成下面几步： 必须继承 UILabel,在子类中实现canBecomeFirstResponder和canPerformAction:withSender:方法 实现每个可以执行的操作，在方法中和UIPasteboard进行交互 初始化label时，将label的userInteractionEnabled属性设置为YES 向label添加一个手势（或者手动在子类中实现UIResponder的方法，例如touchesBegan:withEvent:） 响应手势识别事件，指明UIMenuController的位置，设置为可见 最后，使label成为第一响应者 UIMenuControllerUIMenuController负责展示编辑动作的菜单项。每个应用都持有自己的一个单例对象 sharedMenuController。默认情况下，菜单控制器会展示UIResponderStandardEditActions这个非正式协议（即不需要对应实现的协议）中的方法，假如canPerformAction:withSender:返回YES。 UIMenuItem可以通过UIMenuController的menuItems属性添加自定义的命令，每一个都是UIMenuItem对象，只需要指定每个动作的title和action 1- (instancetype)initWithTitle:(NSString *)title action:(SEL)action NS_DESIGNATED_INITIALIZER; UITableView 和 UICollectionViewUITableView和UICollectionView可以在cell上调出编辑菜单,其实任何自定义的UIView都能实现，UIViewController的子类只是以不同的方式实现而已。为了让UITableView和UICollectionView也能实现，你需要使用一些额外的方法否则屏幕上不会显示任何东西。这些方法给予了你更多的控制在显示指定的上下文菜单基于你将要显示在UITableView和UICollectionView的内容。 UITableViewDelegate 方法 – tableView:shouldShowMenuForRowAtIndexPath: – tableView:canPerformAction:forRowAtIndexPath:withSender: – tableView:performAction:forRowAtIndexPath:withSender: UICollectionViewDelegate 方法 – collectionView:shouldShowMenuForItemAtIndexPath: – collectionView:canPerformAction:forItemAtIndexPath:withSender: – collectionView:performAction:forItemAtIndexPath:withSender: Bonus实现UIImageView图片的复制粘贴功能 Demo地址： Menu_Controller_Demo 参考链接 UIMenuController – nshipster UIMenuController_Class – UIMenuController Class Reference Show the UIMenuController and Display Custom Edit Menus UITableViewCell on iOS 5 UITableViewController – Demo","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"},{"name":"剪切板","slug":"剪切板","permalink":"https://blog.wangruofeng007.com/tags/%E5%89%AA%E5%88%87%E6%9D%BF/"}]},{"title":"创建自定义View在IB中实时渲染","slug":"2016-04-10-chuang-jian-zi-ding-yi-viewzai-ibzhong-shi-shi-xuan-ran","date":"2016-04-10T05:22:56.000Z","updated":"2024-11-02T03:36:52.407Z","comments":true,"path":"2016/04/10/2016-04-10-chuang-jian-zi-ding-yi-viewzai-ibzhong-shi-shi-xuan-ran/","permalink":"https://blog.wangruofeng007.com/2016/04/10/2016-04-10-chuang-jian-zi-ding-yi-viewzai-ibzhong-shi-shi-xuan-ran/","excerpt":"","text":"曾想自定义的View，可以像系统自带属性一样，并且实时渲染，动态更新内容，现在在Xcode6终于让你可以轻松的做到。 你不用编译就能实时预览，现在配置自定义界面方便多了，IBInspectable和IBDesignable使它成为可能。 IBInspectableIBInspectable属性提供访问旧功能的新方法：用户自定义的运行时属性。从目前的身份检查器（identity inspector）中访问，这些属性在Interface Builder整合到Xcode。可以通过它来配置Nib，Xib，storyboard实例中的任何键值编码（key-value-coded）属性： 以前想实现，只能点+号手动添加例如想给UIView添加一个圆角半径，设置Key Path 为：layer.cornerRadius,type为Number ，Value为4，如果使用IBInspectable只需要在@property 声明后加上IBInspectable（或者swift 加上@IBInspectable），就可以在IB的观察面板中（inspector pannel）里直接编辑。其他交由Xcode自动完成，属性名字会自动分组，名称从驼峰（camel-）转换成 title-模式。 目前可检查属性支持 备注 : 经本人亲测，除NSNumber,NSRange不会产生观察面板属性，NSRange不会在runtime Attributes 中自动添加，其他都会自动生成。 支持颜色类型UIColor但是不支持CALayer的CGColor，设置颜色时只需设置UIColor，不要要设置CGColor，系统会自动将UIColor转换，例如设置borderColor。 IBDesignable当你应用到UIView或者UIView的子类中的时候，只需加上IBDesignable，就可以让IB在画布上实时渲染视图。当你更新属性后，视图会自动更新不需要重新运行程序。 标记一个自定义视图为IBDesignable，只需要在类名前面加上IB_DESIGNABLE（Swift里加上@IBDesignable）。你的初始化，布置和绘制方法都将用来在画布上渲染你的自定义视图: 123456789101112IB_DESIGNABLE@interface CustomView :UIView &#123;@property (nonatomic, strong) IBInspectable UIColor *borderColor; @property (nonatomic, assign) IBInspectable CGFloat borderWidth;...&#125;@end 实时效果： 有了这个功能，一个设计师或者开放人员可以轻松调整自定义的控件呈现。任何改变，都将立即呈现，有的想Swift里面的playground功能，实现：所见即所得。 由于在 Interface Builder 中呈现自定义视图不会有应用程序的完整上下文，你可能需要生成模拟数据以便显示，例如一个默认用户头像图片或仿制的天气数据。有两种方法可以为这个特殊的上下文添加代码： prepareForInterfaceBuilder() :此方法与你代码的其余部分一起编译，但只有当视图正在准备在Interface Builder显示时执行 TARGET_INTERFACE_BUILDER:#if TARGET_INTERFACE_BUILDER预处宏,在 Objective-C 或 Swift 下都是工作的，它会视情况编译正确代码 12345678#if !TARGET_INTERFACE_BUILDE// this code will run in the app it self#els// this code will execute only in IB#endif 参考资料: IBInspectable-IBDesignable Apple 官方介绍 Demo地址: IBInspectable_IBDesignable_Demo","categories":[{"name":"OC","slug":"OC","permalink":"https://blog.wangruofeng007.com/categories/OC/"}],"tags":[{"name":"Favorite","slug":"Favorite","permalink":"https://blog.wangruofeng007.com/tags/Favorite/"},{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"Unix Shell常用命令","slug":"2016-03-27-unixshellchang-yong-ming-ling","date":"2016-03-27T10:29:44.000Z","updated":"2024-11-02T03:36:52.406Z","comments":true,"path":"2016/03/27/2016-03-27-unixshellchang-yong-ming-ling/","permalink":"https://blog.wangruofeng007.com/2016/03/27/2016-03-27-unixshellchang-yong-ming-ling/","excerpt":"","text":"输出文件内容到基本输出 cat filename 改变文件的权限 chmod 或 change mode 当前的时间和日期 date 拷贝 copy 显示当前目录下所有文件以及文件夹 ls 显示dir文件夹下所有文件以及文件夹 ls dir 查看磁盘空间状况 du 查看当前进程状况 ps 你的用户名和终端类型 who 创建目录 mkdir dir 删除目录 rmdir dir 进入目录 cd dir 删除文件 rm file 显示文件 more file 显示指定文本 echo 改文件名、移动文件 mv source target 显示目录路径命令 pwd 清屏 clear 退出输入命令 Ctrl + c 改变文件或目录之最后修改时间 touch name 删除目录 rmdir directory-name 或 rm -r directory-name rmdir dir1 删除目录 dir1，但 dir1 下必须没有文件存在，否则无法删除。 rm -r dir1 删除目录 dir1，及其下所有文件及子目录。 删除文件 rm filename (filename 可为文件名，或文件名缩写符号。) rm file1 删除文件名为 file1 之文件。 rm file? 删除文件名中有五个字符，前四个字符为file 之所有文件。 rm f* 删除文件名中，以 f 为字首之所有文件。 rm -rf file 删除名为file的文件夹及其里面的内容","categories":[{"name":"Unix","slug":"Unix","permalink":"https://blog.wangruofeng007.com/categories/Unix/"}],"tags":[{"name":"Favorite","slug":"Favorite","permalink":"https://blog.wangruofeng007.com/tags/Favorite/"},{"name":"Unix","slug":"Unix","permalink":"https://blog.wangruofeng007.com/tags/Unix/"}]},{"title":"git常用命令","slug":"2016-03-27-gitchang-yong-ming-ling","date":"2016-03-27T09:08:45.000Z","updated":"2024-11-02T03:36:52.406Z","comments":true,"path":"2016/03/27/2016-03-27-gitchang-yong-ming-ling/","permalink":"https://blog.wangruofeng007.com/2016/03/27/2016-03-27-gitchang-yong-ming-ling/","excerpt":"","text":"创建新的仓库 新建文件夹，打开，执行 git init 检出仓库 创建一个本地仓库克隆版本 git clone /path/to/repository 创建远程服务器上的仓库 git clone username@host:/path/to/repository Git工作流一个本地仓库由git维护的3客”树”组成。 工作目录 working dic。 – 它持有实际文件 暂存区Index。 – 它像个缓冲区域，临时保存你的改动 HEAD。 – 它指向你最后一次提交的结果 work flow：working dic –add– &#x3D;&#x3D;&gt; Index –commit– &#x3D;&#x3D;&gt;HEAD 添加和提交 添加到暂存区 git add &lt;filename&gt; git add * git add . 提交到HEAD git commit -m &#39;some comment&#39; git commit -m &quot;some comment&quot; 添加提交二合一 git commit -a -m &#39;some comment&#39; 查看仓库修改状态git status 推送更改 现在的改动已经提交到本地仓库的HEAD中，提交到远程仓库 git push 格式git push (remote) (branch),第一次push必须这样写 git push origin master:master 推送到具体某一分支git push origin someBranch 分支操作 查看分支 git branch 查看分支最后提交状态 git branch -v --merged 与 --no-merged 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 git branch --merged aBranch iss53 * master 新建分支 git branch aBranch 切换到aBranch分支 git checkout aBranch 新建切换分支2合一 git checkout - b aBranch 删除分支 git branch -d aBranch 如果将要删除的分支还有没有合并的内容，删除将会失败，使用-D强制删除 error: The branch &#39;testBranch&#39; is not fully merged. If you are sure you want to delete it, run &#39;git branch -D testBranch&#39;. 分支重命名 git branch -m oldBranchName newBranchName 分支操作实例master是默认的分支。在其他分支上进行开发，完成后再将他们合并到主分支上。 创建一个叫“feature_x”的分支，并切换过去 git checkout -b feature_x 切换回主分支： git checkout master 删除新建分支 git branch -d feature_x 将分支推送到远程仓库 git push origin &lt;branch&gt; 更新与合并 更新你的本地仓库到最新改动 git pull 会在你的工作目录 抓取fetch并合并merge远端的改动 合并aBranch分支回master分支 git checkout master git merge aBranch 这种方式叫做直接合并（straight merge）注意没参数的情况下merge是fast-forward的，即Git将master分支的指针直接移到aBranch的最前方。 换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么Git在合并两者时，只会简单移动指针，所以这种合并成为快进式(Fast-forward) 如何避免每次输入密码如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。 如果不想在每一次推送时都输入用户名与密码，你可以设置一个 credential cache。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config --global credential.helper cache 来设置它。 压合合并squashed commits将一条分支上的若干个提交条目压合成一个提交条目，提交到另一条分支的末梢。 把aBranch分支上的所有提交压合成主分支上的一个提交，即压合提交： git checkout master git merge --squash aBranch 此时，aBranch上的所有提交已经合并到当前工作区并暂存，但还没有作为一个提交，可以像其他提交一样，把这个改动提交到版本库中： git commit -m &#39;some comment&#39; 拣选合并cherry-picking拣选另一条分支上的某个提交条目的改动带到当前分支上。 每一次提交都会产生一个全局唯一的提交名称，利用这个名称就可以进行拣选提交。 比如在dev上的某个提交叫：321d76f 把它合并到master中： git checkout master git cherry-pick 321d76f 要拣选多个提交，可以给git cherry-pick命令传递-n选项，比如： git cherry-pick –n 321d76f 这样在拣选了这个改动之后，进行暂存而不立即提交，接着可以进行下一个拣选操作，一旦拣选完需要的各个提交，就可以一并提交。 如果发生冲突，解决冲突完后执行git cherry-pick --continue继续拣选合并。 解决冲突（conflicts） 通过CONFLICT (content):找到冲突文件所在的位置 打开冲突文件，修改冲突后保存 通过git status查看冲突是否解决 通过git diff &lt;source_branch&gt; &lt;target_banch&gt;预览差异 提交更改git commit -a -m &#39;some comment&#39; 查看远程分支的完整列表git ls-remote 获取远程分支更多信息git remote show 新建远程分支git push --set-upstream origin newBranch 提交分支数据到远程服务器git push origin &lt;local_branch_name&gt;:&lt;remote_branch_name&gt; 删除远程分支git push origin :develop git push origin --delete develop 标签创建一个1.0.0的标签 git tag 1.0.0 1b2e1d63ff 1b2e1d63ff是你想要标记的提交ID的前10位字符，可使用下列命令获取提交ID git log 替换本地改动git checkout -- &lt;filename&gt; 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。 假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它 git fetch orgin git reset --hard origin/master 参考链接 Git - 简明指南 Git社区参考指南 Github Help 图解Git Think like a git","categories":[{"name":"Git","slug":"Git","permalink":"https://blog.wangruofeng007.com/categories/Git/"}],"tags":[{"name":"Favorite","slug":"Favorite","permalink":"https://blog.wangruofeng007.com/tags/Favorite/"},{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"},{"name":"Git","slug":"Git","permalink":"https://blog.wangruofeng007.com/tags/Git/"}]},{"title":"使用Mantle高效构建Model","slug":"2016-03-03-shi-yong-mantlegao-xiao-gou-jian-model","date":"2016-03-02T17:05:21.000Z","updated":"2024-11-02T03:36:52.406Z","comments":true,"path":"2016/03/03/2016-03-03-shi-yong-mantlegao-xiao-gou-jian-model/","permalink":"https://blog.wangruofeng007.com/2016/03/03/2016-03-03-shi-yong-mantlegao-xiao-gou-jian-model/","excerpt":"","text":"概述在iOS开发中，从服务器获取数据，然后解析成本地的模型是经常的要做事，而且重复次数特别多，每次增加一个网络请求或者增加一个模型都需要完成JSON到Model层的转换，手写通过字典valueForKey:直接解析已经更不上时代的步伐，学会利用工具提高自己的工作效率，今天就分享一下Mantle这个框架解析的心得。 Mantle解决的痛点： 服务器经常更新（添加或者删除）字段，客服端需要在Model层初始化的时候修改取值字段，易出错，而且繁琐。 实现自定义的Model的序列化，以便将数据保存到本地，也就是说实现NSCoding协议，在模型复制的情况下添加或者修改字段非常麻烦。 自定义的Model的Copy,你必须手动实现NSCopying协议,而且没有办法反序列化成JSON。 Mantle很好的解决的以上痛点： 实现了NSCopying协议。 实现了NSCoding协议，可以通过NSKeyedArchiver将数据归档到本地。 提供了isEqual:和hash的默认实现。 可以在Model和JSON之间互相转换。 以一个CATProfile模型类为例，演示这个框架怎样以一种非常简单的方式将一个NSDictionary对象映射成一个Objective-C,反之亦然。 下面的CATProfile模型 123456789&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Objective Cat&quot;, &quot;birthday&quot;: &quot;2013-09-12 13:29:36 +0100&quot;, &quot;website&quot;: &quot;http://objc.at&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: &quot;48.2083&quot;, &quot;lon&quot;: &quot;16.3731&quot; &#125;, &quot;relationship_status&quot;: &quot;single&quot;, &quot;awesome&quot;: true&#125; 下面我们创建一个MTLModel子类代表以上的Json对象。 1234567891011121314151617181920// CATProfile.htypedef NS_ENUM(NSInteger, CATRelationshipStatus) &#123; CATRelationshipStatusSingle = 0, CATRelationshipStatusInRelationship, CATRelationshipStatusComplicated&#125;;@interface CATProfile : MTLModel&lt;MTLJSONSerializing&gt;@property(strong, nonatomic) NSNumber *profileId;@property(strong, nonatomic) NSString *name;@property(strong, nonatomic) NSDate *birthday;@property(strong, nonatomic) NSURL *website;@property(nonatomic) CLLocationCoordinate2D locationCoordinate;@property(nonatomic) CATRelationshipStatus relationshipStatus;@property(nonatomic, getter=isAwesome) BOOL awesome;@end CATProfile类继承自MTLModel并且实现了MTLJSONSerializing，协议要求实现+JSONKeyPathsByPropertyKey方法 12345678910111213141516// CATProfile.m@implementation+ (NSDictionary *)JSONKeyPathsByPropertyKey &#123; // properties defined in header &lt; : &gt; key in JSON Dictionary return @&#123; @&quot;profileId&quot;: @&quot;id&quot;, @&quot;websiteURL&quot;: @&quot;website&quot;, @&quot;locationCoordinate&quot;: @&quot;location&quot;, @&quot;relationshipStatus&quot;: @&quot;relationship_status&quot;, &#125;;&#125;@end +JSONKeyPathsByPropertyKey方法返回一个在JSON数据中需要模型的属性匹配的值的字典，这能确保Mantle知道那个JSON键键使用来构成一个指定的模型接口。 很明显除了这个列表中的name,birthday和awesome属性。假如一个属性在字典中被忽略，Mantle将自动在JSON中查找带有相同名称的接口。 NSValueTransformer Mantle还能够处理任意类型的转换，例如NSStringheNSNumber默认支持。然而，它也需要一些帮助对于处理非任意的类型例如NSURL和枚举还有自定义的结构体像CLLocationCoordinate2D。 Mantle依赖Foundation框架下NSValueTransformer对象来实现在模型代表的JSON层和OC对象的实际接口之间的值的映射。 创建一个自定义transformer给某个属性，我们需要实现一个叫做+&lt;propertyName&gt;JSONTransformer的类方法并且返回一个想要的NSValueTransformer对象。 12345678910111213141516// mapping birthday to NSDate and vice-versa+ (NSValueTransformer *)birthdayJSONTransformer &#123; return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSString *dateString) &#123; return [self.dateFormatter dateFromString:dateString]; &#125; reverseBlock:^(NSDate *date) &#123; return [self.dateFormatter stringFromDate:date]; &#125;];&#125;+ (NSDateFormatter *)dateFormatter &#123; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; dateFormatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US_POSIX&quot;]; dateFormatter.dateFormat = @&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;Z&#x27;&quot;; return dateFormatter;&#125; Mantle在runtime调用这个方法来决定怎样变换**birthday **属性，正向转换block从一个字符串对象到一个NSDate对象，反向转换block将NSDate对象转换回一个字符串对象，非常棒！ 下面列举了一些变换方法，对于所有的我们需要注意的非任意属性以供参考。 NSURL ↔︎ JSON string123+ (NSValueTransformer *)websiteURLJSONTransformer &#123; return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];&#125; CLLocationCoordinate2D ↔︎ JSON object12345678910+ (NSValueTransformer *)locationCoordinateJSONTransformer &#123; return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSDictionary *coordinateDict) &#123; CLLocationDegrees latitude = [coordinateDict[@&quot;lat&quot;] doubleValue]; CLLocationDegrees longitude = [coordinateDict[@&quot;lon&quot;] doubleValue]; return [NSValue valueWithMKCoordinate:CLLocationCoordinate2DMake(latitude, longitude)]; &#125; reverseBlock:^(NSValue *coordinateValue) &#123; CLLocationCoordinate2D coordinate = [coordinateValue MKCoordinateValue]; return @&#123;@&quot;lat&quot;: @(coordinate.latitude), @&quot;lon&quot;: @(coordinate.longitude)&#125;; &#125;];&#125; enum ↔︎ JSON string1234567+ (NSValueTransformer *)relationshipStatusJSONTransformer &#123; return [NSValueTransformer mtl_valueMappingTransformerWithDictionary:@&#123; @&quot;single&quot;: @(CATRelationshipStatusSingle), @&quot;relationship&quot;: @(CATRelationshipStatusInRelationship), @&quot;complicated&quot;: @(CATRelationshipStatusComplicated) &#125;];&#125; BOOL ↔︎ JSON boolean123+ (NSValueTransformer *)awesomeJSONTransformer &#123; return [NSValueTransformer valueTransformerForName:MTLBooleanValueTransformerName];&#125; 从JSON创建模型对象一旦模型配置完成，就该获得JSON对象从API中，并且把它转换成我们模型的一个实例。首先，我们需要把JSON呈现转换成一个NSDictionary,它能够用来通过Mantle来创建我们的模型，很幸运的是iOS提供了一个非常棒的方法来处理它，就是通过NSJSONSerialization。 那样以后，MTLJSONAdapter类就能利用Mantle做繁重的工作来创建我们的模型。 123456// create NSDictionary from JSON dataNSData JSONData = ... // the JSON response from the APINSDictionary *JSONDict = [NSJSONSerialization JSONObjectWithData:JSONData options:0 error:NULL];// create model object from NSDictionary using MTLJSONSerialisationCATProfile *profile = [MTLJSONAdapter modelOfClass:CATProfile.class fromJSONDictionary:JSONDict error:NULL]; 从模型对象创建JSONMTLJSONAdapter也有能力创建一个字典从我们的的模型类中，以便能直接编码回一个JSON字符串。 123456// create NSDictionary from model class using MTLJSONSerialisationCATProfile *profile = ...NSDictionary *profileDict = [MTLJSONAdapter JSONDictionaryFromModel:profile];// convert NSDictionary to JSON dataNSData *JSONData = [NSJSONSerialization dataWithJSONObject:profileDict options:0 error:NULL]; 假如当创建一个JSON呈现你的模型是在你的模型中有一个属性不应该包括，你应该返回NSNull.null,例如。在+JSONKeyPathsByPropertyKey的@{“name” : “NSNull.null”}。Mantle将安全的忽略这个属性。 映射数组和字典大多数情况，模型和其他模型有关系，这些关系普遍通过JSON数组或者对象来呈现。 1234567891011121314151617181920&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Objective Cat&quot;, ..., &quot;owner&quot;: &#123; &quot;id&quot;: 99, &quot;name&quot;: &quot;Alexander Schuch&quot; &#125;, &quot;friends&quot;: [ &#123; &quot;name&quot;: &quot;Owly&quot;, &quot;type&quot;: &quot;bird&quot; &#125;, &#123; &quot;name&quot;: &quot;Hedgy&quot;, &quot;type&quot;: &quot;mammal&quot; &#125; ]&#125; Mantle支持映射这些关系到新的模型，为了让Mantle知道怎样变换关系，我们可以使用下面提供的分类方法中的一个来返回NSValueTransformer。 12+ (NSValueTransformer *)mtl_JSONDictionaryTransformerWithModelClass:(Class)modelClass;+ (NSValueTransformer *)mtl_JSONArrayTransformerWithModelClass:(Class)modelClass; 当然Mantle需要知道这些官和他们的将要转换的MTLModel子类，就像和创建一个新的MTLModel子类并且实现将要映射到这些对象的MTLJSONSerializing协议一样简单。然后我们可以添加一些新的属性到我们CATProfile类中并且实现两个新的转换器。 123456789101112// CATProfile.h@property(strong, nonatomic) CATOwner *owner; // CATOwner is a MTLModel subclass@property(strong, nonatomic) NSArray *friends; // Array of CATFriend objects// CATProfile.m+ (NSValueTransformer *)ownerJSONTransformer &#123; return [NSValueTransformer mtl_JSONDictionaryTransformerWithModelClass:CATOwner.class];&#125;+ (NSValueTransformer *)friendsJSONTransformer &#123; return [NSValueTransformer mtl_JSONArrayTransformerWithModelClass:CATFriend.class];&#125; 一些有用的补充我们简单的聊了一下NSValueTransformer在前面,NSValueTransformer有一个非常棒的特征让通过名字全局注册一个变换器成为可能。假如你正在使用相同的变换器在你整个app中，确保子类化NSValueTransformer，注册你的自定义变换器一次并且在你随后的MTLModels中使用它。 12345678910111213141516// In CATProfile.mNSString * const kCATCustomValueTransformerName = @&quot;CATCustomValueTransformer&quot;;+ (void)initialize&#123; // Register NSValueTransformer if (self == CATProfile.class) &#123; CATCustomValueTransformer *transformer = [CATCustomValueTransformer new]; [NSValueTransformer setValueTransformer:transformer forName:kCATCustomValueTransformerName]; &#125;&#125;// Then use the custom transformer to translate properties using Mantle+ (NSValueTransformer *)whateverPropertyJSONTransformer &#123; return [NSValueTransformer valueTransformerForName:kCATCustomValueTransformerName];&#125; 结论Mantle是一个非常棒的补充处理JSONAPIs，然而，你也必须意识到假如你不得不处理非常复杂的数据或者不稳定的APIs它也是不合适的。 参考资料 Mantle-Cat Mantle Framework on Github NSValueTransformer at NSHipster Mantle as a Model Layer for iOS and OS X Apps iOS JSON 模型转换库评测","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"Favorite","slug":"Favorite","permalink":"https://blog.wangruofeng007.com/tags/Favorite/"},{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"4种方式实现iOS模糊效果","slug":"2016-01-31-3chong-fang-shi-shi-xian-iosmo-hu-xiao-guo","date":"2016-01-31T15:12:52.000Z","updated":"2024-11-02T03:36:52.405Z","comments":true,"path":"2016/01/31/2016-01-31-3chong-fang-shi-shi-xian-iosmo-hu-xiao-guo/","permalink":"https://blog.wangruofeng007.com/2016/01/31/2016-01-31-3chong-fang-shi-shi-xian-iosmo-hu-xiao-guo/","excerpt":"","text":"介绍iOS中以下四种方式实现： CoreImage中的模糊滤镜 UIImage + ImageEffects的category模糊效果 iOS8中UIVisualEffectView模糊效果 iOS7以后通过UIToolBar实现模糊效果 CoreImage中的模糊滤镜实现CoreImage主要通过CIFilter这个类来实现。 这个类支持的滤镜多达14类，每个类又细分多款滤镜： CICategoryBlur CIBoxBlur CIDiscBlur CIGaussianBlur CIMaskedVariableBlur CIMedianFilter CIMotionBlur CINoiseReduction CIZoomBlur CICategoryColorAdjustment CIColorClamp CIColorControls CIColorMatrix CIColorPolynomial CIExposureAdjust CIGammaAdjust CIHueAdjust CILinearToSRGBToneCurve CISRGBToneCurveToLinear CITemperatureAndTint CIToneCurve CIVibrance CIWhitePointAdjust CICategoryColorEffect CICategoryCompositeOperation CICategoryDistortionEffect CICategoryGenerator CICategoryGeometryAdjustment CICategoryGradient CICategoryHalftoneEffect CICategoryReduction CICategorySharpen CICategoryStylize CICategoryTileEffect CICategoryTransition 我们这里使用的是高斯模糊，也就是CIGaussianBlur。 Sample Code： 1234567891011121314151617181920212223242526272829303132333435UIImage *avatar = [UIImage imageNamed:@&quot;avatar&quot;];/********** CoreImage ************/// CIImageCIImage *ciImage = [[CIImage alloc] initWithImage:avatar];// CIFilterCIFilter *blurFilter = [CIFilter filterWithName:@&quot;CIGaussianBlur&quot;];// 设置模糊滤镜半径[blurFilter setValue:@(20) forKey:@&quot;inputRadius&quot;];// 将图片输入到滤镜[blurFilter setValue:ciImage forKey:kCIInputImageKey];// 将处理好的图片输出CIImage *outCiImage = [blurFilter valueForKey:kCIOutputImageKey];// 查询可以设置的参数和一些信息NSLog(@&quot;%@&quot;,[blurFilter attributes]);// CIContextCIContext *contex = [CIContext contextWithOptions:nil];// 获取CGImage句柄CGImageRef outCGImage = [contex createCGImage:outCiImage fromRect:[outCiImage extent]];// 最终获取到图片UIImage *blurImage = [UIImage imageWithCGImage:outCGImage];// 释放CGImage句柄CGImageRelease(outCGImage); 此时blurImage图片就是经过滤镜处理后的图片，在放在ImageView上加载即可看到效果。 UIImage + ImageEffects的category模糊效果使用Apple开源的一个图片处理分类来实现，这个使用起来只需一行代码，简洁明了。 123UIImage *blurImage = [sourceImage blurImage]; 这里封装了一个区域模糊效果的方法 123- (UIImage *)blurImageAtFrame:(CGRect)frame; iOS8中UIVisualEffectView模糊效果这个效果只支持iOS8.0以上的版本，通过UIVisualEffectView来实现。 Sample Code： 12345678910// 1.创建模糊view UIVisualEffectView *effectView = [[UIVisualEffectView alloc] initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]]; // 2.设置尺寸 effectView.frame = CGRectMake(0, 100, [UIScreen mainScreen].bounds.size.width, 200); // 3.添加到view当中 [self.view addSubview:effectView]; 😊Bonus:实现iOS高版本通知中心炫酷的Label模糊效果。 12345678910111213141516171819202122// 添加一个文本标签 UILabel *label = [[UILabel alloc] initWithFrame:effectView.bounds]; label.text = @&quot;www.blog.wangruofeng007&quot;; label.textAlignment = NSTextAlignmentCenter; label.font = [UIFont systemFontOfSize:30]; [effectView.contentView addSubview:label]; /***************** 添加模糊效果 *****************/ // 1.创建子模糊view UIVisualEffectView *subEffectView = [[UIVisualEffectView alloc] initWithEffect:[UIVibrancyEffect effectForBlurEffect:(UIBlurEffect *)effectView.effect]]; // 2.设定尺寸 subEffectView.frame = effectView.bounds; // 3.将子模糊view添加到effectView的contenView才能生效 [effectView.contentView addSubview:subEffectView]; // 4.添加要显示的view来达到特殊的效果 [subEffectView.contentView addSubview:label]; 效果图： Demo地址： BlurEffectDemo – 本文效果Demo UIVisualEffects_Objective-c – 详细介绍UIVisualEffects的使用 iOS7以后通过UIToolBar实现模糊效果在iOS7以后，UINavigationBar和UIToolBar自带毛玻璃模糊效果，可以通过手动创建UIToolBar对象，然后添加到view中实现，UIToolBar区域就可以实现动态毛玻璃模糊效果。 例如在一个状态栏后方添加一个模糊view,可以在控制器中这样实现，假设没有导航栏 12UIToolbar *statusBar = [[UIToolbar alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 20)];[self.view addSubview:statusBar]; 这个方法非常简单实用😊，快去试试吧。 参考资料： Core Image Programming Guide Core Image Filter Reference UIImageBlur","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"Watch App 开发之 Interface Elements 详解","slug":"2016-01-29-watch-app-kai-fa-zhi-interface-elements-xiang-jie","date":"2016-01-29T09:36:26.000Z","updated":"2024-11-02T03:36:52.405Z","comments":true,"path":"2016/01/29/2016-01-29-watch-app-kai-fa-zhi-interface-elements-xiang-jie/","permalink":"https://blog.wangruofeng007.com/2016/01/29/2016-01-29-watch-app-kai-fa-zhi-interface-elements-xiang-jie/","excerpt":"","text":"iWatch原生态支持的控件主要有以下类型,下面对每个类型一一解刨。 Labels Images Groups Pickers Tables Buttons Switches Sliders Maps Movies Date and Timer Labels Menus Labels – WKInterfaceLabelLabels使用静态的文本来传达简短的消息，是你App中最常见的一个元素之一。它能支持多行显示也可通过代码动态更新内容。 iWatch,设计一个标签事，首先应该把精力集中在易读性,使用更亮的颜色和使用动态类型（ Dynamic Type）来保证文本尺寸的正确，内置已经提供了最佳的易读性和自动的动态的类型支持。假如需要使用自定义的字体，应该避免使用过度格式化的。 更多信息查看：Typography Images – WKInterfaceImage一个Image元素用来显示单张图片或者一系列动画图片。Images支持在iOS上的的任何格式，但是跟偏向于PNG格式。动画系列图片可以通过代码控制启停。 38mm和42mm共用一套图片资源，只要内容能够表达清晰。 Apple Watch支持高清屏显示，所有没有必要创建一个标准的分辨率图片，在图片名应该包括@2x。 当图片正在加载时，应该使用占位图片来占据它的空间。 优化图片查看：Image Optimizations Groups – WKInterfaceGroupGroup这个概念是专为有限空间的iWatch打造的，可以帮你对其他元素进行布局。它有postion,size,marigns以及其他布局相关的接口，一个Group对象本身也是一个可见的元素，它也有背景图片，颜色，圆角半径等属性。 支持水平horizontally和垂直vertically布局，可以让放在里面的项目实现相应的布局，可以使用spacing属性来设置内部项目之间的间距，使用margins来控制Group和它周边的元素的距离。 Group支持镶嵌操作，你可以通过镶嵌来指定你想要的布局样式。 你应该优化你的Group的背景图片来获得更好的体验，因为太大可能使你的App变得卡顿。优化请参考：Image Optimizations 外观大概这样: Pickers – WKInterfacePickerPickers能够显示一个可以使用数字表冠导航的列表。这意味着你可以使用一种更精确和迷人的方式选择。Pickers可以通过下面三种方式的一种来展示它们的项目： List style,可以显示文本或者图片在一个滚动列表里面 Stack style,栈风格以一个卡片风格的界面显示图片，当用户滚动，被选择的图片动画进入最上方，这种风格适合浏览照片。 Sequence style,序列显示，可以显示一系列的图片。当用户转动表冠时，Picker显示先前或下一张图片在这个序列中没有动画，这种风格适合于构建自定义的界面使用你自己的图片。 Pickers还能被配置成显示一个轮廓，标题，滚动指示器。这些元素可以让你分辨出屏幕上的Pickers并且可以帮助用户导航它的内容。 使用标题来指明你选择项目的意义或者picker本身的作用 你可以给项目指定一个独特的标题当那些项目的意思表达不清晰的时候，可选，你也可以设置所有的项目相同的标题来标明Picker它本身的作用。 显示一个滚动指示器当所有的内容不是全部可见时 Tabels – WKInterfaceTableTabels在一列中展示多行的内容。一个表的一行是动态配置的，它的内容可以在随时改变。Tabels天生可滚动，支持各种交互，能够设置背景颜色或者图片。 使用注意事项： 统一使用行的风格类型，即使一个表可以包含多行，它应该呈现一个全局统一的外观，每一行使用你的主要内容开始，然后随你的需要添加更多支持的其他类型的内容，例如headers或者footers,总是用原来设计的目的来使用行类型。例如，你不应该用一行来显示headers或footers的内容。 限制行数最大20，显示最重要的行在顶部，让用户能够浏览尽可能的多。行数越少越容易快速浏览。 不要在groups里面镶嵌tables,Tabels会动态改变它的尺寸基于它所包含的行的数目。它会忽略groups对高度的限制。 不要在table行内包含∧或者∨符号，行后台实现可以自然点击，你不需要包含一个∧或者∨符号或者文字来表明行是可点击的。 Buttons – WKInterfaceButton一个button可以执行一个app指定的动作，button可以自定背景和圆角半径。它还可以充当容器使用，包含一个标签labe;，图片image，或者一个组group对象。 使用事项： 创建横跨屏幕的Buttons ，全宽的buttons看起来更容易点击，假如有两个buttons，必须有相同的水平间距，两者使用相同的高度使用相同的图或者简短的文本标签。 使用相同的高度对于vertical stacks风格布局一行和两行文本按钮，原则是，尽可能的，使用一致到高度让他们在视觉上统一。 使用标准的圆角半径，标准的圆角半径的是6点，使用标准的圆角半径可以提升整个app的视觉的一致性并且可以增强button的内容。 让butotns足够大以便容易点击，创建让用户很容易点击的button，buttons应该遵循下面最小的值。 38mm (minimum) 42mm (minimum) Circular buttons 75 pixels 80 pixels Round rectangular buttons 50 pixels high 52 pixels high Switches – WKInterfaceSwitch开关控件更iOS类似，让用户在量个互斥的选择或者状态中选择，例如开或者关，一个靠近switch的标签应该指定响应的效果当，开关切换时。 效果像这样： Sliders – WKInterfaceSlider一个滑动条让用户来调整到某一个值。一个slider用来显示它设置的一系列的值或者是一个持续的bar, 它可以在一个有限的范围内根据预定的数量自增或者自减。 Note：你可以像使用slider那样使用自定图片,系统默认显示+和-符号。 Maps – WKInterfaceMapMaps是地理位置的静态快照。你可以放一张地图在你的界面里面在预计的时间，但是你WatchKit extension必须配置显示的区域在运行时。显示区域是不可交互的，但是点击一个地图将会打开你Apple Watch上的Mapsapp。 你可以在地图上用一个高亮的点对你感兴趣或者其他相关信息进行标注。地图能显示标准的红，黄，绿大头针，它也可以显示自定义的图片，系统允许你最多添加5个在一张地图上。 使用注意实现： 让你地图的元素根据屏幕自动适应。用户应该能够看到整个地图元素在Apple Watch上而不用滚动屏幕。 配置显示的地图区域到包含兴趣点的最小范围，地图元素内容本身不能滚动，所有所有内容必须附着在一个指定的地图区域 Movies – WKInterfaceMovie一个movie对象会显示一张海报图片，当点击时，模态呈现一份视频或者音频对象，使用这个元素来放置简短的媒体剪切和你内容内联。媒文件的重放由系统来管理。 使用注意事项： 使用一种海报图片来呈现剪切的内容，海报图片能让用户提前做决定是否观看与这个剪切关联的媒体，不要使用没有意义的剪切图片。 不要创建海报图片像系统控件，Movies会让视频和音频内容看起来像你节目的一部分，所以不要通过让他们看起来像其他东西的方式把他们隐藏起来。你应该使用一个Button（而不是一个movie）来呈现媒体回放界面假如你喜欢的话。 保证视频或者音频剪辑得足够短，剪辑不应该超过30秒，首选更短的。长的剪辑会占用更多的磁盘空间并且要求用户保持他们的手腕抬起更长时间，这样可能导致疲劳。 适当的设置剪辑视频的尺寸，无论时候都应该使用推荐的尺寸来剪切，缩放视频剪辑将影响性能导致不理想的外观。更多信息关于推荐的尺寸和编码的值，参考Audio &amp; Video Date &amp; Timer Labels – WKInterfaceDate,WKInterfaceTimerDate 和 Timer 标签用来显示真实的时间在Apple Watch上。 一个date label显示了现在的日期，现在的时间或者两者的组合。它可以使用各种样式，日历和时区来配置，在你配置好后，日期标签直接跟新它的值而不需要通过你app的进一步输入。 一个timer label用来显示一个精准的倒计时和和计数定时器。它能够配置它显示的计数的值以各种形式，在你配置完成后，一个timer label能够计数或者倒计时不用从你的app的进一步输入。 Menus – WKMenuItemIcon强力触摸Apple Watch将调出当前屏幕的menu（假如有点话）。一个菜单能够显示多达4个有关的动作对于当前屏幕，而不用从你的界面离开。 使用注意事项： 包含一个Menu当现在屏幕有相关的操作的时候，菜单是可选的。假如没有菜单呈现，系统将播放一段动画来响应用户的强力触摸操作。 使用一个label和一个icon来传达每个菜单动作的意图，label和icon都需要，label限制2行，所以文本应该尽量的短。 使用菜单来响应它们预期的目的，Menus是一种能够修改当前界面控制器内容的方式，不要使用它们来作为主要的导航形式在你的app中。 避免复制你的其他app中菜单的视觉风格，假如你必须使用一个相似的布局，加上颜色给你的界面或者排列的项目，用一种不同于其他菜单的方式。 更多menu icons 设计的信息，参考 Menu Icons。 参考资料： human-interface-guidelines human-interface-guidelines Visual Design Apple Watch指南 Best-apple-watch-apps","categories":[{"name":"Watch OS2","slug":"Watch-OS2","permalink":"https://blog.wangruofeng007.com/categories/Watch-OS2/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"iWatch","slug":"iWatch","permalink":"https://blog.wangruofeng007.com/tags/iWatch/"}]},{"title":"MVVM资料整理","slug":"2016-01-20-mvvmzi-liao-zheng-li","date":"2016-01-20T14:59:16.000Z","updated":"2024-11-02T03:36:52.405Z","comments":true,"path":"2016/01/20/2016-01-20-mvvmzi-liao-zheng-li/","permalink":"https://blog.wangruofeng007.com/2016/01/20/2016-01-20-mvvmzi-liao-zheng-li/","excerpt":"","text":"MVVM，作为一种新的架构设计，有别于MVC，MVP，它有很多自己的特性和优势，例如易于调试，业务逻辑集中方便管理，统一各种通信机制，将业务和控制器解耦。这框架现在很多公司都在尝试使用，像美团等，以后可能是一种趋势，鉴于它学习成本比较高，此文意在记录和收集相关的资料，以便以后查阅。 Github地址：ReactiveCocoa 比较不错的学习资料： ReactiveCocoa 讨论会 – 唐巧 MVVM without ReactiveCocoa – limboy ReactiveCocoa – 美团 ReactiveCocoa v2.5 源码解析之架构总览 – 雷纯峰 Functor、Applicative 和 Monad – 雷纯峰 Principles of Reactive Programming – 这里有一些视频课程，很不错 ReactiveCocoa Tutorial – The Definitive Introduction: Part 1&#x2F;2 ReactiveCocoa Tutorial – The Definitive Introduction: Part 2&#x2F;2 MVVM Tutorial with ReactiveCocoa: Part 1&#x2F;2 MVVM Tutorial with ReactiveCocoa: Part 2&#x2F;2 Functional Reactive Programming on iOS – 这本书介绍函数式编程配有例子，可以快速理解这种思想，入门级推荐 Reactive​Cocoa – NSHipster ReactiveCocoa 入坑 ing – 简书 ReactiveCocoa学习资源收集 – 简书 ReactiveCocoa学习资料汇总 – 简书","categories":[{"name":"资料收集","slug":"资料收集","permalink":"https://blog.wangruofeng007.com/categories/%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"Favorite","slug":"Favorite","permalink":"https://blog.wangruofeng007.com/tags/Favorite/"},{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"TableView性能优化","slug":"2016-01-18-tableviewxing-neng-you-hua","date":"2016-01-18T14:00:04.000Z","updated":"2024-11-02T03:36:52.404Z","comments":true,"path":"2016/01/18/2016-01-18-tableviewxing-neng-you-hua/","permalink":"https://blog.wangruofeng007.com/2016/01/18/2016-01-18-tableviewxing-neng-you-hua/","excerpt":"","text":"此文整理一下TableView优化相关的方案和思路。 TableView为什么会卡？主要由以下原因： cellForRowAtIndexPath:方法中处理了过多业务 tableviewCell的subview层级太复杂，做了大量透明处理 cell的height动态变化时计算方式不对 优化核心思想：UITableViewCell重用机制简单的理解就是：UITableView只会创建一屏幕（或一屏幕多一点）的UITableViewCell，其他都是从中取出来重用的。每当Cell滑出屏幕时，就会放入到一个集合（或数组）中（这里就相当于一个重用池），当要显示某一位置的Cell时，会先去集合（或数组）中取，如果有，就直接拿来显示；如果没有，才会创建。这样做的好处可想而知，极大的减少了内存的开销。 Tips： 提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法； 异步绘制,遇到复杂界面,参考Facebook的AsyncDisplayKit和YYAsyncLayer异步绘制框架； 缓存图片（SDWebImage），提前处理好UIImageView图片的尺寸按需加载而不是加载原图； 计算等耗时操作异步处理，处理完再回主线程更新UI； 图文混排不定高度采用CoreText排版，缓存Cell高度参考YYKit； 实现Cell的drawRect:方法直接绘制，减少UIView，UIImageView，UILabel等容器的使用。 Bonus： 正确使用reuseIdentifier来重用Cell； 尽量少用或不用透明图层或View； 如果Cell内现实的内容来自web，使用异步加载，缓存请求结果； 减少subviews的数量在heightForRowAtIndexPath:中尽量不使用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果； 尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示； 固定高度不要实现heightForRowAtIndexPath:方法。 可以通过实现以下方法，可以减少高度计算次数 123456@property (nonatomic) CGFloat rowHeight; // will return the default value if unset@property (nonatomic) CGFloat sectionHeaderHeight; // will return the default value if unset@property (nonatomic) CGFloat sectionFooterHeight; // will return the default value if unset@property (nonatomic) CGFloat estimatedRowHeight NS_AVAILABLE_IOS(7_0); // default is 0, which means there is no estimate@property (nonatomic) CGFloat estimatedSectionHeaderHeight NS_AVAILABLE_IOS(7_0); // default is 0, which means there is no estimate@property (nonatomic) CGFloat estimatedSectionFooterHeight NS_AVAILABLE_IOS(7_0); // default is 0, which means there is no estimate 参考资料： code-uitableviewcell-optimizations-part-1 code-uitableviewcell-optimization-part-2 Perfect smooth scrolling in UITableViews 优化UITableViewCell高度计算的那些事 详细整理：UITableView优化技巧 UITableview性能优化总结 AsyncDisplayKit 教程：达到 60 FPS 的滚动帧率 AsyncDisplayKit YYAsyncLayer","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"Favorite","slug":"Favorite","permalink":"https://blog.wangruofeng007.com/tags/Favorite/"},{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"}]},{"title":"iOS Animation Swift 版","slug":"2016-01-16-ios-animation-swift-ban","date":"2016-01-16T11:34:06.000Z","updated":"2024-11-02T03:36:52.404Z","comments":true,"path":"2016/01/16/2016-01-16-ios-animation-swift-ban/","permalink":"https://blog.wangruofeng007.com/2016/01/16/2016-01-16-ios-animation-swift-ban/","excerpt":"","text":"简介此文主要记录我学习iOS的动画相关内容用Swift语言，记录下来以供参考，不定时更新。 目录结构 Section I: View 动画 View animation 弹簧动画 - Springs 转场动画 - Transitions 关键帧动画 - Keyframe Section II: Auto Layout 动画 Section III: Layer 动画 Section IV: 3D 动画 Section V: 未来类型的动画 Section VI: View Controller 动画 Section VII：第三方动画库 Section VIII: Apple Watch 动画 Section I: View 动画1.View animation简介：view 的动画主要是通过UIView的类方法创建，动画内容一般放在block里面，可以镶嵌使用，构成链式动画，主要有3个方法,三个访法只需会参数最多的那个就行，函数名animateWithDuration(_:delay:options:animations:completion:)，其他的使用起来都类似。 123class func animateWithDuration(_ duration: NSTimeInterval, animations animations: () -&gt; Void)class func animateWithDuration(_ duration: NSTimeInterval, animations animations: () -&gt; Void, completion completion: ((Bool) -&gt; Void)?)class func animateWithDuration(_ duration: NSTimeInterval, delay delay: NSTimeInterval, options options: UIViewAnimationOptions, animations animations: () -&gt; Void, completion completion: ((Bool) -&gt; Void)?) 使用： 12345UIView.animateWithDuration(0.5, delay: 0, options: [], animations: &#123; //do something &#125;, completion: &#123;_ in //do something&#125;) 说明：options，动画选项，这个运行你设置一个动画选项集合，传[]表示不需要选项，单个时可以省略放括号例如.Repeat,多个用逗号连接[.Repeat, .CurveEaseInOut] completion闭包需要一个参数，不需要使用参数可以用_表示，不需要实现可以直接传nil 或者像下面这样写 12345UIView.animateWithDuration(0.5, delay: 0, options: [], animations: &#123; () -&gt; Void in //do something &#125;) &#123; (_) -&gt; Void in //do something&#125; 2.弹簧动画 - Springs简介：弹簧动画是iOS 7.0新增的API，函数名animateWithDuration(_:delay:usingSpringWithDamping:initialSpringVelocity:opti ons:animations:completion:)， 1class func animateWithDuration(_ duration: NSTimeInterval, delay delay: NSTimeInterval, usingSpringWithDamping dampingRatio: CGFloat, initialSpringVelocity velocity: CGFloat, options options: UIViewAnimationOptions, animations animations: () -&gt; Void, completion completion: ((Bool) -&gt; Void)?) 使用： 123UIView.animateWithDuration(0.5, delay: 0.5, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.0, options: [], animations: &#123;// do something&#125;, completion: nil) 说明：usingSpringWithDamping:设置弹簧的阻尼，范围（0.0-1.0），越接近0.0弹簧越有弹性，越接近1.0，效果越僵硬，你可以把当成弹簧的刚度来理解，initialSpringVelocity:设置弹簧初始化的速度，设置1.0表示用1秒在动画跨度上完成整个动画距离，值越大或者越小会导致动画有相应的大的或者较小的速度，可以当成弹簧的初始动量来理解。 3.转场动画 - Transitions简介：前两种创建的动画是基于可动画的接口例如，position，alpha，frame等等，Transitions是专门处理添加或者移除一个view的动画,系统有2个标准函数，一个是对单个view的处理，一个是处理2个view替换。 12class func transitionWithView(_ view: UIView, duration duration: NSTimeInterval, options options: UIViewAnimationOptions, animations animations: (() -&gt; Void)?, completion completion: ((Bool) -&gt; Void)?)class func transitionFromView(_ fromView: UIView, toView toView: UIView, duration duration: NSTimeInterval, options options: UIViewAnimationOptions, completion completion: ((Bool) -&gt; Void)?) 使用： 1234567891011121314151617//add the new view via transitionUIView.transitionWithView(animationContainerView!, duration: 0.33,options: [.CurveEaseOut, .TransitionFlipFromBottom], animations: &#123;self.animationContainerView!.addSubview(newView) &#125;, completion: nil)//remove the view via transitionUIView.transitionWithView(animationContainerView!, duration: 0.33,options: [.CurveEaseOut, .TransitionFlipFromBottom], animations: &#123;self.newView.removeFromSuperview() &#125;, completion: nil)//hide the view via transitionUIView.transitionWithView(self.newView, duration: 0.33, options: [.CurveEaseOut, .TransitionFlipFromBottom], animations: &#123;self.newView.hidden = true &#125;, completion: nil)//replace via transitionUIView.transitionFromView(self.oldView!, toView: self.newView!, duration: 0.33, options: [.TransitionFlipFromTop],completion: nil) 4.关键帧动画 - Keyframe简介：关键帧顾名思义就是设定关键的一些帧然后系统会根据一套算法计算中间的其他帧，这样改变的可动画属性时看看起来更加流畅自然，主要有两个函数,一个创建关键帧动画，一个设置具体每帧内容 12class func animateKeyframesWithDuration(_ duration: NSTimeInterval, delay delay: NSTimeInterval, options options: UIViewKeyframeAnimationOptions, animations animations: () -&gt; Void, completion completion: ((Bool) -&gt; Void)?)+ (void)addKeyframeWithRelativeStartTime:(double)frameStartTime relativeDuration:(double)frameDuration animations:(void (^)(void))animations 例如： 1234567891011121314151617181920212223242526272829303132func planeDepart() &#123; UIView.animateKeyframesWithDuration(1.5, delay: 0.0, options: [], animations: &#123; //add keyframes UIView.addKeyframeWithRelativeStartTime(0.0, relativeDuration: 0.25, animations: &#123; self.planeImage.center.x += 100.0 self.planeImage.center.y -= 10.0 &#125;) UIView.addKeyframeWithRelativeStartTime(0.1, relativeDuration: 0.4) &#123; self.planeImage.transform = CGAffineTransformMakeRotation(CGFloat(-M_PI_4/2)) &#125; UIView.addKeyframeWithRelativeStartTime(0.25, relativeDuration: 0.25) &#123; self.planeImage.center.x += 100.0 self.planeImage.center.y -= 60.0 self.planeImage.alpha = 0.0 &#125; UIView.addKeyframeWithRelativeStartTime(0.51, relativeDuration: 0.01) &#123; self.planeImage.transform = CGAffineTransformIdentity self.planeImage.center = CGPoint(x: 0.0, y: originalCenter.y) &#125; UIView.addKeyframeWithRelativeStartTime(0.55, relativeDuration: 0.45) &#123; self.planeImage.alpha = 1.0 self.planeImage.center = originalCenter &#125; &#125;, completion: nil)&#125; 说明：这是设计一个飞机沿一条路径起飞然后再归位的一段动画，addKeyframeWithRelativeStartTime(_:relativeDuration:animations:),第一个参数相对开始时间，是相对于动画持续时间的百分比，例如0.1就是10%，0.25就是25%，如果整个动画持续2秒，0.1就是在2*0.1&#x3D;0.2秒的时候开始，后面的一个参数是相对持续时间，范围更第一参数类似也(0.0-1.0),只从相对开始时间起，往后推移的相对时间。 Section II: Auto Layout 动画12345678910111213141516// change Constraint// init layoutview.layoutIfNeeded()UIView.animateWithDuration(0.8, delay: 0.0, usingSpringWithDamping: 0.4, initialSpringVelocity: 0.0, options: [], animations: &#123; // do something change constraint // layout self.view.layoutIfNeeded() &#125;, completion: nil) 原理就是，修改约束,让添加一个动画，在动画block里面执行布局更新，block里面也可以添加修改约束代码，修改约束的本质是修改相关View的frame和bounds，由于修改View的这个属性是支持动画的，所以修改约束其实是间接修改View的这些属性，所有也是支持动画的，这个动画的强大的之处在于，可以实现一系列View相互协作的动画。 Section VIII: Apple Watch 动画概述：在Apple Watch 中有两种技术来创建动画，一个是一次性创建一系列静态可动画的图片序列或者循环动画，另一种是对标签和其他项目通过改变尺寸，对齐，颜色，透明度进行布局和外观动画。 Animated Image Sequences Animated Image Sequences是由两个或者更多的独立图片组成的序列来随时间按序列显示。每张图片组成了动画的一个单独的帧，整个动画运行在一个循环中除了你在运行的时候修改了播放的行为。主要把它安装在你界面中的image，group,button等元素中。通过WKImageAnimatable协议来实现动画，也就是说凡是遵循这个协议的对象都支持动画，WatchKit中遵循这个协议的对象有：WKInterfaceGroup，WKInterfaceImage 你可以控制image和group元素Animated Image Sequences的播放的速度，方向，帧率,否则界面元素将会无限循环显示一个完整的动画。 Notes: Animated Image Sequences可以正向播放动画也可以反向执行动画在运行的时候，你不应该提供一套一样的图片以反向的方式，你应该使用这个技术来降低App的尺寸。 如果你是从storyboard创建序列图片对象，可以通过func startAnimating()方法开始执行动画，通过func stopAnimating()来停止动画的执行。 实例： 实现WKInterfaceGroup加载进度动画 1.在Watch里面的Interface.storyboard里面拖拽一个WKInterfaceGroup命名为backgroundGroup2.创建一个WKInterfaceButton按钮来触发这个动画事件,在控制器里面实现下面的代码 1234567891011121314@IBAction func checkInButtonTapped() &#123; // 1 let duration = 0.35 let delay = dispatch_time(DISPATCH_TIME_NOW, Int64((duration + 0.15) * Double(NSEC_PER_SEC))) // 2 backgroundGroup.setBackgroundImageNamed(&quot;Progress&quot;) // 3 backgroundGroup.startAnimatingWithImagesInRange(NSRange(location: 0, length: 10), duration: duration, repeatCount: 1) // 4 dispatch_after(delay, dispatch_get_main_queue()) &#123; () -&gt; Void in // 5 dosomething &#125; &#125; 参数说明：imageRange,将要执行动画的图片范围，0表示第一张图片，1表示第二张图片，以此类推；duration,单位秒，表示动画执行单个循环的时间，正值表示从第一帧到最后一帧执行，负值表示以相反的顺序执行动画，以第一帧结束；repeatCount,动画的重复次数，设置0表示无限循环。 3.将素材文件拖入Watch的Asset.xcassets的文件里面，以Progress开始命名后面接一串连续的数字，效果应该像下面这样。 4.然后在模拟器上运行就OK了。 Layout and Appearance Animations 你可以动画改变所有界面元素的布局和外观。动画改变布局让你修改元素的尺寸或者动态的改变布局的方向。你可以移动在屏幕上的元素或者让它们的内容重新对齐。你也可以动画改变元素的外观，包括改变他们的backgroud color或者opactiy。这些类型的动画让你创建动态的界面用来响应用户的交互并且提供一个更好的反馈。 所有的layout- and appearance-based animations在动画开始和结束都以easing的曲线方式自动构建 。你不能关闭或者自定义缓动曲线。相当于UIView的动画选项里面的easeInOut。 可动画属性： Opacity Height Width Group Insets Alignment Background Color Tint Color 核心代码： 123class func animateWithDuration(_ duration: NSTimeInterval, animations animations: () -&gt; Void) 说明:这个方法在WKInterfaceController中，目前发现只有这一个动画API，你可以在这个闭包里面执行相应的动画操作，实现跟UIView的block动画类似。 实例： 在界面已经出现的时候对planeImage进行着色动画,改变separator的颜色 12345678910111213141516var planeImage: WKInterfaceImage!var separator: WKInterfaceSeparator!override func didAppear() &#123; super.didAppear() // 1 animateWithDuration(0.35, animations: &#123; () -&gt; Void in // 2 let color = UIColor(red: 90/255, green: 200/255, blue: 250/255, alpha: 1) planeImage.setTintColor(color) separator.setColor(color) &#125;) &#125;&#125; 参考资料： Apple Human-interface-guidelines – Apple Apple WatchKit Programming Guide – Apple Apple Watch – SwiftGuide Swift Guide – SwiftGuide 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"动画","slug":"动画","permalink":"https://blog.wangruofeng007.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"iWatch OS2","slug":"iWatch-OS2","permalink":"https://blog.wangruofeng007.com/tags/iWatch-OS2/"}]},{"title":"NSURLSession 教程","slug":"2016-01-15-nsurlsession","date":"2016-01-15T10:15:01.000Z","updated":"2024-11-02T03:36:52.404Z","comments":true,"path":"2016/01/15/2016-01-15-nsurlsession/","permalink":"https://blog.wangruofeng007.com/2016/01/15/2016-01-15-nsurlsession/","excerpt":"","text":"本文翻译自 http://www.raywenderlich.com/51127/nsurlsession-tutorial 原作者： Charlie Fulton 译者：@oneruofeng 注意：这是一篇来自我们作为即将发布 iOS 7 Feast的一部分iOS 7 by Tutorials的简短版本的章节。我们希望你们喜欢。 每一个新的iOS版本发布都会包含一些极好的新的网络APIs，iOS7也不例外，在iOS7中，Apple引入了NSURLSession,这是为了取代NSURLConnection作为偏好的网络请求的一系列类。 在这个NSURLSession的教程中，你将了解到这个新类究竟是什么，为什么你要使用它以及你怎样使用它，它和以前的类库比较而言怎样，最后最重要的是：获得一个整合到一个真正的App的实践。 请注意：这个课程是假设你熟悉基本的网络概念。假如网络对你来说完全是新的，你仍然可以跟我一起一步一步的学习，但是可能有些你不熟悉的概念需要需要自己查询在这个过程中。 为什么使用NSURLSession为什么你要使用NSURLSession? 饿，因为它可以带给你一些好处和优势相比以前的： 后台上传和下载 ： 当你创建NSURLSession的时候你只需配置一个选项即可，你便可以进行所有的后台网络任务。这将有对你的电池寿命有利，它支持UIKit多任务并且当切换线程的时候使用相同的代理模型。 使你的网络操作可以暂停和恢复 ：你稍后将会看到，任何使用NSURLSessionAPI的网络任务都可以被暂停，停止，重新开始。而没有使用NSOperation子类的必要。 可配置的容器：对于放进里面的请求而言每一个NSURLSession都是可配置的。例如，假如你需要设置一个HTTP header选项，你只需要设置一次然后每个在session中的请求就都会有相同的配置了。 可子类化和私密存储： NSURLSession是可子类化的并且你可以配置一个session用来作为私密存储在某个会话中。这允许你拥有私密存储对象在全局状态下。 优化的授权处理机制：授权被完成基于某个特定的连接。当使用NSURLConnection的时候假如发生了一处授权改变，这个改变将返回一个随意的请求，你不能确定你具体得到的那个。使用NSURLSession的话，代理回来处理授权。 丰富的代理模型：NSURLConnection有些基于block的同步方法，然而代理就不能使用它们了。当一个请求建立了无论它是成功还是失败，哪怕需要授权。使用NSURLSession就就可以混合接入，使用基于block的异步方法同时也可以设置代理来处理授权。 通过文件系统上传和下载：苹果鼓励把（文件内容）数据跟(URL和一些设置)元数据分开。 NSURLSession vs NSURLConnection“哇哦，NSURLSession听起来很复杂呀！”,你可能这么想。”我可能还是继续使用我的老朋友NSURLConnection。” 别担心–使用NSURLSession使用起来其实和它的前辈NSURLConnection一样简单对于简单的任务来说。例如，让我来看一个在获取伦敦最新的天气的一个简单网络请求，通过它来获取JSON数据的例子。 假设你用这个NSString来构造这个NSURL: 1NSString *londonWeatherUrl = @&quot;http://api.openweathermap.org/data/2.5/weather?q=London,uk&quot;; 这里是第一步你使用NSURLConnection来调用： 12345678910NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:londonWeatherUrl]];[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; // handle response&#125;]; 现在让我们来使用NSURLSession。注意这是使用NSURLSession的最简单的方式来快速构造一个请求。在后面的课程你将看到怎样配置session和设置其他特征比如像代理。 12345678NSURLSession *session = [NSURLSession sharedSession];[[session dataTaskWithURL:[NSURL URLWithString:londonWeatherUrl] completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123; // handle response &#125;] resume]; 注意你并不需要指定它运行在那个队列中。除了你特别指定，这个调用将会在后台线程。你可能很难注意到这两者之间有什么不同，它就是故意这样的。Apple提到打算使用dataTaskWithURL来取代在NSURLConnection中的sendAsynchronousRequest。 所有从根本上来讲–对于简单的任务使用NSURLSession就和使用NSURLConnection一样简单，并且它还有一些列额外的定制功能当你需要它的时候。 NSURLSession vs AFNetworking不提到AFNetworking框架就谈不上谈论网络编程。这个事在iOS/OS X上最流行的框架，有杰出的Mattt Thompson创建。 注意：想了解更多关于AFNetworking,请检出在https://github.com/AFNetworking/AFNetworking的github页面。我们也有一个关于它的课程：http://www.raywenderlich.com/30445/afnetworking-crash-course 下面是的使用AFNetworking 1.x版本处理相同的数据任务的代码： 1234567891011NSURLRequest *request = [NSURLRequest requestWithURL: [NSURL URLWithString:londonWeatherUrl]];AFJSONRequestOperation *operation =[AFJSONRequestOperation JSONRequestOperationWithRequest:request success:^(NSURLRequest *request, NSHTTPURLResponse *response, id JSON) &#123; // handle response&#125; failure:nil];[operation start]; 使用AFNetworking的一个好处是处理响应的数据的数据根据类型被归类。使用AFJSONRequestOperation(或者诸如XML和plist相似的类),成功block已经被解析根据响应并且为你返回你想要的数据。使用NSURLSession你将收到一个NSData对象在completion handler,所有你只需要把NSData转换成JOSN或者其他形式。 注意：你能够很方便的把数据从NSData转换成JSON使用在iOS 5引入的NSJSONSerialization这个类。如果你想了解更多，请查看23章的iOS 5 教程，“Working with JSON”。 你或许想知道你是应该使用AFNetworking还是仅仅是继续使用NSURLSession。 就个人而言，我认为对于简单的需求最好还是继续使用NSURLSession–这样可以避免不必要的引入一个第三方库在你的工程中。另外，使用新的代理，配置，和基于很多添加到AFNetworking中的的“遗失特征”现在都被包括了的API的任务。 然而，假如你想使用一些在AFNetworking中2.0版本的新特性，诸如序列化和将来对UIKit的整合（添加到UIIImageView分类中），然后这样很难争辩不使用它！ 注意：在AFNetworking2.0分支中，它们已经转换到使用NSURLSession。更多信息看这篇帖子：https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-2.0-Migration-Guide 介绍 Byte Club在这篇NSURLSession教程中，你将探索这个新的API通过构建一篇日记好图片分享app基于 Dropbox Core API,因为是顶级机密组织因此姑且命名它Byte Club。 考虑到这个课程是你接受到Byte Club的官方邀请！什么是你可能会问到的关于Byte Club的第一条规则？没人谈论Byte Club–除了那些足够炫酷的人将会阅读这个教程。并且那些Android用户完全不知道；他们被他们俩的生活劫持了。 ：] 开始构建app迎战下一个章节，将充当被Byte Club组织邀请。 主要到这个教程是假设你对基本的网络有基本的了解在先前的版本iOS。它非常有用假如你已经使用过诸如NSURLConnection或者NSURLSession在过去。假如在iOS方面你是网络方面的新手，在继续这个课程之前你应该查询我们的iOS学徒系列作为最初的开发者。 现在开始吧Byte Club是iOS 开发者专有的组织，一起来加入挑战你的编程吧。由于每个成员都是远程工作，在这个挑战中有一个是跨越世界，成员通过分享他们“战场”的全景照片也能找到它的乐趣。 例如，下面是Ray的办公场所的全景照片： 注意：你可能想创建你自己办公室的全景照片–它很有趣，在这个课程的后续中我们将会处理。 在 iOS 7中，你可以通过打开相机选择一个叫Pano（全景）的标签照一张全景照片。 加入你喜欢那张，把它设置成你锁屏界面的墙纸通过打开设置让后选择墙纸 \\选择墙纸 \\我的全景照片。 当然-Byte Club 有它自己的app，我们来见证奇迹。你可以和其他成员使用app来完成编程挑战或者分享全景照片。在幕后，这是通过网络实现-明确的说，就是通过Dropbox API来分享文件。 开始的工程概述首先，下载教程开始的工程。 开始的工程包含了为你预先准备好的UI，所以你只需把精力集中在这个教程中app的网络部分。开始的工程也包含一些处理Dropbox授权的代码,在后面你将学到更多。 在Xcode中打开工程让后在你设备或者模拟器上运行，你应该看到像下面这样： 然而你还并不能登录它-你不得不先配置app，你将做一点。 下一步打开Main.storyboard纵览一下整个app的设计： 这是一个最基本的使用2个标签的的TabBarController app：一个是为了挑战编程，另一个是为了放全景照片。这里也有预先让用户登录到app中的一步。你将要配置登录在你创建完Dropbox平台下的App后。 感到很轻松浏览一下App剩余的部分并且找到到目前为止相似的地方。你将会注意到除了授权组件，这里没有检索挑战编程或者全景照片的网络代码-那就是你的工作！ 创建一个新的Dropbox平台App为了开始你的新的Dropbox App,打开 Dropbox App 位于https://www.dropbox.com/developers/apps的控制台 用你的Dropbox账号登录，假如没有，没问题：马上创建一个免费的Dropbox账号。假如这是你第一次使用Dropbox的API，你需要通知Dropbox的条款和条件。 经过这个法定的材料以后就是上路了，选择创建App选项。将呈现给你一系列问题-提供下面的答案 What type of app do you want to create? Choose: Dropbox API app What type of data does your app need to store on Dropbox? Choose: Files and Datastore Can your app be limited to its own, private folder? Choose: No – My App needs access to files already on Dropbox What type of files does your app need access to? Choose: All File Types 最终，为你的App准备一个名字，选择什么并没有关系只有它是唯一的。假如你选择了一个别人已经在使用的名字Dropbox 将会告诉你。你的屏幕应该看起来像下面这样： 点击Create App，你将开始上路了！ 下一个屏幕你将看到显示到屏幕中的包含 App key 和 App secret : 先不要关闭这个屏幕，你将需要需要下一步的App Key和App Secret。 打开Dropbox.m文件找到下面这些行： 123#warning INSERT YOUR OWN API KEY and SECRET HEREstatic NSString *apiKey = @&quot;YOUR_KEY&quot;;static NSString *appSecret = @&quot;YOUR_SECRET&quot;; 填写你的app key 和 secret，让后删除 #warning line，现在你可以关闭Dropbox Web App 页面。 下面，创建一个文件夹在你Dropbox主文件下的根目录给它命一个你想要的名字。假如你把这个文件夹个和其他的Dropbox用户分享，发送他们在构建 Byte Club App的时候，他们将能够创建笔记并且能够上传所有人都能看得见的照片。 在Dropbox.m中找打下面这些行： 12#warning THIS FOLDER MUST BE CREATED AT THE TOP LEVEL OF YOUR DROPBOX FOLDER, you can then share this folder with othersNSString * const appFolder = @&quot;byteclub&quot;; 改变字符串的值，设置成你创建的Dropbox文件夹的名字，让后删除 #warning pragma. 为了把这个app分发给其他用户，给他们接入access tokens,你将需要为你的Dropbox 平台 App打开Enable additional users设置。 去在https://www.dropbox.com/developers/appsDropbox app的控制台。点击你app 名称。然后点击Enable Additional Users按钮。将出现一个状态对话框表明你已经增加了你的用户限制。点击Okay关闭对话框。你的App 页面将像下面这样显示： 注意：你可能注意到当你正在开发你的app的时候，你可以接入多达100个用户。当你准备发布app销售的时候，你必须申请生产状态，你可以通过点击Apply for production按钮来发送给Dropbox一些额外的信息。 Dropbox 将随后审核你的App 来确保它遵守指南，假如所有的一切进行得顺利的话，你将打开你的app的 API接入无线的用户。 Dropbox 授权: 概览假如你曾经使用过第三方twitter客服端app，像TweetBot,你将会熟悉OAuth授权处理步骤从一个用户的角度。OAuth授权接入过程对你app来说是完全一样的。 构建运行你的app，按照步骤登录。你将看到一个有2个标签的空白屏幕，一个是Notes，一个是PanoPhotos，如下图显示： OAuth授权发生在3和高级的步骤： 获取用来处理剩下的授权一个OAuth请求 token。这是请求token。 一个web 页面被呈现到用户面前通过他们的web浏览器。没有这一步的用户授权，对你的应用想获取一个第三步中的接入token几乎不可能。 在第二步完成后，应用调用web服务来交换临时请求token（从第一步中的）为了一个将存储在app里面的持久接入token。 注意：为了保证这个教程的简洁，我们不打算进行更详细的讲解关于这里Dropbox授权工作。然而，假如你想了解更多点击整个教程的完全版本，它是iOS 7 by Tutorials.的一部分。 NSURLSession 的一系列类Apple已经把NSURLSession描述成一个新类和一系列旧类的组合。这些新的工具是为了处理 上传，下载，处理授权已经处理在HTTP协议里面的任何事情。 一个NSURLSession用一个带可选代理的NSURLSessionConfiguration构造。在你创建会话以后，你应该能够满足你的网络需要通过创建NSURLSessionTask的任务。 NSURLSessionConfiguration这里有三种方式创建NSURLSessionConfiguration: defaultSessionConfiguration - 创建一个使用全局缓存，cookie的配置对象和凭证存储的对象。这个配置会使你的会话最像NSURLConnection。 ephemeralSessionConfiguration - 这个配置是用来作为‘私有的’会话并且不会持久化存储缓存，cookie，或者信用存储对象。 backgroundSessionConfiguration - 当你想要从远程推送或者当app被暂时挂起时进行网络业务使用这个这个配置。参考17章和18章在 iOS 7 by Tutorials,Beginning and Intermediate Multitasking,有更详细的讲解。 一旦你创建一个NSURLSessionConfiguration对象，你就可以在它上面设置各种接口像这样： 1234567891011121314NSURLSessionConfiguration *sessionConfig =[NSURLSessionConfiguration defaultSessionConfiguration];// 1sessionConfig.allowsCellularAccess = NO;// 2[sessionConfig setHTTPAdditionalHeaders: @&#123;@&quot;Accept&quot;: @&quot;application/json&quot;&#125;];// 3sessionConfig.timeoutIntervalForRequest = 30.0;sessionConfig.timeoutIntervalForResource = 60.0;sessionConfig.HTTPMaximumConnectionsPerHost = 1; 你限制了网络操作只有wifi才能进行。 这将设置所有的请求只接受 JSON类型的响应。 这些接口将配置资源或者请求超时时间。你也可以限制你的app对你的主机只能有一个网络连接。 这些仅仅是你能配置的一些东西，确保检查所有列表的文档。 NSURLSessionNSURLSession被设计成替代NSURLConnection的API。Sessions做了他们的工作通过他们的部下，也就是非常出名的NSURLSessionTask对象。使用NSURLSession你能够创建任务使用基于block的便利方法，设置一个代理，或者同时两者。例如，假如你想要下载一张图片（ *challenge hint *）,你就需要创建一个NSURLSessionDownloadTask。 第一步，你需要创建(会话)session。 这里有一个例子： 12345678910111213// 1NSString *imageUrl =@&quot;http://www.raywenderlich.com/images/store/iOS7_PDFonly_280@2x_authorTBA.png&quot;;// 2NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];// 3NSURLSession *session = [NSURLSession sessionWithConfiguration:sessionConfig delegate:self delegateQueue:nil]; Ok,这个仅仅是你目前所看到的一点点不同。让我们一步步重温。 用这个代码片段我们将一样进行下载在两个任务中。 你总是以创建NSURLConfiguration开始。 这里创建一个会话使用现在的类作为代理。 在你创建会话后，你可以通过创建一个带一个completion handler的任务下载这张图片，想下面这样: 1234567891011121314151617181920// 1NSURLSessionDownloadTask *getImageTask =[session downloadTaskWithURL:[NSURL URLWithString:imageUrl] completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) &#123; // 2 UIImage *downloadedImage = [UIImage imageWithData: [NSData dataWithContentsOfURL:location]]; //3 dispatch_async(dispatch_get_main_queue(), ^&#123; // do stuff with image _imageWithBlock.image = downloadedImage; &#125;);&#125;];// 4[getImageTask resume]; Ah ha!现在这个看起来有点像网络代码！ 任务总是被sessions创建。任务一旦被基于block的方法创建。记住你仍然可以使用NSURLSessionDownloadDelegate来跟踪下载进度。所以你将获得最好的两个单词！（ *hint for challenge *） -URLSession:downloadTask :didWriteData:totalBytesWritten :totalBytesExpectedToWrite: 这里你使用在 completion handler提供的本地变量来获取一个指向图片的指针。 最终你能够，例如，更新 UIIImageView的图片来显示新的文件。(hint hint ☺) 你总得自己启动任务！ 记住我在前面所说的，一个会话也可以创建将要发送消息给代理方法来通知你完成等的任务。 应该长成这样，使用相同的会话从上面： 12345// 1NSURLSessionDownloadTask *getImageTask = [session downloadTaskWithURL:[NSURL URLWithString:imageUrl]];[getImageTask resume]; 这当然是确定使用更少的代码☺ 然而，假如你只这样做，你将什么都看不到。你需要让你的代理实现一些NSURLSessionDownloadDelegate协议的方法。 首先我们需要获得通知当下载完成时： 123456-(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; // use code above from completion handler&#125; 再有你需要提供将要下载的文件存放的位置，然后你就可以使用这个来处理图片。 最后，假如你需要跟踪下载进度，对于任务创建方法，你需要像下面这样用： 123456789-(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWrittentotalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; NSLog(@&quot;%f / %f&quot;, (double)totalBytesWritten, (double)totalBytesExpectedToWrite);&#125; 正如你所见，NSURLSessionTask是一匹通过网络来干活的真实的驮马。 NSURLSessionTask目前为止你已经知道NSURLSessionDataTask和NSURLSessionDownloadTask怎样使用了。这两个的任务是来自他们共同的基类NSURLSessionTask，你可以在这类看到： NSURLSessionTask在你的会话中是任务的基类；他们只能通过一个会话创建并且它们是下面子类中的一个。 NSURLSessionDataTask这个任务发起HTTP GET请求来从服服务器拉取数据。数据被返回以NSData的形式返回。你应该在随后将其把这个数据转换成正确的数据类型比如XML,JSON,UIImage，plist等等。 123456NSURLSessionDataTask *jsonData = [session dataTaskWithURL:yourNSURL completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123; // handle NSData&#125;]; NSURLSessionUploadTask使用这个类当你需要上传一些东西到web服务器时，使用HTTP POST 或者 PUT 命令。任务带来也允许你监视网络状况当它正在传输的时候。 上传一张图片： 12345NSData *imageData = UIImageJPEGRepresentation(image, 0.6);NSURLSessionUploadTask *uploadTask = [upLoadSession uploadTaskWithRequest:request fromData:imageData]; 在这类任务被创建从一个会话中并且图片以NSData的形式上传。这里也可以通使用一个文件或者流的方法来进行上传。 NSURLSessionDownloadTaskNSURLSessionDownloadTask让通过远程服务下载文件变得超级简单，并且可以暂停和恢复下载只要你想。这个子类有别于其他两个。 这个类型的任务直接写入一个临时文件。 在下载会话中将调用URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:来更新状态信息。 当任务完成时，URLSession:downloadTask:didFinishDownloadingToURL: 被调用。这就是你该保存文件从临时位置到一个永久位置的时候。 当下载失败或者取消时，你可以让数据重新开始下载。 这个特性将极其有用当你在下载一个Byte Club定位 全景照片给你的设备的相机胶卷。你看到的一个下载任务例子在上面下载图片片段中。 上述全部所有的上述任务被创建在一个暂停的状态；在创建一个任务时你需要调用它的继续方法像下面演示的那样： 1[uploadTask resume]; 当你一次不只管理一个任务时，taskIdentifier接口允许你唯一标示一个在会话中的任务 这就是！既然你已经知道了NSURLSession系列的主要类，让我们尝试一下。 Sharing notes with NSURLSessionOK，这不是死亡诗社，这是Byte Club!是时候开始看看一下这个的网络代码在起作用了。 你需要一个方法来给Byte Club的其他成员发送消息。既然你已经设置了接入token，下一步就是实例化NSURLSesssion对象，让后调用你的第一个Dropbox API。 Creating an NSURLSession添加下面的接口到 NotesViewController.m 文件，就在 NSArray *notes 行的后面： 1@property (nonatomic, strong) NSURLSession *session; 你将创造所有你的下属从上面的session中。 添加下面的方法到NotesViewController.m就在initWithStyle方法的上面： 123456789101112131415- (id)initWithCoder:(NSCoder *)aDecoder&#123; self = [super initWithCoder:aDecoder]; if (self) &#123; // 1 NSURLSessionConfiguration *config = [NSURLSessionConfiguration ephemeralSessionConfiguration]; // 2 [config setHTTPAdditionalHeaders:@&#123;@&quot;Authorization&quot;: [Dropbox apiAuthorizationHeader]&#125;]; // 3 _session = [NSURLSession sessionWithConfiguration:config]; &#125; return self;&#125; 下面是上面代码注释的注释的解释： 你的app调用 initWithCoder当你实例化一个控制器从一个故事版中;因此这是一个完美的时刻初始化和创建NSURLSession。你并不想积极缓存或者持久化这里，所有你使用ephemeralSessionConfiguration便利方法，它返回一个没有持久化缓存，cookies，或者认证存储的会话。这是一个”私有浏览”配置。 下一步，你添加授权HTTP头道配置对象中。apiAuthorizationHeader是一个我写的辅助方法，返回一个字符串，以授权制定的格式。这个字符串包含access token，token secret和你的 Dropbox App API 秘钥。记住这是必要的因为每个对 Dropbox API 的调用都需要被授权。 最后，你使用上面的配置创建了NSURLSession。 会话现在准备好创建在你app中你所需要的任何网络任务。 GET Notes through the Dropbox API为了模拟一条笔记被另一个用户添加，添加任何你在设置在你的Dropbox根目录下的文件夹中选择的文本文件。例如位于Dropbox文件夹下 byteclub 下面显示的 test.txt： 等待直到Dropbox确认它已经同步完你的文件，让后继续下面代码。 添加下面的代码到空的notesOnDropBox方法中在NotesViewController.m: 1234567891011121314151617[UIApplication sharedApplication].networkActivityIndicatorVisible = YES;// 1NSURL *url = [Dropbox appRootURL];// 2NSURLSessionDataTask *dataTask =[self.session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123; if (!error) &#123; // TODO 1: More coming here! &#125; &#125;];// 3 [dataTask resume]; 这个方法的目标是检索在app的Dropbox文件下的文件列表。让我们来重温一下这是怎样工作的一步步。 在Dropbox中，你能看到一个文件夹的内容通过进行一个已经授权的GET请求到某个特别的URL - 像https://api.dropbox.com/1/metadata/dropbox/byteclub. 我已经创建了一个便利的方法在Dropbox类中来为你产生这个URL。 NSURLSession用便利构造方法来简单的创建各种类型的任务。这是你创建的一个数据任务为了执行一个GET请求到那个URL。当请求完成时，你的completionHandler block被调用。一会儿你将添加一下代码到这里。 记住一个任务默认是一个暂停的状态,因此你需要调用恢复方法来启动运行。 那就是所有你需要做的来开始一个GET请求-现在让我们添加代码到解析的结果中。添加下面的这些行到”TUDO 1”注释的后面: 123456789101112131415161718// 1NSHTTPURLResponse *httpResp = (NSHTTPURLResponse *) response;if (httpResp.statusCode == 200) &#123; NSError *jsonError; // 2 NSDictionary *notesJSON = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:&amp;jsonError]; NSMutableArray *notesFound = [[NSMutableArray alloc] init]; if (!jsonError) &#123; // TODO 2: More coming here! &#125;&#125; 下面是两个主要的部分: 你知道你已经发送一个HTTP请求，所以响应将是一个HTTPP响应。因此这里你可以抛出NSURLResponse到一个NSHTTPURLRequest响应以便你能够接入到接口的状态码。假如你收到了一个HTTP状态码200，然后一切正常。 HTTP 错误码举例： 400 - 输入参数错误。错误消息将表明那个和为什么错误。 401 - token错误或者失效。这个可能发生假如用户或者Dropbox被撤销或者接入token过期。你可以通过重新授权修复这个用户。 403 - 错误的授权请求（错误的用户键，坏的随机数，时间戳过期…）。不信的是，重新授权用户在这里并没有用。 404 - 指定路径下的文件或者文件夹没找到。 405 - 未知的请求方法（通常应该是 GET 或者 POST）。 429 - 你的app发送太多请求超出了限制的速率，429能够触发在每个app或者每个用户根部。 503 - 假如响应包括重发后的头，这就意味做你的OAuth 1.0 app 正在被限速。否则，这个表明了一个短暂的服务器错误，并且你的app应该重新发送这这个请求。 507 - 用户超出 Dropbox 储存配额。 5xx - 服务器错误。 Dropbox API返回JSON类型的数据。所有你收到一个200的响应，然后应该把数据转发成JSON使用iOS的构建JSON序列化的方法。了解更多关于JSON和NSJSONSerialization，查看第23章在 iOS 5 by Tutorials,”Working with JSON.” JSON 数据返回从Dropbox将看起来像下面这样： 123456789101112131415161718192021222324252627&#123; &quot;hash&quot;: &quot;6a29b68d106bda4473ffdaf2e94c4b61&quot;, &quot;revision&quot;: 73052, &quot;rev&quot;: &quot;11d5c00e1cf6c&quot;, &quot;thumb_exists&quot;: false, &quot;bytes&quot;: 0, &quot;modified&quot;: &quot;Sat, 10 Aug 2013 21:56:50 +0000&quot;, &quot;path&quot;: &quot;/byteclub&quot;, &quot;is_dir&quot;: true, &quot;icon&quot;: &quot;folder&quot;, &quot;root&quot;: &quot;dropbox&quot;, &quot;contents&quot;: [&#123; &quot;revision&quot;: 73054, &quot;rev&quot;: &quot;11d5e00e1cf6c&quot;, &quot;thumb_exists&quot;: false, &quot;bytes&quot;: 16, &quot;modified&quot;: &quot;Sat, 10 Aug 2013 23:21:03 +0000&quot;, &quot;client_mtime&quot;: &quot;Sat, 10 Aug 2013 23:21:02 +0000&quot;, &quot;path&quot;: &quot;/byteclub/test.txt&quot;, &quot;is_dir&quot;: false, &quot;icon&quot;: &quot;page_white_text&quot;, &quot;root&quot;: &quot;dropbox&quot;, &quot;mime_type&quot;: &quot;text/plain&quot;, &quot;size&quot;: &quot;16 bytes&quot; &#125;], &quot;size&quot;: &quot;0 bytes&quot;&#125; 所有最后一段添加的代码是拉取的部分你感兴趣的从JSON中。特别的，你想循环遍历“contents”数组来把“is_dir”设置成false。 这样做，添加下面的代码到“TODO 2”注释后面： 12345678910111213141516171819202122// 1NSArray *contentsOfRootDirectory = notesJSON[@&quot;contents&quot;];for (NSDictionary *data in contentsOfRootDirectory) &#123; if (![data[@&quot;is_dir&quot;] boolValue]) &#123; DBFile *note = [[DBFile alloc] initWithJSONData:data]; [notesFound addObject:note]; &#125;&#125;[notesFound sortUsingComparator: ^NSComparisonResult(id obj1, id obj2) &#123; return [obj1 compare:obj2]; &#125;];self.notes = notesFound;// 6dispatch_async(dispatch_get_main_queue(), ^&#123; [UIApplication sharedApplication].networkActivityIndicatorVisible = NO; [self.tableView reloadData];&#125;); 这里有两部分： 你拉取数组对象从“contents”键中，让后循环便利数组。每个数组入口是一个文件，所以你创建一个相应的DBFile文件模型为每一个文件。 DBFile是一个我为你创建的辅助类，为了拉取信息从一个JSON字典到一个文件中 - 轻轻一瞥就能看到它是怎样工作的。 当你完成时，你添加所有的笔记到self.notes接口中。表视图被设置来显示数组中的任何记录。 既然你的表视图数据源已经更新了，你需要重载表的数据。无论何时你正在处理异步网络请求时，你必须保证更新UIKit在主线程。 机敏的读者将会注意到在上述代码中没有错误处理；假如你感觉你像一个哭丧女（大多数Byte Club 都是！）添加一些代码在这里（在随后的代码块中你将添加），代码在错误和警告用户的时候将重试。 构建运行你的app；你应该看你添加到你的Dropbox文件夹的文件是否显示在列表中，就像下面例子一样显示： 事情本来是小事，当时这证明了你正确的调用了Dropbox API。 下一步是发布比较然后向其他俱乐部成员发起挑战，再一次使用Dropbox API 就当你是传送机构。 POST Notes through the Dropbox API轻点右上角的 + 号，你将看到笔记add&#x2F;edit屏幕出现，就像下面演示的一样： 开始的app已经安装了DBFile 模型对象到NoteDetailsViewController在prepareForSegue:sender:方法中： 加入你瞥一眼这个方法，你将看到NoteViewController被设置成NoteDetailsViewController的代理。这种方法，NoteDetailsViewController能够通知NoteViewController当用户完成编辑一篇笔记或者取消编辑一篇笔记时。 打开NotesViewController.m ,添加下面这行到prepareForSegue:sender:中，就在showNote.delegate = self行的后面； 1showNote.session = _session; NoteDetailsViewController已经有一个NSURLSession的接口名字叫做session,因此你能够设置它在prepareForSegue:sender: 载入之前。 现在detail view controller将获得相同的NSURLSession,所有detail view controller能够使用它来进行DropBox 的API调用。 Cancel和Done按钮已经呈现在你的app中；你只需要添加一些在他们背后保存或者取消在尚未完工的笔记逻辑。 在NoteDetailsViewController.m,找到下面这一行在(IBAction)done:(id)sender:方法中： 12// - UPLOAD FILE TO DROPBOX - // [self.delegate noteDetailsViewControllerDoneWithDetails:self]; …用下面的替换它： 12345678910111213141516171819202122232425262728293031// 1NSURL *url = [Dropbox uploadURLForPath: _note.path];// 2NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url];[request setHTTPMethod:@&quot;PUT&quot;];// 3NSData *noteContents = [_note.contents dataUsingEncoding:NSUTF8StringEncoding];// 4NSURLSessionUploadTask *uploadTask = [_session uploadTaskWithRequest:request fromData:noteContents completionHandler:^(NSData *data, NSURLResponse *response, NSError *error)&#123; NSHTTPURLResponse *httpResp = (NSHTTPURLResponse*) response; if (!error &amp;&amp; httpResp.statusCode == 200) &#123; [self.delegate noteDetailsViewControllerDoneWithDetails:self]; &#125; else &#123; // alert for error saving / updating note &#125;&#125;];// 5[uploadTask resume]; 这个实现了你需要保存和分享你的笔记的所有事情。假如仔细观察每一块的注释，你将发现做了下面的事： 为了上传一个文件到Dropbox，你需要再次使用某个API URL。就像先前你需要一个URL来列出在一个文件夹中的文件，我已经构造了一个辅助方法来为你产生URL。你可以在这里调用。 下一步是你的老朋友NSMutableURLRequest,新的APIs能够同时使用普通的URL是和NSURLRequest对象，但是这里你需要可变的形式来使Dropbox API让它的请求变成PUT请求。设置HTTP方法作为PUT发信号给Dropbox来让它为你创建一个新的文件。 下一步是将文本从你的UITextView编码成NSData对象。 既然你已经创建好了请求和NSData数据，你下一步就是创建一个NSURLSessionUploadTask然后设置completion handler block.一旦成功，你就调用代理方法 noteDetailsViewControllerDoneWithDetails:来关闭呈现的内容。在生产级别的应用中你可以回传一个新的BDFile给代理然后同步你需要持久化的数据。为了这个应用，你只需要刷新NotesViewController 用一个网络调用。 再次提到，所有的任务以暂停的状态被创建，所以你必须调用恢复来启动他们。 构建然后运行你的App，点击笔记标签上的+号。在challenge name字段上输入你的名字，输入一些文本在note字段想Ray发布一份挑战书，和下面的例子相似： 当你清点Done时，NoteViewController将返回并且给你列出新的笔记像下面显示的那样： ) 你已经正式的给Ray下发挑战书；然而，他有朋友在非常高的位置所有你最好尽力完成这场比赛。 但是这里有一条非常重要的消息遗漏了。你能告诉我是什么么？ 轻点笔记包含的挑战；NoteDetailsViewController自己呈现，当时笔记的内容确实空白的。 Ray并不会找到你的发的非常有威胁的挑战假如他没有读的话！ 现在，app只是调用Dropbox元数据API来检索文件列表。你也需要添加一些代码来抓取笔记的内容。 打开NoteDetailsViewController.m,用下面的实现替换空白的retreiveNoteText的实现： 12345678910111213141516171819202122232425262728293031323334353637383940-(void)retreiveNoteText&#123; // 1 NSString *fileApi = @&quot;https://api-content.dropbox.com/1/files/dropbox&quot;; NSString *escapedPath = [ _note.path stringByAddingPercentEscapesUsingEncoding: NSUTF8StringEncoding]; NSString *urlStr = [NSString stringWithFormat: @&quot;%@/%@&quot;, fileApi,escapedPath]; NSURL *url = [NSURL URLWithString: urlStr]; [UIApplication sharedApplication].networkActivityIndicatorVisible = YES; // 2 [[ _session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123; if (!error) &#123; NSHTTPURLResponse *httpResp = (NSHTTPURLResponse*) response; if (httpResp.statusCode == 200) &#123; // 3 NSString *text = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; dispatch_async(dispatch_get_main_queue(), ^&#123; [UIApplication sharedApplication].networkActivityIndicatorVisible = NO; self.textView.text = text; &#125;); &#125; else &#123; // HANDLE BAD RESPONSE // &#125; &#125; else &#123; // ALWAYS HANDLE ERRORS :-] // &#125; // 4 &#125;] resume];&#125; 上面在笔记中的代码（没有错误检查）下面来解释： 设置请求的路径和你期望检索的文件的URL地址；&#x2F;文件的端点在Dropbox API中将会返回给你一个指定文件的内容。 用指向感兴趣的文件的URL创建数据任务。这个调用应该开始，只要你纵览整个app你会相当熟悉。 假如你响应的代码表明所有的都是好的，在主线程用你在先前的步骤中检索到的文件内容设置textView。记住，UI更新必须切换到主线程。 一旦这个任务被初始化，调用恢复。这里有写不一样的方法和以前的相比，当恢复被直接调用时在任务还没有指派时。 构建运行你的App，在列表中对你的挑战轻点，内容将直接正确的显示在view中，像下面这样： 你可以扮演Ray然后通过向笔记中输入文本响应这个挑战；文件将很快更新当你轻点Done。 使用NSURLSessionTask代理发送照片你已经看到怎样使用NSURLSession异步便利构造方法。但是假如你想把注意力集中在文件传输上，例如上传一个大文件并且显示一个进度条怎么样？ 对于这种异步的，耗时任务类型你需要实现NSURLSessionTaskDelegate协议方。通过实现这个方法，你能够检索回调当一个任务接收到数据和完成接收数据时。 你可能已经注意到PanoPhotos标签是空的当你启动App的时候。然而，Byte Club组织的创办成员已经慷慨的提供了一些他们自己的全景照片，你可以用它来填充你的app。 下载这些 我们为你放在一起的全景照片。解压文件，拷贝到你的app在Dropbox目录下的照片目录。你文件夹的内容应该和下面一样： Dropbox和核心API可以提供照片的缩略图；使用一个 UITableView cell这听起来想一件非常完美的事。 打开 PhotosViewController.m然后在“GO GET THUMBNAILS注释后面添加下面的代码到tableView:cellForRowAtIndexPath: 12345678910111213141516[UIApplication sharedApplication].networkActivityIndicatorVisible = YES;NSURLSessionDataTask *dataTask = [_session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123; if (!error) &#123; UIImage *image = [[UIImage alloc] initWithData:data]; photo.thumbNail = image; dispatch_async(dispatch_get_main_queue(), ^&#123; [UIApplication sharedApplication].networkActivityIndicatorVisible = NO; cell.thumbnailImage.image = photo.thumbNail; &#125;); &#125; else &#123; // HANDLE ERROR // &#125;&#125;];[dataTask resume]; 上面的代码显示了照片的缩略图图在表视图的cell中。。。或者至少它会是，假如_photoThumbnails现在不是空的话。 找到refreshPhotos用下面的实现替换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748- (void)refreshPhotos&#123; [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES]; NSString *photoDir = [NSString stringWithFormat:@&quot;https://api.dropbox.com/1/search/dropbox/%@/photos?query=.jpg&quot;,appFolder]; NSURL *url = [NSURL URLWithString:photoDir]; [[ _session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123; if (!error) &#123; NSHTTPURLResponse *httpResp = (NSHTTPURLResponse*) response; if (httpResp.statusCode == 200) &#123; NSError *jsonError; NSArray *filesJSON = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:&amp;jsonError]; NSMutableArray *dbFiles = [[NSMutableArray alloc] init]; if (!jsonError) &#123; for (NSDictionary *fileMetadata in filesJSON) &#123; DBFile *file = [[DBFile alloc] initWithJSONData:fileMetadata]; [dbFiles addObject:file]; &#125; [dbFiles sortUsingComparator:^NSComparisonResult(id obj1, id obj2) &#123; return [obj1 compare:obj2]; &#125;]; _photoThumbnails = dbFiles; dispatch_async(dispatch_get_main_queue(), ^&#123; [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO]; [self.tableView reloadData]; &#125;); &#125; &#125; else &#123; // HANDLE BAD RESPONSE // &#125; &#125; else &#123; // ALWAYS HANDLE ERRORS :-] // &#125; &#125;] resume];&#125; 这个和你早期载入挑战笔记时写的代码很像。这次，API调用来查找在photos目录的内容，并且只会以.jpg拓展的文件。 既然_photoThumbnails数组已经填充好了，缩略图将出现在表视图中并且异步更新。 构建运行你的app，然后切换到PanoPhotos标签；缩略图将载入并且像下面这样出现： ！networking21 照片看起来非常的棒–只是请当心Matthijs家撕裂代码的猫🐱！ 上传一张全景照片你的app能够下载相片，如果它也能上传照片并且显示上传进度的话就非常棒了。 为了跟踪上传的进度，PhotosViewController必须成为NSURLSessionDelegate和NSURLSessionTaskDelegate协议的代理，以便你能收到进度回调。 修改在PhotosViewController.m中PhotosViewController的接口声明，添加NSURLSessionTaskDelegate,像下面这样： 1@ interface PhotosViewController ()UITableViewDelegate, UITableViewDataSource, UIImagePickerControllerDelegate, UINavigationControllerDelegate, NSURLSessionTaskDelegate&gt; 下一步，添加下面的私有接口： 12@property (nonatomic, strong) NSURLSessionUploadTask *uploadTask; 上面的指针引用了任务对象；通过哪种方式，你就可以接入到对象的成员中来跟踪上传任务的进度了。 当用户选择一张图片上传时，didFinishPickingMediaWithInfo调用uploadImage:方法来执行文件上传。现在，那个方法空了-这是你的工作让它丰满起来。 替换uploadImage: 用下面的代码： 12345678910111213141516171819202122232425262728- (void)uploadImage:(UIImage*)image&#123; NSData *imageData = UIImageJPEGRepresentation(image, 0.6); // 1 NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration]; config.HTTPMaximumConnectionsPerHost = 1; [config setHTTPAdditionalHeaders:@&#123;@&quot;Authorization&quot;: [Dropbox apiAuthorizationHeader]&#125;]; // 2 NSURLSession *upLoadSession = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:nil]; // for now just create a random file name, dropbox will handle it if we overwrite a file and create a new name.. NSURL *url = [Dropbox createPhotoUploadURL]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url]; [request setHTTPMethod:@&quot;PUT&quot;]; // 3 self.uploadTask = [upLoadSession uploadTaskWithRequest:request fromData:imageData]; // 4 self.uploadView.hidden = NO; [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES]; // 5 [ _uploadTask resume];&#125; 下面是上面的代码做的事： 起先，你使用设置在initWithCoder的会话和相关的便利方法来创建异步任务。这个时候，你使用一个NSURLSessionConfiguration ,它只允许一个连接连接到远程主机，因为你上传进度处理一次就是一个文件。 上传和下载任务报告信息通过它们的代理返回；你将简短的实现。 这里你设置了uploadTask接口使用从UIImagePicker获得的JPEG图片。 下一步，你显示UIProgressView让它隐藏在PhotosViewController内部。 开始任务–额，抱歉，是恢复任务。 既然代理已经设置了，你就可以实现NSURLSessionTaskDelegate方法来更新进度视图。 添加下面的代码到 PhotosViewController.m文件末尾： 1234567891011121314#pragma mark - NSURLSessionTaskDelegate methods- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [ _progress setProgress: (double)totalBytesSent / (double)totalBytesExpectedToSend animated:YES]; &#125;);&#125; 上面的代理方法将定期报告信息给调用者关于上传任务的信息。它同时会更新UIProgressView（ _progress）的进度以便显示 totalBytesSent&#x2F;totalBytesExpectedToSend,这比显示一个完成的百分比跟有意义（也更极客）。 剩下唯一的事就是当上传任务结束时指示一下。添加下面的代码到 PhotosViewController.m文件末尾： 123456789101112131415161718- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&#123; // 1 dispatch_async(dispatch_get_main_queue(), ^&#123; [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO]; _uploadView.hidden = YES; [ _progress setProgress:0.5]; &#125;); if (!error) &#123; // 2 dispatch_async(dispatch_get_main_queue(), ^&#123; [self refreshPhotos]; &#125;); &#125; else &#123; // Alert for error &#125;&#125; 这里没有很多代码，但是它执行了两项非常重要的任务： 打开网络指示器，然后隐藏_uploadView作为上传完成的一点点清理工作。 刷新PhotosViewController以便包含你刚刚上传的照片，由于demo app是不能进行任何本地储存的上传。在一个真正的app中，你应该把图片在本地进行储存和缓存。 构建运行你的app，导航到PanoPhotos标签，点击照相图标选择一张照片。 注意：假如你说使用模拟器测试app，很显然你不能用你的Mac拍照，所有仅仅是拷贝一张全景照片给模拟器然后上传。这样做，可以确保没有其他的Xcode工程现在连接到这个模拟器，在Xcode中选择 Xcode Open Developer Tool iOS Simulator。 从Finder中拖拽一张全景照片带模拟器中，在模拟器中图片将会在Safari中打开。长按图片然后保存图片到图库中。 在选择一张图片后上传，uploadView显示在屏幕的中央，并且带有上传进度，乡下面这一样显示： ！networking23 你可能注意到一张图片上传需要花一些时间由于上传任务设置了better quality缩放因子。对于那些A类性格的人，你应该提供一个取消函数假如上传花费太长的时间。 取消按钮在uploadView已经被封装起来在故事板中，所有你只需实现清楚逻辑来杀死下载操作就行。 用下面的代码替换 PhotosViewController.m的cancelUpload: ： 12345- (IBAction)cancelUpload:(id)sender &#123; if ( _uploadTask.state == NSURLSessionTaskStateRunning) &#123; [ _uploadTask cancel]; &#125;&#125; 在这类你会看到，取消一个任务相当简单就是调用一个取消方法。 现在构建运行你的app，选择一张照片上传然后点击Cancel。图片上传将会停止并且uploadView将会被隐藏。 就这样–Byte Club完成了！ 何去何从？这里是完成的工程在这个NSURLSession教程中。 假如你做到这一步，恭喜你可以享受到Byte Club的时光！不要告诉任何Android的小伙伴们！ :]你现在能够处理在你app需要的任何网络任务了。 假如你喜欢这个课程，你可能想要查阅我们的新书 iOS 7 by Tutorials,这是这本书的一个简略版本，这本书几乎涵盖了在iOS 7中最新和最多的APIs，这些你应该清楚的知道作为一个开发者。 我几乎忘记了。。。 /slap &lt;you the reader&gt; have been slapped around a bit with a large trout. （不要问我为什么 hehe！😄） 假如你有任何问题或者评论关于这个教程或者NSURLSession,请加入到下面的论坛讨论！ 参考资料： 从 NSURLConnection 到 NSURLSession NSURLSession Tutorial 译者注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://blog.wangruofeng007.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"网络","slug":"网络","permalink":"https://blog.wangruofeng007.com/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"iOS线程安全-锁","slug":"2016-01-14-iosxian-cheng-an-quan-suo","date":"2016-01-13T18:08:36.000Z","updated":"2024-11-02T03:36:52.402Z","comments":true,"path":"2016/01/14/2016-01-14-iosxian-cheng-an-quan-suo/","permalink":"https://blog.wangruofeng007.com/2016/01/14/2016-01-14-iosxian-cheng-an-quan-suo/","excerpt":"","text":"Objective－C使用 @synchronized 类实现锁1234567891011121314151617// 实例类personPerson *person = [[Person alloc] init];// 线程Adispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @synchronized(person) &#123; [person personA]; [NSThread sleepForTimeInterval:3]; // 线程休眠3秒 &#125;&#125;);// 线程Bdispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @synchronized(person) &#123; [person personB]; &#125;&#125;); 使用 NSRecursiveLock 类实现锁 递归锁，递归或循环方法时使用此方法实现锁，可避免死锁等问题 123456789101112131415161718192021222324252627282930// 实例类personPerson *person = [[Person alloc] init];// 创建锁对象NSRecursiveLock *theLock = [[NSRecursiveLock alloc] init];// 创建递归方法static void (^testCode)(int);testCode = ^(int value) &#123; [theLock tryLock]; if (value &gt; 0) &#123; [person personA]; [NSThread sleepForTimeInterval:1]; testCode(value - 1); &#125; [theLock unlock];&#125;;//线程Adispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; testCode(5);&#125;);//线程Bdispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [theLock lock]; [person personB]; [theLock unlock];&#125;); 使用 NSConditionLock（条件锁）类实现锁 使用此方法可以指定，只有满足条件的时候才可以解锁 123456789101112131415161718// 实例类personPerson *person = [[Person alloc] init];// 创建条件锁NSConditionLock *conditionLock = [[NSConditionLock alloc] init];// 线程Adispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [conditionLock lock]; [person personA]; [NSThread sleepForTimeInterval:5]; [conditionLock unlockWithCondition:10]; &#125;);// 线程Bdispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [conditionLock lockWhenCondition:10]; [person personB]; [conditionLock unlock]; &#125;); NSDistributedLock（分布式锁） 在iOS中不需要用到，也没有这个方法，因此本文不作介绍，这里写出来只是想让大家知道有这个锁存在。如果想要学习NSDistributedLock的话，你可以创建MAC OS的项目自己演练，方法请自行Google，谢谢 C语言使用 pthread_mutex_t 实现锁 注意：必须在头文件导入：#import &lt;pthread.h&gt; 12345678910111213141516171819// 实例类personPerson *person = [[Person alloc] init];// 创建锁对象__block pthread_mutex_t mutex;pthread_mutex_init(&amp;mutex, NULL);// 线程Adispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;mutex); [person personA]; [NSThread sleepForTimeInterval:5]; pthread_mutex_unlock(&amp;mutex);&#125;);// 线程Bdispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;mutex); [person personB]; pthread_mutex_unlock(&amp;mutex);&#125;); 使用 GCD 实现“锁”(信号量） GCD提供一种信号的机制，使用它我们可以创建“锁” 123456789101112131415161718192021// 实例类personPerson *person = [[Person alloc] init];// 创建并设置信量dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);// 线程Adispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [person personA]; [NSThread sleepForTimeInterval:5]; dispatch_semaphore_signal(semaphore);&#125;);// 线程Bdispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [person personB]; dispatch_semaphore_signal(semaphore);&#125;); 我在这里解释一下代码。dispatch_semaphore_wait方法是把信号量加1，dispatch_semaphore_signal是把信号量减1。 我们把信号量当作是一个计数器，当计数器是一个非负整数时，所有通过它的线程都应该把这个整数减1。 如果计数器大于0，那么则允许访问，并把计数器减1。如果为0，则访问被禁止，所有通过它的线程都处于等待的状态。 使用POSIX（条件锁）创建锁）12345678910111213141516171819202122232425262728// 实例类personPerson *person = [[Person alloc] init];// 创建互斥锁 __block pthread_mutex_t mutex; pthread_mutex_init(&amp;mutex, NULL); // 创建条件锁 __block pthread_cond_t cond; pthread_cond_init(&amp;cond, NULL); // 线程A dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;mutex); pthread_cond_wait(&amp;cond, &amp;mutex); [person personA]; pthread_mutex_unlock(&amp;mutex); &#125;); // 线程B dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;mutex); [person personB]; [NSThread sleepForTimeInterval:5]; pthread_cond_signal(&amp;cond); pthread_mutex_unlock(&amp;mutex); &#125;); 效果：程序会首先调用线程B，在5秒后再调用线程A。因为在线程A中创建了等待条件锁，线程B有激活锁，只有当线程B执行完后会激活线程A。 pthread_cond_wait方法为等待条件锁。 pthread_cond_signal方法为激活一个相同条件的条件锁。 注意:自旋锁OSSpinLock已经不再线程安全 参考资料 http://www.liuhaihua.cn/archives/25316.html 不再安全的 OSSpinLock","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://blog.wangruofeng007.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"SQLite_教程(七)","slug":"2016-01-14-sqlite-jiao-cheng-qi","date":"2016-01-13T17:46:57.000Z","updated":"2024-11-02T03:36:52.403Z","comments":true,"path":"2016/01/14/2016-01-14-sqlite-jiao-cheng-qi/","permalink":"https://blog.wangruofeng007.com/2016/01/14/2016-01-14-sqlite-jiao-cheng-qi/","excerpt":"","text":"SQLite Order BySQLite 的 ORDER BY 子句是用来基于一个或多个列按升序或降序顺序排列数据。 语法 ORDER BY 子句的基本语法如下： SELECT column-list FROM table_name [WHERE condition] [ORDER BY column1, column2, .. columnN] [ASC | DESC]; 您可以在 ORDER BY 子句中使用多个列。确保您使用的排序列在列清单中。 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它会将结果按 SALARY 升序排序： sqlite&gt; SELECT * FROM COMPANY ORDER BY SALARY ASC; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 7 James 24 Houston 10000.0 2 Allen 25 Texas 15000.0 1 Paul 32 California 20000.0 3 Teddy 23 Norway 20000.0 6 Kim 22 South-Hall 45000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 下面是一个实例，它会将结果按 NAME 和 SALARY 升序排序： sqlite&gt; SELECT * FROM COMPANY ORDER BY NAME, SALARY ASC; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000.0 5 David 27 Texas 85000.0 7 James 24 Houston 10000.0 6 Kim 22 South-Hall 45000.0 4 Mark 25 Rich-Mond 65000.0 1 Paul 32 California 20000.0 3 Teddy 23 Norway 20000.0 下面是一个实例，它会将结果按 NAME 降序排序： sqlite&gt; SELECT * FROM COMPANY ORDER BY NAME DESC; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 3 Teddy 23 Norway 20000.0 1 Paul 32 California 20000.0 4 Mark 25 Rich-Mond 65000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 5 David 27 Texas 85000.0 2 Allen 25 Texas 15000.0 SQLite Group BySQLite 的 GROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。 语法 下面给出了 GROUP BY 子句的基本语法。GROUP BY 子句必须放在 WHERE 子句中的条件之后，必须放在 ORDER BY 子句之前。 SELECT column-list FROM table_name WHERE [ conditions ] GROUP BY column1, column2....columnN ORDER BY column1, column2....columnN 您可以在 GROUP BY 子句中使用多个列。确保您使用的分组列在列清单中。 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 如果您想了解每个客户的工资总额，则可使用 GROUP BY 查询，如下所示： sqlite&gt; SELECT NAME, SUM(SALARY) FROM COMPANY GROUP BY NAME; 这将产生以下结果： NAME SUM(SALARY) ---------- ----------- Allen 15000 David 85000 James 20000 Kim 45000 Mark 65000 Paul 40000 Teddy 20000 让我们把 ORDER BY 子句与 GROUP BY 子句一起使用，如下所示： sqlite&gt; SELECT NAME, SUM(SALARY) FROM COMPANY GROUP BY NAME ORDER BY NAME DESC; 这将产生以下结果： NAME SUM(SALARY) ---------- ----------- Teddy 20000 Paul 40000 Mark 65000 Kim 45000 James 20000 David 85000 Allen 15000 SQLite Having 子句HAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。 WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。 语法 下面是 HAVING 子句在 SELECT 查询中的位置： SELECT FROM WHERE GROUP BY HAVING ORDER BY 在一个查询中，HAVING 子句必须放在 GROUP BY 子句之后，必须放在 ORDER BY 子句之前。下面是包含 HAVING 子句的 SELECT 语句的语法： SELECT column1, column2 FROM table1, table2 WHERE [ conditions ] GROUP BY column1, column2 HAVING [ conditions ] ORDER BY column1, column2 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 8 Paul 24 Houston 20000.0 9 James 44 Norway 5000.0 10 James 45 Texas 5000.0 下面是一个实例，它将显示名称计数小于 2 的所有记录： sqlite &gt; SELECT * FROM COMPANY GROUP BY name HAVING count(name) &lt; 2; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000 5 David 27 Texas 85000 6 Kim 22 South-Hall 45000 4 Mark 25 Rich-Mond 65000 3 Teddy 23 Norway 20000 下面是一个实例，它将显示名称计数大于 2 的所有记录,注意其实这里只返回最后一条记录： sqlite &gt; SELECT * FROM COMPANY GROUP BY name HAVING count(name) &gt; 2; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 10 James 45 Texas 5000 SQLite Distinct 关键字SQLite 的 DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。 语法 用于消除重复记录的 DISTINCT 关键字的基本语法如下： SELECT DISTINCT column1, column2,.....columnN FROM table_name WHERE [condition] 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 8 Paul 24 Houston 20000.0 9 James 44 Norway 5000.0 10 James 45 Texas 5000.0 首先，让我们来看看下面的 SELECT 查询，它将返回重复的工资记录： sqlite&gt; SELECT name FROM COMPANY; 这将产生以下结果： NAME ---------- Paul Allen Teddy Mark David Kim James Paul James James 现在，让我们在上述的 SELECT 查询中使用 DISTINCT 关键字： sqlite&gt; SELECT DISTINCT name FROM COMPANY; 这将产生以下结果，没有任何重复的条目： NAME ---------- Paul Allen Teddy Mark David Kim James 资料整理于：RUNOOB.COM-SQLite教程转载请注明出处。","categories":[{"name":"Database","slug":"Database","permalink":"https://blog.wangruofeng007.com/categories/Database/"}],"tags":[]},{"title":"SQLite_教程(六)","slug":"2016-01-14-sqlite-jiao-cheng-liu","date":"2016-01-13T17:41:01.000Z","updated":"2024-11-02T03:36:52.403Z","comments":true,"path":"2016/01/14/2016-01-14-sqlite-jiao-cheng-liu/","permalink":"https://blog.wangruofeng007.com/2016/01/14/2016-01-14-sqlite-jiao-cheng-liu/","excerpt":"","text":"SQLite Delete 语句SQLite 的 DELETE 查询用于删除表中已有的记录。可以使用带有 WHERE 子句的 DELETE 查询来删除选定行，否则所有的记录都会被删除。 语法 带有 WHERE 子句的 DELETE 查询的基本语法如下： DELETE FROM table_name WHERE [condition]; 您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 现在，COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 如果您想要从 COMPANY 表中删除所有记录，则不需要使用 WHERE 子句，DELETE 查询如下： sqlite&gt; DELETE FROM COMPANY; 现在，COMPANY 表中没有任何的记录，因为所有的记录已经通过 DELETE 语句删除。 SQLite Like 子句SQLite 的 LIKE 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。这里有两个通配符与 LIKE 运算符一起使用： 百分号 （%） 下划线 （_） 百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。 语法 % 和 _ 的基本语法如下： SELECT FROM table_name WHERE column LIKE &#39;XXXX%&#39; or SELECT FROM table_name WHERE column LIKE &#39;%XXXX%&#39; or SELECT FROM table_name WHERE column LIKE &#39;XXXX_&#39; or SELECT FROM table_name WHERE column LIKE &#39;_XXXX&#39; or SELECT FROM table_name WHERE column LIKE &#39;_XXXX_&#39; 您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。在这里，XXXX 可以是任何数字或字符串值。 实例 下面一些实例演示了 带有 ‘%’ 和 ‘_’ 运算符的 LIKE 子句不同的地方： 语句 描述 WHERE SALARY LIKE ‘200%’ 查找以 200 开头的任意值 WHERE SALARY LIKE ‘%200%’ 查找任意位置包含 200 的任意值 WHERE SALARY LIKE ‘_00%‘ 查找第二位和第三位为 00 的任意值 WHERE SALARY LIKE ‘2_%_%’ 查找以 2 开头，且长度至少为 3 个字符的任意值 WHERE SALARY LIKE ‘%2’ 查找以 2 结尾的任意值 WHERE SALARY LIKE ‘_2%3’ 查找第二位为 2，且以 3 结尾的任意值 WHERE SALARY LIKE ‘2___3’ 查找长度为 5 位数，且以 2 开头以 3 结尾的任意值 让我们举一个实际的例子，假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它显示 COMPANY 表中 AGE 以 2 开头的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE LIKE &#39;2%&#39;; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它显示 COMPANY 表中 ADDRESS 文本里包含一个连字符（-）的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE ADDRESS LIKE &#39;%-%&#39;; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 Mark 25 Rich-Mond 65000.0 6 Kim 22 South-Hall 45000.0 SQLite Glob 子句SQLite 的 GLOB 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。与 LIKE 运算符不同的是，GLOB 是大小写敏感的，对于下面的通配符，它遵循 UNIX 的语法。 星号 （*） 问号 （?） 星号（*）代表零个、一个或多个数字或字符。问号（?）代表一个单一的数字或字符。这些符号可以被组合使用。 语法 * 和 ? 的基本语法如下： SELECT FROM table_name WHERE column GLOB &#39;XXXX*&#39; or SELECT FROM table_name WHERE column GLOB &#39;*XXXX*&#39; or SELECT FROM table_name WHERE column GLOB &#39;XXXX?&#39; or SELECT FROM table_name WHERE column GLOB &#39;?XXXX&#39; or SELECT FROM table_name WHERE column GLOB &#39;?XXXX?&#39; or SELECT FROM table_name WHERE column GLOB &#39;????&#39; 您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。在这里，XXXX 可以是任何数字或字符串值。 实例 下面一些实例演示了 带有 ‘*’ 和 ‘?’ 运算符的 GLOB 子句不同的地方： 语句 描述 WHERE SALARY GLOB ‘200*‘ 查找以 200 开头的任意值 WHERE SALARY GLOB ‘*200*‘ 查找任意位置包含 200 的任意值 WHERE SALARY GLOB ‘?00*‘ 查找第二位和第三位为 00 的任意值 WHERE SALARY GLOB ‘2??’ 查找以 2 开头，且长度至少为 3 个字符的任意值 WHERE SALARY GLOB ‘*2’ 查找以 2 结尾的任意值 WHERE SALARY GLOB ‘?2*3’ 查找第二位为 2，且以 3 结尾的任意值 WHERE SALARY GLOB ‘2???3’ 查找长度为 5 位数，且以 2 开头以 3 结尾的任意值 让我们举一个实际的例子，假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它显示 COMPANY 表中 AGE 以 2 开头的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE GLOB &#39;2*&#39;; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它显示 COMPANY 表中 ADDRESS 文本里包含一个连字符（-）的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE ADDRESS GLOB &#39;*-*&#39;; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 Mark 25 Rich-Mond 65000.0 6 Kim 22 South-Hall 45000.0 SQLite Limit 子句SQLite 的 LIMIT 子句用于限制由 SELECT 语句返回的数据数量。 语法 带有 LIMIT 子句的 SELECT 语句的基本语法如下： SELECT column1, column2, columnN FROM table_name LIMIT [no of rows] 下面是 LIMIT 子句与 OFFSET 子句一起使用时的语法： SELECT column1, column2, columnN FROM table_name LIMIT [no of rows] OFFSET [row num] SQLite 引擎将返回从下一行开始直到给定的 OFFSET 为止的所有行，如下面的最后一个实例所示。 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它限制了您想要从表中提取的行数： sqlite&gt; SELECT * FROM COMPANY LIMIT 6; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 但是，在某些情况下，可能需要从一个特定的偏移开始提取记录(OFFSET下标从0开始)。下面是一个实例，从第三位开始提取 3 个记录： sqlite&gt; SELECT * FROM COMPANY LIMIT 3 OFFSET 2; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 资料整理于：RUNOOB.COM-SQLite教程转载请注明出处。","categories":[{"name":"Database","slug":"Database","permalink":"https://blog.wangruofeng007.com/categories/Database/"}],"tags":[]},{"title":"SQLite_教程(五)","slug":"2016-01-14-sqlite-jiao-cheng-wu","date":"2016-01-13T17:35:50.000Z","updated":"2024-11-02T03:36:52.403Z","comments":true,"path":"2016/01/14/2016-01-14-sqlite-jiao-cheng-wu/","permalink":"https://blog.wangruofeng007.com/2016/01/14/2016-01-14-sqlite-jiao-cheng-wu/","excerpt":"","text":"SQL表达式表达式是一个或多个值、运算符和计算值的SQL函数的组合。 SQL 表达式与公式类似，都写在查询语言中。您还可以使用特定的数据集来查询数据库。 语法 假设 SELECT 语句的基本语法如下： SELECT column1, column2, columnN FROM table_name WHERE [CONTION | EXPRESSION]; 有不同类型的 SQLite 表达式，具体讲解如下： SQLite - 布尔表达式SQLite 的布尔表达式在匹配单个值的基础上获取数据。语法如下： SELECT column1, column2, columnN FROM table_name WHERE SINGLE VALUE MATCHTING EXPRESSION; 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的实例演示了 SQLite 布尔表达式的用法： sqlite&gt; SELECT * FROM COMPANY WHERE SALARY = 10000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 James 24 Houston 10000.0 SQLite - 数值表达式这些表达式用来执行查询中的任何数学运算。语法如下： SELECT numerical_expression as OPERATION_NAME [FROM table_name WHERE CONDITION] ; 在这里，numerical_expression 用于数学表达式或任何公式。下面的实例演示了 SQLite 数值表达式的用法： sqlite&gt; SELECT (15 + 6) AS ADDITION ADDITION = 21 有几个内置的函数，比如 avg()、sum()、count()，等等，执行被称为对一个表或一个特定的表列的汇总数据计算。 sqlite&gt; SELECT COUNT(*) AS &quot;RECORDS&quot; FROM COMPANY; RECORDS = 7 SQLite - 日期表达式日期表达式返回当前系统日期和时间值，这些表达式将被用于各种数据操作。 sqlite&gt; SELECT CURRENT_TIMESTAMP; CURRENT_TIMESTAMP = 2016-01-13 16:29:56 SQLite Where 子句SQLite的 WHERE 子句用于指定从一个表或多个表中获取数据的条件。 如果满足给定的条件，即为真（true）时，则从表中返回特定的值。您可以使用 WHERE 子句来过滤记录，只获取需要的记录。 WHERE 子句不仅可用在 SELECT 语句中，它也可用在 UPDATE、DELETE 语句中，等等，这些我们将在随后的章节中学习到。 语法 SQLite 的带有 WHERE 子句的 SELECT 语句的基本语法如下： SELECT column1, column2, columnN FROM table_name WHERE [condition] 实例 您还可以使用比较或逻辑运算符指定条件，比如 &gt;、&lt;、&#x3D;、LIKE、NOT，等等。假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的实例演示了 SQLite 逻辑运算符的用法。下面的 SELECT 语句列出了 AGE 大于等于 25 且工资大于等于 65000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 下面的 SELECT 语句列出了 AGE 大于等于 25 或工资大于等于 65000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;&#x3D; 25 OR SALARY &gt;&#x3D; 65000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 下面的 SELECT 语句列出了 AGE 不为 NULL 的所有记录，结果显示所有的记录，意味着没有一个记录的 AGE 等于 NULL： sqlite&gt; SELECT * FROM COMPANY WHERE AGE IS NOT NULL; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的 SELECT 语句列出了 NAME 以 ‘Ki’ 开始的所有记录，’Ki’ 之后的字符不做限制（不区分大小写）： sqlite&gt; SELECT * FROM COMPANY WHERE NAME LIKE &#39;Ki%&#39;; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 6 Kim 22 South-Hall 45000.0 下面的 SELECT 语句列出了 NAME 以 ‘Ki’ 开始的所有记录，’Ki’ 之后的字符不做限制（区分大小写）： sqlite&gt; SELECT * FROM COMPANY WHERE NAME GLOB &#39;Ki*&#39;; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 6 Kim 22 South-Hall 45000.0 下面的 SELECT 语句列出了 AGE 的值为 25 或 27 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE IN ( 25, 27 ); ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 SQLite AND&#x2F;OR 运算符SQLite 的 AND 和 OR 运算符用于编译多个条件来缩小在 SQLite 语句中所选的数据。这两个运算符被称为连接运算符。 这些运算符为同一个 SQLite 语句中不同的运算符之间的多个比较提供了可能。 AND 运算符AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。使用 AND 运算符时，只有当所有条件都为真（true）时，整个条件为真（true）。例如，只有当 condition1 和 condition2 都为真（true）时，[condition1] AND [condition2] 为真（true）。 语法 带有 WHERE 子句的 AND 运算符的基本语法如下： SELECT column1, column2, columnN FROM table_name WHERE [condition1] AND [condition2]...AND [conditionN]; 您可以使用 AND 运算符来结合 N 个数量的条件。SQLite 语句需要执行的动作是，无论是事务或查询，所有由 AND 分隔的条件都必须为真（TRUE）。 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的 SELECT 语句列出了 AGE 大于等于 25 且工资大于等于 65000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 OR 运算符OR 运算符也用于结合一个 SQL 语句的 WHERE 子句中的多个条件。使用 OR 运算符时，只要当条件中任何一个为真（true）时，整个条件为真（true）。例如，只要当 condition1 或 condition2 有一个为真（true）时，[condition1] OR [condition2] 为真（true） 语法 带有 WHERE 子句的 OR 运算符的基本语法如下： SELECT column1, column2, columnN FROM table_name WHERE [condition1] OR [condition2]...OR [conditionN] 您可以使用 OR 运算符来结合 N 个数量的条件。SQLite 语句需要执行的动作是，无论是事务或查询，只要任何一个由 OR 分隔的条件为真（TRUE）即可。 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的 SELECT 语句列出了 AGE 大于等于 25 或工资大于等于 65000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;= 25 OR SALARY &gt;= 65000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 SQLite Update 语句SQLite 的 **UPDATE **查询用于修改表中已有的记录。可以使用带有 WHERE 子句的 UPDATE 查询来更新选定行，否则所有的行都会被更新。 语法 带有 WHERE 子句的 UPDATE 查询的基本语法如下： UPDATE table_name SET column1 = value1, column2 = value2...., columnN = valueN WHERE [condition]; 您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它会更新 ID 为 6 的客户地址： sqlite&gt; UPDATE COMPANY SET ADDRESS = &#39;Texas&#39; WHERE ID = 6; 现在，COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 Texas 45000.0 7 James 24 Houston 10000.0 如果您想修改 COMPANY 表中 ADDRESS 和 SALARY 列的所有值，则不需要使用 WHERE 子句，UPDATE 查询如下： sqlite&gt; UPDATE COMPANY SET ADDRESS = &#39;Texas&#39;, SALARY = 20000.00; 现在，COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 Texas 20000.0 2 Allen 25 Texas 20000.0 3 Teddy 23 Texas 20000.0 4 Mark 25 Texas 20000.0 5 David 27 Texas 20000.0 6 Kim 22 Texas 20000.0 7 James 24 Texas 20000.0 资料整理于：RUNOOB.COM-SQLite教程转载请注明出处。","categories":[{"name":"Database","slug":"Database","permalink":"https://blog.wangruofeng007.com/categories/Database/"}],"tags":[]},{"title":"SQLite_教程(四)","slug":"2016-01-13-sqlite-jiao-cheng-si","date":"2016-01-13T15:37:18.000Z","updated":"2024-11-02T03:36:52.402Z","comments":true,"path":"2016/01/13/2016-01-13-sqlite-jiao-cheng-si/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-sqlite-jiao-cheng-si/","excerpt":"","text":"SQLite 运算符SQLite 运算符是什么？ 运算符是一个保留字或字符，主要用于 SQLite 语句的 WHERE 子句中执行操作，如比较和算术运算。 运算符用于指定 SQLite 语句中的条件，并在语句中连接多个条件。 算术运算符 比较运算符 逻辑运算符 位运算符 SQLite 算术运算符假设变量 a&#x3D;10，变量 b&#x3D;20，则： 运算符 描述 实例 + 加法 - 把运算符两边的值相加 a + b 将得到 30 - 减法 - 左操作数减去右操作数 a - b 将得到 -10 * 乘法 - 把运算符两边的值相乘 a * b 将得到 200 &#x2F; 除法 - 左操作数除以右操作数 b &#x2F; a 将得到 2 % 取模 - 左操作数除以右操作数后得到的余数 b % a will give 0 实例 下面是 SQLite 算术运算符的简单实例： sqlite&gt; .mode line sqlite&gt; select 10 + 20; 10 + 20 = 30 sqlite&gt; select 10 - 20; 10 - 20 = -10 sqlite&gt; select 10 * 20; 10 * 20 = 200 sqlite&gt; select 10 / 5; 10 / 5 = 2 sqlite&gt; select 12 % 5; 12 % 5 = 2 SQLite 比较运算符假设变量 a&#x3D;10，变量 b&#x3D;20，则： 运算符 描述 实例 &#x3D;&#x3D; 检查两个操作数的值是否相等，如果相等则条件为真。 (a &#x3D;&#x3D; b) 不为真。 &#x3D; 检查两个操作数的值是否相等，如果相等则条件为真。 (a &#x3D; b) 不为真。 !&#x3D; 检查两个操作数的值是否相等，如果不相等则条件为真。 (a !&#x3D; b) 为真。 &lt;&gt; 检查两个操作数的值是否相等，如果不相等则条件为真。 (a &lt;&gt; b) 为真。 &gt; 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (a &gt; b) 不为真。 &lt; 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (a &lt; b) 为真。 &gt;&#x3D; 检查左操作数的值是否大于等于右操作数的值，如果是则条件为真。 (a &gt;&#x3D; b) 不为真。 &lt;&#x3D; 检查左操作数的值是否小于等于右操作数的值，如果是则条件为真。 (a &lt;&#x3D; b) 为真。 !&lt; 检查左操作数的值是否不小于右操作数的值，如果是则条件为真。 (a !&lt; b) 为假 !&gt; 检查左操作数的值是否不大于右操作数的值，如果是则条件为真。 (a !&gt; b) 为真 实例假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的实例演示了各种 SQLite 比较运算符的用法。 在这里，我们使用 WHERE 子句，这将会在后边单独的一个章节中讲解，但现在您需要明白，WHERE 子句是用来设置 SELECT 语句的条件语句。 下面的 SELECT 语句列出了 SALARY 大于 50,000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE SALARY &gt; 50000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 下面的 SELECT 语句列出了 SALARY 等于 20,000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE SALARY = 20000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 3 Teddy 23 Norway 20000.0 下面的 SELECT 语句列出了 SALARY 不等于 20,000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE SALARY != 20000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的 SELECT 语句列出了 SALARY 不等于 20,000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE SALARY &lt;&gt; 20000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的 SELECT 语句列出了 SALARY 大于等于 65,000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE SALARY &gt;= 65000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 SQLite 逻辑运算符下面是 SQLite 中所有的逻辑运算符列表。 运算符 描述 AND AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。 BETWEEN BETWEEN 运算符用于在给定最小值和最大值范围内的一系列值中搜索值。 EXISTS EXISTS 运算符用于在满足一定条件的指定表中搜索行的存在。 IN IN 运算符用于把某个值与一系列指定列表的值进行比较。 NOT IN IN 运算符的对立面，用于把某个值与不在一系列指定列表的值进行比较。 LIKE LIKE 运算符用于把某个值与使用通配符运算符的相似值进行比较。 GLOB GLOB 运算符用于把某个值与使用通配符运算符的相似值进行比较。GLOB 与 LIKE 不同之处在于，它是大小写敏感的。 NOT NOT 运算符是所用的逻辑运算符的对立面。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。它是否定运算符。 OR OR 运算符用于结合一个 SQL 语句的 WHERE 子句中的多个条件。 IS NULL NULL 运算符用于把某个值与 NULL 值进行比较。 IS IS 运算符与 &#x3D; 相似。 IS NOT IS NOT 运算符与 !&#x3D; 相似。 || 连接两个不同的字符串，得到一个新的字符串。 UNIQUE UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。 实例假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的实例演示了 SQLite 逻辑运算符的用法。下面的 SELECT 语句列出了 AGE 大于等于 25 且工资大于等于 65000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 下面的 SELECT 语句列出了 AGE 大于等于 25 或工资大于等于 65000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;= 25 OR SALARY &gt;= 65000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 下面的 SELECT 语句列出了 AGE 不为 NULL 的所有记录，结果显示所有的记录，意味着没有一个记录的 AGE 等于 NULL： sqlite&gt; SELECT * FROM COMPANY WHERE AGE IS NOT NULL; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的 SELECT 语句列出了 NAME 以 ‘Ki’ 开始的所有记录，’Ki’ 之后的字符不做限制： sqlite&gt; SELECT * FROM COMPANY WHERE NAME LIKE &#39;Ki%&#39;; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 6 Kim 22 South-Hall 45000.0 下面的 SELECT 语句列出了 NAME 以 ‘Ki’ 开始的所有记录，’Ki’ 之后的字符不做限制： sqlite&gt; SELECT * FROM COMPANY WHERE NAME GLOB &#39;Ki*&#39;; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 6 Kim 22 South-Hall 45000.0 下面的 SELECT 语句列出了 AGE 的值为 25 或 27 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE IN ( 25, 27 ); ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 下面的 SELECT 语句列出了 AGE 的值既不是 25 也不是 27 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE NOT IN ( 25, 27 ); ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 3 Teddy 23 Norway 20000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的 SELECT 语句使用 SQL 子查询，子查询查找 SALARY &gt; 65000 的带有 AGE 字段的所有记录，后边的 WHERE 子句与 EXISTS 运算符一起使用，列出了外查询中的 AGE 存在于子查询返回的结果中的所有记录： sqlite&gt; SELECT AGE FROM COMPANY WHERE EXISTS (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000); AGE ---------- 32 25 23 25 27 22 24 下面的 SELECT 语句使用 SQL 子查询，子查询查找 SALARY &gt; 65000 的带有 AGE 字段的所有记录，后边的 WHERE 子句与 &gt; 运算符一起使用，列出了外查询中的 AGE 大于子查询返回的结果中的年龄的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt; (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000); ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 SQLite 位运算符位运算符作用于位，并逐位执行操作。真值表 &amp; 和 | 如下： p q p&amp;q p|q 0 0 0 0 0 1 0 1 1 1 1 1 1 0 0 1 假设如果 A &#x3D; 60，且 B &#x3D; 13，现在以二进制格式，它们如下所示： A &#x3D; 0011 1100 B &#x3D; 0000 1101 A&amp;B &#x3D; 0000 1100 A|B &#x3D; 0011 1101 ~A &#x3D; 1100 0011 下表中列出了 SQLite 语言支持的位运算符。假设变量 A&#x3D;60，变量 B&#x3D;13，则： 运算符 描述 实例 &amp; 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 (A &amp; B) 将得到 12，即为 0000 1100 | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。 (A ~ 二进制补码运算符是一元运算符，具有”翻转”位效应。 (~A ) 将得到 -61，即为 1100 0011，2 的补码形式，带符号的二进制数。 &lt;&lt; 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。 A &lt;&lt; 2 将得到 240，即为 1111 0000 &gt;&gt; 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。 A &gt;&gt; 2 将得到 15，即为 0000 1111 实例 下面的实例演示了 SQLite 位运算符的用法： sqlite&gt; .mode line sqlite&gt; select 60 | 13; 60 | 13 = 61 sqlite&gt; select 60 &amp; 13; 60 &amp; 13 = 12 sqlite&gt; select 60 ^ 13; 10 * 20 = 200 sqlite&gt; select (~60); (~60) = -61 sqlite&gt; select (60 &lt;&lt; 2); (60 &lt;&lt; 2) = 240 sqlite&gt; select (60 &gt;&gt; 2); (60 &gt;&gt; 2) = 15 资料整理于：RUNOOB.COM-SQLite教程转载请注明出处。","categories":[{"name":"Database","slug":"Database","permalink":"https://blog.wangruofeng007.com/categories/Database/"}],"tags":[]},{"title":"SQLite_教程(三)","slug":"2016-01-13-sqlite-jiao-cheng-san","date":"2016-01-13T15:22:37.000Z","updated":"2024-11-02T03:36:52.401Z","comments":true,"path":"2016/01/13/2016-01-13-sqlite-jiao-cheng-san/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-sqlite-jiao-cheng-san/","excerpt":"","text":"SQLite Insert 语句SQLite 的 INSERT INTO 语句用于向数据库的某个表中添加新的数据行。 语法 INSERT INTO 语句有两种基本语法，如下所示： INSERT INTO TABLE_NAME (column1, column2, column3,...columnN)] VALUES (value1, value2, value3,...valueN); 在这里，column1, column2,…columnN 是要插入数据的表中的列的名称。如果要为表中的所有列添加值，您也可以不需要在 SQLite 查询中指定列名称。但要确保值的顺序与列在表中的顺序一致。SQLite 的 INSERT INTO 语法如下： INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN); 实例 假设您已经在 testDB.db 中创建了 COMPANY表，如下所示： sqlite&gt; CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); 现在，下面的语句将在 COMPANY 表中创建六个记录： INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (1, &#39;Paul&#39;, 32, &#39;California&#39;, 20000.00 ); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (2, &#39;Allen&#39;, 25, &#39;Texas&#39;, 15000.00 ); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (3, &#39;Teddy&#39;, 23, &#39;Norway&#39;, 20000.00 ); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (4, &#39;Mark&#39;, 25, &#39;Rich-Mond &#39;, 65000.00 ); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (5, &#39;David&#39;, 27, &#39;Texas&#39;, 85000.00 ); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (6, &#39;Kim&#39;, 22, &#39;South-Hall&#39;, 45000.00 ); 您也可以使用第二种语法在 COMPANY 表中创建一个记录，如下所示： INSERT INTO COMPANY VALUES (7, &#39;James&#39;, 24, &#39;Houston&#39;, 10000.00 ); 上面的所有语句将在 COMPANY 表中创建下列记录。下一章会教您如何从一个表中显示所有这些记录。 ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 使用一个表来填充另一个表您可以通过在一个有一组字段的表上使用 select 语句，填充数据到另一个表中。下面是语法： INSERT INTO first_table_name [(column1, column2, ... columnN)] SELECT column1, column2, ...columnN FROM second_table_name [WHERE condition]; SQLite Select 语句SQLite 的 SELECT 语句用于从 SQLite 数据库表中获取数据，以结果表的形式返回数据。这些结果表也被称为结果集。 语法 SQLite 的 SELECT 语句的基本语法如下： SELECT column1, column2, columnN FROM table_name; 在这里，column1, column2…是表的字段，他们的值即是您要获取的。如果您想获取所有可用的字段，那么可以使用下面的语法： SELECT * FROM table_name; 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，使用 SELECT 语句获取并显示所有这些记录。在这里，前三个命令被用来设置正确格式化的输出。 sqlite&gt;.header on sqlite&gt;.mode column sqlite&gt; SELECT * FROM COMPANY; 最后，将得到以下的结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 如果只想获取 COMPANY 表中指定的字段，则使用下面的查询： sqlite&gt; SELECT ID, NAME, SALARY FROM COMPANY; 上面的查询会产生以下结果： ID NAME SALARY ---------- ---------- ---------- 1 Paul 20000.0 2 Allen 15000.0 3 Teddy 20000.0 4 Mark 65000.0 5 David 85000.0 6 Kim 45000.0 7 James 10000.0 设置输出列的宽度 有时，由于要显示的列的默认宽度导致 .mode column，这种情况下，输出被截断。此时，您可以使用 .width num, num…. 命令设置显示列的宽度，如下所示： sqlite&gt;.width 10, 20, 10 sqlite&gt;SELECT * FROM COMPANY; 上面的 .width 命令设置第一列的宽度为 10，第二列的宽度为 20，第三列的宽度为 10。因此上述 SELECT 语句将得到以下结果： ID NAME AGE ADDRESS SALARY ---------- -------------------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 Schema 信息因为所有的点命令只在 SQLite 提示符中可用，所以当您进行带有 SQLite 的编程时，您要使用下面的带有 sqlite_master 表的 SELECT 语句来列出所有在数据库中创建的表： sqlite&gt; SELECT tbl_name FROM sqlite_master WHERE type = &#39;table&#39;; 假设在 testDB.db 中已经存在唯一的 COMPANY 表，则将产生以下结果： tbl_name ---------- COMPANY 您可以列出关于 COMPANY 表的完整信息，如下所示： sqlite&gt; SELECT sql FROM sqlite_master WHERE type = &#39;table&#39; AND tbl_name = &#39;COMPANY&#39;; 假设在 testDB.db 中已经存在唯一的 COMPANY 表，则将产生以下结果： CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ) 资料整理于：RUNOOB.COM-SQLite教程转载请注明出处。","categories":[{"name":"Database","slug":"Database","permalink":"https://blog.wangruofeng007.com/categories/Database/"}],"tags":[]},{"title":"SQLite_教程(二)","slug":"2016-01-13-sqlite-jiao-cheng-er","date":"2016-01-13T15:21:34.000Z","updated":"2024-11-02T03:36:52.401Z","comments":true,"path":"2016/01/13/2016-01-13-sqlite-jiao-cheng-er/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-sqlite-jiao-cheng-er/","excerpt":"","text":"SQLite 数据类型SQLite 数据类型是一个用来指定任何对象的数据类型的属性。SQLite 中的每一列，每个变量和表达式都有相关的数据类型。 您可以在创建表的同时使用这些数据类型。SQLite 使用一个更普遍的动态类型系统。在 SQLite 中，值的数据类型与值本身是相关的，而不是与它的容器相关。 SQLite 存储类每个存储在 SQLite 数据库中的值都具有以下存储类之一： 存储类 描述 NULL 值是一个 NULL 值。 INTEGER 值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中。 REAL 值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。 TEXT 值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 BLOB 值是一个 blob 数据，完全根据它的输入存储。 SQLite 的存储类稍微比数据类型更普遍。INTEGER 存储类，例如，包含 6 种不同的不同长度的整数数据类型。 SQLite Affinity 类型SQLite 支持列上的类型 affinity 概念。任何列仍然可以存储任何类型的数据，但列的首选存储类是它的 affinity。在 SQLite3 数据库中，每个表的列分配为以下类型的 affinity 之一： Affinity 描述 TEXT 该列使用存储类 NULL、TEXT 或 BLOB 存储所有数据。 NUMERIC 该列可以包含使用所有五个存储类的值。 INTEGER 与带有 NUMERIC affinity 的列相同，在 CAST 表达式中带有异常。 REAL 与带有 NUMERIC affinity 的列相似，不同的是，它会强制把整数值转换为浮点表示。 NONE 带有 affinity NONE 的列，不会优先使用哪个存储类，也不会尝试把数据从一个存储类强制转换为另一个存储类。 SQLite Affinity 及类型名称下表列出了当创建 SQLite3 表时可使用的各种数据类型名称，同时也显示了相应的应用 Affinity： 数据类型 Affinity INT INTEGERTINYINT SMALLINT MEDIUMINT BIGINT UNSIGNED BIG INT INT2 INT8 INTEGER CHARACTER(20) VARCHAR(255) VARYING CHARACTER(255) NCHAR(55) NATIVE CHARACTER(70) NVARCHAR(100) TEXT CLOB TEXT BLOB no datatype specified NONE REAL DOUBLE DOUBLE PRECISION FLOAT REAL NUMERIC DECIMAL(10,5) BOOLEAN DATE DATETIME NUMERIC Boolean 数据类型SQLite 没有单独的 Boolean 存储类。相反，布尔值被存储为整数 0（false）和 1（true）。 Date 与 Time 数据类型SQLite 没有一个单独的用于存储日期和&#x2F;或时间的存储类，但 SQLite 能够把日期和时间存储为 TEXT、REAL 或 INTEGER 值。 存储类 日期格式 TEXT 格式为 “YYYY-MM-DD HH:MM:SS.SSS” 的日期。 REAL 从公元前 4714 年 11 月 24 日格林尼治时间的正午开始算起的天数。 INTEGER 从 1970-01-01 00:00:00 UTC 算起的秒数。 您可以以任何上述格式来存储日期和时间，并且可以使用内置的日期和时间函数来自由转换不同格式。 SQLite 创建数据库SQLite 的 sqlite3 命令被用来创建新的 SQLite 数据库。您不需要任何特殊的权限即可创建一个数据。 语法 sqlite3 命令的基本语法如下： $sqlite3 DatabaseName.db 通常情况下，数据库名称在 RDBMS 内应该是唯一的。 实例 如果您想创建一个新的数据库 &lt;testDB.db&gt;，SQLITE3 语句如下所示： $sqlite3 testDB.db SQLite version 3.8.10.2 2015-05-20 18:17:19 Enter &quot;.help&quot; for usage hints. sqlite&gt; 上面的命令将在当前目录下创建一个文件 testDB.db。该文件将被 SQLite 引擎用作数据库。如果您已经注意到 sqlite3 命令在成功创建数据库文件之后，将提供一个 sqlite&gt; 提示符。一旦数据库被创建，您就可以使用 SQLite 的 .databases 命令来检查它是否在数据库列表中，如下所示： sqlite&gt;.databases seq name file ---- ---------------- -------------------------------------------- 0 main /Users/wangruofeng/Documents/SQLitePractice/testDB.db 您可以使用 SQLite .quit 命令退出 sqlite 提示符，如下所示： sqlite&gt;.quit $ .dump 命令您可以在命令提示符中使用 SQLite .dump 点命令来导出完整的数据库在一个文本文件中，如下所示： $sqlite3 testDB.db .dump &gt; testDB.sql 上面的命令将转换整个 testDB.db 数据库的内容到 SQLite 的语句中，并将其转储到 ASCII 文本文件 testDB.sql 中。您可以通过简单的方式从生成的 testDB.sql 恢复，如下所示： $sqlite3 testDB.db &lt; testDB.sql 此时的数据库是空的，一旦数据库中有表和数据，您可以尝试上述两个程序。现在，让我们继续学习下一章。 SQLite 附加数据库假设这样一种情况，当在同一时间有多个数据库可用，您想使用其中的任何一个。SQLite 的 ATTACH DTABASE 语句是用来选择一个特定的数据库，使用该命令后，所有的 SQLite 语句将在附加的数据库下执行。相当于给数据库取一个别名 语法 SQLite 的 ATTACH DATABASE 语句的基本语法如下： ATTACH DATABASE &#39;DatabaseName&#39; As &#39;Alias-Name&#39;; 如果数据库尚未被创建，上面的命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库 ‘Alias-Name’ 绑定在一起。 实例如果想附加一个现有的数据库 testDB.db，则 ATTACH DATABASE 语句将如下所示： sqlite&gt; ATTACH DATABASE &#39;testDB.db&#39; as &#39;TEST&#39;; 使用 SQLite .database 命令来显示附加的数据库。 sqlite&gt; .database seq name file --- --------------- ---------------------- 0 main /home/sqlite/testDB.db 2 test /home/sqlite/testDB.db 数据库名称 main 和 temp 被保留用于主数据库和存储临时表及其他临时数据对象的数据库。这两个数据库名称可用于每个数据库连接，且不应该被用于附加，否则将得到一个警告消息，如下所示： sqlite&gt; ATTACH DATABASE &#39;testDB.db&#39; as &#39;TEMP&#39;; Error: database TEMP is already in use sqlite&gt; ATTACH DATABASE &#39;testDB.db&#39; as &#39;main&#39;; Error: database main is already in use SQLite 分离数据库SQLite的 DETACH DTABASE 语句是用来把命名数据库从一个数据库连接分离和游离出来，连接是之前使用 ATTACH 语句附加的。如果同一个数据库文件已经被附加上多个别名，DETACH 命令将只断开给定名称的连接，而其余的仍然有效。您无法分离 main 或 temp 数据库。 如果数据库是在内存中或者是临时数据库，则该数据库将被摧毁，且内容将会丢失。 语法 SQLite 的 DETACH DATABASE ‘Alias-Name’ 语句的基本语法如下： DETACH DATABASE &#39;Alias-Name&#39;; 在这里，’Alias-Name’ 与您之前使用 ATTACH 语句附加数据库时所用到的别名相同。 实例 假设在前面的章节中您已经创建了一个数据库，并给它附加了 ‘test’ 和 ‘currentDB’，使用 .database&#x2F;.databases 命令，我们可以看到： sqlite&gt; .databases seq name file --- --------------- ---------------------- 0 main /home/sqlite/testDB.db 2 test /home/sqlite/testDB.db 3 currentDB /home/sqlite/testDB.db 现在，让我们尝试把 ‘currentDB’ 从 testDB.db 中分离出来，如下所示： sqlite&gt; DETACH DATABASE &#39;currentDB&#39;; 现在，如果检查当前附加的数据库，您会发现，testDB.db 仍与 ‘test’ 和 ‘main’ 保持连接。 sqlite&gt; .databases seq name file --- --------------- ---------------------- 0 main /home/sqlite/testDB.db 2 test /home/sqlite/testDB.db SQLite 创建表SQLite 的 CREATE TABLE 语句用于在任何给定的数据库创建一个新表。创建基本表，涉及到命名表、定义列及每一列的数据类型。 语法 CREATE TABLE 语句的基本语法如下： CREATE TABLE database_name.table_name( column1 datatype PRIMARY KEY(one or more columns), column2 datatype, column3 datatype, ..... columnN datatype, ); CREATE TABLE 是告诉数据库系统创建一个新表的关键字。CREATE TABLE 语句后跟着表的唯一的名称或标识。您也可以选择指定带有 table_name 的 database_name。 实例 下面是一个实例，它创建了一个 COMPANY 表，ID 作为主键，NOT NULL 的约束表示在表中创建纪录时这些字段不能为 NULL： sqlite&gt; CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); 让我们再创建一个表，我们将在随后章节的练习中使用： sqlite&gt; CREATE TABLE DEPARTMENT( ID INT PRIMARY KEY NOT NULL, DEPT CHAR(50) NOT NULL, EMP_ID INT NOT NULL ); 您可以使用 SQLIte 命令中的 .tables&#x2F;.table 命令来验证表是否已成功创建，该命令用于列出附加数据库中的所有表。 sqlite&gt; .tables COMPANY DEPARTMENT TEST.COMPANY TEST.DEPARTMENT 在这里，可以看到 COMPANY 表出现两次，一个是主数据库的 COMPANY 表，一个是为 testDB.db 创建的 ‘test’ 别名的 test.COMPANY 表。您可以使用 SQLite .schema 命令得到表的完整信息，如下所示： sqlite&gt;.schema COMPANY CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); SQLite 删除表SQLite 的 DROP TABLE 语句用来删除表定义及其所有相关数据、索引、触发器、约束和该表的权限规范。 使用此命令时要特别注意，因为一旦一个表被删除，表中所有信息也将永远丢失。 语法 DROP TABLE 语句的基本语法如下。您可以选择指定带有表名的数据库名称，如下所示： DROP TABLE database_name.table_name; 实例 让我们先确认 COMPANY 表已经存在，然后我们将其从数据库中删除。 sqlite&gt; .tables COMPANY test.COMPANY 这意味着 COMPANY 表已存在数据库中，接下来让我们把它从数据库中删除，如下： sqlite&gt; DROP TABLE COMPANY; sqlite&gt; 现在，如果尝试 .TABLES 命令，那么将无法找到 COMPANY 表了： sqlite&gt; .tables sqlite&gt; 显示结果为空，意味着已经成功从数据库删除表。 资料整理于：RUNOOB.COM-SQLite教程转载请注明出处。","categories":[{"name":"Database","slug":"Database","permalink":"https://blog.wangruofeng007.com/categories/Database/"}],"tags":[]},{"title":"SQLite_教程(一)","slug":"2016-01-13-sqlite-jiao-cheng-[?]","date":"2016-01-13T15:18:15.000Z","updated":"2024-11-02T03:36:52.401Z","comments":true,"path":"2016/01/13/2016-01-13-sqlite-jiao-cheng-[?]/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-sqlite-jiao-cheng-[?%5D/","excerpt":"","text":"简介：SQLite 是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite 是在世界上最广泛部署的 SQL 数据库引擎。SQLite 源代码不受版权限制。本教程将告诉您如何使用 SQLite 编程，并让你迅速上手。 什么是 SQLite？SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。就像其他数据库，SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件 为什么要用 SQLite？ 不需要一个单独的服务器进程或操作的系统（无服务器的）。 SQLite 不需要配置，这意味着不需要安装或管理。 一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。 SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于250KiB。 SQLite 是自给自足的，这意味着不需要任何外部的依赖。 SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。 SQLite 支持 SQL92（SQL2）标准的大多数查询语言的功能。 SQLite 使用 ANSI-C 编写的，并提供了简单和易于使用的 API。 SQLite 可在 UNIX（Linux, Mac OS-X, Android, iOS）和 Windows（Win32, WinCE, WinRT）中运行。 SQLite 命令与关系数据库进行交互的标准 SQLite 命令类似于 SQL。命令包括 CREATE、SELECT、INSERT、UPDATE、DELETE 和 DROP。这些命令基于它们的操作性质可分为以下几种： DDL - 数据定义语言 命令 描述 CREATE 创建一个新的表，一个表的视图，或者数据库中的其他对象。 ALTER 修改数据库中的某个已有的数据库对象，比如一个表。 DROP 删除整个表，或者表的视图，或者数据库中的其他对象。 DML - 数据操作语言 命令 描述 INSERT 创建一条记录。 UPDATE 修改记录。 DELETE 删除记录。 DQL - 数据查询语言 命令 描述 SELECT 从一个或多个表中检索某些记录。 在 Mac OS X 上安装 SQLite最新版本的 Mac OS X 会预安装 SQLite，但是如果没有可用的安装，只需按照如下步骤进行：请访问 SQLite 下载页面，从源代码区下载 sqlite-autoconf-*.tar.gz。步骤如下： $tar xvfz sqlite-autoconf-3071502.tar.gz $cd sqlite-autoconf-3071502 $./configure --prefix=/usr/local $make $make install 上述步骤将在 Mac OS X 机器上安装 SQLite，您可以使用下列命令进行验证： $sqlite3 SQLite version 3.7.15.2 2013-01-09 11:53:05 Enter &quot;.help&quot; for instructions Enter SQL statements terminated with a &quot;;&quot; sqlite&gt; 最后，在 SQLite 命令提示符下，使用 SQLite 命令做练习。 SQLite语法大小写敏感性 有个重要的点值得注意，SQLite 是不区分大小写的，但也有一些命令是大小写敏感的，比如 GLOB 和 glob 在 SQLite 的语句中有不同的含义。 注释 SQLite 注释是附加的注释，可以在 SQLite 代码中添加注释以增加其可读性，他们可以出现在任何空白处，包括在表达式内和其他 SQL 语句的中间，但它们不能嵌套。SQL 注释以两个连续的 “-“ 字符（ASCII 0x2d）开始，并扩展至下一个换行符（ASCII 0x0a）或直到输入结束，以先到者为准。您也可以使用 C 风格的注释，以 “&#x2F;*“ 开始，并扩展至下一个 “*&#x2F;“ 字符对或直到输入结束，以先到者为准。SQLite的注释可以跨越多行。 SQLite 语句所有的 SQLite 语句可以以任何关键字开始，如 SELECT、INSERT、UPDATE、DELETE、ALTER、DROP 等，所有的语句以分号（;）结束。 SQLite ANALYZE 语句： ANALYZE; or ANALYZE database_name; or ANALYZE database_name.table_name; SQLite AND&#x2F;OR 子句： SELECT column1, column2....columnN FROM table_name WHERE CONDITION-1 &#123;AND|OR&#125; CONDITION-2; SQLite ALTER TABLE 语句： ALTER TABLE table_name ADD COLUMN column_def...; SQLite ALTER TABLE 语句（Rename）： ALTER TABLE table_name RENAME TO new_table_name; SQLite ATTACH DATABASE 语句： ATTACH DATABASE &#39;DatabaseName&#39; As &#39;Alias-Name&#39;; SQLite BEGIN TRANSACTION 语句： BEGIN; or BEGIN EXCLUSIVE TRANSACTION; SQLite BETWEEN 子句： SELECT column1, column2....columnN FROM table_name WHERE column_name BETWEEN val-1 AND val-2; SQLite COMMIT 语句： COMMIT; SQLite CREATE INDEX 语句： CREATE INDEX index_name ON table_name ( column_name COLLATE NOCASE ); SQLite CREATE UNIQUE INDEX 语句： CREATE UNIQUE INDEX index_name ON table_name ( column1, column2,...columnN); SQLite CREATE TABLE 语句： CREATE TABLE table_name( column1 datatype, column2 datatype, column3 datatype, ..... columnN datatype, PRIMARY KEY( one or more columns ) ); SQLite CREATE TRIGGER 语句： CREATE TRIGGER database_name.trigger_name BEFORE INSERT ON table_name FOR EACH ROW BEGIN stmt1; stmt2; .... END; SQLite CREATE VIEW 语句： CREATE VIEW database_name.view_name AS SELECT statement....; SQLite CREATE VIRTUAL TABLE 语句： CREATE VIRTUAL TABLE database_name.table_name USING weblog( access.log ); or CREATE VIRTUAL TABLE database_name.table_name USING fts3( ); SQLite COMMIT TRANSACTION 语句： COMMIT; SQLite COUNT 子句： SELECT COUNT(column_name) FROM table_name WHERE CONDITION; SQLite DELETE 语句： DELETE FROM table_name WHERE &#123;CONDITION&#125;; SQLite DETACH DATABASE 语句： DETACH DATABASE &#39;Alias-Name&#39;; SQLite DISTINCT 子句： SELECT DISTINCT column1, column2....columnN FROM table_name; SQLite DROP INDEX 语句： DROP INDEX database_name.index_name; SQLite DROP TABLE 语句： DROP TABLE database_name.table_name; SQLite DROP VIEW 语句： DROP INDEX database_name.view_name; SQLite DROP TRIGGER 语句： DROP INDEX database_name.trigger_name; SQLite EXISTS 子句： SELECT column1, column2....columnN FROM table_name WHERE column_name EXISTS (SELECT * FROM table_name ); SQLite EXPLAIN 语句： EXPLAIN INSERT statement...; or EXPLAIN QUERY PLAN SELECT statement...; SQLite GLOB 子句： SELECT column1, column2....columnN FROM table_name WHERE column_name GLOB &#123; PATTERN &#125;; SQLite GROUP BY 子句： SELECT SUM(column_name) FROM table_name WHERE CONDITION GROUP BY column_name; SQLite HAVING 子句： SELECT SUM(column_name) FROM table_name WHERE CONDITION GROUP BY column_name HAVING (arithematic function condition); SQLite INSERT INTO 语句： INSERT INTO table_name( column1, column2....columnN) VALUES ( value1, value2....valueN); SQLite IN 子句： SELECT column1, column2....columnN FROM table_name WHERE column_name IN (val-1, val-2,...val-N); SQLite Like 子句： SELECT column1, column2....columnN FROM table_name WHERE column_name LIKE &#123; PATTERN &#125;; SQLite NOT IN 子句： SELECT column1, column2....columnN FROM table_name WHERE column_name NOT IN (val-1, val-2,...val-N); SQLite ORDER BY 子句： SELECT column1, column2....columnN FROM table_name WHERE CONDITION ORDER BY column_name &#123;ASC|DESC&#125;; SQLite PRAGMA 语句： PRAGMA pragma_name; For example: PRAGMA page_size; PRAGMA cache_size = 1024; PRAGMA table_info(table_name); SQLite RELEASE SAVEPOINT 语句： RELEASE savepoint_name; SQLite REINDEX 语句： REINDEX collation_name; REINDEX database_name.index_name; REINDEX database_name.table_name; SQLite ROLLBACK 语句： ROLLBACK; or ROLLBACK TO SAVEPOINT savepoint_name; SQLite SAVEPOINT 语句： SAVEPOINT savepoint_name; SQLite SELECT 语句： SELECT column1, column2....columnN FROM table_name; SQLite UPDATE 语句： UPDATE table_name SET column1 = value1, column2 = value2....columnN=valueN [ WHERE CONDITION ]; SQLite VACUUM 语句： VACUUM; SQLite WHERE 子句： SELECT column1, column2....columnN FROM table_name WHERE CONDITION; 资料整理于：RUNOOB.COM-SQLite教程转载请注明出处。","categories":[{"name":"Database","slug":"Database","permalink":"https://blog.wangruofeng007.com/categories/Database/"}],"tags":[]},{"title":"CocoaPods使用指南","slug":"2016-01-13-cocoapodsshi-yong-zhi-nan","date":"2016-01-12T21:51:18.000Z","updated":"2024-11-02T03:36:52.394Z","comments":true,"path":"2016/01/13/2016-01-13-cocoapodsshi-yong-zhi-nan/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-cocoapodsshi-yong-zhi-nan/","excerpt":"","text":"简介CocoaPods是iOS最常用的第三方类库管理工具，绝大部分有名的开源类库支持CocoaPods。 CocoaPods是用Ruby实现的，要使用它首先需要有Ruby的环境。 安装幸亏OS X系统默认已经可以运行Ruby了，我们只需执行以下命令： 1sudo gem install cocoapods 由于某些原因，执行时会出现下面的错误提示： 1234ERROR :Could not find a valid gem `cocoapods` (&gt;= 0), here is why: Unable to download data from https://rubygems.org/ - Errno::EPIPI: Broken pipe - SSL_connect(https://rubygems.org/lastest_specs.4.8.gz) 安装成功后，接着执行命令： 1pod setup 如果Ruby环境不够新，可能需要更新以下： 1sudo gem update --system 至此安装就完成了，我们可以尝试搜索一个第三方类库： 1pod search AFNetworking 使用使用CocoaPods第一步，是在当前项目下，新建一个Podfile文件： 1touch Podfile 然后利用vim打开Podfile文件编辑，加入你想要的类库，格式如下： 123456platform :iospod &#x27;Reachability&#x27;, &#x27;3.1.0&#x27;platform :ios, &#x27;6.0&#x27;pod &#x27;JSONKit&#x27;, &#x27;1.4&#x27;pod &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.3.1&#x27; 如果是拷贝别人的项目，或是一个很久没打开过的项目，可能需要先执行一下： 1pod update 最后一步，执行命令： 1pod install 当终端出现类似下面的提示后，就代表成功了： 1[!] From now no use `Sample0814.xcworkspace`. 这个时候会看到项目文件夹多了一个xxx.xcworkspace,以后要通过这个文件打开项目，老项目xxx.xcodeproj不再使用。 上面的每一步都可能出现问题，但大部分问题都是因为局域网的原因，用一个网速稳定的境外VPN可破 如果上面因为权限问题安装失败，必须每次都要删除 1rm -rf /User/loginname/Library/Caches/CocoaPods/ 因为这个缓冲中会存下你的github的东西，造成每次调用上次权限问题的缓存。 关于Podfile文件编辑时，第三方版本号的各种写法: 123456789pod &#x27;AFNetworking&#x27; # 不显式指定依赖库版本，表示每次都获取最新版本pod &#x27;AFNetworking&#x27;, &#x27;2.0&#x27; # 只使用2.0版本pod &#x27;AFNetworking&#x27;, &#x27;&gt;2.0&#x27; # 使用高于2.0的版本pod &#x27;AFNetworking&#x27;, &#x27;&gt;=2.0&#x27; # 使用大于或等于2.0的版本pod &#x27;AFNetworking&#x27;, &#x27;&lt;2.0&#x27; # 使用小于2.0的版本pod &#x27;AFNetworking&#x27;, &#x27;&lt;=2.0&#x27; # 使用小于或等于2.0的版本pod &#x27;AFNetworking&#x27;, &#x27;~&gt;0.1.2&#x27; # 使用大于等于0.1.2但小于0.2的版本，相当于&gt;=0.1.2并且&lt;0.2.0pod &#x27;AFNetworking&#x27;, &#x27;~&gt;0.1&#x27; # 使用大于等于0.1但小于1.0的版本pod &#x27;AFNetworking&#x27;, &#x27;~&gt;0&#x27; # 高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本 参考资料 语义化版本 2.0.0","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://blog.wangruofeng007.com/tags/CocoaPods/"},{"name":"Skill","slug":"Skill","permalink":"https://blog.wangruofeng007.com/tags/Skill/"}]},{"title":"GET&amp;POST","slug":"2016-01-13-get-and-post","date":"2016-01-12T21:48:10.000Z","updated":"2024-11-02T03:36:52.396Z","comments":true,"path":"2016/01/13/2016-01-13-get-and-post/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-get-and-post/","excerpt":"","text":"GET和POST是两种最常用的与服务器进行交互的HTTP方法 . GET GET的语义是获取指定的URL资源, 将数据按照 variable &#x3D; value 的形式, 添加到action所指向的URL后面, 并且两者使用 ‘ ? ‘连接, 各变量之间使用 ‘ &amp; ‘连接 . 对用户来说不安全, 因为在传输过程中, 数据被放在请求的URL中. 传输的数据量小, 这主要是因为受URL长度限制. URL长度限制 在http协议中，其实并没有对url长度作出限制，往往url的最大长度和用户浏览器和Web服务器有关，不一样的浏览器，能接受的最大长度往往是不一样的，当然，不一样的Web服务器能够处理的最大长度的URL的能力也是不一样的。 IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。 Firefox浏览器URL的长度限制为65,536个字符 ; Apache(Server)能够接受的最大URL长度为8192个字符 ; 如果浏览器的编码为UTF8的话，一个汉字最终编码后的字符长度为9个字符。 GET请求示例 POST POST语义是向指定URL的资源添加数据. 将数据放在数据体中, 按照变量和值相对应的方式, 传递到action所指向的URL. 所有数据对用户来说不可见. 可以传输大量数据, 上传文件只能使用POST. POST请求示例 在浏览器中判断GET&amp;POST请求因为POST请求会向服务器发送数据体, 因此刷新页面时会出现提示窗口. 而GET请求不会向服务器发送数据体, 因此没有提示 . 从请求本质来看, GET请求要比POST更安全, 效率也会更高 .(对服务器而言) iOS网络发送网络请求的步骤 实例化URL( 网络资源 ) ; 根据URL建立URLRequest ( 网络请求 ) ; 默认为GET请求; 对于POST请求, 需要创建请求的数据体 . 利用 URLConnection 发送网络请求(发送请求并获得结果) ; NSURLConnection提供了两个静态方法可以直接以同步或异步的方式向服务器发送网络请求. 同步请求: sendSynchronousRequest : returningResponse : error : 异步请求: sendAsynchronousRequest : queue : completionHandler : 在网络请求过程中, 接收数据的过程实际上是通过 NSURLConnectionDataDelegate来实现的, 常用代理方法包括: 12345678// 服务器开始返回数据- (void)connection:didReceiveResponse:// 收到服务器返回的数据，本方法会被调用多次- (void)connection:didReceiveData:// 数据接收完毕，做数据的最后处理- (void)connectionDidFinishLoading:// 网络连接错误- (void)connection:didFailWithError: 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://blog.wangruofeng007.com/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"HTTP POST and multipart forms","slug":"2016-01-13-http-post-and-multipart-forms","date":"2016-01-12T21:45:41.000Z","updated":"2024-11-02T03:36:52.397Z","comments":true,"path":"2016/01/13/2016-01-13-http-post-and-multipart-forms/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-http-post-and-multipart-forms/","excerpt":"","text":"HTTP POST使用注意事项： http Body 中的NSData 编码方式要用NSASCIIStringEncoding而不是NSUTF8StringEncoding 通过 NSString *postLength = [NSString stringWithFormat:@&quot;%d&quot;,[postData length]]; 计算数据的长度 POST参数设置123456//设置header Content-Length[request setValue:postLength forHTTPHeaderField:@&quot;Content-Length&quot;];//设置header contentType[request setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Current-Type&quot;];//设置body[request setHTTPBody:postData]; 备注:普通post的header的Current-Type为application/x-www-form-urlencoded Multipart Forms POST参数设置123456//设置header contentTypeNSString *contentType = [NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;, boundary];[request addValue:contentType forHTTPHeaderField:@&quot;Content-Type&quot;];//设置body contentType[body appendData:[@&quot;Content-Type: application/octet-stream\\r\\n\\r\\n&quot; dataUsingEncoding:NSUTF8StringEncoding]]; 备注:Multipart Forms的header的Current-Type为multipart/form-data request body like this --YOUR_BOUNDARY_STRING Content-Disposition: form-data; name=&quot;photo&quot;; filename=&quot;calm.jpg&quot; Content-Type: image/jpeg YOUR_IMAGE_DATA_GOES_HERE --YOUR_BOUNDARY_STRING Content-Disposition: form-data; name=&quot;message&quot; My first message --YOUR_BOUNDARY_STRING Content-Disposition: form-data; name=&quot;user&quot; 1 --YOUR_BOUNDARY_STRING I’m sending over three variables: an image named photo, a string named message, and an integer named user. It’s important to note the linebreaks and the dashes before the boundary string. These must be included in order to build a good request. Now lets write some objective-c: 12345678910111213141516171819202122NSString *boundary = @&quot;YOUR_BOUNDARY_STRING&quot;;NSString *contentType = [NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;, boundary];[request addValue:contentType forHTTPHeaderField:@&quot;Content-Type&quot;];NSMutableData *body = [NSMutableData data];[body appendData:[[NSString stringWithFormat:@&quot;\\r\\n--%@\\r\\n&quot;, boundary] dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:[[NSString stringWithFormat:@&quot;Content-Disposition: form-data; name=\\&quot;photo\\&quot;; filename=\\&quot;%@.jpg\\&quot;\\r\\n&quot;, self.message.photoKey] dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:[@&quot;Content-Type: application/octet-stream\\r\\n\\r\\n&quot; dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:[NSData dataWithData:imageData]];[body appendData:[[NSString stringWithFormat:@&quot;\\r\\n--%@\\r\\n&quot;, boundary] dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:[[NSString stringWithFormat:@&quot;Content-Disposition: form-data; name=\\&quot;message\\&quot;\\r\\n\\r\\n%@&quot;, self.message.message] dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:[[NSString stringWithFormat:@&quot;\\r\\n--%@\\r\\n&quot;, boundary] dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:[[NSString stringWithFormat:@&quot;Content-Disposition: form-data; name=\\&quot;user\\&quot;\\r\\n\\r\\n%d&quot;, 1] dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:[[NSString stringWithFormat:@&quot;\\r\\n--%@\\r\\n&quot;, boundary] dataUsingEncoding:NSUTF8StringEncoding]];[request setHTTPBody:body]; Now all we need to do is make a connection to the server and send the request: [request setHTTPBody:body]; 1234NSURLResponse *response;NSError *error;[NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error]; 参考资料： Sending Multipart Forms with Objective-C POST multipart&#x2F;form-data with Objective-C Sending an HTTP POST request on iOS The Multipart Content-Type–w3规范 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://blog.wangruofeng007.com/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"工厂模式详解","slug":"2016-01-13-gong-han-mo-shi-xiang-jie","date":"2016-01-12T21:39:21.000Z","updated":"2024-11-02T03:36:52.396Z","comments":true,"path":"2016/01/13/2016-01-13-gong-han-mo-shi-xiang-jie/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-gong-han-mo-shi-xiang-jie/","excerpt":"","text":"3种工厂模式概述：工厂模式是个系列，分为简单工厂模式， 工厂方法模式， 抽象工厂模式，这三种模式也非常常用。这些模式最最经典的就例子就是设计计算器。 Factory Method (工厂方法模式) Abstract Factory (抽象工厂模式） Simple Factory（简单工厂模式） 参考GoF《Design Patterns》一书 GOF是这样描述工厂模式的： “Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.” 在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。 简单工厂模式 严格的说，简单工厂模式并不是23种常用的设计模式之一，它只算工厂模式的一个特殊实现。简单工厂模式在实际中的应用相对于其他2个工厂模式用的还是相对少得多，因为它只适应很多简单的情况，最最重要的是它违背了我们在概述中说的开放-封闭原则。因为每次你要新添加一个功能，都需要在生switch-case 语句（或者if-else 语句）中去修改代码，添加分支条件 简单工厂模式角色分配： Creator（产品创建者）简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。 Product （ 产品抽象类）简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 Concrete Product （具体产品）是简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。 简单的工厂模式UML图 考虑下面一个事例： 加入你是一个商人，你做的的是手机生意。现在你生产android 手机和iphone等，考虑到以后你可能还会生产其他手机例如ubuntu手机。假定你选择了简单工厂模式来实现。那么显然，我们需要所有产品的抽象基类（Product） 即是Phone类： 123456class Phone &#123; public: virtual ~Phone()&#123;&#125;;//在删除的时候防止内存泄露 virtual void call(string number) = 0; &#125;; 然后我们需要具体的产品类 Concrete Product： AndroidPhone 和iOSPhone 1234567891011class AndroidPhone : public Phone &#123; public: void call(string number)&#123; cout&lt;&lt;&quot;AndroidPhone is calling...&quot;&lt;&lt;endl;&#125; &#125;; class IosPhone : public Phone &#123; public: void call(string number) &#123; cout&lt;&lt;&quot;IosPhone is calling...&quot;&lt;&lt;endl;&#125; &#125;; 最后我们需要Creator 12345678910111213141516class PhoneFactory &#123; public: Phone* createPhone(string phoneName) &#123; if(phoneName == &quot;AndroidPhone&quot;) &#123; return new AndroidPhone(); &#125;else if(phoneName == &quot;IosPhone&quot;) &#123; return new IosPhone(); &#125; return NULL; &#125; &#125;; 客户端这样实现： 12345678910111213141516171819void main() &#123; PhoneFactor factory; Phone* myAndroid = factory.createPhone(&quot;AndroidPhone&quot;); Phone* myIPhone = factory.createPhone(&quot;iOSPhone&quot;); if(myAndroid) &#123; myAndroid-&gt;call(&quot;123&quot;); delete myAndroid; myAndroid = NULL; &#125; if(myIPhone) &#123; myIPhone-&gt;call(&quot;123&quot;); delete myIPhone; myIPhone = NULL; &#125; &#125; 这就是简单工厂方法，把所有的创建交给creator,creator 通过switch-case(或者if-else)语句来选择具体创建的对象。简单明了。但是就如上面所说，它最致命的问题的违背了开放-封闭原则。每次你要新添加一个功能，都要修改factor里面的createPhone代码。 但是工厂方法模式可以解决这个问题。 工厂方法模式个人觉得工厂方法模式在工厂模式家族中是用的最多模式。上面说过了，如果简单工厂模式，要添加一个新功能，比如我现在要增加WinPhone 的生产，那么我要修改PhoneFactory中的createPhone 中的分支判断条件。这违背了开放-封闭原则，那为什么不能将创建方法放到子类中呢？工厂方法的定义就是：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。 工厂方法模式角色： 抽象工厂(Creator)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 具体工厂(Concrete Creator)角色：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。 抽象产品(Product)角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。 具体产品(Concrete Product)角色：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应 工厂方法模式UML图： 看定义看的晕乎乎的？那么我们来看代码：产品接口，以及其相应的子类。 123456789101112131415161718class Phone &#123; public: virtual ~Phone()&#123;&#125;;//在删除的时候防止内存泄露 virtual void call(string number) = 0; &#125;; class AndroidPhone : public Phone &#123; public: void call(string number)&#123; cout&lt;&lt;&quot;AndroidPhone is calling...&quot;&lt;&lt;endl;&#125; &#125;; class iOSPhone : public Phone &#123; public: void call(string number) &#123; cout&lt;&lt;&quot;iOSPhone is calling...&quot;&lt;&lt;endl;&#125; &#125;; 上面这个和简单工厂方法还是一样的。接下来不一样的来了… 123456789101112131415161718192021222324class PhoneFactory &#123; public: virtual ~PhoneFactory()&#123;&#125;; virtual Phone* createPhone() = 0; &#125;; class AndroidPhoneFactory : public PhoneFactory &#123; public: virtual Phone* createPhone() &#123; return new AndroidPhone(); &#125; &#125;; class IosPhoneFactory : public PhoneFactory &#123; public: virtual Phone* createPhone() &#123; return new IosPhone(); &#125; &#125;; 工厂方法将PhoneFactory抽象成了基类，PhoneFactory的createPhone不在像以前那样将所有的判断塞到里面。而是改由其子类来实现创建功能，这感觉就是权力下放。客户端： 1234567891011121314151617181920212223void main() &#123; PhoneFactory* androidCreator = new AndroidPhoneFactory(); PhoneFactory* iosCreator = new IosPhoneFactory(); Phone* myAndroid = androidCreator-&gt;createPhone(); Phone* myIPhone = iosCreator-&gt;createPhone(); if(myAndroid) &#123; myAndroid-&gt;call(&quot;123&quot;); delete myAndroid; myAndroid = NULL; &#125; if(myIPhone) &#123; myIPhone-&gt;call(&quot;123&quot;); delete myIPhone; myIPhone = NULL; &#125; delete androidCreator; delete iosCreator; &#125; 在工厂方法模式中，核心工厂类不在负责产品的创建，而是将具体的创建工作交给子类去完成。也就是后所这个核心工厂仅仅只是提供创建的接口，具体实现方法交给继承它的子类去完成。当我们的系统需要增加其他新功能时，只需要继承PhoneFactory这个类，并且实现createPhone接口。 不需要对原工厂PhoneFactory进行任何修改，这样很好地符合了“开放-封闭“原则。 虽然工厂方法模式满足了”开放-封闭”原则，但是这个模式也仍然有缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 抽象工厂模式在工厂方法模式中，其实我们有一个潜在意识的意识。那就是我们生产的都是同一类产品，例如我们生产的都是手机！那么现在假如现在我们又要生产平板了了呢？那么就要用到抽象工厂模式。我抽象工厂模式也用的比较多在工厂模式家族中，仅次于工厂方法模式。在了解抽象工厂模式之前，还是老生常谈的理清下产品等级结构和产品簇的概念。下面的图还是老图。但是我讲讲我的理解： 产品等级结构：产品的等级结构也就是产品的继承结构。我理解就是同一类产品，比如手机是一个系列，有android手机，ios手机，win手机，那么这个抽象类手机和他的子类就构成了一个产品等级结构。那其他的平板显然不是和手机一个系列的，一个平板，一个是手机，所以他们是不同的产品等级结构。 产品族: 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。比如分为android产品，和ios产品。其中一个ios产品包含ios手机和ios平板。显然ios手机和ios平板不是同一个产品等级结构的，因为一个是手机，一个是平板。但他们是同一个产品簇—都是ios产品。希望大家通过上面的例子大家明白了这两个概念。 抽象工厂模式的UML图： 接着上面的话题，现在假如我要增加对平板的支持，那么我们肯定先添加两个产品等级结构，一个是手机，一个是平板： 123456789101112131415161718192021222324252627282930313233343536373839//产品等级结构--手机 class Phone &#123; public: virtual ~Phone()&#123;&#125;;//在删除的时候防止内存泄露 virtual void call(string number) = 0; &#125;; class AndroidPhone : public Phone &#123; public: void call(string number)&#123; cout&lt;&lt;&quot;AndroidPhone is calling...&quot;&lt;&lt;endl; &#125; &#125;; class IosPhone : public Phone &#123; public: void call(string number) &#123; cout&lt;&lt;&quot;IosPhone is calling...&quot;&lt;&lt;endl; &#125; &#125;; //产品等级结构--平板 class Pad &#123; public: virtual ~Pad()&#123;&#125;; virtual void playMovie() = 0; &#125;; class AndroidPad : public Pad &#123; public: virtual void playMovie()&#123; cout&lt;&lt;&quot;AndriodPad is playing movie...&quot;&lt;&lt;endl; &#125; &#125;; class IosPad : public Pad &#123; public: virtual void playMovie()&#123; cout&lt;&lt;&quot;IosPad is playing movie...&quot;&lt;&lt;endl; &#125; &#125;; 然后具体的工厂我们整个工厂是生产移动设备的所以我们取名为MobileFactory,然后工厂可以生产平板和手机，故有了createPhone 和createPad两个接口。 1234567class MobileFactory &#123; public: virtual ~MobileFactory()&#123;&#125;; virtual Phone* createPhone() = 0; virtual Pad* createPad() = 0; &#125;; 接着是 android 产品簇 的工厂类，负责生产android 的手机和平板： 123456789101112class AndroidFactory : public MobileFactory &#123; public: Phone* createPhone() &#123; return new AndroidPhone(); &#125; Pad* createPad() &#123; return new AndroidPad(); &#125; &#125;; 接着是ios的产品簇的工厂类，负责生产ios的手机和平板： 12345678910111213class IosFactory : public MobileFactory &#123; public: Phone* createPhone() &#123; return new IosPhone(); &#125; Pad* createPad() &#123; return new IosPad(); &#125; &#125;; 最后客户端这样实现： 12345678910111213141516void main() &#123; MobileFactory* androidCreator = new AndroidFactory(); MobileFactory* iosCreator = new IosFactory(); Phone* myAndroidPhone = androidCreator-&gt;createPhone(); Pad* myAndroidPad = androidCreator-&gt;createPad(); Phone* myIosPhone = iosCreator-&gt;createPhone(); Pad* myIosPad = iosCreator-&gt;createPad(); myAndroidPhone-&gt;call(&quot;123&quot;); myAndroidPad-&gt;playMovie(); myIosPhone-&gt;call(&quot;123&quot;); myIosPad-&gt;playMovie(); //这里没有做释放和判断，请自己判断和释放 &#125; 总结：抽象工厂模式适用于那些有多种产品的产品簇，并且每次使用其中的某一产品簇的产品。缺点 ： 抽象工厂模式的添加新功能也非常麻烦，比工厂方法模式都还要复杂的多。优点： 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象 主要用途工厂方法要解决的问题是对象的创建时机，它提供了一种扩展的策略，很好地符合了开放封闭原则。工厂方法也叫做虚构造器（Virtual Constructor）。 什么时候使用工厂方法当是如下情况是，可以使用工厂方法：一个类不知道它所必须创建的对象的类时，一个类希望有它的子类决定所创建的对象时。 更多关于工厂方法的介绍，可以参考本文最后给出的参考内容。下面我们就来看看在iOS中工厂方法的一种实现方法。 iOS中工厂方法的实现实例如下有一个类图，该图描述了下面即将实现的工厂方法（利用工厂方法，创建出不同的形状）。其中BVShapeFactory为工厂方法的基类，BVShape为形状的基类，BVClient通过BVShapeFactory，利用 BVShapeFactory的子类（BVCircleShapeFactory和BVSquareShapeFactory）分别创建出BVCircleShape和BVSquareShape。 github下载地址:https://github.com/BeyondVincent/ios_patterns/tree/master/FactoryMethodPattern 参考资料 iOS设计模式——工厂方法（简单工厂模式，工厂方法模式， 抽象工厂模式） iOS设计模式(03):工厂方法 Objective-C类族和工厂模式 Objective C Design Patterns - Factory Class Factory Methods–Apple iOS Design Patterns–raywenderlich Abstract Factory Design Pattern Objective C The factory design pattern explained by example-php Design Patterns Series, Day 3: Factory and Singleton Patterns–safaribooksonline Automagic Factories in Objective-C–bobmccune 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.wangruofeng007.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"多线程之NSThread","slug":"2016-01-13-duo-xian-cheng-zhi-nsthread","date":"2016-01-12T21:36:48.000Z","updated":"2024-11-02T03:36:52.395Z","comments":true,"path":"2016/01/13/2016-01-13-duo-xian-cheng-zhi-nsthread/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-duo-xian-cheng-zhi-nsthread/","excerpt":"","text":"本文目录 前言 1.获取当前线程 2.获取主线程 3.NSThread的创建 4.暂停当前线程 5.线程的其他操作 6.优缺点 前言每个iOS应用程序都有个专门用来更新显示UI界面、处理用户触摸事件的主线程，因此不能将其他太耗时的操作放在主线程中执行，不然会造成主线程堵塞(出现卡机现象)，带来极坏的用户体验。一般的解决方案就是将那些耗时的操作放到另外一个线程中去执行，多线程编程是防止主线程堵塞，增加运行效率的最佳方法。 iOS中有3种常见的多线程编程方法 NSThread这种方法需要管理线程的生命周期、同步、加锁问题，会导致一定的性能开销 NSOperation和NSOperationQueue是基于OC实现的。NSOperation以面向对象的方式封装了需要执行的操作，然后可以将这个操作放到一个NSOperationQueue中去异步执行。不必关心线程管理、同步等问题。 Grand Centeral Dispatch简称GCD，iOS4才开始支持，是纯C语言的API。自iPad2开始，苹果设备开始有了双核CPU，为了充分利用这2个核，GCD提供了一些新特性来支持多核并行编程 这篇文章简单介绍NSThread这个类，一个NSThread实例就代表着一条线程 1.获取当前线程1NSThread *current = [NSThread currentThread]; 2.获取主线程12NSThread *main = [NSThread mainThread];NSLog(@&quot;主线程:%@&quot;, main); 打印结果是： 2013-04-18 21:36:38.599 thread[7499:c07] 主线程:&lt;NSThread: 0x71434e0&gt;&#123;name = (null), num = 1&#125; num相当于线程的id，主线程的num是为1的 3.NSThread的创建a.动态方法- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument; 在第2行创建了一条新线程，然后在第4行调用start方法启动线程，线程启动后会调用self的run:方法，并且将@”mj”作为方法参数 1234// 初始化线程NSThread *thread = [[[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@&quot;mj&quot;] autorelease];// 开启线程[thread start]; 假如run:方法是这样的： 1234- (void)run:(NSString *)string &#123; NSThread *current = [NSThread currentThread]; NSLog(@&quot;执行了run:方法-参数：%@，当前线程：%@&quot;, string, current);&#125; 打印结果为： 2013-04-18 21:40:33.102 thread[7542:3e13] 执行了run:方法-参数：mj，当前线程：&lt;NSThread: 0x889e8d0&gt;&#123;name = (null), num = 3&#125; 可以发现，这条线程的num值为3，说明不是主线程，主线程的num为1 b.静态方法1+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument; 1[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;mj&quot;]; c.隐式创建线程1[self performSelectorInBackground:@selector(run:) withObject:@&quot;mj&quot;]; 会隐式地创建一条新线程，并且在这条线程上调用self的run:方法，以@”mj”为方法参数 4.暂停当前线程1[NSThread sleepForTimeInterval:2]; 12NSDate *date = [NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]]; [NSThread sleepUntilDate:date]; 上面两种做法都是暂停当前线程2秒 5.线程的其他操作a.在指定线程上执行操作1[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES]; 上面代码的意思是在thread这条线程上调用self的run方法 最后的YES代表：上面的代码会阻塞，等run方法在thread线程执行完毕后，上面的代码才会通过 b.在主线程上执行操作1[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES]; 在主线程调用self的run方法 c.在当前线程执行操作1[self performSelector:@selector(run) withObject:nil]; 在当前线程调用self的run方法 6.优缺点 优点：NSThread比其他多线程方案较轻量级，更直观地控制线程对象 缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://blog.wangruofeng007.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.wangruofeng007.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"NSOperation and NSOperationQueue Tutorial in Swift","slug":"2016-01-13-nsoperation-and-nsoperationqueue-tutorial-in-swift","date":"2016-01-12T21:18:36.000Z","updated":"2024-11-02T03:36:52.399Z","comments":true,"path":"2016/01/13/2016-01-13-nsoperation-and-nsoperationqueue-tutorial-in-swift/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-nsoperation-and-nsoperationqueue-tutorial-in-swift/","excerpt":"","text":"译自 Written by Richard Turton — on October 7, 2014 原文链接：http://www.raywenderlich.com/76341/use-nsoperation-nsoperationqueue-swift 译者@oneruofeng Post info: Updated for Xcode 7.1 and Swift 2.1 – 1 January 2016 Update note: This tutorial was updated to iOS 8, Xcode 6.1 and Swift by Richard Turton. Original post by Tutorial Team member Soheil Azarpour. 每个人都有点击一个按钮或者进入一些文本在iOS或者Mac App上的令人沮丧的经历，就是突然-WHAM，用户交互停止了响应。 在Mac上，你的用户开始盯着一个沙漏或者一个七彩的轮子开始旋转直到它们再次恢复UI交互为止。在一个iOS app中，用户期望App立即响应它们的触摸事件，无响应的app给人的感觉是笨重和缓慢，这样通常会导致收到差评。 保持你的app的可交互的状态说起来容易做起来难，一旦你的app需要执行不仅仅是少量的任务，事情很快就变得很复杂，我们并没有多少事件在主事件循环执行繁重的工作并且同时提供一个可以响应的UI。 低级的开发者是怎样做的呢？解决方案就是把工作从主线程中移除通过并发。并发意味着你应用所有的操作同时执行在多个流（或者线程）中–这样的话用户界面就能保持响应的要执行的工作。 一种实现并发操作在iOS是通过NSOperation和NSOperationQueue这两个类。在这个教程中，你将学会怎样使用它们！你将从一个没有使用并发的App开始，所以它将出现的非常迟钝和无响应。然后你将重做你的应用给它们添加并发操作并且–希望–呈现一个更加响应良好的可交互界面给用户！ 我们开始吧这份样品工程的总的目标的就是展示一个滤镜处理过的图片的表视图。图片将从网络上下载，经过一个滤镜处理后，然后在表视图中显示。 下面是这个app模型的示意图 第一个版本尝试下载你将在这个教程中使用的第一个版本的项目 注意：所以的图片来自 stock.xchng.。一下图片在数据源故意错误命名，以便这里有些例子是图片下载失败好处理失败的情况。 构建并且运行这个工程，最终你将看到这个app运行起来显示一列照片。尝试滚动这个列表，很痛苦，不是吗？ 传统的相册，运行缓慢 所有的操作都发生在ListViewController.swift里，并且最主要的是发生在 tableView(_:cellForRowAtIndexPath:)方法里。看一下那个方法和注释这里有两件相当集中的事情需要思考： 从网络载入图片数据。即使网络状况良好，app将仍然必须等待直到下载完成了才能继续。 使用Core Image给图片加滤镜。这个方法给图片应用一个深褐色的滤镜，假如你想了解更多关于Core Image滤镜的知识，请点击Beginning Core Image in Swift 还有，你将载入一系列图片请求从网络当它第一次被请求时: 1lazy var photos = NSDictionary(contentsOfURL:dataSourceURL) 所有的工作发生在应用的主线程。由于主线程也负责用户交互，让它一直忙于从网络下载东西和给图片加滤镜消磨掉了响应中的app。你可以通过使用Xcode的仪表测量视图获得这样一个快速的概述。你可以通过显示调试导航(Commnad+6)接入这个仪表视图,让后选择CPU当app正在运行的时候。 Xcode的仪表视图表明，主线程的任务非常重 你会看到那些所有的长钉在Thread 1，那就是app的主线程。更多详细的信息你可以运行app的Instruments,但是那个在 whole other tutorial :].中 是时候考虑怎样改善一下你的用户体验了！ 任务，线程和进程在你专研这篇教程之前，这里有一下技术上的慨念需要理一下，我将定义一些专用术语： 任务 ：一个简单单个的需要完成的工作 线程 ：操作系统提供的机制允许多个用户操作同时进行在一个应用中 进程 ：一个可执行的代码块，它可以由多个线程构成 注意：在iOS和OS X中，线程的功能由POSIX线程API（或者 pthreads）实现，并且它使操作系统的一部分。而这个又是相当底层的东西，你将发现它很容易犯错误；或许关于线程最糟糕的事情是那些很难被发现的错误！ Foundation框架包含了一个叫做NSThread的类，这让我们处理事情更容易，但是用NSThread管理多个线程仍是一件令人头疼的事情。NSOperation和NSOperationQueue是为了最大化简化处理多线程的更高级的类。 在这个图解中，你会看到进程，线程和任务之间的关系： 进程，线程和任务 正如你所见，一个进程可以包涵多个执行的线程，每个线程能够同时执行多个任务。 在这个图集中, thread 2执行文件的读的工作，同时thread 1执行UI相关的代码。这和你应该怎样在iOS中构建你的代码（主线程执行任何和UI相关的工作，第二线程应当执行慢的或者长时间运行的耗时操作例如读取文件，接入网络等等）有点相似。 NSOperation vs. Grand Central Dispatch (GCD)你应该听说过Grand Central Dispatch (GCD).。简单的来说，GCD由语言的特征，运行时库和系统增强组成来提供一个在iOS和OS X多核硬件中支持并发系统并且综合的改良。假如你想了解更多关于GCD相关的知识，有可以阅读我们的Multithreading and Grand Central Dispatch on iOS for Beginners Tutorial。 NSOperation和NSOperationQueue构建在GCD之上。普遍来说，苹果推荐使用最高级别抽象，当需要显示他们一些需要的测量工作时回到最底层。 下面是关于这两者的一些简单比较，将帮助你决定何时何地选择使用GCD或者NSOperation： GCD 是一个轻量级的方式来描述将要被并发执行的工作单元。你不必定制这个工作单元的时刻表；系统为你定制时刻表。在blocks中增加依赖是一件头疼的事情。取消或者暂停一个block来进行额外的工作为作为开发者的你！ :] NSOperation 和GCD相比增加了一些额外开支，但是你能够在各种操作之间增加依赖并且恢复，取消，暂停他们。 这个教程将使用NSOperation,因为你将处理一个列表为了好的表现并且由于它大量的消耗的资源你需要能够取消一个操作针对某个图片，假如用户已经将那张图片滚出屏幕。即使这些操作在后台线程，假如这里有一打事情在队列里等着它们去处理，这将表现得跟糟糕。 重构 App Model是时候重构开始的非多线程的模型了！假如你仔细观察先前的模型，你会发现这里有三个可以被改进的线程受困区域。通过切割这三个区域让后把他们放在单独的线程里，主线程的压力将得到缓解并且能够保持和用户交互。 改进后的 model 为了摆脱你应用的瓶颈，你需要一个指定一个线程来响应你的用户时间，一个线程专注于下载资源和图片，一个线程执行图片滤镜操作。在新的模型中，app从主线程启动让后载入一个空的表视图。同时，app启动第二个线程开始下载数据资源。 一旦数据资源下载完成，你将通知表视图重新载入。这些事情必须在主线程完成，因为它涉及到用户界面相关的操作。从这一点来说，表视图知道有多少行，并且它知道他将显示图片的URL地址，但是她不知道它是否真的有图片！假如你立即开始下载所有的图片在这个点上，这可能导致效率极其低下，因为你不需要一次性把所有图片下载完！ 为了让这个变得更好我们能够做什么？ 一个更好的模型就是可交互的行在屏幕范围内可见时才开始下载图片。所以你的代码开始将询问表视图有多少行可见。因此，代码应该直到这里有一个未加滤镜的图片等待处理时才开始处理图片加滤镜操作。 为了使app更加快速响应，代码将要让图片一旦下载完毕立即显示。让后才开始进行图片加滤镜操作，让后更新UI界面来显示已经经过滤镜处理后的图片。下面的图标显示了这个过程的控制流： Cotroll Flow 为了获得这些对象，你需要跟踪这张图片现在是否正在被下载，一旦完成下载，假如图片的滤镜被应用上。你需要跟跟踪每个操作的状态，它是否正在下载中或者执行滤镜操作，以便你能够取消，暂停或者恢复每个操作当用户滚动的时候。 Okey！ 现在你准备好开始码代码了！ :] 打开你下载的工程，添加一个新的Swift File到你的工程中命名为** PhotoOperations.swift**。添加下面代码： 1234567891011121314151617class PendingOperations &#123; lazy var downloadsInProgress = [NSIndexPath:NSOperation]() lazy var downloadQueue:NSOperationQueue = &#123; var queue = NSOperationQueue() queue.name = &quot;Download queue&quot; queue.maxConcurrentOperationCount = 1 return queue &#125;() lazy var filtrationsInProgress = [NSIndexPath:NSOperation]() lazy var filtrationQueue:NSOperationQueue = &#123; var queue = NSOperationQueue() queue.name = &quot;Image Filtration queue&quot; queue.maxConcurrentOperationCount = 1 return queue &#125;()&#125; 这回类包含了2个字典为了跟踪激活和正在进行中的下载和滤镜操作对表中的每一行，并且两个操作队列都有各自的操作类型。 所有的值被懒加载的方式创建，意味着他们不会被初始化知道他们第一次被接入。这样改善了你app的表现性能。 创建一个NSOperationQueue是非常简单的，正如你所见，给你的队列命名是非常有用的，因为名字会在仪器或者调速器中显示。maxConcurrentOperationCount在这里由于这个教程的缘故被设置成1，是为了让你看到操作一个接一个完成。你可以离开这一部分允许队列决定他一次处理多少个操作–这样会进一步改善性能。 队列是怎样决定一次运行多少个操作的呢？这是一个非常好的问题！ :] 这取决于硬件。默认，NSOperationQueue将要处理一写计算在屏幕背后，决定什么是最好的需要看代码是运行在某个具体的平台，和将载入的最大数量的线程数。 考虑到下面的例子，假设系统此时是空闲的，这里有很多资源可用，所以这个队列能够载入可能8条并发的线程。下一个时刻你运行程序，系统可能忙于其他不相关的正在抢夺资源的操作，这时队列就仅仅载入2个并发的线程。因为你已经设置了一个最大并发操作数，在这个app中一次只会进行一个操作。 注意：你可能想知道为什么你必须跟踪所有的激活的和正在进行中操作。队列有一个operations的方法，它将返回一个操作的数组，所有为什么不用它呢？在这个工程中这样做效果不是很好。你需要跟踪更表视图行数关联的操作，它可能会重复执行数组每次你需要一个的时候。把它们储存在一个字典中用index path来作为他的key方便快速和高效的查找。 是时候考虑下载和过滤操作了。添加下列代码到 PhotoOperations.swift:文件的末尾： 1234567891011121314151617181920212223242526272829303132333435class ImageDownloader: NSOperation &#123; //1 let photoRecord: PhotoRecord //2 init(photoRecord: PhotoRecord) &#123; self.photoRecord = photoRecord &#125; //3 override func main() &#123; //4 if self.cancelled &#123; return &#125; //5 let imageData = NSData(contentsOfURL:self.photoRecord.url) //6 if self.cancelled &#123; return &#125; //7 if imageData?.length &gt; 0 &#123; self.photoRecord.image = UIImage(data:imageData!) self.photoRecord.state = .Downloaded &#125; else &#123; self.photoRecord.state = .Failed self.photoRecord.image = UIImage(named: &quot;Failed&quot;) &#125; &#125;&#125; NSOperation是一个抽象类，为它的子类而设计。每个子类代表了一个特别的任务正如呈现在列表早期那样。 下面是上面代码每行注释到底发生了什么的说明： 添加一个常量引用到和操作相关的PhotoRecord对象 创建一个设计初始化方法允许photo record参数可以被传进来 main是你在NSOperation子类中需要重写的方法，用来执行相关工作 在启动开始前检查是否被取消，操作应该定期检查是否已经被取消在尝试长时间或密集的工作之前 下载图片数据 再次检查是否被取消 假如这里有数据，创建一个图片对象然后把它添加到记录中，同时改变它的状态，假如这里没有数据，把这条记录标记成失败然后设置适当的图片 下一步，你将创建另一个操作来处理图片加滤镜的操作！添加下面的代码到PhotoOperations.swift文件末尾： 12345678910111213141516171819202122class ImageFiltration: NSOperation &#123; let photoRecord: PhotoRecord init(photoRecord: PhotoRecord) &#123; self.photoRecord = photoRecord &#125; override func main () &#123; if self.cancelled &#123; return &#125; if self.photoRecord.state != .Downloaded &#123; return &#125; if let filteredImage = self.applySepiaFilter(self.photoRecord.image!) &#123; self.photoRecord.image = filteredImage self.photoRecord.state = .Filtered &#125; &#125;&#125; 除了你对图片应用滤镜（使用一个未实现的方法，因此编译1错误）而不是下载它之外，这个看起来和下载操作非常相像。 添加遗失的图片滤镜处理方法到ImageFiltration类中: 1234567891011121314151617181920(image:UIImage) -&gt; UIImage? &#123; let inputImage = CIImage(data:UIImagePNGRepresentation(image)) if self.cancelled &#123; return nil &#125; let context = CIContext(options:nil) let filter = CIFilter(name:&quot;CISepiaTone&quot;) filter.setValue(inputImage, forKey: kCIInputImageKey) filter.setValue(0.8, forKey: &quot;inputIntensity&quot;) let outputImage = filter.outputImage if self.cancelled &#123; return nil &#125; let outImage = context.createCGImage(outputImage, fromRect: outputImage.extent()) let returnImage = UIImage(CGImage: outImage) return returnImage&#125; 图片添加滤镜操作使用先前ListViewController中相同的实现。已经把它移动到这里来了以至于它它能在后台的一个单独的操作中完成。再次强调，你应该非常频繁的检查取消操作；最佳实践是在进行任何耗时操作调用之前和之后。一旦加滤镜操作完成，你应该立即设置photo record 实例的值。 很棒！现在你已经有了所有的工具和基础为了处理后台任务进程的操作。是时候回到控制器修改它以便能利用所有这些新的福利。 切换到ListViewController.swift文件，然后删除lazy var photos接口声明。添加下面声明： 12var photos = [PhotoRecord]()let pendingOperations = PendingOperations() 这些将持有一个数组的你在开始创建的PhotoDetails对象，PendingOperations对象来管理操作。 添加一个下载photos property列表新的方法到类中： 123456789101112131415161718192021222324252627func fetchPhotoDetails() &#123; let request = NSURLRequest(URL:dataSourceURL!) UIApplication.sharedApplication().networkActivityIndicatorVisible = true NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue()) &#123;response,data,error in if data != nil &#123; let datasourceDictionary = NSPropertyListSerialization.propertyListWithData(data, options: Int(NSPropertyListMutabilityOptions.Immutable.rawValue), format: nil, error: nil) as! NSDictionary for(key : AnyObject,value : AnyObject) in datasourceDictionary &#123; let name = key as? String let url = NSURL(string:value as? String ?? &quot;&quot;) if name != nil &amp;&amp; url != nil &#123; let photoRecord = PhotoRecord(name:name!, url:url!) self.photos.append(photoRecord) &#125; &#125; self.tableView.reloadData() &#125; if error != nil &#123; let alert = UIAlertView(title:&quot;Oops!&quot;,message:error.localizedDescription, delegate:nil, cancelButtonTitle:&quot;OK&quot;) alert.show() &#125; UIApplication.sharedApplication().networkActivityIndicatorVisible = false &#125;&#125; 这个方法创建一个异步的网络请求，当完成的时候，将执行completion block在主线程。当下载完成property list的数据被萃取成一个NSDictionary,然后再次处理一个数组的PhotoRecord的对象。你不能直接使用这里的NSOperation,你应该在主线程中接入它使用NSOperationQueue.mainQueue()。 在viewDidLoad调用新方法 fetchPhotoDetails() 下一步找到 tableView(_:cellForRowAtIndexPath:)然后替换它用下面的实现： 12345678910111213141516171819202122232425262728293031override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCellWithIdentifier(&quot;CellIdentifier&quot;, forIndexPath: indexPath) as! UITableViewCell //1 if cell.accessoryView == nil &#123; let indicator = UIActivityIndicatorView(activityIndicatorStyle: .Gray) cell.accessoryView = indicator &#125; let indicator = cell.accessoryView as! UIActivityIndicatorView //2 let photoDetails = photos[indexPath.row] //3 cell.textLabel?.text = photoDetails.name cell.imageView?.image = photoDetails.image //4 switch (photoDetails.state)&#123; case .Filtered: indicator.stopAnimating() case .Failed: indicator.stopAnimating() cell.textLabel?.text = &quot;Failed to load&quot; case .New, .Downloaded: indicator.startAnimating() self.startOperationsForPhotoRecord(photoDetails,indexPath:indexPath) &#125; return cell&#125; 花点时间来通读注释区域下面的解释： 为了给用户提供反馈，创建UIActivityIndicatorView让后把它设成cell的accessory view。 数据源包含PhotoRecord实例。抓取正确的数据基于当前行的indexPath。 cell的文本标签总是一样的，图片被正确的设置在PhotoRecord中当它被处理的时候，以便你能够设置他们两者，而不管记录的状态。 检查记录，正确的设置activity indicator和文本，然后开始操作（暂时还没实现） 你可以移除applySepiaFilter的实现，因为那个将不再被调用了，添加下面的方法到类中来开始操作： 12345678910func startOperationsForPhotoRecord(photoDetails: PhotoRecord, indexPath: NSIndexPath)&#123; switch (photoDetails.state) &#123; case .New: startDownloadForRecord(photoDetails, indexPath: indexPath) case .Downloaded: startFiltrationForRecord(photoDetails, indexPath: indexPath) default: NSLog(&quot;do nothing&quot;) &#125;&#125; 这里，你将传递一个PhotoRecord类型的实例带有它的index path。依据photo record的状态，你选开始进行下载还是加滤镜的步骤。 注意：下载图片和给图片加滤镜的方法分开实现，因为这里有可能出现当一个图片正在被下载，用户可能把它滚开了，这样你就不必对它应用滤镜操作。当下一次用户又来到相同的哪行时，你不必重新下载图片；你只需对它应用图片滤镜即可！ Efficiency rocks! :] 现在你需要实现你在上面调用的方法。记住你创建的自定义的类，PendingOperations,保持跟踪操作；现在实际上你可以使用它了！添加下面的方法到类中： 123456789101112131415161718192021222324252627282930313233343536373839404142func startDownloadForRecord(photoDetails: PhotoRecord, indexPath: NSIndexPath)&#123; //1 if let downloadOperation = pendingOperations.downloadsInProgress[indexPath] &#123; return &#125; //2 let downloader = ImageDownloader(photoRecord: photoDetails) //3 downloader.completionBlock = &#123; if downloader.cancelled &#123; return &#125; dispatch_async(dispatch_get_main_queue(), &#123; self.pendingOperations.downloadsInProgress.removeValueForKey(indexPath) self.tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .Fade) &#125;) &#125; //4 pendingOperations.downloadsInProgress[indexPath] = downloader //5 pendingOperations.downloadQueue.addOperation(downloader)&#125;func startFiltrationForRecord(photoDetails: PhotoRecord, indexPath: NSIndexPath)&#123; if let filterOperation = pendingOperations.filtrationsInProgress[indexPath]&#123; return &#125; let filterer = ImageFiltration(photoRecord: photoDetails) filterer.completionBlock = &#123; if filterer.cancelled &#123; return &#125; dispatch_async(dispatch_get_main_queue(), &#123; self.pendingOperations.filtrationsInProgress.removeValueForKey(indexPath) self.tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .Fade) &#125;) &#125; pendingOperations.filtrationsInProgress[indexPath] = filterer pendingOperations.filtrationQueue.addOperation(filterer)&#125; Okey!下面是一个快速列表来帮助你立即上面的代码到底做了什么： 首先，检查特定的indexPath来看这里是否已经有一个操作在downloadsInProgress中。假如有，忽略它。 假如没有，通过designated initializer创建一个ImageDownloader实例 添加一个当操作完成时执行的完成block。这是最好的地方让你其余的应用知道一个操作已经完成。注意完成block必须被执行即使这个操作被取消，这相当的重要，所以你需要使用GCD来触发重新载入表视图在主线程。 添加操作到downloadsInProgress中来保持跟踪一些事情。 添加操作到下载队列中。这是你实际获取这些操作开始运行的方法–队列需要注意的是一旦你添加了操作它就会执行。 过滤图片的方法遵循下面相同的类型，除了它使用ImageFiltration和filtrationsInProgress来跟踪操作。作为经验，你应该尝试不要重复这个区域的代码 :] 你做到了！你的工程完成了。构建让后运行看有什么改进在操作上！当你滚动表视图的时候，app并没有停止，还是像它们变得可见一样继续下载图片和给图片加滤镜操作。 原来的图片，现在可以滚动了 是不是很酷？你能看到随做你的进步让你的应用更易于响应能做出的努力 –对用户来说更有趣！ 细微的调整你已经随着这个教程走过漫长的路！你的小项目现在反应灵敏表明了在原来的版本基础上有很多改进。然而，这里任然有一些遗留的细节我们需要考虑。你是想成为一名伟大的程序员，而不仅仅是一名优秀的程序员！ 你可能已经注意到了当你滚动表视图时，那些离屏的cell仍然在处理下载和给图片加滤镜的操作。假如你快速滚动，app将忙于下载和给图片处理滤镜的操作，在列表中从最前面甚至到不可见的地方。理想的情况下app应该对离开屏幕的cells就是现在不可见的取消滤镜操作。 难道你没有把取消的规定放进你的代码里？ 是的，你做了–现在你应该充分利用它们！:] 回到Xcode，让后打开ListViewController.swift文件。去到tableView(_:cellForRowAtIndexPath:)方法的实现，封装startOperationsForPhotoRecord调用在一个if条件向下面的： 123if (!tableView.dragging &amp;&amp; !tableView.decelerating) &#123; self.startOperationsForPhotoRecord(photoDetails, indexPath: indexPath)&#125; 你需要告诉表视图开始操作仅仅当表视图没有滚动的时候。这实际上是UIScrollView的接口，由于UITableView是UIScrollView的子类，你自动继承了这些接口。 下一步，添加到下面UIScrollView代理方法的实现到类中： 123456789101112131415161718override func scrollViewWillBeginDragging(scrollView: UIScrollView) &#123; //1 suspendAllOperations()&#125;override func scrollViewDidEndDragging(scrollView: UIScrollView, willDecelerate decelerate: Bool) &#123; // 2 if !decelerate &#123; loadImagesForOnscreenCells() resumeAllOperations() &#125;&#125;override func scrollViewDidEndDecelerating(scrollView: UIScrollView) &#123; // 3 loadImagesForOnscreenCells() resumeAllOperations()&#125; 快速走查上面的代码显示在下面： 当用户开始滚动，你想暂停所有的操作让后看看用户想看到什么。你将要实现suspendAllOperations在一会儿工夫。 假如decelerate的值是false,那就意味着停止拖拽表视图，因此你想恢复暂停的，因为cell离开屏幕取消的操作，启动在屏幕内cells的操作。你将要一起实现loadImagesForOnscreenCells和resumeAllOperations。 代理方法告诉你表视图已经停止滚动，所以你将做和#2条相同的处理。 现在，添加下面这些遗失的方法的实现到ListViewController.swift: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func suspendAllOperations () &#123; pendingOperations.downloadQueue.suspended = true pendingOperations.filtrationQueue.suspended = true&#125;func resumeAllOperations () &#123; pendingOperations.downloadQueue.suspended = false pendingOperations.filtrationQueue.suspended = false&#125;func loadImagesForOnscreenCells () &#123; //1 if let pathsArray = tableView.indexPathsForVisibleRows() &#123; //2 var allPendingOperations = Set(pendingOperations.downloadsInProgress.keys.array) allPendingOperations.unionInPlace(pendingOperations.filtrationsInProgress.keys.array) //3 var toBeCancelled = allPendingOperations let visiblePaths = Set(pathsArray as! [NSIndexPath]) toBeCancelled.subtractInPlace(visiblePaths) //4 var toBeStarted = visiblePaths toBeStarted.subtractInPlace(allPendingOperations) // 5 for indexPath in toBeCancelled &#123; if let pendingDownload = pendingOperations.downloadsInProgress[indexPath] &#123; pendingDownload.cancel() &#125; pendingOperations.downloadsInProgress.removeValueForKey(indexPath) if let pendingFiltration = pendingOperations.filtrationsInProgress[indexPath] &#123; pendingFiltration.cancel() &#125; pendingOperations.filtrationsInProgress.removeValueForKey(indexPath) &#125; // 6 for indexPath in toBeStarted &#123; let indexPath = indexPath as NSIndexPath let recordToProcess = self.photos[indexPath.row] startOperationsForPhotoRecord(recordToProcess, indexPath: indexPath) &#125; &#125;&#125; suspendAllOperations和resumeAllOperations有一个简单的实现。NSOperationQueues能够被暂停，通过设置suspended接口为true。这将暂停队列里面的所有操作–你不能单独暂停一个操作。 loadImagesForOnscreenCells有一点小复杂。这里发生了什么事？ 以一个包含了现在表视图可见的index paths的数组开始开始 构造一个所有进行中的操作的集合通过结合所有在下载的进度+所有在处理滤镜的进度。 构造一个index paths集合用来取消操作。开始所有的操作，然后移除可见行的index paths，这样讲留下一个离开屏幕的行正在执行的操作集合 构造一个index paths集合，需要操作启动，用所有可见行的index paths启动，让后移除它们中在进行的操作。 遍历那些被取消的操作，取消它们，然后移除它们的引用从PendingOperations。 遍历那些将要开始的操作，然后对他们每个调用startOperationsForPhotoRecord。 构建运行然后你发现一个更流畅，资源管理德更好的应用！给你自己一轮掌声！ 原来的相册，载入东西一次一个 注意到当你完成滚动表视图，在可见区域行的cell的图片立即开始处理。 何去何从？这里是completed version of the project。 注意：此教程写于Update 17 April 2015: Updated for Xcode 6.3 and Swift 1.2,现在Swift最新版本2.1使用Xcode7+以上编辑会报错，这里打包一个新语法修改版completed fixed version of the project。 假如你完成这个工程应该花时间来真正理解它，恭喜你！你可以认为你自己是一位更有价值iOS开发者了比起在教程刚开始的时候！大多数开发的公司是非常幸运的有一个或者两个人正在知道这个东西。 当时请当心 – 像多层嵌套的blocks,不必要的使用多线程可能让一个工程变得难以理解对维护你代码的人来说。线程可能引入一些难以捉摸的bugs，将永远不出现知道你网络非常慢，或者代码运行在一个更快（或更慢）的设备上，或一个不同数量的核的芯片上时。小心测试，尽量使用Instruments（或者你自己的观察）来确定引入多线程真的有很大改进。 一个有用的特征使用操作时在这里没涉及到就是依赖（dependency）。你可以给一个操作添加一个或者更多的操作的依赖。这个操作不会开始直到它所有依赖的操作完成时。例如： 123456// MyDownloadOperation is a subclass of NSOperationlet downloadOperation = MyDownloadOperation()// MyFilterOperation is a subclass of NSOperationlet filterOperation = MyFilterOperation()filterOperation.addDependency(downloadOperation) 移除依赖： 1filterOperation.removeDependency(downloadOperation) 这个工程是否能使用依赖简化呢？把你学到的新技能用起来试一试 ：]有件非常重要的事需要注意的就是一个依赖操作将仍然启动假如它依赖的操作被取消，还有它将自然完成。你需要牢记在心。 假如你有任何评论或者问题关于这个教程或者NSOperations,请加Pull request。 译者注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://blog.wangruofeng007.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"网络","slug":"网络","permalink":"https://blog.wangruofeng007.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.wangruofeng007.com/tags/Swift/"}]},{"title":"多线程之NSOperation","slug":"2016-01-13-duo-xian-cheng-zhi-nsoperation","date":"2016-01-12T21:14:59.000Z","updated":"2024-11-02T03:36:52.395Z","comments":true,"path":"2016/01/13/2016-01-13-duo-xian-cheng-zhi-nsoperation/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-duo-xian-cheng-zhi-nsoperation/","excerpt":"","text":"本文目录 前言 NSInvocationOperation NSBlokcOperation NSOperation的其他用法 自定义NSOperation 参考资料 前言1.虽然NSThread也可以实现多线程编程，但是需要我们去管理线程的生命周期，还要考虑线程同步、加锁问题，造成一些性能上的开销。我们也可以配合使用NSOperation和NSOperationQueue实现多线程编程，实现步骤大致是这样的 先将需要执行的操作封装到一个NSOperation对象中 然后将NSOperation对象添加到NSOperationQueue中 系统会自动将NSOperation中封装的操作放到一条新线程中执行在此过程中，我们根本不用考虑线程的生命周期、同步、加锁等问题下面列举一个应用场景，比如微博的粉丝列表： 每一行的头像肯定要从新浪服务器下载图片后才能显示的，而且是需要异步下载。这时候你就可以把每一行的图片下载操作封装到一个NSOperation对象中，上面有6行，所以要创建6个NSOperation对象，然后添加到NSOperationQueue中，分别下载不同的图片，下载完毕后，回到对应的行将图片显示出来。 2 .默认情况下，NSOperation并不具备封装操作的能力，必须使用它的子类，使用NSOperation子类的方式有3种： NSInvocationOperation NSBlockOperation 自定义子类继承NSOperation，实现内部相应的方法 这讲先介绍如何用NSOperation封装一个操作，后面再结合NSOperationQueue来使用。 NSInvocationOperation12NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run:) object:@&quot;mj&quot;];[operation start]; 第1行初始化了一个NSInvocationOperation对象，它是基于一个对象和selector来创建操作 第2行调用了start方法，紧接着会马上执行封装好的操作，也就是会调用self的run:方法，并且将@”mj”作为方法参数 这里要注意：默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作。只有将operation放到一个NSOperationQueue中，才会异步执行操作。 NSBlockOperationa.同步执行一个操作12345NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^()&#123; NSLog(@&quot;执行了一个新的操作&quot;); &#125;]; // 开始执行任务[operation start]; 第1行初始化了一个NSBlockOperation对象，它是用一个Block来封装需要执行的操作 第2行调用了start方法，紧接着会马上执行Block中的内容 这里还是在当前线程同步执行操作，并没有异步执行 b.并发执行多个操作123456789101112131415161718NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^()&#123; NSLog(@&quot;执行第1次操作，线程：%@&quot;, [NSThread currentThread]);&#125;];[operation addExecutionBlock:^() &#123; NSLog(@&quot;又执行了1个新的操作，线程：%@&quot;, [NSThread currentThread]);&#125;];[operation addExecutionBlock:^() &#123; NSLog(@&quot;又执行了1个新的操作，线程：%@&quot;, [NSThread currentThread]);&#125;];[operation addExecutionBlock:^() &#123; NSLog(@&quot;又执行了1个新的操作，线程：%@&quot;, [NSThread currentThread]);&#125;];// 开始执行任务[operation start]; 第1行初始化了一个NSBlockOperation对象 分别在第5、9、13行通过addExecutionBlock:方法添加了新的操作，包括第1行的操作，一共封装了4个操作 在第18行调用start方法后，就会并发地执行这4个操作，也就是会在不同线程中执行 1 2013-02-02 21:38:46.102 thread[4602:c07] 又执行了1个新的操作，线程：&lt;NSThread: 0x7121d50&gt;&#123;name = (null), num = 1&#125; 2 2013-02-02 21:38:46.102 thread[4602:3f03] 又执行了1个新的操作，线程：&lt;NSThread: 0x742e1d0&gt;&#123;name = (null), num = 5&#125; 3 2013-02-02 21:38:46.102 thread[4602:1b03] 执行第1次操作，线程：&lt;NSThread: 0x742de50&gt;&#123;name = (null), num = 3&#125; 4 2013-02-02 21:38:46.102 thread[4602:1303] 又执行了1个新的操作，线程：&lt;NSThread: 0x7157bf0&gt;&#123;name = (null), num = 4&#125; 可以看出，每个操作所在线程的num值都不一样，说明是不同线程 NSOperation的其他用法a.取消操作operation开始执行之后, 默认会一直执行操作直到完成，我们也可以调用cancel方法中途取消操作 [operation cancel]; b.在操作完成后做一些事情如果想在一个NSOperation执行完毕后做一些事情，就调用NSOperation的setCompletionBlock方法来设置想做的事情 operation.completionBlock = ^() &#123; NSLog(@&quot;执行完毕&quot;); &#125;; 当operation封装的操作执行完毕后，就会回调Block里面的内容 自定义NSOperation如果NSInvocationOperation和NSBlockOperation不能满足需求，我们可以直接新建子类继承NSOperation，并添加任何需要执行的操作。如果只是简单地自定义NSOperation，只需要重载-(void)main这个方法，在这个方法里面添加需要执行的操作。 下面写个子类DownloadOperation来下载图片 a.继承NSOperation，重写main方法DownloadOperation.h 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;@protocol DownloadOperationDelegate;@interface DownloadOperation : NSOperation// 图片的url路径@property (nonatomic, copy) NSString *imageUrl;// 代理@property (nonatomic, assign) id&lt;DownloadOperationDelegate&gt; delegate;- (id)initWithUrl:(NSString *)url delegate:(id&lt;DownloadOperationDelegate&gt;)delegate;@end// 图片下载的协议@protocol DownloadOperationDelegate &lt;NSObject&gt;- (void)downloadFinishWithImage:(UIImage *)image;@end DownloadOperation.m 12345678910111213141516171819202122232425262728#import &quot;DownloadOperation.h&quot;@implementation DownloadOperation@synthesize delegate = _delegate;@synthesize imageUrl = _imageUrl;// 初始化- (id)initWithUrl:(NSString *)url delegate:(id&lt;DownloadOperationDelegate&gt;)delegate &#123; if (self = [super init]) &#123; self.imageUrl = url; self.delegate = delegate; &#125; return self;&#125;// 释放内存- (void)dealloc &#123; [super dealloc]; [_imageUrl release];&#125;// 执行主任务- (void)main &#123; // 新建一个自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池 @autoreleasepool &#123; // .... &#125;&#125;@end 在第22行重载了main方法，等会就把下载图片的代码写到这个方法中 如果这个DownloadOperation是在异步线程中执行操作，也就是说main方法在异步线程调用，那么将无法访问主线程的自动释放池，所以在第24行创建了一个属于当前线程的自动释放池 b.正确响应取消事件 默认情况下，一个NSOperation开始执行之后，会一直执行任务到结束，就比如上面的DownloadOperation，默认会执行完main方法中的所有代码 NSOperation提供了一个cancel方法，可以取消当前的操作。 如果是自定义NSOperation的话，需要手动处理这个取消事件。比如，一旦调用了cancel方法，应该马上终止main方法的执行，并及时回收一些资源。 处理取消事件的具体做法是：在main方法中定期地调用isCancelled方法检测操作是否已经被取消，也就是说是否调用了cancel方法，如果返回YES，表示已取消，则立即让main方法返回。 以下地方可能需要调用isCancelled方法: 在执行任何实际的工作之前，也就是在main方法的开头。因为取消可能发生在任何时候，甚至在operation执行之前。 执行了一段耗时的操作之后也需要检测操作是否已经被取消 1234567891011121314151617181920212223242526272829- (void)main &#123; // 新建一个自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池 @autoreleasepool &#123; if (self.isCancelled) return; // 获取图片数据 NSURL *url = [NSURL URLWithString:self.imageUrl]; NSData *imageData = [NSData dataWithContentsOfURL:url]; if (self.isCancelled) &#123; url = nil; imageData = nil; return; &#125; // 初始化图片 UIImage *image = [UIImage imageWithData:imageData]; if (self.isCancelled) &#123; image = nil; return; &#125; if ([self.delegate respondsToSelector:@selector(downloadFinishWithImage:)]) &#123; // 把图片数据传回到主线程 [(NSObject *)self.delegate performSelectorOnMainThread:@selector(downloadFinishWithImage:) withObject:image waitUntilDone:NO]; &#125; &#125;&#125; 在第4行main方法的开头就先判断operation有没有被取消。如果被取消了，那就没有必要往下执行了 经过第8行下载图片后，在第10行也需要判断操作有没有被取消 总之，执行了一段比较耗时的操作之后，都需要判断操作有没有被取消 图片下载完毕后，在第26行将图片数据传递给了代理(delegate)对象 参考资料 NSHipster 的NSOperation 雷纯锋的博客的《iOS 并发编程之 Operation Queues》 objc的并发编程指南《Concurrent Programming》 StackOverflow: NSOperation vs. Grand Central Dispatch Blog: When to use NSOperation vs. GCD 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://blog.wangruofeng007.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.wangruofeng007.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"iOS中的触摸事件和手势处理","slug":"2016-01-13-ioszhong-de-hong-mo-shi-jian-he-shou-shi-chu-li","date":"2016-01-12T21:05:09.000Z","updated":"2024-11-02T03:36:52.398Z","comments":true,"path":"2016/01/13/2016-01-13-ioszhong-de-hong-mo-shi-jian-he-shou-shi-chu-li/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-ioszhong-de-hong-mo-shi-jian-he-shou-shi-chu-li/","excerpt":"","text":"iOS触摸事件分类 触摸事件 加速事件 远程事件 谁能处理触摸事件?响应者对象 在iOS中不是任何对象都能处理事件,只有继承了UIResponder的对象才能接收并处理事件.我们称之为响应者对象. UIApplication,UIViewController,UIView都继承自UIResponder,因此它们都是响应者对象,都能够接收并处理事件. UIResponderUIResponder内部提供了方法来处理事件 触摸事件 一次完成的触摸过程,会经历3个状态; UIView的触摸事件处理 1.一根或多根手指开始触摸view,系统会自动调用view下面的方法: - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event; &#x2F;&#x2F;触摸开始 2.一根或者多根手指在view上移动，系统会自动调用view下面的方法（随着手指的移动，会持续调用该方法） - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event; &#x2F;&#x2F;触摸移动 3.一根或者多根手指离开view，系统会自动调用view下面的方法 - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event; &#x2F;&#x2F;触摸结束 4.触摸结束前，某个系统事件（例如电话呼入 ）会打断触摸过程，系统会自动调用view下面的方法 - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; &#x2F;&#x2F;触摸取消(可能会经历) 4个触摸事件的处理方法中，都有 NSSet *touches 和 UIEvent *event 两个参数: 一次完整的触摸过程，只会产生一个事件对象，4个触摸方法都是同一个event参数 如果两根手指同时触摸一个view，那么view只会调用一次 touchesBegan:withEvent: 方法，touches参数中装着两个UITouch对象； 如果这两根手指一前一后分开触摸同一个view，那么view会分别调用两次 touchesBegan:withEvent:方法， 并且每次调用时的touches参数只包含一个UITouch对象； 根据touches中UITouch个数可以判断出使单点触摸还是多点触摸 提示：touches中存放的都是UITouch对象。 加速计事件 (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event; (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event; (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event; 远程控制事件 - (void)remoteControlReceivedWithEvent:(UIEvent *)event; UITouch当用户用一根手指触摸屏幕时，会创建一个与手指相关联的UITouch对象；一根手指对应一个UITouch对象UITouch的作用: 保存跟手指相关的信息，比如触摸的位置、时间、阶段； 当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指的触摸位置； 当手指离开屏幕时，系统会销毁相应的UITouch对象。 提示：iPhone开发中，要避免使用双击事件。 UITouch的属性:触摸产生时所处的窗口: 1@property(nonatomic,readonly,retain) UIWindow *window; 触摸产生时所处的视图 1@property(nonatomic,readonly,retain) UIView *view; 短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多地点击 1@property(nonatomic,readonly) NSUInteger tapCount; 记录了触摸事件产生或变化时的时间，单位是秒 1@property(nonatomic,readonly) NSTimeInterval timestamp; 当前触摸事件所处的状态 12345678@property(nonatomic,readonly) UITouchPhase phase;/*UITouchPhase是一个枚举类型，包含：UITouchPhaseBegan（触摸开始）UITouchPhaseMoved（接触点移动）UITouchPhaseStationary（接触点无移动）UITouchPhaseEnded（触摸结束）UITouchPhaseCancelled（触摸取消）*/ UITouch的方法： 1- (CGPoint)locationInView:(UIView *)view; 1.返回值表示触摸在view上的位置； 2.这里返回的位置是针对view坐标系的,（以view的左上角为原点（0，0））； 3.调用时传入的view参数为nil 的话，返回的是触摸点在UIWindow的位置。 1- (CGPoint)previousLocationInView:(UIView *)view; 该方法记录了前一个触摸点的位置； UIEvent 每产生一个事件，就会产生一个UIEvent对象； UIEvent:称为事件对象，记录事件产生的时刻和类型。 常见属性：1.事件类型 123456789101112131415161718192021222324252627@property(nonatomic,readonly) UIEventType type;@property(nonatomic,readonly) UIEventSubtype subtype;typedefNS_ENUM(NSInteger, UIEventType) &#123; UIEventTypeTouches, UIEventTypeMotion, UIEventTypeRemoteControl,&#125;;typedefNS_ENUM(NSInteger, UIEventSubtype) &#123; // available in iPhone OS 3.0 UIEventSubtypeNone = 0, // for UIEventTypeMotion, available in iPhone OS 3.0 UIEventSubtypeMotionShake = 1, // for UIEventTypeRemoteControl, available in iOS 4.0 UIEventSubtypeRemoteControlPlay = 100, UIEventSubtypeRemoteControlPause = 101, UIEventSubtypeRemoteControlStop = 102, UIEventSubtypeRemoteControlTogglePlayPause = 103, UIEventSubtypeRemoteControlNextTrack = 104, UIEventSubtypeRemoteControlPreviousTrack = 105, UIEventSubtypeRemoteControlBeginSeekingBackward = 106, UIEventSubtypeRemoteControlEndSeekingBackward = 107, UIEventSubtypeRemoteControlBeginSeekingForward = 108, UIEventSubtypeRemoteControlEndSeekingForward = 109,&#125;; 2.事件产生的时间 1@property(nonatomic,readonly) NSTimeInterval timestamp; UIEvent还提供了相应的方法可以获得在某个view上面的触摸对象（UITouch）。 触摸事件的产生： 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中； UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）； 主窗口会在视图层次结构中找到一个最合适的视图控件来处理触摸事件，这也是整个事件处理过程的第一步； 找到合适的视图控件后，就会调用视图控件的touches方法来做具体的事件处理。 触摸事件的传递： 触摸事件的传递是从父控件传递到子控件； 如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件。 UIView不接收触摸事件的三种情况:不接受用户交互 ： userInteractionEnable &#x3D; NO; 隐藏 ：hidden &#x3D; YES; 透明：alpha &#x3D; 0.0 ~ 0.01 提示：UIImageView的userInteractionEnable默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的。 触摸事件处理的详细过程： 用户点击屏幕后产生的一个触摸事件，经过一些列的传递过程后，会找到最合适的视图控件来处理这个事件 找到最合适的视图控件后，就会调用控件的touches方法来作具体的事件处理 touchesBegan… touchesMoved… touchedEnded… 这些touches方法的默认做法是将事件顺着响应者链条向上传递，将事件交给上一个响应者进行处理 响应者链的事件传递过程： 如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图； 在视图层次结构最顶级的视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理。 如果window对象也不处理，则其将事件或消息传递给UIApplication对象； 如果UIApplication也不能处理该事件或消息，则将其丢弃 监听触摸事件的做法如果想监听一个view上面的触摸事件，之前的做法是： 自定义一个view； 实现view的touches方法，在方法内部实现具体处理代码。 通过touches方法监听view触摸事件，有很明显的几个缺点： 必须得自定义view； 由于是在view内部的touches方法中监听触摸事件，因此默认情况下，无法让其他外界对象监听view的触摸事件； 不容易区分用户的具体手势行为。 iOS 3.2之后，苹果推出了手势识别功能（Gesture Recognizer）,在触摸事件处理方面，大大简化了开发者的开发难度。 UIGestureRescognizer为了完成手势识别，必须借助于手势识别器：UIGestureRecognizer 。 利用UIGestureRecognizer,能轻松识别用户在某个view上面做的一些常见手势。 UIGestureRecognizer是一个抽象类，定义了所有的手势基本行为，使用它的子类才能处理具体的手势 UITapGestureRecognizer(敲击) UIPinchGestureRecognizer(捏合，用于缩放) UIPanGestureRecognizer(拖拽) UISwipeGestureRecognizer(轻扫) UIRotationGestureRecognizer(旋转) UILongPressGestureRecognizer(长按) 每一个手势识别器的用法都差不多，比如UITapGestureRecognizer的使用步骤如下: 创建手势识别器对象； UITapGestureRecognizer *tap &#x3D; [[UITapGestureRecognizer alloc] init]; 设置手势识别器对象的具体属性； // 连续敲击2次 tap.numberOfTapsRequired = 2; // 需要2根手指一起敲击 tap.numberOfTouchesRequired = 2; 添加手势识别器到对应的view上 [self.iconView addGestureRecognizer:tap]; 监听手势的触发 [tap addTarget:self action:@selector(tapIconView:)]; 手势识别的状态 12345678910111213141516typedef NS_ENUM(NSInteger, UIGestureRecognizerState) &#123; // 没有触摸事件发生，所有手势识别的默认状态 UIGestureRecognizerStatePossible, // 一个手势已经开始但尚未改变或者完成时 UIGestureRecognizerStateBegan, // 手势状态改变 UIGestureRecognizerStateChanged, // 手势完成 UIGestureRecognizerStateEnded, // 手势取消，恢复至Possible状态 UIGestureRecognizerStateCancelled, // 手势失败，恢复至Possible状态 UIGestureRecognizerStateFailed, // 识别到手势识别 UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded&#125;; 参考资料：傲风凌寒的博客 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"事件处理","slug":"事件处理","permalink":"https://blog.wangruofeng007.com/tags/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"}]},{"title":"iOS里程碑事件","slug":"2016-01-13-iosli-cheng-bei-shi-jian","date":"2016-01-12T20:46:48.000Z","updated":"2024-11-02T03:36:52.398Z","comments":true,"path":"2016/01/13/2016-01-13-iosli-cheng-bei-shi-jian/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-iosli-cheng-bei-shi-jian/","excerpt":"","text":"记录iOS各种重要里程碑事件 私有成员变量的实现1.0时代，在.h文件采用@private关键词 1234@interface ViewController : UIViewController &#123; @private NSInteger _value;&#125; 2.0时代 通过在.m文件通过匿名Category 12345@interface ViewController ()@property (nonatomic) NSInteger value;@end 3.0时代 2013 年的 WWDC 允许在 .m 的 @implementation 中 123@implementation ViewController &#123; NSInteger _value;&#125; ARC推出2011 自动生成getter和setter方法的@synthesize2012 AutoLayout引入iOS 6.0 Swift WWDC 1.0 版本发布 – 2014.06.02 Swift 2.0发布 – 2015.08.07 Open Source – 2015.12.04 Size ClassesiOS 8.0 BlocksMac OS X 10.6 “Snow Leopard” and iOS 4.0 Objective-C 2.0At the 2006 Worldwide Developers Conference release of Objective-C 2.0 Watch OS2015.05.21 iOS API DifferencesiOS 2.1 to iOS 2.2 API DifferencesAdded frameworks: AVFoundation iOS 2.2 to iOS 3.0 API DifferencesAdded frameworks: CoreData ExternalAccessory GameKit MapKit MessageUI MobileCoreServices StoreKit iOS 3.2 to iOS 4.0 API DifferencesAdded frameworks: Accelerate AssetsLibrary CoreMedia CoreMotion CoreTelephony CoreVideo EventKit EventKitUI iAd ImageIO QuickLook iOS 4.3 to iOS 5.0 API DifferencesAdded frameworks Accounts CoreBluetooth CoreImage GLKit GSS NewsstandKit Twitter 5.1 to iOS 6.0 API DifferencesAdded frameworks AdSupport MediaToolbox PassKit Social 6.1 to iOS 7.0 API DifferencesAdded frameworks GameController JavaScriptCore MediaAccessibility MultipeerConnectivity SafariServices SpriteKit iOS 7.1 to iOS 8.0 API DifferencesAdded frameworks Accelerate Accounts AddressBook AddressBookUI AudioToolbox AudioUnit AVFoundation AVKit (Added) CFNetwork CloudKit (Added) CoreAudio CoreAudioKit (Added) CoreAuthentication (Added) CoreBluetooth CoreData CoreFoundation CoreImage CoreLocation CoreMedia CoreMotion CoreText CoreVideo EventKit EventKitUI ExternalAccessory Foundation GameController GameKit GLKit GSS HealthKit (Added) HomeKit (Added) iAd ImageIO IOKit JavaScriptCore LocalAuthentication (Added) MapKit MediaAccessibility MediaPlayer MessageUI Metal (Added) MobileCoreServices MultipeerConnectivity NetworkExtension (Added) NewsstandKit NotificationCenter (Added) OpenGLES PassKit Photos (Added) PhotosUI (Added) PushKit (Added) QuartzCore QuickLook SceneKit (Added) Security Social SpriteKit StoreKit UIKit VideoToolbox WebKit (Added) iOS 8.3 to iOS 9.0 API DifferencesAdded frameworks Objective-C &#x2F;usr&#x2F;include Accelerate Accounts AddressBook AddressBookUI AssetsLibrary AudioToolbox AudioUnit AVFoundation AVKit CFNetwork CloudKit Contacts (Added) ContactsUI (Added) CoreAudio CoreAudioKit CoreBluetooth CoreData CoreFoundation CoreGraphics CoreImage CoreLocation CoreMedia CoreMIDI CoreMotion CoreSpotlight (Added) CoreTelephony CoreText CoreVideo EventKit EventKitUI ExternalAccessory Foundation GameController GameKit GameplayKit (Added) GLKit GSS HealthKit HomeKit iAd ImageIO JavaScriptCore LocalAuthentication MapKit MediaPlayer MediaToolbox MessageUI Metal MetalKit (Added) MetalPerformanceShaders (Added) MobileCoreServices ModelIO (Added) MultipeerConnectivity NetworkExtension NewsstandKit OpenAL PassKit Photos PushKit QuartzCore QuickLook ReplayKit (Added) SafariServices SceneKit Security SpriteKit StoreKit SystemConfiguration UIKit VideoToolbox WatchConnectivity (Added) WatchKit WebKit 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"Favorite","slug":"Favorite","permalink":"https://blog.wangruofeng007.com/tags/Favorite/"}]},{"title":"优雅处理UIImage图片旋转","slug":"2016-01-13-you-ya-chu-li-uiimagetu-pian-xuan-zhuan","date":"2016-01-12T20:38:49.000Z","updated":"2024-11-02T03:36:52.402Z","comments":true,"path":"2016/01/13/2016-01-13-you-ya-chu-li-uiimagetu-pian-xuan-zhuan/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-you-ya-chu-li-uiimagetu-pian-xuan-zhuan/","excerpt":"","text":"UIImag构造方式UIImag构造方式大致有4种方式 从本地bundle中加载 imageNamed:，传入一个bundle的文件名即可 从本地一个文件路径读取 imageWithContentsOfFile:，需要传一个文件的文件路径path 通过二进制数据NSData来创建imageWithData: 通过一个CoreGraphics的CGImageRef来创建，initWithCGImage: 通过一个CoreImage的CIImage来创建initWithCIImage 通过查阅Apple官网文档我们发现有2个这样的方法，今天就来一探究竟 12345+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(4_0);+ (UIImage *)imageWithCIImage:(CIImage *)ciImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(6_0);- (instancetype)initWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(4_0);- (instancetype)initWithCIImage:(CIImage *)ciImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(6_0); 2个类方法2个实例方法都是类似，这里以CGImageRef为例 1+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(4_0); 新建的Xcode工程选择single Application 在storyboard中拖一个UIImageView设置它水平垂直居中对齐，宽带高度随便设一个值不要太大就行，设置UIImageView的contentMode为Aspect Fit方便查看以免变形 在UIImageView下发放一个UIButton控件方便后面好对图片进行旋转操作 在viewController中建立一个UIImageView引用,拉出一个rotate按钮的IBAction 现在大概界面大概这样 下面我们实现- (IBAction)rotateImage:(id)sender &#123;&#125;这个方法 在这里我们想通过点击按钮实现图片旋转 为了方便使用我们使用Category的方式实现 新建一个UIImage的分类取名叫Rotate 这里需要传一张要处理的图片和一个待处理成的图片方向 12+ (UIImage *)rotateImage:(UIImage *)oldImage orientation:(UIImageOrientation)orientation; 123456789101112131415161718192021222324252627282930313233343536373839404142434445 + (UIImage *)rotateImage:(UIImage *)oldImage orientation:(UIImageOrientation)orientation&#123; UIImage *newImage = [UIImage imageWithCGImage:oldImage.CGImage scale:1 orientation:orientation]; NSString *orientationStr = nil; switch (orientation) &#123; case UIImageOrientationUp: &#123; orientationStr = @&quot;UIImageOrientationUp&quot;; break; &#125; case UIImageOrientationDown: &#123; orientationStr = @&quot;UIImageOrientationDown&quot;; break; &#125; case UIImageOrientationLeft: &#123; orientationStr = @&quot;UIImageOrientationLeft&quot;; break; &#125; case UIImageOrientationRight: &#123; orientationStr = @&quot;UIImageOrientationRight&quot;; break; &#125; case UIImageOrientationUpMirrored: &#123; orientationStr = @&quot;UIImageOrientationUpMirrored&quot;; break; &#125; case UIImageOrientationDownMirrored: &#123; orientationStr = @&quot;UIImageOrientationDownMirrored&quot;; break; &#125; case UIImageOrientationLeftMirrored: &#123; orientationStr = @&quot;UIImageOrientationLeftMirrored&quot;; break; &#125; case UIImageOrientationRightMirrored: &#123; orientationStr = @&quot;UIImageOrientationRightMirrored&quot;; break; &#125; &#125; NSLog(@&quot;current orientation: %@&quot;,orientationStr); return newImage;&#125; 在button点击事件触发时的这样使用 12345678- (IBAction)rotateImage:(id)sender &#123; UIImage *oldImage = self.imgView.image; UIImage *rotatedImage = [UIImage rotateImage:oldImage orientation:UIImageOrientationLeft]; self.imgView.image = rotatedImage;&#125; 点击按钮测试发现第一次没问题，但是重逢点击无效原来+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation方法执行原理是执行前通过@property(nonatomic,readonly) UIImageOrientation imageOrientation;接口先判断当前图片的方向是否为将要旋转的方向，如果是就直接返回不做处理，如果不是再作旋转处理，也就是说这个方法并没有实际上旋转image的数据，只是用一个枚举标记旋转的状态 如果我们想每次旋转需要直接改变原始image的数据该怎么办呢？在这里我们通过CGBitmapContext,使用CGContextRotateCTM来设置旋转，再把UIImage通过drawInRect 重新绘制出来，通过UIGraphicsGetImageFromCurrentImageContext获得处理后的图片下面是具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475- (UIImage *)fixedRotation&#123; if (self.imageOrientation == UIImageOrientationUp) return self; CGAffineTransform transform = CGAffineTransformIdentity; switch (self.imageOrientation) &#123; case UIImageOrientationDown: case UIImageOrientationDownMirrored: transform = CGAffineTransformTranslate(transform, self.size.width, self.size.height); transform = CGAffineTransformRotate(transform, M_PI); break; case UIImageOrientationLeft: case UIImageOrientationLeftMirrored: transform = CGAffineTransformTranslate(transform, self.size.width, 0); transform = CGAffineTransformRotate(transform, M_PI_2); break; case UIImageOrientationRight: case UIImageOrientationRightMirrored: transform = CGAffineTransformTranslate(transform, 0, self.size.height); transform = CGAffineTransformRotate(transform, -M_PI_2); break; case UIImageOrientationUp: case UIImageOrientationUpMirrored: break; &#125; switch (self.imageOrientation) &#123; case UIImageOrientationUpMirrored: case UIImageOrientationDownMirrored: transform = CGAffineTransformTranslate(transform, self.size.width, 0); transform = CGAffineTransformScale(transform, -1, 1); break; case UIImageOrientationLeftMirrored: case UIImageOrientationRightMirrored: transform = CGAffineTransformTranslate(transform, self.size.height, 0); transform = CGAffineTransformScale(transform, -1, 1); break; case UIImageOrientationUp: case UIImageOrientationDown: case UIImageOrientationLeft: case UIImageOrientationRight: break; &#125; // Now we draw the underlying CGImage into a new context, applying the transform // calculated above. CGContextRef ctx = CGBitmapContextCreate(NULL, self.size.width, self.size.height, CGImageGetBitsPerComponent(self.CGImage), 0, CGImageGetColorSpace(self.CGImage), CGImageGetBitmapInfo(self.CGImage)); CGContextConcatCTM(ctx, transform); switch (self.imageOrientation) &#123; case UIImageOrientationLeft: case UIImageOrientationLeftMirrored: case UIImageOrientationRight: case UIImageOrientationRightMirrored: // Grr... CGContextDrawImage(ctx, CGRectMake(0,0,self.size.height,self.size.width), self.CGImage); break; default: CGContextDrawImage(ctx, CGRectMake(0,0,self.size.width,self.size.height), self.CGImage); break; &#125; // And now we just create a new UIImage from the drawing context CGImageRef cgimg = CGBitmapContextCreateImage(ctx); UIImage *img = [UIImage imageWithCGImage:cgimg]; CGContextRelease(ctx); CGImageRelease(cgimg); return img;&#125; 现在再优化一下原来+ (UIImage *)rotateImage:(UIImage *)oldImage orientation:(UIImageOrientation)orientation 方法,修改成这样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748+ (UIImage *)rotateImage:(UIImage *)oldImage orientation:(UIImageOrientation)orientation&#123; UIImage *newImage = [UIImage imageWithCGImage:oldImage.CGImage scale:1 orientation:orientation]; //fix original Image with gived orientation. UIImage *fixedRotationImage = [newImage fixedRotation]; NSString *orientationStr = nil; switch (orientation) &#123; case UIImageOrientationUp: &#123; orientationStr = @&quot;UIImageOrientationUp&quot;; break; &#125; case UIImageOrientationDown: &#123; orientationStr = @&quot;UIImageOrientationDown&quot;; break; &#125; case UIImageOrientationLeft: &#123; orientationStr = @&quot;UIImageOrientationLeft&quot;; break; &#125; case UIImageOrientationRight: &#123; orientationStr = @&quot;UIImageOrientationRight&quot;; break; &#125; case UIImageOrientationUpMirrored: &#123; orientationStr = @&quot;UIImageOrientationUpMirrored&quot;; break; &#125; case UIImageOrientationDownMirrored: &#123; orientationStr = @&quot;UIImageOrientationDownMirrored&quot;; break; &#125; case UIImageOrientationLeftMirrored: &#123; orientationStr = @&quot;UIImageOrientationLeftMirrored&quot;; break; &#125; case UIImageOrientationRightMirrored: &#123; orientationStr = @&quot;UIImageOrientationRightMirrored&quot;; break; &#125; &#125; NSLog(@&quot;current orientation: %@&quot;,orientationStr); return fixedRotationImage;&#125; 现在再测试一下，well，It‘s OK。 have fun!!! 参考资料 UIImageOrientation &#x2F; EXIF orientation sample images Apple-UIImage Class Reference ios-uiimageview-how-to-handle-uiimage-image-orientation 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"用CAShapeLayer动画绘制CGPath","slug":"2016-01-13-dong-hua-hui-zhi-cashapelayerde-lu-jing-cgpath","date":"2016-01-12T20:35:42.000Z","updated":"2024-11-02T03:36:52.395Z","comments":true,"path":"2016/01/13/2016-01-13-dong-hua-hui-zhi-cashapelayerde-lu-jing-cgpath/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-dong-hua-hui-zhi-cashapelayerde-lu-jing-cgpath/","excerpt":"","text":"原文链接 这是什么？ 此文将讲解通过形状图层CAShaperLayer的strokeStart和strokeEnd来实现动画绘制路径CGPath,此文是By Ole Begemann创建于December 18, 2010,当时是发布iOS SDK 4.2时CAShapeLayer新增加的两个属性strokeStart和strokeEnd,这两个值是两个浮点数取值范围0.0~1.0,用来表明形状图层所指向的路径在绘制开始和结束路径中的相对位置。 strokeStart默认值是0.0，strokeEnd默认值是1.0，显然这会导致形状图层的路径将一整个被绘制。假如，你想说，如果设置了layer.strokeEnd &#x3D; 0.5f,只让她绘制前半部分，那该多好。 真正有趣的事情是这些接口都是可动画的。通过动画绘制strokeEnd从0.0到1.0在几秒内，我们就能很容易自己绘制路径像下面这样写： 12345CABasicAnimation *pathAnimation = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];pathAnimation.duration = 10.0;pathAnimation.fromValue = [NSNumber numberWithFloat:0.0f];pathAnimation.toValue = [NSNumber numberWithFloat:1.0f];[self.pathLayer addAnimation:pathAnimation forKey:@&quot;strokeEndAnimation&quot;]; 最后，再添加第二个图层包含一个铅笔图片，使用关键帧动画 CAKeyframeAnimation来让它随着这个路径以相同的速度绘制，就可以达到完美的错觉效果： 12345CAKeyframeAnimation *penAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];penAnimation.duration = 10.0;penAnimation.path = self.pathLayer.path;penAnimation.calculationMode = kCAAnimationPaced;[self.penLayer addAnimation:penAnimation forKey:@&quot;penAnimation&quot;]; 绘制普通路径效果视频 下载地址 这个对文本一样有效；我们只需要把字符转化成CGPath。Core Text提供了那样的功能的函数，CTFontCreatePathForGlyph( )。为了使用它，我们需要创建一个带属性的字符串用我们想要渲染的文本，先把它们分割成行在分割成一个个字符。在把所有的字符转换成路径后，我们以子路径方式把它添加到一个单个的CGPath路径中。更多细节可以查看Ohmu写的Low-level text rendering这篇文章。结果看以来非常的炫酷： 绘制文字路径效果视频 下载地址 从Github上获得iPad版的样品工程 你将学到的知识点 使用CAShapeLayer的strokeStart和strokeEnd来实现路径动画,比较高级复杂的效果像google的下拉刷新转圈就可以从这里引申去实现。 CABasicAnimation和CABasicAnimation使用 深入理解CAShapeLayer和CALayer 通过文本创建路径，核心函数CTFontCreatePathForGlyph() 补充说明1234567891011CAShapeLayer *pathLayer = [CAShapeLayer layer];pathLayer.frame = self.animationLayer.bounds;pathLayer.bounds = pathRect;pathLayer.geometryFlipped = YES;pathLayer.path = path.CGPath;pathLayer.strokeColor = [[UIColor blackColor] CGColor];pathLayer.fillColor = nil;pathLayer.lineWidth = 10.0f;pathLayer.lineJoin = kCALineJoinBevel;[self.animationLayer addSublayer:pathLayer]; 有一点非常重要，CALayer在iOS系统中相对坐标系是以屏幕左上top-left为坐标原点的，在Mac OS X上以坐下bottom-left为坐标原点,但是可以通过CALayer的接口geometryFlipped垂直翻转坐标系，这个值默认是NO，设置成YES就可以把坐标系转换成左下bottom-left了，这里作者使用的左下bottom-left的坐标系。 1@property(getter=isGeometryFlipped) BOOL geometryFlipped; 关于这个属性使用时需要特别注意 翻转会同时作用于它的子图层 即使这个属性设置成YES,图片的orientation仍然是不变的（也就是说当设置flipped=YES和flipped=NO时一个CGImageRef储存在contents接口中的内容将会显示一致，赋值并不会真正变换底层的图层） pathLayer动画实现原理 先创建一个动画用的图层animationLayer类型CALayer，用来充当动画的画布。 创建真正的路径图层pathLayer类型为CAShapeLayer,让它的坐标系垂直翻转，并且让图层宽高同时向内收缩100个点,通过CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)实现 把pathLayer添加到animationLayer的子图层中去 创建一个铅笔图层penLayer类型为CALayer,把它添加到pathLayer去 对pathLayer添加CABasicAnimation动画，动画属性为strokeEnd 对penLayer添加CAKeyframeAnimation动画，动画属性为position textLayer动画实现原理 先创建一个动画用的图层animationLayer类型CALayer，用来充当动画的画布 Create path from text,See:http://www.codeproject.com/KB/iPhone/Glyph.aspx，最终保存到一个类型为CGMutablePathRef的letter中 通过letter来创建文字UIBezierPath类型的path 通过path再创建CAShapeLayerpathLayer,并且把pathLayer添加到animationLayer中去 创建一个铅笔图层penLayer类型为CALayer,把它添加到pathLayer去 对pathLayer添加CABasicAnimation动画，动画属性为strokeEnd 对penLayer添加CAKeyframeAnimation动画，动画属性为position 修复一处bug重复点击UISegmentedControl导致铅笔消失，这是设置了 penAnimation.delegate = self;在代理方法里面没有判断结束直接将设置self.penLayer.hidden = YES，导致连续切换时铅笔不见了，要修复这个bug只需加一个判断 if (flag) self.penLayer.hidden = YES;即可,这样的意思是只有当动画完成时才设置self.penLayer.hidden的值，好了现在已经非常完美了，快去动手自己试试吧！🍺 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"Animation","slug":"Animation","permalink":"https://blog.wangruofeng007.com/categories/Animation/"}],"tags":[{"name":"动画","slug":"动画","permalink":"https://blog.wangruofeng007.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"CAShapeLayer","slug":"CAShapeLayer","permalink":"https://blog.wangruofeng007.com/tags/CAShapeLayer/"}]},{"title":"Blog网站备忘录","slug":"2016-01-13-blogwang-zhan-bei-wang-lu","date":"2016-01-12T20:29:59.000Z","updated":"2024-11-02T03:36:52.394Z","comments":true,"path":"2016/01/13/2016-01-13-blogwang-zhan-bei-wang-lu/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-blogwang-zhan-bei-wang-lu/","excerpt":"","text":"用于收藏不错的个人或者公司Blog地址 幽幽传送门 我常常浏览的博客和网站 –叶孤城__ 11个超棒的iOS开发学习网站 iOS开发如何提高 中文 iOS&#x2F;Mac 开发博客列表–唐巧精心整理了国内40多位iOS开发博主的博客地址列表 简书 叶孤城___ MarkNote lp_马建成 seedante 大灰灰iOS StrongX 国内个人 猫神onevcat – 地球人都知道 唐巧–猿题库作者 虾神–话说你们晓得虾神年纪多大么？反正我是觉得白活了。90后太厉害了。 sunnyxx – FDFullscreenPopGesture作者，值得关注 nixzhu–有几篇翻译的文章质量不错 破船之家–这让我想起，喝上一杯朗姆酒🍺 Limboy – 蘑菇街一位资深iOS程序员 MacTalk-池建强的随想录–Mac开发大牛 雨松MOMO–专注移动互联网，专注Unity3D游戏开发,国内最早开发Unity3d的大神之一 玉令天下的博客 – 关于runtime的资料整理得非常不错 Chun Tips – 对Runtime,RunLoop,AutoLayout讲解得非常详细 ❤️ 鹏威の博客 – 非常炫酷的博客，值得学习 mgenware – 往全栈方向发展ing 国外个人 mikeash–白天飞行员，晚上程序员 ：] just this guy, you know? shinobicontrols–iOS 最新 API 以及新功能用法 iosdevelopertips–教程配合Demo让你学习成长立竿见影 iosdevweekly–很棒的个人技术博客网，已发表230篇文章 ios-goodies–iOS,UI,UX,Objective-c,Swift,Xcode mattt-thompson – 不用解释 subjc –Subjective-C is a study of innovative iOS interfaces. thinkandbuild–《Introduction To 3D Drawing in CoreAnimtion》作者 robb.is–《How to build a nice Hamburger transition in swift》作者 commandshift–不多说，质量极高 indieambitions–raywenderlich常驻作者之一的blog，非常赞。 nvie–国外一个大神的blog，讲得比较杂，git，ios，python都有涉猎，但是每篇都很精彩。 stuartkhall–很多关于app上线运营之类的blog，值得一看。 ittybittyapps–神器Reveal的作者的blog。 adoptioncurve–更新极快，当时iOS8还没出几个周，作者就写了篇sizeclass解析。非常棒 ciechanowski–各种数学上几何变化 bignerdranch cocoawithlove–2008-2011的老文章，现在没怎么跟新了 codinghorror –Jeff Atwood 主站 g8production lucida – 我比较佩服一名程序员，想学算法找他推荐咯😁 团体blog ibireme–最近很🔥的YYKit的作者 Glow技术团队 美团点评技术团队 优质iOS学习资源 github–这个不用我说吧 stackoverflow–最专业的问答社区 raywenderlich–iOS界的百科全书 nshipster–里面文章质量非常的高，最喜欢的几个网站之一AFNetworkting的作者Mattt Thompson–经常出没 nshipster中国 objc.io–这个也不用多说了，Raywenderlich是百科全书的话，这个就是深入深入再深入 objc中国 realm.io–一个跨平台的移动数据库引擎 tutsplus–也是包罗万象的一个网站，有web ios ui，不比Raywenderlich逊色。 maniacdev–类似Raywenderlich，文章质量高，而且涵盖面广 Appcoda – 技术类学习网站，里面的技术更新挺及时的 中文网站 cocoachina code4app 泰然网 –游戏教程不错的网站 伯乐在线 Swift： 介紹 | 《The Swift Programming Language》中文版 Swift必备Tips – 猫神的杰作 Let’s Swift – Swift站点导航 Swiftify | Objective-C to Swift Converter – 辅助将旧的* Objective-C代码转成Swift。 Swift.org – Apple Swift 官网 Swift - Blog – Apple Swift 官方博客 CocoaChina小组翻译的Swift版本 tutorialspoint – 有一些Swift教程 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"Efficiency","slug":"Efficiency","permalink":"https://blog.wangruofeng007.com/categories/Efficiency/"}],"tags":[]},{"title":"__autoreleasing的理解","slug":"2016-01-13-autoreleasingde-li-jie","date":"2016-01-12T20:27:10.000Z","updated":"2024-11-02T03:36:52.394Z","comments":true,"path":"2016/01/13/2016-01-13-autoreleasingde-li-jie/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-autoreleasingde-li-jie/","excerpt":"","text":"__autoreleasing 修饰符将对象赋值给附有__autoreleasing 修饰符的变量等同于ARC 无效时调用对象的autorelease方法。我们通过以下源代码来看一下 123@autoreleasepool &#123;id __autoreleasing obj = [[NSObject alloc] init];&#125; 该源代码主要将NSObject 类对象注册到autoreleasepool 中，可作如下变换： 123456/* 编译器的模拟代码 */id pool = objc_autoreleasePoolPush();id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj, @selector(init));objc_autorelease(obj);objc_autoreleasePoolPop(pool); 这与苹果的autorelease 实现中的说明（参考1.2.7 节）完全相同。虽然ARC 有效和无效时，其在源代码上的表现有所不同，但autorelease 的功能完全一样。 在alloc&#x2F;new&#x2F;copy&#x2F;mutableCopy 方法群之外的方法中使用注册到autoreleasepool 中的对象会如何呢？下面我们来看看NSMutableArray 类的array 类方法。 123@autoreleasepool &#123;id __autoreleasing obj = [NSMutableArray array];&#125; 这与前面的源代码有何不同呢？ 123456/* 编译器的模拟代码 */id pool = objc_autoreleasePoolPush();id obj = objc_msgSend(NSMutableArray, @selector(array));objc_retainAutoreleasedReturnValue(obj);objc_autorelease(obj);objc_autoreleasePoolPop(pool); 虽然持有对象的方法从alloc 方法变为objc_retainAutoreleasedReturnValue 函数， 但注册autoreleasepool 的方法没有改变，仍是objc_autorelease 函数。 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"https://blog.wangruofeng007.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"__attribute__","slug":"2016-01-13-attribute","date":"2016-01-12T20:10:33.000Z","updated":"2024-11-02T03:36:52.393Z","comments":true,"path":"2016/01/13/2016-01-13-attribute/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-attribute/","excerpt":"","text":"译自 Written by Mattt Thompson — January 14th, 2013 原文链接：http://nshipster.com/__attribute__/ 译者@oneruofeng 重复发布这个主题已经说明了同编译器保存健康关系的重要性,像任何草稿一样，作为一个实践者的效率取决于他们怎样对待他们的工具，你照顾好它们，它们反过来也会对你有好处。 __attribute__是一个编译器的指令在声明的时候指明了一些参数，这些参数允许更多的检查错误和高级的优化。 语法关键字是__attribute__紧跟2套圆括号（双圆括号让出现的宏更容易辨认，特别是在有多个属性的时候）。在括号内部是一个以逗号分隔的属性列表，__attribute__指令被放在函数，变量和类型声明后面。 12345678910 // Return the square of a numberint square(int n) __attribute__((const));// Declare the availability of a particular APIvoid f(void) __attribute__((availability(macosx,introduced=10.4,deprecated=10.6)));// Send printf-like message to stderr and exitextern void die(const char *format, ...) __attribute__((noreturn, format(printf, 1, 2))); 假如这个让你想起ISO C语言的 #pragma,你就不会感到孤单了。 实际上，当__attribute__被第一次引入到GCC编译器时，它面临一些阻力，有人建议使用专用的#pragma因为相同的目的。 这里，然而，有2个非常好的理由为什么__attribute__被添加进来 从一个宏中产生#pragma命令几乎是不能的（在C99 _Pragma 预算符以前）。 这里没人知道相同的#pragma在另一个编译器中可能的意思。 引用GCC Documentation for Function Attributes 这里有2个原因被应用到几乎所有的应用推荐使用#pragma,这犯了一个低级错误就是把#pragma使用到任何地方。 确实，假如你在苹果的框架中和牛逼工程师的开源项目中的头文件看一下现代的Objective-c–__attribute__被大量使用。（相反，#pragma的主要声明名声来着这些天是装饰:#pragma mark） 所以为了以后不费力，我们还是先看一下最重要的属性： GCCformat format属性指定了一个函数像printf,scanf,strftime或者strfmo风格的参数，这个参数应该是可以进行类型检查的一个格式化字符串。 123extern intmy_printf (void *my_object, const char *my_format, ...) __attribute__((format(printf, 2, 3))); Objective-C程序员也可使用__NSString__来格式化来做到相同的格式化规则，像在NNString中通过 +stringWithFormat: 和 NSLog()格式化字符串一样。 nonnull 这个nonnull属性指定了某些函数的参数必须是非空的指针。 123extern void *my_memcpy (void *dest, const void *src, size_t len) __attribute__((nonnull (1, 2))); 使用nonnull编码期望这个值遵守一个明确的约定中，这样能帮助捕获潜伏在任何代码调用的NULL指针bugs，请记住：编译时的错误 &gt;&gt; 运行时的错误。 noreturn 一些标准库函数，例如abort和exit,是不能返回的。GCC自动知道这些东西，这个noreturn属性用于指定任何其他函数永远不会返回的情况。 例如，AFNetworking 使用noreturn属性在它的网络请求线程进入点的方法里面,这个方法用在当大量产生专用的网络的线程里用来保证分离的线程持续执行在应用的整个生命周期中。 pure&#x2F;const pure属性指定了一个函数除了返回值没有副作用，例如它的返回值仅仅依赖参数和&#x2F;或者全局变量。这样的函数可以用公共子表达式消除并且循环优化就像一个算数操作符那样。 pure属性指定了一个函数不会检查任何值除了它们的参数，并且返回值没有副作用。注意到一个函数有一个指针参数并且需呀检查数据的指向不能声明成const。同样的，一个函数调用一个非nonst函数通常不能为const,一个const函数返回void并没有什么意义。 1int square(int n) __attribute__((const)); pure和const是两个执行在一个函数式编程惯例中的参数为了允许有效性能优化。const可以被认为是严格形式的pure因为它不依赖全局变量或者指针。 例如，因为一个函数声明为const的结果并不依赖任何东西除了传进来的参数。函数的结果能够缓存那个结果并且当函数被调用时返回，这样的函数叫做相同的组合参数（也就是说，我们知道一个数字的平方是一个常量，所以我们仅仅需要只计算它一次)。 unused 这个属性，附着在一个函数后面，意味着那个函数很可能不会被使用，GCC不会对这个函数产生警告。 用__unused关键词可以获得相同的效果，声明这个在方法实现中不会被使用的参数中。知道那以后一些上下文就可以允许编译器来做相应的优化。你很可能喜欢在delegate方法实现李勉使用__unused,因为协议频繁的提高更多的上下文比通常必要的情况，为了满足大量的潜在使用案例。 LLVM像GCC的很多特征一样，Clang也支持__attribute__,添加到它自己的小范围的扩展。为了检查某个属性的可用性，你可以直接使用__has_attribute属性。 availability Clang引进了availability属性，这个可以被取代在声明描述的生命周期中声明相对于操作系统的版本。思考对一个简单函数f：的函数声明 1void f(void) __attribute__((availability(macosx,introduced=10.4,deprecated=10.6,obsoleted=10.7))); availability属性声明f在OS X老虎系统中被引入，在OS X雪豹系统中被弃用，在OS X 山狮系统中被废弃。 这个信息被Clang用来决定什么时候使用f：函数式安全的，例如，假如Clang在OS X 美洲豹系统上编译，调用f()函数将成功。假如Clang在OS X雪豹系统中编译，函数调用将成功但是Clang会发出一个警告指明这个函数被弃用了。最后，假如Clang被引进编译OS X山狮系统的代码，函数调用将失败，因为f()函数已经不再可用了。 availability属性是一个逗号分隔的列表以平台名开始然后引入一些定语列举出生命周期内的重要里程碑事件附加额外的信息（以任何顺序）。 introduced：声明被引入的第一个版本 deprecated：声明被弃用的第一个版本，这意味着用户应该把这个API移走 obsoleted： 声明被废弃的第一个版本，这意味着它将被完全移除并且不能再使用 unavailable：声明在这个平台上将永远不可用 message：额外的消息将被Clang提供当忽略一个警告或者一个错误在使用一个被弃用或者被废弃的声明。对引导用户替换APIs很有用。 在声明时可以使用多个availability属性，每个对应不同的平台，仅当availability属性对应相应的目标平台被使用的时候，任何其他才将被忽略。假如没有availability 属性指定可用性对现在的目标平台，availability 属性将被忽略。 支持的平台 ios：苹果的iOS操作系统。最小的部署目标被指定通过-mios-version-min=*version*或者-miphoneos-version-min=*version*命令行参数。 macosx：苹果的OS X 操作系统，最小的部署目标被指定通过-mmacosx-version-min=*version*命令行参数 overloadable Clang提供对C++函数在C中重载的支持。在C中函数重载被引进使用overloadable属性。例如，一个可能提供一个重载版本的tgsin函数来精确执行相关的标准函数计算float,double,long double的正弦值： 1234#include &lt;math.h&gt;float __attribute__((overloadable)) tgsin(float x) &#123; return sinf(x); &#125;double __attribute__((overloadable)) tgsin(double x) &#123; return sin(x); &#125;long double __attribute__((overloadable)) tgsin(long double x) &#123; return sinl(x); &#125; 请注意overloadable只对函数起作用。你可以重载方法声明在某种范围内通过使用通用的返回值和参数类型，想id或者void *. 上下文是国王当它遇到编译器优化时。通过提供限制在怎样解析你的代码，增加你参数尽可能高效代码的可能性。遇到编译器把你打断，这将是一项奖励。 还有__attribute__并不仅仅对编译器有用：下一个人看代码也将感谢这些额外的上下文。所以多走几英尺远将对你的合作中和接替者或者从现在算2年以后的你(那个时候你已经忘记了所以的事情关于这份代码)自己有用 你付出了多少爱,最终你会得到多少爱。 译者注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://blog.wangruofeng007.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"编译器","slug":"编译器","permalink":"https://blog.wangruofeng007.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"RunLoop详解","slug":"2016-01-13-runloopxiang-jie","date":"2016-01-11T20:44:06.000Z","updated":"2024-11-02T03:36:52.400Z","comments":true,"path":"2016/01/12/2016-01-13-runloopxiang-jie/","permalink":"https://blog.wangruofeng007.com/2016/01/12/2016-01-13-runloopxiang-jie/","excerpt":"","text":"NSRunLoop是什么？在Cocoa中，每个线程(NSThread)对象中内部都有一个run loop（NSRunLoop）对象用来循环处理输入事件. NSRunloop并不真的是一个loop，的apple的文档中 也提到了需要自己写while或者for语句来实现,类似下面： 123while(running)&#123; [NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];&#125; 何为Run loop 事件源从字面翻译来看，run loop就是一个运行循环，的确它就是一个处理输入时间的运行循环，为什么需要这样处理，难道没有事件发生的时候让线程空转浪费资源？很明显在有事件发生的时候唤醒线程，没有事件发生的时候让其sleep更好。 下面我还是拿这张百看不厌的图来说事： 处理的事件包括两类 来自Timer sources的同步事件 来自Input sources的异步事件 1.Time Source. Timer sources deliver synchronous events, occurring at a scheduled time or repeating interval.苹果文档中有句话需要注意， Timer sources deliver events to their handler routines but do not cause the run loop to exit.* 创建NSTimer添加到run loop中的时候，这里需要注意的是，NSTimer默认是处于NSDefaultRunloopMode，这也就可以解释为什么如果你在你的控制器中添加了一个timer定时刷新你的界面，而你在拖动视图的时候timer不回fire，因为这个时候你的runloop 是NSEventTrackingRunloopMode,在这个mode下timer不回fire 2.input source input source 主要是一些异步的事件，比如来自其它线程或者其它app的消息。 input source 传递异步事件到其对应的处理函数，并且使runUntilDate(与线程相关联的runloop对象调用)返回 为了能够处理input sourcr，run loops 产生notifications.通过注册成run-loop observers可以接受到这些通知（通过Core Foundation 来注册observers）. RunLoopMode有哪些？run loop在处理输入事件时会产生通知，可以通过Core Foundation向线程中添加run loop observers来监听特定事件,以在监听的事件发生时做附加的处理工作。 每个run loop可运行在不同的模式下,一个run loop mode是一个集合，其中包含其监听的若干输入事件源，定时器，以及在事件发生时需要通知的run loop observers。运行在一种mode下的run loop只会处理其run loop mode中包含的输入源事件，定时器事件，以及通知run loop mode中包含的observers。 Cocoa中的预定义模式有: Default模式 定义NSDefaultRunLoopMode (Cocoa) kCFRunLoopDefaultMode (Core Foundation) 描述：默认模式中几乎包含了所有输入源(NSConnection除外),一般情况下应使用此模式，这是最常用的run loop mode。 Connection模式 定义：NSConnectionReplyMode(Cocoa) 描述：处理NSConnection对象相关事件，系统内部使用，这个mode表明NSConnection对象等待reply,用户基本不会使用。 Modal模式 定义：NSModalPanelRunLoopMode(Cocoa) 描述：处理modal panels事件,需要等待处理的input source为modal panel时设置，比如NSSavePanel和NSOpenPanel。 Event tracking模式 定义：UITrackingRunLoopMode(iOS) NSEventTrackingRunLoopMode(cocoa) 描述：使用该模式来处理用户界面相关的事件,例如在拖动loop或其他user interface tracking loops时处于此种模式下，在此模式下会限制输入事件的处理。例如，当手指按住UITableView拖动时就会处于此模式。 Common模式 定义：NSRunLoopCommonModes (Cocoa) kCFRunLoopCommonModes (Core Foundation) 描述：这是一个伪模式，其为一组run loop mode的集合，将输入源加入此模式意味着在Common Modes中包含的所有模式下都可以处理。在Cocoa应用程序中，默认情况下Common Modes包含default modes,modal modes,event Tracking modes, 可使用CFRunLoopAddCommonMode方法向Common Modes中添加自定义modes。 注意这个并不是一个特定的mode，而是一个mode的集合，而runloop必须运行在一个特定的mode下。 获取当前线程的runloop mode 1NSString* runLoopMode = [[NSRunLoop currentRunLoop] currentMode]; NSTimer、NSURLConnection与UITrackingRunLoopModeNSTimer与NSURLConnection默认运行在default mode下，这样当用户在拖动UITableView处于UITrackingRunLoopMode模式时，NSTimer不能fire,NSURLConnection的数据也无法处理。NSTimer的例子:在一个UITableViewController中启动一个0.2s的循环定时器，在定时器到期时更新一个计数器，并显示在label上。 123456789101112131415161718- (void)viewDidLoad &#123; label =[[UILabel alloc]initWithFrame:CGRectMake(10, 100, 100, 50)]; [self.view addSubview:label]; count = 0; NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval: 0.2 target: self selector: @selector(incrementCounter:) userInfo: nil repeats: YES];&#125;- (void)incrementCounter:(NSTimer *)theTimer&#123; count++; label.text = [NSString stringWithFormat:@&quot;%zd&quot;,count];&#125; 在正常情况下，可看到每隔0.2s，label上显示的数字+1,但当你拖动或按住tableView时，label上的数字不再更新，当你手指离开时，label上的数字继续更新。当你拖动UItableView时，当前线程run loop处于UIEventTrackingRunLoopMode模式，在这种模式下，不处理定时器事件，即定时器无法fire,label上的数字也就无法更新。解决方法，一种方法是在另外的线程中处理定时器事件，可把Timer加入到NSOperation中在另一个线程中调度;还有一种方法时修改Timer运行的run loop模式，将其加入到UITrackingRunLoopMode模式或NSRunLoopCommonModes模式中。即 1[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode]; 或 1[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 另外一种是放到NSThread中 1234567891011121314151617181920- (void)viewDidLoad&#123; [super viewDidLoad]; NSLog(@&quot;主线程 %@&quot;, [NSThread currentThread]); //创建并执行新的线程 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil]; [thread start];&#125;- (void)newThread&#123; @autoreleasepool&#123; //在当前Run Loop中添加timer，模式是默认的NSDefaultRunLoopMode [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(timer_callback) userInfo:nil repeats:YES]; //开始执行新线程的Run Loop，如果不启动run loop，timer的事件是不会响应的 [[NSRunLoop currentRunLoop] run]; &#125;&#125;- (void)timer_callback&#123; NSLog(@&quot;Timer %@&quot;, [NSThread currentThread]);&#125; NSURLConnection也是如此，见SDWebImage中的描述,以及SDWebImageDownloader.m代码中的实现。修改NSURLConnection的运行模式可使用scheduleInRunLoop:forMode:方法。 123456NSURL *url = [NSURL URLWithString:@&quot;https://www.baidu.com&quot;];NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:15];self.connection = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:NO];[connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];[connection start]; 参考资料： Threading Programming Guide – Run Loops NSRunLoop Class Reference NSURLConnection Class Reference NSTimer Class Reference CFRunLoop wiki SDWebImage TestButtonDown 关于NSRunloop的学习和理解 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"RunLoop","slug":"RunLoop","permalink":"https://blog.wangruofeng007.com/tags/RunLoop/"}]},{"title":"iOS7 tintColor详解","slug":"2016-01-13-ios7-tintcolorxiang-jie","date":"2016-01-11T20:41:39.000Z","updated":"2024-11-02T03:36:52.397Z","comments":true,"path":"2016/01/12/2016-01-13-ios7-tintcolorxiang-jie/","permalink":"https://blog.wangruofeng007.com/2016/01/12/2016-01-13-ios7-tintcolorxiang-jie/","excerpt":"","text":"为什么需要出现tintColor ？ 解决以前不方便统一设置视图颜色风格的通点，方便自定义系统控件外观 跟UIAppearance协议设计有点类似，UIAppearance是为了方便统一 设置一类控件的外观，而tintColor是为方便设置某个控件的外观，或者 说某个容器内所有控件的风格。 像在UIViewController 中，通过这段代码可以实现容器内，所有的子view风格统一化,这样在这个控制器中的所有子view都会以tintColor显示 1self.view.tintAdjustmentMode = UIViewTintAdjustmentModeNormal UIView的tintAdjustmentMode需要说明一下，这是一个UIViewTintAdjustmentMode枚举 UIViewTintAdjustmentModeAutomatic（着色调整模式自动） UIViewTintAdjustmentModeNormal（着色调整模式正常） UIViewTintAdjustmentModeDimmed（着色调整模式变暗，打开控风格会变成灰白模式） 先看看官方API说明 iOS7以后所有的UIView以及它的子类都新增了一个叫tintColor的接口，方便我们对视图进行颜色调整 注意事项 UIImageView需要设置renderingMode为UIImageRenderingModeAlwaysTemplate才能生效。renderingMode是一个类型为UIImageRenderingMode的枚举 UIImageRenderingModeAutomatic （默认渲染模式，自动模式） UIImageRenderingModeAlwaysOriginal（总是绘制原来的图片，不把它当成临时图片来处理） UIImageRenderingModeAlwaysTemplate （总是绘制临时图片，会忽略它原本的颜色信息，也就是根据tintColor生产图片） UIImageView的使用12UIImage *image = [UIImage imageNamed:@&quot;xxx.png&quot;];image = [image imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate]; tintColor更新在子类中重写- (void)tintColorDidChange 方法，就可以实现每次更新tintColor的时候调用相关配置 12345- (void)tintColorDidChange&#123; _tintColorLabel.textColor = self.tintColor; _tintColorBlock.backgroundColor = self.tintColor;&#125; 参考链接 Demo - iOS7 tintColor day by day","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"Skill","slug":"Skill","permalink":"https://blog.wangruofeng007.com/tags/Skill/"},{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/tags/iOS/"}]},{"title":"MacOSX10.11上用Octopress和GitHub搭建个人博客","slug":"2016-01-13-macosx10-dot-11shang-yong-octopresshe-githubda-jian-ge-ren-bo-ke","date":"2015-12-11T20:30:38.000Z","updated":"2024-11-02T06:08:18.362Z","comments":true,"path":"2015/12/12/2016-01-13-macosx10-dot-11shang-yong-octopresshe-githubda-jian-ge-ren-bo-ke/","permalink":"https://blog.wangruofeng007.com/2015/12/12/2016-01-13-macosx10-dot-11shang-yong-octopresshe-githubda-jian-ge-ren-bo-ke/","excerpt":"","text":"序言经过一晚上的折腾，终于从Hexo成功转入Octopress,那么本文就来细说一下如何使用 Octopress+GitHub Pages搭建个人博客 为什么选择 Octopress &amp; Github Pages? 免费且独立。把 Octopress 博客系统搭建到 Github Pages 虽是免费，但不失独立性，即便 Github 全站关闭，你也将有一份本地全站备份，随时可以重新恢复。不必受托管商之气，而且还免费，如果你愿意，甚至可以自行插入广告挣钱。 版本控制。写文章，建网站，做软件都需要修改，但有时候改完了又会后悔，如果有时光机就好了，Git 就是你的时光机。当然如果你不想了解这些看上去很唬人的 IT 名词，只是想写博客的话，请在需要的时候再研究这条的内容。 相对其他托管到 Github 上的博客程序，Octopress 更加成熟易上手。打个比方，Jekyll 可以说是毛坯房，Hexo 和 Octopress 算是简装修，但相比 Hexo，Octopress 有更多装修范例和更多熟练的装修工人，更容易获取帮助。当然如果你只想住精装修的房子，那不得不花点钱上 WordPress 了 使用 Markdown。Markdown 是现在最为流行的轻量级标记语言，也是已故的天才 Aaron Swartz 留给世人最好的礼物，窃以为每个在互联网上发布文章的人都该掌握。 按照官方的说法，Octopress 是个A blogging framework for hackers(「为黑客设计的博客框架」)，这很酷，你不觉得吗？ 如果你之前没有写过博客，打算开始搭建自己第一个博客的话，其实也不妨试试 Octopress，免费还能学到东西，何乐而不为？ 本文是在OS X EI Capitan系统上搭建一个基于Octopress的个人博客系统，记录搭建过程的各种坑，希望对有想搭建个人博客的朋友有所帮助。 本文是建立在你有Shell指令基础和Git操作基础之上，如果不了解的话，需要查阅相关资料。 先解释几个专业术语： Ruby Ruby 是一种编程语言。Octopress 是用 Ruby语言 实现的。我们不需要对它有太多了解，只需要正确安装 Ruby 的环境（Ruby版本必须不低于1.9.3-p0，后面会详细介绍）及按步骤执行指令即可。 RubyGems RubyGems（简称 gems）是一个用于对 Ruby组件进行打包的 Ruby 打包系统。它可以用来查找、安装、升级和卸载软件包。我们也是通过它安装Octopress包的 RVM RVM 是Ruby Version Manager的简称，是一款 Ruby 语言安装、管理的工具。我们对 Ruby 的操作是通过它的指令完成的。 Jekyll Jekyll 一个简单的博客形态的静态站点生产机器。 Jekyll 有一套模板目录，可以将 Markdown文件（或者Textile）转换为静态网页，并生成一个完整的可发布的静态网站。 同时，我们可以将产生的静态网站布置到 GitHub Pages 上，生成个人博客站点。 想了解更多内容可以查看中文文档。 Octopress Octopress 是基于 Jekyll 的博客框架。他们的关系就像 jQuery 与 js 的关系一样。 它为我们提供了现成的美观的主题模板，并且配置简单，使用方便，大大降低了我们建站的门槛。 Git 分布式版本控制工具，跟它有点类似的是SVN，只是两者使用场景不一样。 GitHub GitHub 是全球最热的开源社区，程序界的 Facebook。它为我们提供代码托管服务，以及我们搭建博客所需要的 Pages 服务。 GitHub Pages GitHub Pages 是 GitHub 提供的一项服务。它用于显示托管在 GitHub 上的静态网页。所以我们可以用 Github Pages 搭建博客，当然我们也可以把项目的文档和主页放在上面。 通过以上内容，我们大概能够明白 Octopress 建站的原理：我们使用基于 Jekyll 的 Octopress 站点生成工具，生成本地的静态网站。然后将静态网站托管到 GitHub 为我们提供的 GitHub Pages 服务上。访问 username.github.io 即可显示你的个人博客站了 明白了上面这些内容，下面进行具体的搭建工作： 第一步：安装 RubyMac自带Ruby环境打开终端，安装 RVM ，终端执行指令： 1$ curl -L https://get.rvm.io | bash -s stable --ruby 接下来我们要查看自己的 Ruby 环境 1$ ruby -v 如果你的 Ruby 版本不低于 1.9.3-p0 可以忽略 Ruby 的安装（或升级），直接跳到安装 RubyGems 。 否则，我们执行之后的操作，终端执行指令： 12$ rvm install 1.9.3$ rvm use 1.9.3 然后安装 RubyGems， 终端执行指令： 1$ rvm rubygems latest 到这里第一步完成。我们可以再执行一次第一条指令 ruby -v 来查看当前 Ruby 的版本了。 第二步：安装Octopress因为Mac系统自动git环境，所以我们不需要考虑git的安装。直接将 Octopress的项目clone到本地，在终端执行指令： 1$ git clone git://github.com/imathis/octopress.git octopress 完成后进入 octopress 的目录 1$ cd octopress 接下来，安装依赖： 12345$ gem install bundler# 这时你可能会遇到没有权限的问题，那么我们需要加上sudo重新执行，并输入密码。$ sudo gem install bundler# 接下来执行：$ bundle install 这时你可能还会遇到问题如下： 12345Fetching gem metadata from https://rubygems.org/...........Resolving dependencies...Gem::RemoteFetcher::FetchError: SocketError: getaddrinfo: Name or service not known (https://rubygems.org/gems/rake-10.4.2.gem)An error occurred while installing rake (10.4.2), and Bundler cannot continue. 这是因为被墙了，解决办法有两个： 一个是，可以使用自己的翻墙工具； 另一个，淘宝做了一个gem的镜像。我们需要在Octopress的文件目录下找到Gemfile文件，将其中的source &#39;https://rubygems.org/&#39;改为source &#39;https://ruby.taobao.org/&#39; 再重新运行bundle install就可以了。 这段内容可以参考 bundle install 提示如下，是需要翻墙解决么。 下面就可以安装 Octopress 的默认主题了，终端执行指令： 1rake install 这样一个最基本的个人博客站就产生了。 安装octostrap3主题（可选）1234$ cd octopress$ git clone https://github.com/kAworu/octostrap3.git .themes/octostrap3$ rake &quot;install[octostrap3]&quot;$ rake generate 会提示以下信息 1A theme is already installed, proceeding will overwrite existing files. Are you sure? [y/n] 输入y继续，然后开始安装。。。 1234567## Copying octostrap3 theme into ./source and ./sassmkdir -p sourcecp -r .themes/octostrap3/source/. sourcemkdir -p sasscp -r .themes/octostrap3/sass/. sassmkdir -p source/_postsmkdir -p public 显示上面的内容完成后没有错误，就安装主题完成 可以看出，现在显示得都是预设值，并不是我们想要的，所以需要修改Octopress目录下的_config.yml文件。 文件目录_config.yml 描述：保存配置数据。很多配置选项都会直接从命令行中进行设置，但是如果你把那些配置写在这儿，你就不用非要去记住那些命令了。 _config.yml 文件共分为3个部分内容 Main Configs Jekyll &amp; Plugins 3rd Party Settings 目前，我们只需要关注第一部分Main Configs。 # ----------------------- # # Main Configs # # ----------------------- # #网站地址 url: http://wangruofeng.github.io #网站标题 title: 王若风的技术博客 #网站副标题 subtitle: 天天向上. #网址作者，通常显示在页尾和每篇文章的尾部 author: Ace #搜索引擎 #simple_search: http://google.com/search #网站的描述，出现在HTML页面中的 meta 中的 description #description: 对应填入你的个人信息，其中url为必填的，一般填GitHub仓库对应的连接，其内容大致就是 username.github.io ，这个地址我们会在后面步骤中获得。 第三步：集成 GitHub Pages1.注册 Github 账号 这个没什么好说的，早晚需要，去 http://github.com 注册吧。 2.在 GitHub 上创建一个代码参考，项目名称命名规则为 username.github.io，username必须与用户名称一致。 域名指向（可选）如果你有自己的域名可用，可以在这时就配置好，毕竟解析起来需要一段时间，不如在我们搭建博客的时候让它开始，这样我们搭建完成后，基本上就可以直接用自有域名访问了。 我的是在万网申请的，原价一年100多点现在有活动便宜的几块的都有，想要个性域名的可以去注册一个。 如果你用的是顶级域名，比如 wangruofeng007.com, 请创建两个 A 记录 (A Record) 分别指向 192.30.252.153 和 192.30.252.154. 如果你使用二级域名，比如 blog.wangruofeng007.com, 请将该域名的 CNAME 指向 [your_username].github.io, 把其中的 [your_username]换成你自己在 Github 上的用户名。 如果你暂时没有域名，这一步可以暂时不用管 Ps. 在创建过程中最好不要添加忽略文件和README文件。因为我们要把本地的 git 仓库同步到 GitHub 远程仓库中。如果再远程仓库中添加了其他文件，需要我们执行 pull 操作。除非你能非常熟练的使用 git ，否则不建议你制造不必要的麻烦。接下来将本地代码仓库同步到 GitHub 上，执行终端指令： 1$ rake setup_github_pages 它会要求你绑定远程仓库的地址，此时只需要输入即可： 1$ git@github.com:username/username.github.com.git 这样就会将 Octopress 生成的静态站点与 GitHub 进行绑定了。 之后我们创建第一篇文章： 1rake new_post[&quot;title&quot;] 然后会有一个名为 yyyy-mm-dd-Post-Title.markdown 的文件在 octopress&#x2F;source&#x2F;_posts 目录下生成，其中 yyyy-mm-dd 是你当时的日期。然后执行以下命令： 12cd source/_posts/vim yyyy-mm-dd-Post-Title.markdown 即可用 vim 编辑器编辑的刚才的文章了，好吧我知道你作为这篇文章的读者并不是一个能熟练使用 vim 的人，那么请在命令行输入 q！退出这个编辑器。如果你不想假装是个黑客的话，其实发布文章并不需要这么麻烦。 我们直接打开 octopress/source/_posts 文件夹，找到刚才生成的文件，用你喜欢的 Markdown 编辑器（免费的我推荐 Mou或者Atom）或者文本编辑器打开，对文章内容进行编辑。 打开文件后，你会发现文章开头有这么一段信息: 1234567--- layout: post title: &quot;Post Title&quot; date: yyyy-mm-dd hh:mm:ss comments: true categories: &quot;&quot;--- 这其实是这篇文章的元数据：layout 暂时不要理会；title 是这篇文章显示在最终网页上的标题；date 部分是详细的文件生成时间，如 2014-01-28 03:35:00；comment 部分表示是否允许评论，目前显示是允许，如果想关闭评论，请改为 false；categories 指这篇文章的分类目录，请在后面引号中输入,不用引号也可以，多个分类用空格隔开，如果没有该目录，则会自动生成。请不要删除这段信息，在这段信息下面开始你的文章内容 这件事情给我们的启发是，以后发布文章，其实并不需要使用终端命令行生成文件。可以直接将自己写好的文章放到这个文件夹下面，当然请按照 yyyy-mm-dd-Post-Title.markdown 这样的文件格式命名，同时记得在文章前面添加元数据信息。这种做法生成的文章与上面的方法无异 生成的新文章在source&#x2F;_post&#x2F;目录下，文件名构成为时间和标题的拼音。我们可以用Markdown编辑器对文章进行修改。之后生成静态站点，终端执行指令： 12# 生成静态站点$ rake generate 如果你想预览本地的站点，可以执行终端指令： 12# 预览静态站点$ rake preview 此时，可以使用浏览器打开localhost:4000 查看效果。如果没有问题可以将静态站点同步到 GitHub 远程仓库中，终端执行指令： 12# 同步内容$ rake deploy 你会发现我们的静态站点已经被 push 到 GitHub仓库的 master 分支上。稍等几分钟，访问 username.github.io (或者 username.github.com)，就会发现你的个人博客站已创建成功了。如果你还想给自己的本地资源文件（如Markdown文件等内容）也同步到 GitHub 中，可以执行以下指令： 123$ git add .$ git commit -m &quot;comment&quot;$ git push origin source 这样我们的资源文件就会同步到 GitHub 的 source 分支了。 使用自己的域名（可选）如果你有自己的域名，并且想指向这个新博客的话，请首先确保执行了第三步的域名指向（可选）的内容。如果没有执行，可以随时执行。然后执行下面的命令，注意把 your-domain.com 换成你自己的域名。 1echo &#x27;your-domain.com&#x27; &gt;&gt; source/CNAME 这句话的意思是在source分支下创建一个CNAME的文件并且将your-domain.com写入文件 然后再次执行以下命令： 12rake generaterake deploy 或者二合一 1rake gen_deploy 这样你就可以使用自己的域名了。域名解析需要一段时间，如果没有马上生效，请不要着急。如果长时间没有生效，请确保完整执行了 域名指向（可选）和使用自己的域名（可选）的内容。 现在我们完成了个人博客的初级搭建，足够满足我们的基本需求。 错误处理出现下面的错误： 12Pushing generated _deploy website Permission denied (publickey).fatal: Could not read from remote repository. 这个错误是因为缺少SSH keys ，只有拥有这个key才有权限push到远程仓库，通过这种方式实现权限安全控制。解决方案:Generating SSH keys 出现下面错误： 12345678## Pushing generated _deploy websiteTo git@github.com:wangruofeng/wangruofeng.github.io.git ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to &#x27;git@github.com:wangruofeng/wangruofeng.github.io.git&#x27;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: &#x27;git pull ...&#x27;) before pushing again.hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details. 原因，是修改了远程仓库，导致本地本地版本落后于远程仓库版本。最佳解决方案： 1234cd octopress/_deploygit pull origin mastercd ..rake deploy 参考链接：rake-gen-deploy-rejected-in-octopress 参考资料： 唐巧的博客: [象写程序一样写博客：搭建基于github的博客]（http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/） 觅珠人: 第一篇博文：用Octopress搭建博客系统 破船之家: 你好！github页面 opoo.org: Octopress 博客系统 —— a Blogging Framework for Hackers Ocotpress: Octopress Documentation Havee’s Space: 为 Octopress 添加多说评论系统 colors4.us: Octopress博客从零开始 III 浮生猎趣:用Octopress在Github搭建博客，并绑定独立域名 Aster0id的个人博客:制作个人博客站（一）：Mac系统下使用 Octopress + GitHub Pages 搭建个人博客 octopress博客搭建和个性化配置 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://blog.wangruofeng007.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.wangruofeng007.com/tags/Hexo/"}]}],"categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://blog.wangruofeng007.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"dart","slug":"dart","permalink":"https://blog.wangruofeng007.com/categories/dart/"},{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.wangruofeng007.com/categories/Swift/"},{"name":"生活","slug":"生活","permalink":"https://blog.wangruofeng007.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"资料收集","slug":"资料收集","permalink":"https://blog.wangruofeng007.com/categories/%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"},{"name":"OC","slug":"OC","permalink":"https://blog.wangruofeng007.com/categories/OC/"},{"name":"Unix","slug":"Unix","permalink":"https://blog.wangruofeng007.com/categories/Unix/"},{"name":"Git","slug":"Git","permalink":"https://blog.wangruofeng007.com/categories/Git/"},{"name":"Watch OS2","slug":"Watch-OS2","permalink":"https://blog.wangruofeng007.com/categories/Watch-OS2/"},{"name":"Database","slug":"Database","permalink":"https://blog.wangruofeng007.com/categories/Database/"},{"name":"Animation","slug":"Animation","permalink":"https://blog.wangruofeng007.com/categories/Animation/"},{"name":"Efficiency","slug":"Efficiency","permalink":"https://blog.wangruofeng007.com/categories/Efficiency/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.wangruofeng007.com/tags/Hexo/"},{"name":"物联网","slug":"物联网","permalink":"https://blog.wangruofeng007.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"ChatGPT, OpenAI, AIGC","slug":"ChatGPT-OpenAI-AIGC","permalink":"https://blog.wangruofeng007.com/tags/ChatGPT-OpenAI-AIGC/"},{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/tags/%E6%95%88%E7%8E%87/"},{"name":"flutter","slug":"flutter","permalink":"https://blog.wangruofeng007.com/tags/flutter/"},{"name":"Typora","slug":"Typora","permalink":"https://blog.wangruofeng007.com/tags/Typora/"},{"name":"Runtime","slug":"Runtime","permalink":"https://blog.wangruofeng007.com/tags/Runtime/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://blog.wangruofeng007.com/tags/CocoaPods/"},{"name":"Skill","slug":"Skill","permalink":"https://blog.wangruofeng007.com/tags/Skill/"},{"name":"翻译","slug":"翻译","permalink":"https://blog.wangruofeng007.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Favorite","slug":"Favorite","permalink":"https://blog.wangruofeng007.com/tags/Favorite/"},{"name":"音视频","slug":"音视频","permalink":"https://blog.wangruofeng007.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"动画","slug":"动画","permalink":"https://blog.wangruofeng007.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"Debug","slug":"Debug","permalink":"https://blog.wangruofeng007.com/tags/Debug/"},{"name":"剪切板","slug":"剪切板","permalink":"https://blog.wangruofeng007.com/tags/%E5%89%AA%E5%88%87%E6%9D%BF/"},{"name":"Unix","slug":"Unix","permalink":"https://blog.wangruofeng007.com/tags/Unix/"},{"name":"Git","slug":"Git","permalink":"https://blog.wangruofeng007.com/tags/Git/"},{"name":"iWatch","slug":"iWatch","permalink":"https://blog.wangruofeng007.com/tags/iWatch/"},{"name":"iWatch OS2","slug":"iWatch-OS2","permalink":"https://blog.wangruofeng007.com/tags/iWatch-OS2/"},{"name":"网络","slug":"网络","permalink":"https://blog.wangruofeng007.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.wangruofeng007.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"设计模式","slug":"设计模式","permalink":"https://blog.wangruofeng007.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.wangruofeng007.com/tags/Swift/"},{"name":"事件处理","slug":"事件处理","permalink":"https://blog.wangruofeng007.com/tags/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"},{"name":"CAShapeLayer","slug":"CAShapeLayer","permalink":"https://blog.wangruofeng007.com/tags/CAShapeLayer/"},{"name":"内存管理","slug":"内存管理","permalink":"https://blog.wangruofeng007.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"编译器","slug":"编译器","permalink":"https://blog.wangruofeng007.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"RunLoop","slug":"RunLoop","permalink":"https://blog.wangruofeng007.com/tags/RunLoop/"},{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/tags/iOS/"}]}