{"meta":{"title":"王若风的技术博客","subtitle":"世界尽头の冷酷仙境","description":"王若风的技术博客","author":"王若风","url":"https://blog.wangruofeng007.com","root":"/"},"pages":[{"title":"分类","date":"2024-11-02T05:43:56.000Z","updated":"2024-11-02T05:46:10.309Z","comments":true,"path":"categories/index.html","permalink":"https://blog.wangruofeng007.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-11-02T05:44:19.000Z","updated":"2024-11-02T05:46:14.793Z","comments":true,"path":"tags/index.html","permalink":"https://blog.wangruofeng007.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式 与 Flutter","slug":"设计模式-与-Flutter","date":"2024-11-02T08:38:31.000Z","updated":"2024-11-03T05:54:13.974Z","comments":true,"path":"2024/11/02/设计模式-与-Flutter/","permalink":"https://blog.wangruofeng007.com/2024/11/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%8E-Flutter/","excerpt":"写在最前比起设计模式，个人认为这 3 条原则更加重要： DRY（Don’t Repeat Yourself）：尽量在项目中减少重复的代码行，重复的方法，重复的模块。其实许多设计原则和模式最本质的思想都是在消除重复。 KISS（Keep It Simple, Stupid）：让代码简单直接，用简单的方法解决复杂的问题，保持代码可读性和可维护性，足够简单，也就意味着很容易读懂，这就让 BUG 不容易隐藏且更容易修复。 YAGNI（You aren’t gonna need it）：只有当你需要的时候才去添加额外的功能，不要过度设计。我们经常会在开发当中尽可能的迎合未来可能的需求。而为了迎合某些产生概率极低的需求而设计的成本是非常高的，这种过度设计的收益非常低。可能你深思熟虑的设计花了不少时间成本，却在未来的两三年内这个设计却完全没有派上用场。一些设计是否必要，更多的应该基于当前的情况。而不是为了应对未来的各种变化，画蛇添足的设计。","text":"写在最前比起设计模式，个人认为这 3 条原则更加重要： DRY（Don’t Repeat Yourself）：尽量在项目中减少重复的代码行，重复的方法，重复的模块。其实许多设计原则和模式最本质的思想都是在消除重复。 KISS（Keep It Simple, Stupid）：让代码简单直接，用简单的方法解决复杂的问题，保持代码可读性和可维护性，足够简单，也就意味着很容易读懂，这就让 BUG 不容易隐藏且更容易修复。 YAGNI（You aren’t gonna need it）：只有当你需要的时候才去添加额外的功能，不要过度设计。我们经常会在开发当中尽可能的迎合未来可能的需求。而为了迎合某些产生概率极低的需求而设计的成本是非常高的，这种过度设计的收益非常低。可能你深思熟虑的设计花了不少时间成本，却在未来的两三年内这个设计却完全没有派上用场。一些设计是否必要，更多的应该基于当前的情况。而不是为了应对未来的各种变化，画蛇添足的设计。 设计模式历史1994 年， 埃里希·伽玛、 约翰·弗利赛德斯、 拉尔夫·约翰逊、 理查德·赫尔姆这四位作者出版了 《设计模式： 可复用面向对象软件的基础》 一书， 将设计模式的概念应用到程序开发领域中。 该书提供了 23 个模式来解决面向对象程序设计中的各种问题， 很快便成为了畅销书。 由于书名太长， 人们将其简称为 “四人组 （Gang of Four， GoF） 的书”， 并且很快进一步简化为 “GoF 的书”。 三大类设计模式根据其意图或目的，可以分为三种主要的模式类别： 六大原则（SOLID） 创建型 单例模式 (Singleton) 单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/single 单例 （Sin­gle­ton） 类声明了一个名为 get­Instance 的静态方法来返回其所属类的一个相同实例。 单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 get­Instance 方法必须是获取单例对象的唯一方式。 123456class Singleton &#123; Singleton._(); static late final Singleton _instance = Singleton._(); static Singleton get instance =&gt; _instance;&#125; 简单工厂模式 * (Simple Factory) 简单工厂模式 不在 23 种 GoF 设计模式中，却是我们最常使用的一种编程方式。 主要涉及到一个特殊的方法，专门用来提供我们想要的实例对象（对象工厂），我们可以将这个方法放到一个单独的类 SimpleFactory 中，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243class SimpleFactory &#123; /// 工厂方法 static Product createProduct(int type) &#123; switch (type) &#123; case 1: return Product1(); case 2: return Product2(); default: return Product3(); &#125; &#125;&#125;// 抽象类abstract class Product &#123; String? name; String? color;&#125;// 实现类 1class Product1 implements Product &#123; @override String? name = &#x27;Product 1&#x27;; @override String? color = &#x27;red&#x27;;&#125;// 实现类 2class Product2 implements Product &#123; @override String? name = &#x27;Product 2&#x27;; @override String? color = &#x27;green&#x27;;&#125;// 实现类 3class Product3 implements Product &#123; @override String? name = &#x27;Product 3&#x27;; @override String? color = &#x27;blue&#x27;;&#125; 当我们想要在代码中获取对应的类型对象时，只需要通过这个方法传入想要的类型值即可，我们不必关心生产如何被生产以及哪个对象被选择的具体逻辑： 1final Product product = SimpleFactory.createProduct(1); 这就是 简单工厂模式。说到这里，就不得不提到 Dart 中特有的 factory 关键词了。 factory 关键词 可以用来修饰 Dart 类的构造函数，意为 工厂构造函数，它能够让 类 的构造函数天然具有工厂的功能，使用方式如下： 12345678910111213141516abstract class Product &#123; String? name; String? color; // 工厂构造函数 factory Product.createProduct(int type) &#123; switch (type) &#123; case 1: return Product1(); case 2: return Product2(); default: return Product3(); &#125; &#125;&#125; 工厂模式 (Factory Method) 工厂方法模式 是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/factory 产品 （Prod­uct） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。 具体产品 （Con­crete Prod­ucts） 是产品接口的不同实现。 创建者 （Cre­ator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。 注意， 尽管它的名字是创建者， 但它最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。 具体创建者 （Con­crete Cre­ators） 将会重写基础工厂方法， 使其返回不同类型的产品。 注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。 Flutter Demo 应用 在 Flutter 中，Widget 就属于 Product 抽象类，每一个具体实现的 Widget 都属于 Con­crete Prod­uct。 假如我们需要区分 Android 、iOS 等平台来显示不同的对话框： 1234567891011121314151617181920212223242526272829abstract class CustomDialog &#123; Widget create(BuildContext context); Future&lt;T?&gt; show&lt;T&gt;(BuildContext context) &#123; final dialog = create(context); return showDialog(context: context, builder: (context) =&gt; dialog); &#125;&#125;class AndroidAlertDialog extends CustomDialog &#123; @override Widget create(BuildContext context) &#123; return const AlertDialog(); &#125;&#125;class IOSAlertDialog extends CustomDialog &#123; @override Widget create(BuildContext context) &#123; return const CupertinoAlertDialog(); &#125;&#125;// 使用void test(BuildContext context) &#123; // final dialog = AndroidAlertDialog(); final dialog = IOSAlertDialog(); dialog.show(context);&#125; 抽象工厂模式 (Abstract Factory) 抽象工厂模式是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/factory 抽象产品 （Abstract Prod­uct） 为构成系列产品的一组不同但相关的产品声明接口。 具体产品 （Con­crete Prod­uct） 是抽象产品的多种不同类型实现。 所有变体 （苹果&#x2F;小米&#x2F;…） 都必须实现相应的抽象产品 （手机&#x2F;平板&#x2F;…）。 抽象工厂 （Abstract Fac­to­ry） 接口声明了一组创建各种抽象产品的方法。 具体工厂 （Con­crete Fac­to­ry） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。 尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的抽象产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 客户端 （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂&#x2F;产品变体交互。 与工厂模式的区别简单工厂 和 工厂方法 这两种模式只生产一种对象， 而抽象工厂生产的是一系列对象（对象族），而且生成的这一系列对象一定存在某种联系。比如 Apple 会生产 手机、平板 等多个产品，这些产品都属于 Apple 这个品牌。 Flutter Demo 应用 定义抽象工厂，用于生产 widget： 1234567abstract class IWidgetsFactory &#123; Widget createButton(BuildContext context); Widget createDialog(BuildContext context); // ...&#125; 针对每一个平台，我们都可以实现对应的实现工厂 1234567891011121314151617181920212223242526272829303132Dart// Material 风格组件工厂class MaterialWidgetsFactory extends IWidgetsFactory &#123; @override Widget createButton(BuildContext context) &#123; return ElevatedButton( child: const Text(&#x27;text&#x27;), onPressed: () &#123;&#125;, ); &#125; @override Widget createDialog(BuildContext context) &#123; return const AlertDialog(); &#125;&#125;// Cupertino 风格组件工厂class CupertinoWidgetsFactory extends IWidgetsFactory &#123; @override Widget createButton(BuildContext context) &#123; return CupertinoButton( child: const Text(&#x27;text&#x27;), onPressed: () &#123;&#125;, ); &#125; @override Widget createDialog(BuildContext context) &#123; return const CupertinoAlertDialog(); &#125;&#125; 这样，在 Android 平台上我们使用 MaterialWidgetsFactory ，在 iOS 平台上使用 CupertinoWidgetsFactory ，就能使用对应平台的 widget，想要适配更多平台只需要再继承 IWidgetsFactory 实现对应平台的工厂类即可。 至此，我们可以发现，作为创建型模式，这三类工厂模式主要工作就是以不同的方式创建对象，但他们各有特点：简单工厂模式抽象的是 生产对象，工厂模式抽象的是 类方法，抽象工厂模式抽象的则是 生产对象的工厂，如何使用就见仁见智了。 原型模式 (Prototype) 原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/proxy 原型 （Pro­to­type） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone 的方法。 具体原型 （Con­crete Pro­to­type） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。 客户端 （Client） 可以复制实现了原型接口的任何对象。 建造者模式 (Builder) 建造者模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/builder Flutter 应用 Dart 语言的级联语法，就已经提供了最基础的 Builder 实现，举个例子： 12345678910Dartclass Person &#123; String firstName = &#x27;&#x27;; String lastName = &#x27;&#x27;;&#125;// 创建方法final person = Person() ..firstName = &#x27;San&#x27; ..lastName = &#x27;Zhang&#x27;; 结构型 适配器模式 Adapter 适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/adapter 对象适配器 类适配器 Flutter Demo 应用 在 Flutter 中，最常见的适配器实现就是 SliverToBoxAdapter 我们经常会使用到 CustomScrollView 创建拥有自定义滚动效果的组件，而 CustomScrollView 只允许包含 sliver 系列组件 (SliverAppBar、SliverList、SliverPersistentHeader 等) ，如果想包含普通的组件，必然需要使用 SliverToBoxAdapter。 123456789DartCustomScrollView( slivers: &lt;Widget&gt;[ SliverAppBar(), SliverToBoxAdapter( child: Container(height: 100.0), ), ],) 桥接模式 Bridge 桥接模式是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/bridge 抽象部分 （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。 实现部分 （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。 抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。 具体实现 （Concrete Implementations） 中包括特定于平台的代码。 精确抽象 （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。 通常情况下， 客户端 （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。 组合模式 Composite 组合模式是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/combination 组件 （Component） 接口描述了树中简单项目和复杂项目所共有的操作。 叶节点 （Leaf） 是树的基本结构， 它不包含子项目。 一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。 容器 （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。 容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。 客户端 （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。 装饰模式 Decorator 装饰模式是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/decorator 部件 （Component） 声明封装器和被封装对象的公用接口。 具体部件 （Concrete Component） 类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。 基础装饰 （Base Decorator） 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。 具体装饰类 （Concrete Decorators） 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。 客户端 （Client） 可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。 外观模式 Facades 外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/facade 外观 （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。 创建附加外观 （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。 复杂子系统 （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。 子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。 客户端 （Client） 使用外观代替对子系统对象的直接调用。 享元模式 Flyweight 享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/flyweight 享元模式只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。 享元 （Flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。 情景 （Context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。 通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。 客户端 （Client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。 享元工厂 （Flyweight Factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。 代理模式 Proxy 代理模式是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/proxy 服务接口 （Service Interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。 服务 （Service） 类提供了一些实用的业务逻辑。 代理 （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。 客户端 （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。 行为型 责任链模式 Chain of Responsibility 责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/duty 处理者 （Handler） 声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。 基础处理者 （Base Handler） 是一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。 通常情况下， 该类中定义了一个保存对于下个处理者引用的成员变量。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为： 确定下个处理者存在后再将请求传递给它。 具体处理者 （Concrete Handlers） 包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。 处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。 客户端 （Client） 可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的任意一个处理者， 而非必须是第一个处理者。 命令模式 Command 命令模式是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/command 发送者 （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。 命令 （Command） 接口通常仅声明一个执行命令的方法。 具体命令 （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。 接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。 接收者 （Receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。 客户端 （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。 迭代器模式 Iterator 迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/iterator 迭代器 （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。 具体迭代器 （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。 集合 （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。 具体集合 （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。 客户端 （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。 客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。 中介者模式 Mediator 中介者模式是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/midd 组件 （Component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。 中介者 （Mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。 具体中介者 （Concrete Mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。 组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。 对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。 备忘录模式 Memento 备忘录模式是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/memory 原发器 （Originator） 类可以生成自身状态的快照， 也可以在需要时通过快照恢复自身状态。 备忘录 （Memento） 是原发器状态快照的值对象 （value object）。 通常做法是将备忘录设为不可变的， 并通过构造函数一次性传递数据。 负责人 （Caretaker） 仅知道 “何时” 和 “为何” 捕捉原发器的状态， 以及何时恢复状态。 负责人通过保存备忘录栈来记录原发器的历史状态。 当原发器需要回溯历史状态时， 负责人将从栈中获取最顶部的备忘录， 并将其传递给原发器的恢复 （restoration） 方法。 在该实现方法中， 备忘录类将被嵌套在原发器中。 这样原发器就可访问备忘录的成员变量和方法， 即使这些方法被声明为私有。 另一方面， 负责人对于备忘录的成员变量和方法的访问权限非常有限： 它们只能在栈中保存备忘录， 而不能修改其状态。 观察者模式 Observer 观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/observer 发布者 （Pub­lish­er） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。 当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。 订阅者 （Sub­scriber） 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 update 方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。 具体订阅者 （Con­crete Sub­scribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。 订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。 客户端 （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。 Flutter Demo 应用 Stream 可以被看作是 Dart 语言原生支持的观察者模式的典型模型之一 ChangeNotifier 大概是 Flutter 中实现观察者模式最典型的例子 Flutter 中每个 Navigator 对象都接受一个 NavigatorObserver 对象的数组，在实际开发过程中，我们可以通过根组件 MaterialApp (或 CupertinoPageRoute ) 的 navigatorObservers 属性传递给根 Navigator 组件，用于观察根 Navigator 的路由行为，这一组 NavigatorObserver 对象就是一系列的路由观察者。 更多参考： https://flutter.cn/community/tutorials/observer-pattern-in-flutter-n-dart 状态模式 State 状态模式是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。 Demo: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/state 上下文 （Context） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。 状态 （State） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。 具体状态 （Concrete States） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。 状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。 上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。 策略模式 Strategy 策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。 Demo：https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/strategy 上下文 （Context） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。 策略 （Strategy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。 具体策略 （Concrete Strategies） 实现了上下文所用算法的各种不同变体。 当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。 客户端 （Client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。 这个是最受争议的设计模式，因为策略模式在绝大部分现代编程语言中可以简单地使用匿名 （lamb­da） 函数来实现。 包括 Dart，允许在匿名函数中实现不同版本的算法。 因此使用这些函数的方式就和使用策略对象时完全相同， 无需借助额外的类和接口来保持代码简洁。如下： 123456789101112class Context &#123; void doSomething(&#123;required Function() strategy&#125;) &#123; strategy(); &#125;&#125;// ClientContext().doSomething( strategy: () &#123; // ... &#125;); 模板方法模式 Template Method 模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。 Demo：https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/template 抽象类 （Abstract­Class） 会声明作为算法步骤的方法， 以及依次调用它们的实际模板方法。 算法步骤可以被声明为 抽象 类型， 也可以提供一些默认实现。 具体类 （Concrete­Class） 可以重写所有步骤， 但不能重写模板方法自身。 访问者模式 Visitor 访问者模式是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。 访问者 （Visitor） 接口声明了一系列以对象结构的具体元素为参数的访问者方法。 如果编程语言支持重载， 这些方法的名称可以是相同的， 但是其参数一定是不同的。 具体访问者 （Concrete Visitor） 会为不同的具体元素类实现相同行为的几个不同版本。 元素 （Element） 接口声明了一个方法来 “接收” 访问者。 该方法必须有一个参数被声明为访问者接口类型。 具体元素 （Concrete Element） 必须实现接收方法。 该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。 请注意， 即使元素基类实现了该方法， 所有子类都必须对其进行重写并调用访问者对象中的合适方法。 客户端 （Client） 通常会作为集合或其他复杂对象 （例如一个组合树） 的代表。 客户端通常不知晓所有的具体元素类， 因为它们会通过抽象接口与集合中的对象进行交互。 解释器模式 Interpreter Demo：https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/interpreter 参考 https://refactoringguru.cn/design-patterns https://github.com/FlutterOpen/design_patterns","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.wangruofeng007.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.wangruofeng007.com/tags/Flutter/"}]},{"title":"Hexo 升级到 V7.3","slug":"Hexo-升级到-V7-3","date":"2024-11-01T06:04:25.000Z","updated":"2024-11-03T09:20:48.533Z","comments":true,"path":"2024/11/01/Hexo-升级到-V7-3/","permalink":"https://blog.wangruofeng007.com/2024/11/01/Hexo-%E5%8D%87%E7%BA%A7%E5%88%B0-V7-3/","excerpt":"最近换了台 Apple M2 电脑，整个软件都进行重装，Hexo 年久失修，在设置的时候出现很多警告 ⚠️，看了一下日志主要原因是以前版本依赖的 node 版本太低了，还有相关依赖库因为太旧有不少安全漏洞，查了一下 Hexo 最新发布的为 7.3 版本 ，于是打算整体迁移一下。","text":"最近换了台 Apple M2 电脑，整个软件都进行重装，Hexo 年久失修，在设置的时候出现很多警告 ⚠️，看了一下日志主要原因是以前版本依赖的 node 版本太低了，还有相关依赖库因为太旧有不少安全漏洞，查了一下 Hexo 最新发布的为 7.3 版本 ，于是打算整体迁移一下。 安装 Hexo 7.3首先 Hexo 的安装可以用 brew 了。使用 brew install hexo 安装，安装好之后 Hexo 在 /opt/homebrew/Cellar/hexo/7.3.0 下。 使用 Hexo 的如下指令完成建站 123hexo init blogcd blognpm install 当前环境配置如下： 1234hexo: 7.3.0node：v22.11.0npm：10.9.0brew：4.4.2 基本配置资源迁移：建完站之后，把之前的文章（source&#x2F;_posts）和静态资源（例如图片 source&#x2F;images）都迁移过去。 如果博客有映射自己的域名，记得把 CNAME 文件也迁移一下 配置主题：由于我定制过 Next 主题，就直接把旧项目的主题直接拷贝到新项目的 themes&#x2F;next 目录即可。如果是第一次建站需要在 themes 目录下把 Next clone 下来： 1git clone https://github.com/next-theme/hexo-theme-next.git next 配置 _config.yml 主题为 next： 1theme: next 配置语言：在 _config.yml 中更新博客语言配置，默认为英语 1language: zh-CN 配置链接风格：修改 _config.yml 的 permalink 生成格式，这里配置成短链风格，如下内容： 12345# 默认风格# permalink: :year/:month/:day/:title/# 将文章 url 风格调整成短链风permalink: posts/:abbrlink/ 配置分类这步配置可以参考[这个帖子](https://tohugo.com/2021/01/26/工具配置/Hexo 添加分类及标签（在 Next 主题下）&#x2F;) 打开命令行，进入博客项目所在的文件夹下，执行以下命令 1hexo new page categories 成功会有提示 1INFO Created: ~/path_to_blog/source/categories/index.md 这样我们就创建好了分类页面了。但是这个时候主题还不会识别这个页面为分类页；所以我们需要编辑这个新建的页面，让主题识别这个页面，并自动为这个页面显示分类。 编辑 index.md 在文件中添加 type: “categories” 12345---title: 分类date: 2024-11-02 13:43:56type: &quot;categories&quot;--- 配置标签同理 配置 tags 1hexo new page tags 成功会有提示 1INFO Created: ~/path_to_blog/source/tags/index.md 编辑 index.md 在文件中添加 type: “tags” 12345---title: 标签date: 2024-11-02 13:44:19type: &quot;tags&quot;--- 安装插件站内搜索安装 hexo-generator-searchdb 插件 1npm install hexo-generator-searchdb --save 在 _config.yml 中添加配置： 123456# searchsearch: path: search.json field: post format: html limit: 1000 字数统计安装 npm install hexo-word-counter 插件 , 参考 12npm install hexo-word-counterhexo clean Disqus要在 Hexo 博客中使用 Next 主题集成 Disqus 评论系统，请按照以下步骤进行配置： 注册 Disqus 并获取短名称: 前往 Disqus 官网注册一个账户，并创建一个新的站点。 创建站点后，会分配一个 shortname，这是你在 Next 主题中配置 Disqus 的关键。 配置 Next 主题: 打开你的 Hexo 博客的 Next 主题配置文件，路径通常是 /Users/ruofeng/Documents/git_repo/hexo_blog/themes/next/_config.yml。 找到 disqus 设置部分并启用它。 示例配置： 1234# Disqus commentsdisqus: enable: true shortname: your_disqus_shortname 将 your_disqus_shortname 替换为你在 Disqus 上获得的 shortname。 重新部署博客 &amp; 集成验证:确保保存配置文件后，在 Hexo 根目录中执行以下命令重新生成和部署博客： 1hexo clean &amp;&amp; hexo g -d 打开你的博客页面，检查文章页底部是否显示了 Disqus 评论区域。 发布插件然后需要在 blog 根目录下安装以下插件： 1npm install hexo-deployer-git --save 因为我在 config.yml 中配置好了 deploy 信息： 1234567# Deploymentdeploy: type: git message: &quot;Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm&#x27;) &#125;&#125;&quot; repo: github: git@github.com:wangruofeng/wangruofeng.github.io.git branch: master 常用命令1234567891011121314# 发布新文章hexo new &quot;My New Post&quot;# 预览hexo s# 生成文件到 public 目录hexo g# 发布到 Github Pageshexo d# 清除缓存hexo clean 需要注意，如果改了文件发布的话，要先 hexo g ，然后再 hexo d 。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://blog.wangruofeng007.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.wangruofeng007.com/tags/Hexo/"}]},{"title":"如何通过 SSH 的方式向 Github 提交代码","slug":"如何通过-ssh-方式向-Github-提交代码","date":"2024-10-30T04:19:02.000Z","updated":"2024-11-03T05:32:35.297Z","comments":true,"path":"2024/10/30/如何通过-ssh-方式向-Github-提交代码/","permalink":"https://blog.wangruofeng007.com/2024/10/30/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-ssh-%E6%96%B9%E5%BC%8F%E5%90%91-Github-%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/","excerpt":"通过 SSH 提交代码到 GitHub，可以提高安全性并避免每次提交时输入用户名和密码。","text":"通过 SSH 提交代码到 GitHub，可以提高安全性并避免每次提交时输入用户名和密码。 以下是详细步骤： 1. 检查本地是否有 SSH 密钥在终端中输入以下命令，检查是否已有 SSH 密钥： 1ls ~/.ssh 如果看到 id_rsa 和 id_rsa.pub 文件，表示已有密钥；否则需要生成一个新的 SSH 密钥。 2. 生成新的 SSH 密钥如果没有现有密钥，可以生成新的： 1ssh-keygen -t rsa -b 4096 -C &quot;你的邮箱@example.com&quot; 按回车接受默认路径，创建密钥时可选择设置密码以增加安全性。 3. 启动 SSH Agent 并添加密钥启动 SSH Agent 并将密钥添加到它： 12eval &quot;$(ssh-agent -s)&quot;ssh-add ~/.ssh/id_rsa 4. 将 SSH 公钥添加到 GitHub复制公钥到剪贴板： 123cat ~/.ssh/id_rsa.pub | pbcopy # macOScat ~/.ssh/id_rsa.pub | clip # Windowscat ~/.ssh/id_rsa.pub # Linux，手动复制 登录 GitHub，导航到 Settings &gt; SSH and GPG keys，点击 New SSH key，粘贴公钥并保存。 5. 测试 SSH 连接使用以下命令测试与 GitHub 的 SSH 连接： 1ssh -T git@github.com 如果连接成功，会看到类似以下消息： 1Hi &lt;你的用户名&gt;! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 6. 克隆仓库或更新远程仓库 URL如果已经克隆了仓库，更新其远程仓库 URL： 1git remote set-url origin git@github.com:&lt;用户名&gt;/&lt;仓库名&gt;.git 7. 提交和推送代码按照正常的 Git 工作流，提交并推送代码： 123git add .git commit -m &quot;提交说明&quot;git push origin main # 或者其他分支名 这时，你应该能够通过 SSH 将代码安全地推送到 GitHub。 Tips 确保你的本地 Git 配置了正确的用户名和邮箱： 12git config --global user.name &quot;你的用户名&quot;git config --global user.email &quot;你的邮箱@example.com&quot; 这样，你就可以使用 SSH 将代码提交到 GitHub，而无需输入用户名和密码了。","categories":[{"name":"CLI","slug":"CLI","permalink":"https://blog.wangruofeng007.com/categories/CLI/"}],"tags":[{"name":"SSH","slug":"SSH","permalink":"https://blog.wangruofeng007.com/tags/SSH/"}]},{"title":"物联网通讯协议","slug":"物联网通讯协议","date":"2024-02-24T04:16:29.000Z","updated":"2024-11-03T05:32:35.300Z","comments":true,"path":"2024/02/24/物联网通讯协议/","permalink":"https://blog.wangruofeng007.com/2024/02/24/%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/","excerpt":"物联网协议分类： 接入协议、通讯协议 接入协议：一般负责子网内设备间的组网及通信。 通讯协议：主要是运行在传统互联网 TCP&#x2F;IP 协议之上的设备通讯协议，负责设备通过互联网进行数据交换及通信。","text":"物联网协议分类： 接入协议、通讯协议 接入协议：一般负责子网内设备间的组网及通信。 通讯协议：主要是运行在传统互联网 TCP&#x2F;IP 协议之上的设备通讯协议，负责设备通过互联网进行数据交换及通信。 一、物理层、数据链路层协议1. 远距离蜂窝通讯 2G、3G、4G 通讯协议 NB-loT (Narrow Brand Internet of Things) 窄带物联网 5G 2. 远距离非蜂窝通讯 WiFi ZigBee LoRa（LongRange） 3. 近距离通讯 RFID（Radio Frequency Identification）射频识别 NFC Bluetooth（BLE） UWB （Ultra Wideband）无载波无线通讯技术 4. 有线通信 USB（Universal Series Bus）通用串行总线 串口通讯协议，RS-232、RS-422 和 RS-485 以太网 MBus（symphonic mbus）远程抄表系统 二、网络层、传输协议 IPv4 IPv6 TCP（Transmission Control Protocol）传输控制协议 6LowPAN 三、应用层协议 MQTT（Message Queue Telemetry Transport）遥测传输协议 CoAP（Constrained Application Protocol）协议 REST &#x2F; HTTP 协议 DDS（Data Distribution Service）分布式实时数据分发服务中间件协议 AMQP（Advanced Message Queuing Protocol）高级消息队列协议 XMPP（Extensible messaging and presence protocol 基于 XML 协议）可扩展通讯和表示协议 四、部分协议比较1. NB-IoT 协议和 LoRa 协议比较第一，频段。LoRa 工作在 1GHz 以下的非授权频段，在应用时不需要额外付费，NB-IoT 和蜂窝通信使用 1GHz 以下的频段是 2113 授权的，是需要收费的。 第二，电池供电寿命。LoRa 模块在处理干扰、网络 5261 重迭、可伸缩性等方面具有独特的特性，但却不能提供像蜂窝协议一样的服务质量 4102。NB-IoT 出于对服务质量的考虑，不能提供类似 LoRa 一样的电池寿命。 第三，设备成本。对终端节点来说，LoRa 协议比 NB-IoT 更简单，更容易开发并且 1653 对于微处理器的适用和兼容性更好。同时低成本、技术相对成熟的 LoRa 模块已经可以在市场上找到了，并且还会有升级版本陆续出来。 第四，网络覆盖和部署时间表。NB-IoT 标准在 2016 年公布，除回网络部署之外，相应的商业化和产业链的建立还需要更长的时间和努力去探索。LoRa 的整个产业链相对已经较为成熟了，产品也处于“蓄势待答发”的状态，同时全球很多国家正在进行或者已经完成了全国性的网络部署。 2. 蓝牙、WiFi、ZigBee 协议比较目前来说，WiFi 的优势是应用广泛，已经普及到千家万户；ZigBee 的优势是低功耗和自组网；UWB 无载波无线通信技术的优势是传输速率；蓝牙的优势组网简单。然而，这 3 种技术，也都有各自的不足，没有一种技术能完全满足智能家居的全部要求。 蓝牙技术的出现使得短距离无线通信成为可能，但其协议较复杂、功耗高、成本高等特点不太适用于要求低成本、低功耗的工业控制和家庭网络。尤其蓝牙最大的障碍在于传输范围受限，一般有效的范围在 10 米左右，抗干扰能力不强、信息安全问题等问题也是制约其进一步发展和大规模应用的主要因素。 WiFi 也是是一种短距离无线传输技术，可以随时接入无线信号，移动性强，比较适合在办公室及家庭的环境下应用。当然 WiFi 也存在一个致命缺点。由于 WiFi 采用的是射频技术，通过空气发送和接收数据，使用无线电波传输数据信号，比较容易受到外界的干扰。 ZigBee 则是国际通行的无线通讯技术，它的每个网络端口可以最多接入 6.5 万多个端口，适合家居、工业、农业等多个领域使用，而蓝牙和 WiFi 网端只能接入 10 个端口，显然不能适应家庭需要。ZigBee 还具有低功耗和低成本优势。 3. MQTT 协议和 CoAP 协议比较MQTT 是多对多通讯协议用于在不同客户端之间通过中间代理传送消息，解耦生产者与消费者，通过使得客户端发布，让代理决定路由并且拷贝消息。虽然 MQTT 支持一些持久化，最好还是作为实时数据通讯总线。 CoAP 主要是一个点对点协议，用于在客户端与服务器之间传输状态信息。虽然支持观察资源，CoAP 最好适合状态传输模型，不是完全基于事件。 MQTT 客户端建立长连接 TCP，这通常表示没有问题，CoAP 客户端与服务器都发送与接收 UDP 数据包，在 NAT 环境中，隧道或者端口转发可以用于允许 CoAP，或者像 LWM2M，设备也许会先初始化前端连接。 MQTT 不提供支持消息打类型标记或者其他元数据帮助客户端理解，MQTT 消息可用于任何目的，但是所有的客户端必须知道向上的数据格式以允许通讯，CoAP，相反地，提供内置支持内容协商与发现，允许设备相互探测以找到交换数据的方式。 两种协议各有优缺点，选择合适的取决于自己的应用。 参考 【知识分享】您了解物联网通信协议 5G、NB-Iot、LoRa、ZigBee、NFC…….都是啥吗？","categories":[{"name":"网络协议","slug":"网络协议","permalink":"https://blog.wangruofeng007.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"loT","slug":"loT","permalink":"https://blog.wangruofeng007.com/tags/loT/"}]},{"title":"几分钟内本地快速搭建 ChatGPT 环境","slug":"几分钟内本地快速搭建ChatGPT环境","date":"2023-07-31T15:04:59.000Z","updated":"2024-11-03T05:32:35.304Z","comments":true,"path":"2023/07/31/几分钟内本地快速搭建ChatGPT环境/","permalink":"https://blog.wangruofeng007.com/2023/07/31/%E5%87%A0%E5%88%86%E9%92%9F%E5%86%85%E6%9C%AC%E5%9C%B0%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAChatGPT%E7%8E%AF%E5%A2%83/","excerpt":"简介使用 Docker 虚拟机，几步在本地快速搭建 ChatGPT 环境，免 API，免翻墙，即可使用纯正 OpenAI 的全部功能，完全免费！","text":"简介使用 Docker 虚拟机，几步在本地快速搭建 ChatGPT 环境，免 API，免翻墙，即可使用纯正 OpenAI 的全部功能，完全免费！ 正文下载安装 Docker官网下载地址：https://www.docker.com/ 拉取 pandora 镜像pandora 源码地址：https://github.com/pengzhile/pandora 安装好 Docker 后，打开 Mac 终端，输入以下命令 1docker pull pengzhile/pandora 启动 pandora 镜像等上面镜像下载完成后，输入以下命令 1docker run -e PANDORA_CLOUD=cloud -e PANDORA_SERVER=0.0.0.0:8899 -p 8899:8899 -d pengzhile/pandora 成功运行效果 获取 AccessToken通过登录 OpenAI 官方 API，登录成功后，然后访问 这里 即可拿到官方的 Access Token（ps：这一步需要翻墙才能完成） 获取成功后效果图 注意：Token 目前看有效期是一个月，一个月后需要重新获取 访问本地链接http://127.0.0.1:8899 使用上一步获取的 Access Token 登录即可 登录成功后，即可使用 OpenAI 的全部功能，完全免费！🎉🎉🎉","categories":[{"name":"AI","slug":"AI","permalink":"https://blog.wangruofeng007.com/categories/AI/"}],"tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://blog.wangruofeng007.com/tags/ChatGPT/"}]},{"title":"Flutter 最佳实践整理","slug":"Flutter最佳实践整理","date":"2021-03-28T04:10:21.000Z","updated":"2024-11-03T05:37:41.776Z","comments":true,"path":"2021/03/28/Flutter最佳实践整理/","permalink":"https://blog.wangruofeng007.com/2021/03/28/Flutter%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%95%B4%E7%90%86/","excerpt":"","text":"Text 以字符的方式截断https://github.com/flutter/flutter/issues/52869 在 flutter 中，Text 控件默认的溢出显示模式是 TextOverflow.fade ,就是淡出 在 iOS 或者 Android 平台默认的文件截断模式一般是…省略，flutter 里面对应的截断模式为 TextOverflow.ellipsis ,不过这里的截断是英文按照单词来的，这样的模式会导致如果最后一个单词很长时，截断显示会整理省略而不是最后超出的字符省略，导致模块可能有一大块空白。 Dart 系统定义的截断模式 1234567891011121314151617/// How overflowing text should be handled.////// A [TextOverflow] can be passed to [Text] and [RichText] via their/// [Text.overflow] and [RichText.overflow] properties respectively.enum TextOverflow &#123; /// Clip the overflowing text to fix its container. clip, /// Fade the overflowing text to transparent. fade, /// Use an ellipsis to indicate that the text has overflowed. ellipsis, /// Render overflowing text outside of its container. visible,&#125; 如何解决英文单词被整体截断呢？ 将单词的每个字符切割开，插入宽度 0 的占位字符，打破系统默认的机制，这样就可以以字符为单位省略了 需要注意。这种方式相当于修改了文本的内容，一般文本最大一行显示可以用，如果文本支持 2 行以及以上的显示的话，将会导致换行不再按照字符进行而按照单词进行 下面是 Example 实现 123456789101112131415extension TextOverflowUtil on String &#123; /// 将 flutter 系统默认的单词截断模式转换成字符截断模式 /// 通过向文本中插入宽度为 0 的空格实现 static String toCharacterBreakStr(String word) &#123; if (word == null || word.isEmpty) &#123; return word; &#125; String breakWord = &#x27;&#x27;; word.runes.forEach((element) &#123; breakWord += String.fromCharCode(element); breakWord += &#x27;\\u200B&#x27;; &#125;); return breakWord; &#125;&#125; 文本划线通过 Text 的 decoration 属性来实现划线 TextDecoration.none 没有 TextDecoration.underline 下划线 TextDecoration.overline 上划线 TextDecoration.lineThrough 中间的线（删除线） &#x2F;&#x2F; 划线相关的属性设置decorationColor decoration 划线的颜色decorationStyle decoration 划线的样式 TextDecorationStyle.solid 实线 TextDecorationStyle.double 画两条线 TextDecorationStyle.dotted 点线（一个点一个点的） TextDecorationStyle.dashed 虚线（一个长方形一个长方形的线） TextDecorationStyle.wavy 正玄曲 效果图如下 VS Code 实现保存时自动代码格式化VS Code 中代码格式化默认快捷键：【Shift】+【Alt】+ F 实现手动保存（Ctril + S）时自动触发代码格式化： 1）Code → Perference → Settting 点击右上角（Open Setting(JSON) ） 2）在 settings.json 下的【工作区设置】中添加以下语句： 12&quot;editor.formatOnType&quot;: true,&quot;editor.formatOnSave&quot;: true 解决 setState() called after diapose()网络请求成功前退出了页面，该 State 被从对象树卸载掉，而这时回调了网络请求的方法，方法中带有 setState 的调用，也就导致了该问题。 12345if (mounted) &#123; setState(() &#123; this._books = dataModel.books; &#125;);&#125; Waiting for another flutter command to release the startup lock…等待另一个 flutter 命令释放启动锁 退出 VS Code。 打开 flutter 安装目录 如：…\\flutter\\flutter\\bin\\cache 删除里面的 lockfile。 重启打开 VS Code。 原因：当你的项目异常关闭，下次启动就会出现上面的一行话，此时需要打开 flutter&#x2F;bin&#x2F;cache&#x2F;lockfile，删除就行了，或者直接用下面的命令：rm .&#x2F;flutter&#x2F;bin&#x2F;cache&#x2F;lockfile。 在 Stateless 控件内部或者浮层内部刷新，可以使用 StatefullBuilder123456789101112131415161718192021222324showDialog&lt;void&gt;( context: context, builder: (BuildContext context) &#123; int selectedRadio = 0; return AlertDialog( content: StatefulBuilder( builder: (BuildContext context, StateSetter setState) &#123; return Column( mainAxisSize: MainAxisSize.min, children: List&lt;Widget&gt;.generate(4, (int index) &#123; return Radio&lt;int&gt;( value: index, groupValue: selectedRadio, onChanged: (int value) &#123; setState(() =&gt; selectedRadio = value); &#125;, ); &#125;), ); &#125;, ), ); &#125;,); 这里通过 selectedRadio 变量记录 Radio 的是否选中的状态 平台相关的判断只关心是否是 iOS 和 Android 的情况下不需要依赖 context ，优先使用 Platform &#96;&#96;&#96;jsonPlatform.isAndroidPlatform.isIOS 1234567891011需要详细知道具体哪个平台才使用 `TargetPlatform` 这个 API 的缺点是需要依赖 `context` 这个参数```dartfinal platform = Theme.of(context).platform;if (platform == TargetPlatform.android) &#123; ...&#125; else if (platform == TargetPlatform.iOS) &#123; ...&#125; ScrollView 滑动隐藏键盘https://stackoverflow.com/questions/55306855/hide-keyboard-on-scroll-in-flutter 使用 ScrollView 的 keyboardDismissBehavior 属性 123ListView( keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag) 回调写法a.无参数回调VoidCallback b.有一个参数回调ValueChanged c.参数大于一个可以通过 typedef 自定义一个函数 下面是 Example 用法 123final VoidCallback onPressed;final ValueChanged&lt;T&gt; onSelectHandler;typedef ImageSwiperOnTap = void Function(int index, List&lt;String&gt; imgUrls); flutter pub get is stuck可以通过切换 flutter 镜像到中文站点来解决 使用系统 shell，请编辑 使用 oh_my_zsh, 需要编辑 .zshrc 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 保存文件后，关闭，下次重新打开终端生效 再执行 flutter pub get 查看速度是否正常","categories":[{"name":"最佳实践","slug":"最佳实践","permalink":"https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.wangruofeng007.com/tags/Flutter/"}]},{"title":"Flutter 精华资料收集","slug":"flutter精华资料收集","date":"2020-10-19T13:16:37.000Z","updated":"2024-11-03T05:32:35.285Z","comments":true,"path":"2020/10/19/flutter精华资料收集/","permalink":"https://blog.wangruofeng007.com/2020/10/19/flutter%E7%B2%BE%E5%8D%8E%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/","excerpt":"","text":"说明此文用于记录日常 flutter 开发中使用到或者看到的精华文章或者资源，方便日后查阅 文章Flutter 进阶 让 Flutter 真正支持 View 级别的混合开发 Dart Souls -《Dart 之魂》 Flutter 完整开发实战详解系列 深入理解 Flutter Platform Channel Flutter 布局控件完结篇 超详解析 Flutter 渲染引擎|业务想创新，不了解底层原理怎么行？ – from 淘系技术 深入理解 Flutter 引擎线程模式 Flutter 的性能分析、工程架构与细节处理 – from 有道云 Flutter 图片控件适配之路 – from 网易云音乐 业界动态 Flutter 在哈啰出行 B 端创新业务的实践 Flutter 在 PLUS 业务中的探索和实践 &quot;零&quot;学习成本：使用 Web 标准开发动态化 Flutter 应用 京东技术中台的 Flutter 实践之路 打破重重阻碍，Flutter 和 Web 生态如何对接？ 性能优化 Flutter 性能优化实践 —— UI 篇 Flutter 动态 Dart: 健全的空安全概览 深入理解 Dart 空安全 nullsafety dartpad 观摩！Flutter 1.22 正式发布 网站 Flutter 官网 Flutter 中文网 Flutter 中文开发文档 Flutter 教程网 视频 Introducing Widget of the Week! Flutter by Google AliFlutter 第二期直播回放 阿里巴巴闲鱼技术团队客户端负责人一起探讨 Flutter 的行业现状与未来 博客 咸鱼技术 - Flutter Loki 的博客 — 目前就职于北京腾讯，博客里面有很 flutter 总结的文章 老孟 flutter — 整理了几乎所有的 widget，包含使用的例子，还有部分实战项目 GuruMeditation — 有一些关于 flutter 架构方面的文章 掘金博主 Vadaski 张风捷特烈 YYDev 老孟 Flutter 闲鱼技术 电子书 Flutter 实战 — 来自 duwen 是dio、fly、dsBridge等多个知名开源项目作者 工具 flutter 在线编辑工具 CodePen Dart 在线编辑工具 DartPad 在线 JSON To Dart 代码生成 Json to Dart built_value class converter 2020 年 20 个 Flutter 最漂亮的 UI 库和项目 优秀项目 &amp; App GSYGithubAppFlutter — 大型 flutter 项目， Star 10.8k Developer_quest — Google 官方演示游戏 Demo，Star 2.6k Flutter Go — Ali 开发的 flutter 组件 demo 演示和新闻资讯 Flutter Samples — Flutter 官方 Demo，Star 7.3k awesome-flutter — Flutter 相关的资料集合，Star 28.3k Flutter-Notebook — FlutterDemo 合集, Star 5.7k FlutterUnit — 组件演示项目， Star 1.8k flutter-samples — Flutter 演示项目，很多动画效果 , Star 1.5k flutter_deer — Flutter 练手项目 ,功能很丰富， Star 4.1k FlutterExampleApps — Flutter 示例 App，包含常见流行作品（WhatsApp，Instagram 等）, Star 13.8k PPT AliFlutter 图片解决方案与优化 UC Flutter 技术实践分享","categories":[{"name":"资料收集","slug":"资料收集","permalink":"https://blog.wangruofeng007.com/categories/%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://blog.wangruofeng007.com/tags/%E7%BD%91%E7%AB%99/"}]},{"title":"Flutter 开发 Tips （第二期）","slug":"Flutter-开发Tips-（第二期）","date":"2020-09-16T18:51:21.000Z","updated":"2024-11-03T05:32:35.305Z","comments":true,"path":"2020/09/17/Flutter-开发Tips-（第二期）/","permalink":"https://blog.wangruofeng007.com/2020/09/17/Flutter-%E5%BC%80%E5%8F%91Tips-%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%9C%9F%EF%BC%89/","excerpt":"","text":"提高 flutter attach 的成功率方案 1断开 wifi，执行 flutter attach，attach 成功后再链接 wifi 方案 2通过指定设备 uuid 进行 attach 通过 flutter devices 查找已链接设备列表，获取链接设备的 uuid flutter attach -d &lt;#uuid#&gt; 指定想要 attach 的设备进行连接，例如 flutter attach -d AE5D772C-6D56-43AD-83F2-0554257B16C4 方案 3通过指定应用的 app-id 进行 attach 同一 wifi 环境下如果有多台相同项目设备连接中，找到你需要 attach 的 app-id 进行连接 执行： flutter attach --app-id &lt;#app_id#&gt; 例如： flutter attach --app-id com.xxx.xxx ## 从 package 中加载 json 文件 背景例如我这里有一个 flutter 的 demo 项目叫 flutter_demo_package_json_load ，在根目录通过命令： flutter create --template=package json_test_package ,创建了一个名为 json_test_package 的 package，在 package 的 assets 中有一个为 test2.json 文件，现在需要在 package 中加载到改文件。 从工程加载 json对于普通项目的 json 文件，加载方式如下： 在项目中添加 json 文件，例如项目的 assets 下有一个名为 test1.json 的文件 我们在 yaml 中添加如下依赖 12345678# 只加载 assets 下的 test1.json 文件assets: - assets/test1.json# 或者# 加载 assets 下的所有文件 assets: - assets/ 通过 rootBundle 加载 1234Future&lt;String&gt; _loadFromProjectAsset() async &#123; // json file in project,is ok return rootBundle.loadString(&quot;assets/test1.json&quot;);&#125; 但是对于 package 下面 json 文件上面的方法失效了，使用上面的方法加载将会报错，错误信息如下： 错误原因是资源路径不对，加载不到，因为 rootBundle 类没有提供 package name 的参数，我们只能把 package name 信息放在资源路径里面。 从 package 加载 json灵感来自 https://pub.dev/packages/lottie 库的 Lottie.asset(&quot;assetsPath&quot;,package: &quot;package_name&quot;) 方法，因为 lottie 实现动画的原理也是加载一份 json 配置，不过这个方法支持指定 package 配置。 这里的 keyName 就是我们 rootBundle 类里面需要用的资源路径，包含带 package 的情况。 正确的方式如下： 第一步和上面一样，将 json 文件添加到工程中，假如这里我们 package 里面的 json 文件名为 test2.json 在 yaml 中添加如下依赖12345678# 只加载 assets 下的 test2.json 文件assets: - assets/test2.json# 或者# 加载 assets 下的所有文件assets: - assets/ 通过 rootBundle 加载，但是 path 的格式为 packages/&lt;#package_name#&gt;/&lt;#file_path#&gt; 这里为 123456// json file in package,this is workFuture&lt;String&gt; _loadFromPackageAsset() async &#123; // 【importance】 packag json file need use this formate: // `packages/$package/$assetName` return rootBundle.loadString(&quot;packages/json_test_package/assets/test2.json&quot;);&#125; 通过 DefaultAssetBundle 也是一样可以 1234567// This is work too.Future&lt;String&gt; testLoadJsonFileByDefaultAssetBundle(BuildContext context) &#123; // 【importance】 packag json file need use this formate: // `packages/$package/$assetName` return DefaultAssetBundle.of(context) .loadString(&#x27;packages/json_test_package/assets/test2.json&#x27;);&#125; Demo 链接 flutter analyse配置步骤 在项目更目录添加 analysis_options.yaml 文件可以配置 lint 规则和 analyzer 行为 具体支持的 lint 规则参考 https://dart-lang.github.io/linter/lints/ 目前有 3 类已经定义的常用规则 Many lints are included in various predefined rulesets: pedantic for rules enforced internally at Google effective_dart for rules corresponding to the Effective Dart style guide flutter for rules used in flutter analyze * 推荐使用 google 团队内部的规则库 pedantic 在 yaml 里面添加依赖 pedantic: ^1.8.0+1 * 在 analysis_options.yaml 里面引入使用 include: package:pedantic/analysis_options.1.8.0.yaml ### 使用 配置好 analysis_options.yaml 文件的规则后,执行 flutter analyse 命令将对你整个项目或者 package 的代码进行静态分析 修复 根据提示修复 点击提示的规则，就会跳转到需要修复位置，按照 lint 规则的说明和例子就可以修正了。 利用 VSCode 快速修复 在提示有问题的代码的地方 Ctrl +. , 就会自动弹出快速修复，比如图中为增加 const 标识。 是不是快多了。 参考配置当然你还可以根据你的需要定制自己的静态分析规则，下面是最近使用的一套配置，仅供你参考： analysis_options.yaml 参考配置 dartfmt 命令 dartfmt ./ -w 静态分析代码，并尝试自动修复 dartfmt ./ -n 静态分析代码，不会修复代码 DevTool 介绍flutter 提供了一个 devTool 系列工具，方便开发者进行调试，查看日志，网络请求，性能等信息，更多信息请参考DevTools Install DevTools Install from command line Install and run DevTools from Android Studio Install from VS Code Launch the DevTools application server启动本地 web 服务 1pub global run devtools # If you have `pub` on your path. or 1flutter pub global run devtools # If you have `flutter` on your path. 在命令行，你应该看到类似下面输出，表明服务启动成功 1Serving DevTools at http://127.0.0.1:9100 Start an application to debug运行 app 12cd path/to/flutter/appflutter run 一旦你成功运行起来你的 app，你将在终端控制台看到如下类似的信息 用浏览器打开里面的地址，格式如下 http://127.0.0.1:59681/fVO-_3yziG8=/ 打开将会看到下面的调试面板，可以根据自己的需要进行调试 这里有一个很有用的功能，【debug】 打开页面可以查看断点的帧和控制台的日志。 Open DevTools and connect to the target app一旦工程运行起来了，在浏览器打开 http://localhost:9100，打开 DevTools 完整版本 输入上面的地址，点击 Connect，跳转到完整 devTools 这里的功能非常强大和具体使用可以参考官方文档 flutter 调试这里以 VSCode 为例 纯 flutter 项目纯 flutter 项目比较简单，VSCode 支持各种 devtool，使用 debug 模式运行 app，或者直接按 F5 运行成功后会出现一下工具条 控制台输出以下内容 例如这里我们在这个文件 107 行直接下一个断点，代码执行到时会触发断点 此时工具栏变成下面的样式 可以通过相关的按钮进行断点调试 混合项目(原生+flutter) 打开已经编译运行过的原生端 App 通过 VSCode 打开壳工程，进入壳工程根目录 选择 main.dart 文件 执行 cmd+shift+p,呼出 VSCode 命令面板，输入 &gt;attach to flutter onDevice 选择下面的对应的命令执行 如果 attach 不上请断开 wifi 重试 Attach 成功的话会显示下面一条悬浮工具栏和纯 flutter 相比里面多了一个类似插头的按钮 Debug Console 控制台也会输出下面信息 剩下的调试和上面 DevTool 介绍的流程一致 在这个项目里面可以直接对引用到的代码进行断点调试 参考 analyzer dartfmt Flutter Analysis Options Customizing static analysis How to access assets in package DevTools","categories":[{"name":"最佳实践","slug":"最佳实践","permalink":"https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.wangruofeng007.com/tags/Flutter/"}]},{"title":"Flutter 开发 Tips （第一期）","slug":"Flutter-开发Tips-（第一期）","date":"2020-09-06T17:00:18.000Z","updated":"2024-11-03T05:32:35.295Z","comments":true,"path":"2020/09/07/Flutter-开发Tips-（第一期）/","permalink":"https://blog.wangruofeng007.com/2020/09/07/Flutter-%E5%BC%80%E5%8F%91Tips-%EF%BC%88%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%89/","excerpt":"","text":"…延展操作符( ... )可以对数组或者字典进行操作 12345678910111213141516171819202122// 合并数组test1() &#123; var list = [1, 2, 3]; var list2 = [0, ...list, 4]; print(list2); // [0, 1, 2, 3, 4]&#125;// 合并字典test2() &#123; var map1 = &#123; &quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;, &#125;; var map2 = &#123; &quot;key3&quot;: &quot;value3&quot;, &quot;key4&quot;: &quot;value4&quot;, &#125;; var map3 = &#123;...map1, ...map2&#125;; print(map3); // &#123;key1: value1, key2: value2, key3: value3, key4: value4&#125;&#125; for ()…[]合并 widgets 到集合中，使用 for ()...[] 范式，使用延展操作符( ... )来合并一个数组的 widgets 到一个存在的集合中。例如在构造 Row 或者 Column 的 children 时，非常方便。下面是示例： 12345678910111213141516171819202122232425262728293031323334List&lt;Food&gt; foods = [ Food(name: &#x27;apple&#x27;, isVegetarian: true), Food(name: &#x27;nuts&#x27;, isVegetarian: true), Food(name: &#x27;eggs&#x27;, isVegetarian: true), Food(name: &#x27;chicken&#x27;, isVegetarian: false),];class Food &#123; Food(&#123; this.name, this.isVegetarian, &#125;); String name; bool isVegetarian;&#125;class HomePage extends StatelessWidget &#123; const HomePage(&#123;Key key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Container( child: Column( children: [ Container(), for (final food in foods) ...[ if (food.isVegetarian) ListTile(title: Text(food.name)), SizedBox(height: 50.0), ], ], ), ); &#125; () {} ()立即执行一个匿名函数： () &#123;&#125; () ,相当于声明一个匿名函数并且里面执行，这种范式在处理一个 widget 可能有多种输出时特别有用。而不是使用镶嵌的三目运算符或者通过一个函数调用，这个代码跟内联。下面是示例： 123456789101112131415161718192021T getRandomElement&lt;T&gt;(List&lt;T&gt; list) =&gt; list[Random().nextInt(list.length)];Column( children: [ Container( color: () &#123; switch (getRandomElement(foods).name) &#123; case &#x27;apple&#x27;: return Colors.green; case &#x27;nuts&#x27;: return Colors.brown; case &#x27;eggs&#x27;: return Colors.yellow; default: return Colors.transparent; &#125; &#125;(), child: Text(&#x27;Food of the Day&#x27;), ), ], ) 代码静态分析在提交代码时为了提高代码质量，保持团队的代码风格一致，需要进行代码静态分析，一般通过下面 2 种方法来进行 flutter analyze使用 flutter analyze 进行代码静态分析,此命令会根据 analysis_options.yaml 定义的规则进行静态分析 dartfmt使用 dartfmt ./ -w 对当前目录以及子目录的 dart 代码进行代码, -w 选项会自动重写文件使其符合规范。 使用 dartfmt ./ -n 显示当前目录以及子目录的 dart 代码格式可以修改的文件但是不做修改，可以配合 ci 分析代码格式问题。 更多选项请使用 dartfmt --help 查看 Push &amp; present &amp; Pop1234567891011121314151617// Push by routeNavigator.pushNamed(context, &#x27;/b&#x27;) // push Navigator.of(context).push(MaterialPageRoute(builder: (BuildContext context) =&gt; MyPage()));// presentNavigator.of(context).push(MaterialPageRoute(builder: (BuildContext context) =&gt; MyPage(),fullscreenDialog: true));// popNavigator.pop(context) // pop + pushNavigator.of(context) ..pop() ..pop() ..pushNamed(&#x27;/settings&#x27;); API 123456789// pushFuture push(BuildContext context, Route route)// popbool pop(BuildContext context, [ result ]) // 下面两种是等效的Navigator.push(BuildContext context, Route route)Navigator.of(context).push(Route route) 获取 widget 的位置和宽高123final RenderBox box = keyContext.findRenderObject();final size = box.size;final topLeftPosition = box.localToGlobal(Offset.zero); See more How to get a height of a Widget? Flutter : Widget Size and Position Model To JSONjson_serializable 引入 12345678dependencies: # Your other regular dependencies here json_annotation: ^2.0.0dev_dependencies: # Your other dev_dependencies here build_runner: ^1.0.0 json_serializable: ^2.0.0 使用 1234567891011121314151617import &#x27;package:json_annotation/json_annotation.dart&#x27;;// user.g.dart 将在我们运行生成命令后自动生成part &#x27;user.g.dart&#x27;;///这个标注是告诉生成器，这个类是需要生成 Model 类的@JsonSerializable()class User&#123; User(this.name, this.email); String name; String email; //不同的类使用不同的 mixin 即可 factory User.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$UserFromJson(json); Map&lt;String, dynamic&gt; toJson() =&gt; _$UserToJson(this);&#125; 单次解析： flutter packages pub run build_runner build 4. 持续集成： flutter packages pub run build_runner watch 5. json_serializable 在线 json 转 dart model 工具 Built value 在线 json 转 build value 模板工具 https://charafau.github.io/json2builtvalue/ VSCode built value 插件 Sample code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// interface modelimport &#x27;package:built_value/built_value.dart&#x27;;part &#x27;user.g.dart&#x27;;abstract class User implements Built&lt;User, UserBuilder&gt; &#123; String get name; @nullable String get nickname; User._(); factory User([updates(UserBuilder b)]) = _$User;&#125;// initvar user1 = new User((b) =&gt; b ..name = &#x27;John Smith&#x27; ..nickname = &#x27;Joe&#x27;);// updatevar user2 = user.rebuild((b) =&gt; b ..nickname = &#x27;Jojo&#x27;);// updatevar updatedStructuredData = structuredData.rebuild((b) =&gt; b ..user.update((b) =&gt; b ..name = &#x27;Johnathan Smith&#x27;) ..credentials.phone.update((b) =&gt; b ..country = Country.switzerland ..number = &#x27;555 01234 555&#x27;));// nested buildersabstract class Node implements Built&lt;Node, NodeBuilder&gt; &#123; @nullable String get label; @nullable Node get left; @nullable Node get right; Node._(); factory Node([updates(NodeBuilder b)]) = _$Node;&#125;// new or updatevar node = new Node((b) =&gt; b ..left.left.left.right.left.right.label = &#x27;I’m a leaf!&#x27; ..left.left.right.right.label = &#x27;I’m also a leaf!&#x27;);var updatedNode = node.rebuild((b) =&gt; b ..left.left.right.right.label = &#x27;I’m not a leaf any more!&#x27; ..left.left.right.right.right.label = &#x27;I’m the leaf now!&#x27;); 参考 3 cool Dart patterns built_collection - pub.dev Dart’s built_collection for Immutable Collections dartfmt Customizing static analysis","categories":[{"name":"最佳实践","slug":"最佳实践","permalink":"https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.wangruofeng007.com/tags/Flutter/"}]},{"title":"开发 Flutter 有哪些好用的 VSCode 插件","slug":"开发Flutter有哪些好用的VSCode插件","date":"2020-07-31T15:18:49.000Z","updated":"2024-11-03T05:32:35.290Z","comments":true,"path":"2020/07/31/开发Flutter有哪些好用的VSCode插件/","permalink":"https://blog.wangruofeng007.com/2020/07/31/%E5%BC%80%E5%8F%91Flutter%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84VSCode%E6%8F%92%E4%BB%B6/","excerpt":"","text":"简介这里整理了日常使用 vscode 开发 flutter 相关的插件，也有部分通用类型的插件 Flutter &amp; Dart这 2 个是 flutter 官方插件，开发 flutter 装机必备，不用多说。 Awesome Flutter Snippets Awesome Flutter Snippets is a collection snippets and shortcuts for commonly used Flutter functions and classes 这里面包含 Flutter 中非常常用的代码片段 Bracket Pair Colorizer 2 A customizable extension for colorizing matching brackets 这个插件可以使成对的括号带上不同颜色，特别适合 dart 这种嵌套层级很深声明式语言， 这个插件可以很方便的区分括号的开始和截止位置 ![Bracket _Pair_Colorizer_2](&#x2F;images&#x2F;flutter_plugin&#x2F;Bracket _Pair_Colorizer_2.jpg) GitLens Supercharge the Git capabilities built into Visual Studio Code — Visualize code authorship at a glance via Git blame annotations and code lens, seamlessly navigate and explore Git repositories, gain valuable insights via powerful comparison commands, and so much more 最好用的 feature 是在该行末尾的引人注目的当前行责任注释，可通过悬停获取详细的责任信息，当然还有很多其他的 feature，请自行探索。 git 相关的右键菜单 Color Highlight Highlight web colors in your editor web 颜色高亮，直接将颜色对应的 css 显示出来，非常直观 Image Preview Shows image preview in the gutter and on hover 单鼠标悬浮在带有图片的超链接上会显示预览图片 pubspec assist Easily add and update dependencies to your Dart and Flutter project. 下面是官方的演示效果，可以直接命令搜索 flutter 相关库 Material Icon Theme Material Design Icons for Visual Studio Code 针对不同的文件 icon 和文件夹 icon 设计了一套主题图标 Error lens Improve highlighting of errors, warnings and other language diagnostics. 增强了语言中的错误高亮效果，使错误提示在代码后面显示 flutter-stylizer Flutter Stylizer organizes your Flutter classes in an opinionated and consistent manner. 使 flutter 中的代码按照下面的方式排序，方便统一约束团队代码的结构 1234567891011&quot;flutterStylizer.memberOrdering&quot;: [ &quot;public-constructor&quot;, &quot;named-constructors&quot;, &quot;public-static-variables&quot;, &quot;public-instance-variables&quot;, &quot;private-static-variables&quot;, &quot;private-instance-variables&quot;, &quot;public-override-methods&quot;, &quot;public-other-methods&quot;, &quot;build-method&quot;,], 当然这只是默认顺序，具体的顺序可以自行调整,插件安装完成后，通过快捷键格式化当前的文件 RESTClient REST Client for Visual Studio Code 在 VSCode 里面直接发送请求，能自动识别 .http 和 .rest 后缀的文件 点击 Send Request 开始发送请求。","categories":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/categories/%E6%95%88%E7%8E%87/"}],"tags":[{"name":"插件","slug":"插件","permalink":"https://blog.wangruofeng007.com/tags/%E6%8F%92%E4%BB%B6/"}]},{"title":"Flutter 中 Key 的作用","slug":"Flutter中Key的作用","date":"2020-07-26T09:44:33.000Z","updated":"2024-11-03T05:32:35.301Z","comments":true,"path":"2020/07/26/Flutter中Key的作用/","permalink":"https://blog.wangruofeng007.com/2020/07/26/Flutter%E4%B8%ADKey%E7%9A%84%E4%BD%9C%E7%94%A8/","excerpt":"","text":"key 的定义Key Class 官方介绍： A [Key] is an identifier for [Widget]s, [Element]s and [SemanticsNode]s. A new widget will only be used to update an existing element if its key is the same as the key of the current widget associated with the element. {@youtube 560 315 https://www.youtube.com/watch?v=kn0EOS-ZiIc} Keys must be unique amongst the [Element]s with the same parent. Subclasses of [Key] should either subclass [LocalKey] or [GlobalKey]. 翻译过来： 一个 Key 是 Widget，Element 以及 SemanticsNode 的标识。 一个新 widget 将仅用来更新一个已存在的 element 假如它的 key 和当前 widget 关联的元素一致。 官方介绍视频 https://www.youtube.com/watch?v=kn0EOS-ZiIc 在有着相同父节点的 element 中，Key 必须是唯一的。 Key 的子类要么是 LocalKey，要么是 GlobalKey。 Key 官方介绍： Controls how one widget replaces another widget in the tree. If the runtimeType and key properties of the two widgets are operator&#x3D;&#x3D;, respectively, then the new widget replaces the old widget by updating the underlying element (i.e., by calling Element.updatewith the new widget). Otherwise, the old element is removed from the tree, the new widget is inflated into an element, and the new element is inserted into the tree. In addition, using a GlobalKey as the widget’s key allows the element to be moved around the tree (changing parent) without losing state. When a new widget is found (its key and type do not match a previous widget in the same location), but there was a widget with that same global key elsewhere in the tree in the previous frame, then that widget’s element is moved to the new location. Generally, a widget that is the only child of another widget does not need an explicit key. 翻译过来： 控制一个小部件如何替换树中的另一个小部件。 如果两个 widget 的runtimeType和key属性分别是相等的(&#x3D;&#x3D;)，则新 widget 通过更新基础 element（即，通过使用新的 widget 调用Element.update）来替换旧 widget。否则，将从树中删除旧 element，将新 widget 放大为一个 element，然后将新 element 插入到树中。 另外，使用GlobalKey作为窗口小部件的key允许该 element 在树上移动（更改父级）而不会丢失状态。当找到新的 widget（其键和类型与相同位置的先前 widget 不匹配），但是在前一帧的树中其他位置有一个具有相同全局键的 widget 时，该 widget 的 element 将移至新位置。 通常，作为另一个 widget 的唯一 child 的 widget 不需要显式 key。 Key 的作用大多数时候并不需要使用 key。 当需要在一个StatefulWidget集合中进行添加、删除、重排序等操作时，才是 key 登场的时候。 无状态组件下面这段代码在一个 Row 中展示了两个彩色方片（StatelessContainer），当点击按钮时，会交换两个方片的位置： 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import &#x27;dart:math&#x27;;import &#x27;package:flutter/material.dart&#x27;;class StatelessContainer extends StatelessWidget &#123; final Color color = Color.fromRGBO( Random().nextInt(256), Random().nextInt(256), Random().nextInt(256), 1); @override Widget build(BuildContext context) &#123; return Container( width: 100, height: 100, color: color, ); &#125;&#125;class Screen extends StatefulWidget &#123; @override _ScreenState createState() =&gt; _ScreenState();&#125;class _ScreenState extends State&lt;Screen&gt; &#123; List&lt;Widget&gt; widgets = [ StatelessContainer(), StatelessContainer(), ]; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Row( mainAxisAlignment: MainAxisAlignment.center, children: widgets, ), ), floatingActionButton: FloatingActionButton( onPressed: switchWidget, child: Icon(Icons.undo), ), ); &#125; switchWidget() &#123; widgets.insert(0, widgets.removeAt(1)); setState(() &#123;&#125;); &#125;&#125; 有状态组件有状态组件的状态信息（如颜色）通常是存储在 state 中的，而 state 是存储在 element 树中的。 那么 Key 到底应该用到哪呢？我们再来一个例子，我们把色块用 Padding 包装一下。运行之后会发现，色块并没有交换，而是以随机的形式在变换颜色。为什么呢？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import &#x27;dart:math&#x27;;import &#x27;package:flutter/material.dart&#x27;;class Screen extends StatefulWidget &#123; Screen(&#123;Key key&#125;) : super(key: key); @override _ScreenState createState() =&gt; _ScreenState();&#125;class _ScreenState extends State&lt;Screen&gt; &#123; List&lt;Widget&gt; widgets = [ Padding( padding: const EdgeInsets.all(8.0), child: StatefulContainer(key: UniqueKey()), ), Padding( padding: const EdgeInsets.all(8.0), child: StatefulContainer(key: UniqueKey()), ), ]; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Row( mainAxisAlignment: MainAxisAlignment.center, children: widgets, ), ), floatingActionButton: FloatingActionButton( onPressed: switchWidget, child: Icon(Icons.undo), ), ); &#125; switchWidget() &#123; widgets.insert(0, widgets.removeAt(1)); setState(() &#123;&#125;); print(&#x27;$&#123;widgets[0]&#125;, $&#123;widgets[1]&#125;&#x27;); &#125;&#125;class StatefulContainer extends StatefulWidget &#123; StatefulContainer(&#123;Key key&#125;) : super(key: key); @override _StatefulContainerState createState() =&gt; _StatefulContainerState();&#125;class _StatefulContainerState extends State&lt;StatefulContainer&gt; &#123; final Color color = Color.fromRGBO( Random().nextInt(256), Random().nextInt(256), Random().nextInt(256), 1); @override Widget build(BuildContext context) &#123; return Container( color: color, width: 100, height: 100, ); &#125;&#125; 结合我们上面的理论，我们分析一下这次的 Widget Tree 和 Element Tree，当我们交换元素后，Flutter element-to-widget matching algorithm,(元素-组件匹配算法)，开始进行对比，算法每次只对比一层，即 Padding 这一层。显然，Padding 并没有发生本质的变化。 于是开始进行第二层对比，在对比时 Flutter 发现元素与组件的 Key 并不匹配，于是，把它设置成不可用状态，但是这里所使用的 Key 只是本地 Key（Local Key），Flutter 并不能找到另一层里面的 Key（即另外一个 Padding Widget 中的 Key）所以，Flutter 就创建了一个新的 Widget，而这个 Widget 的颜色就成了我们看到的『随机色』。 通过上面的示例，我们能明显的看出，我们的 Key 要设置到组件树的 顶层，而这一层在改变时，才能复用或者更新状态。 修正版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import &#x27;dart:math&#x27;;import &#x27;package:flutter/material.dart&#x27;;class Screen extends StatefulWidget &#123; Screen(&#123;Key key&#125;) : super(key: key); @override _ScreenState createState() =&gt; _ScreenState();&#125;class _ScreenState extends State&lt;Screen&gt; &#123; List&lt;Widget&gt; widgets = [ Padding( key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulContainer(), ), Padding( key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulContainer(), ), ]; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Row( mainAxisAlignment: MainAxisAlignment.center, children: widgets, ), ), floatingActionButton: FloatingActionButton( onPressed: switchWidget, child: Icon(Icons.undo), ), ); &#125; switchWidget() &#123; widgets.insert(0, widgets.removeAt(1)); setState(() &#123;&#125;); print(&#x27;$&#123;widgets[0]&#125;, $&#123;widgets[1]&#125;&#x27;); &#125;&#125;class StatelessContainer extends StatelessWidget &#123; final Color color = Color.fromRGBO( Random().nextInt(256), Random().nextInt(256), Random().nextInt(256), 1); @override Widget build(BuildContext context) &#123; return Container( color: color, width: 100, height: 100, ); &#125;&#125;class StatefulContainer extends StatefulWidget &#123; StatefulContainer(&#123;Key key&#125;) : super(key: key); @override _StatefulContainerState createState() =&gt; _StatefulContainerState();&#125;class _StatefulContainerState extends State&lt;StatefulContainer&gt; &#123; final Color color = Color.fromRGBO( Random().nextInt(256), Random().nextInt(256), Random().nextInt(256), 1); @override Widget build(BuildContext context) &#123; return Container( color: color, width: 100, height: 100, ); &#125;&#125; Key 的分类 ValueKey:以一个值为 key。 ObjectKey:以一个对象为 key。 UniqueKey:生成唯一的随机数作为 key。 PageStorageKey:专用于存储页面滚动位置的 key。 GlobalKey:见后文。 何时使用 keyValueKey如果您有一个 Todo List 应用程序，它将会记录你需要完成的事情。我们假设每个 Todo 事情都各不相同，而你想要对每个 Todo 进行滑动删除操作。 这时候就需要使用 ValueKey！ 1234567return TodoItem( key: ValueKey(todo.task), todo: todo, onDismissed: (direction)&#123; _removeTodo(context, todo); &#125;,); ObjectKey如果你有一个生日应用，它可以记录某个人的生日，并用列表显示出来，同样的还是需要有一个滑动删除操作。 我们知道人名可能会重复，这时候你无法保证给 Key 的值每次都会不同。但是，当人名和生日组合起来的 Object 将具有唯一性。 这时候你需要使用 ObjectKey！ UniqueKey如果组合的 Object 都无法满足唯一性的时候，你想要确保每一个 Key 都具有唯一性。那么，你可以使用 UniqueKey。它将会通过该对象生成一个具有唯一性的 hash 码。 不过这样做，每次 Widget 被构建时都会去重新生成一个新的 UniqueKey，失去了一致性。也就是说你的小部件还是会改变。（还不如不用😂） PageStorageKey当你有一个滑动列表，你通过某一个 Item 跳转到了一个新的页面，当你返回之前的列表页面时，你发现滑动的距离回到了顶部。这时候，给 Sliver 一个 PageStorageKey！它将能够保持 Sliver 的滚动状态。 GlobalKey每个 globalkey 都是一个在整个应用内唯一的 key。 globalkey 相对而言是比较昂贵的，如果你并不需要 globalkey 的某些特性，那么可以考虑使用 Key、ValueKey、ObjectKey 或 UniqueKey。 用途 1允许 widget 在应用程序中的任何位置更改其 parent 而不丢失其状态。应用场景：在两个不同的屏幕上显示相同的 widget，并保持状态相同。 用途 2GlobalKey 能够跨 Widget 访问状态。 在这里我们有一个 Switcher 小部件，它可以通过 changeState 改变它的状态。 12345678910111213141516171819202122class SwitcherScreenState extends State&lt;SwitcherScreen&gt; &#123; bool isActive = false; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Switch.adaptive( value: isActive, onChanged: (bool currentStatus) &#123; isActive = currentStatus; setState(() &#123;&#125;); &#125;), ), ); &#125; changeState() &#123; isActive = !isActive; setState(() &#123;&#125;); &#125;&#125; 但是我们想要在外部改变该状态，这时候就需要使用 GlobalKey。 123456789101112131415class _ScreenState extends State&lt;Screen&gt; &#123; final GlobalKey&lt;SwitcherScreenState&gt; key = GlobalKey&lt;SwitcherScreenState&gt;(); @override Widget build(BuildContext context) &#123; return Scaffold( body: SwitcherScreen( key: key, ), floatingActionButton: FloatingActionButton(onPressed: () &#123; key.currentState.changeState(); &#125;), ); &#125;&#125; 这里我们通过定义了一个 GlobalKey 并传递给 SwitcherScreen。然后我们便可以通过这个 key 拿到它所绑定的 SwitcherState 并在外部调用 changeState 改变状态了。 参考资料 何时使用密钥 - Flutter 小部件 101 第四集 widgets-intro#keys Flutter | 深入浅出 Key Flutter 中的 Key 和 GlobalKey","categories":[{"name":"最佳实践","slug":"最佳实践","permalink":"https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Key","slug":"Key","permalink":"https://blog.wangruofeng007.com/tags/Key/"}]},{"title":"Flutter factory 使用总结","slug":"Flutter-factory-使用总结","date":"2020-07-26T08:54:39.000Z","updated":"2024-11-03T05:32:35.296Z","comments":true,"path":"2020/07/26/Flutter-factory-使用总结/","permalink":"https://blog.wangruofeng007.com/2020/07/26/Flutter-factory-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"0x01 官方描述 Use the factory keyword when implementing a constructor that doesn’t always create a new instance of its class. For example, a factory constructor might return an instance from a cache, or it might return an instance of a subtype. 当实现并非总是创建其类的新实例的构造函数时，请使用“ factory”关键字。例如，工厂构造函数可能会从缓存返回一个实例，或者可能会返回一个子类型的实例。 0x02 使用场景 避免创建过多的重复实例，如果该实例已创建，则直接从缓存获取。 调用子类的构造函数(工厂模式 factory pattern） 实现单例模式(singleton pattern) 0x03 Demo创建缓存实例 引用自 https://dart.dev/guides/language/language-tour#factory-constructors 123456789101112131415161718192021222324252627class Logger &#123; final String name; // 缓存 Map static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;&#123;&#125;; factory Logger(String name) &#123; // name 对应的 key 在_cache 不存在，执行 Logger._internal(name)，否则直接返回 return _cache.putIfAbsent(name, () =&gt; Logger._internal(name)); &#125; // 私有构造函数 Logger._internal(this.name) &#123; print(&#x27;生成新实例:$name&#x27;); &#125;&#125;void main(List&lt;String&gt; args) &#123; var p1 = Logger(&#x27;1&#x27;); var p2 = Logger(&#x27;2&#x27;); var p3 = Logger(&#x27;1&#x27;); print(identical(p1, p2)); print(identical(p1, p3)); // 生成新实例:1 // 生成新实例:2 // false // true&#125; 调用子类的构造函数12345678910111213141516171819202122232425262728293031323334353637383940414243abstract class Animal extends Object &#123; String name; void getNoise(); factory Animal(String type, String name) &#123; switch (type) &#123; case &#x27;cat&#x27;: return Cat(name); break; case &#x27;dog&#x27;: return Dog(name); break; default: throw &quot;The &#x27;$type&#x27; is not an animal&quot;; &#125; &#125;&#125;class Cat implements Animal &#123; String name; Cat(this.name); @override void getNoise() &#123; print(&#x27;$&#123;this.name&#125;:mew~&#x27;); &#125;&#125;class Dog implements Animal &#123; String name; Dog(this.name); @override void getNoise() &#123; print(&#x27;$&#123;this.name&#125;:wang~&#x27;); &#125;&#125;void main(List&lt;String&gt; args) &#123; var cat = Animal(&#x27;cat&#x27;, &#x27;haha&#x27;); var dog = Animal(&#x27;dog&#x27;, &#x27;hehe&#x27;); cat.getNoise(); dog.getNoise(); // haha:mew~ // hehe:wang~&#125; 实现单例模式12345678910111213141516class Singleton &#123; static final Singleton _singleton = Singleton._internal(); factory Singleton() &#123; return _singleton; &#125; Singleton._internal();&#125;void main(List&lt;String&gt; args) &#123; var s1 = Singleton(); var s2 = Singleton(); print(identical(s1, s2)); // true&#125;","categories":[{"name":"最佳实践","slug":"最佳实践","permalink":"https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.wangruofeng007.com/tags/Flutter/"}]},{"title":"Flutter ShapeBorder 使用手册","slug":"Flutter-ShapeBorder-使用手册","date":"2020-07-12T11:09:55.000Z","updated":"2024-11-03T05:32:35.288Z","comments":true,"path":"2020/07/12/Flutter-ShapeBorder-使用手册/","permalink":"https://blog.wangruofeng007.com/2020/07/12/Flutter-ShapeBorder-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"简介ShapeBorder 用于设置形状和轮廓，比如圆形，矩形，圆角矩形等。常用于 Container 中。","text":"简介ShapeBorder 用于设置形状和轮廓，比如圆形，矩形，圆角矩形等。常用于 Container 中。 继承结构如下： ShapeBorder【abstract】 BeveledRectangleBorder BoxBorder【abstract】 Border BorderDirectional CircleBorder ContinuousRectangleBorder RoundedRectangleBorder StadiumBorder InputBorder【abstract】 OutlineInputBorder UnderlineInputBorder 其中 ShapeBorder、BoxBorder、InputBorder 是抽象父类。InputBorder 通常用于输入框相关的。 类的关系图 ![ShapeBorder 子类继承关系图](&#x2F;images&#x2F;flutter_shape_border&#x2F;ShapeBorder 子类继承关系图.png) BeveledRectangleBorder斜面圆角矩形 继承关系: BeveledRectangleBorder &gt; ShapeBorder &#96;&#96;&#96;dartWidget _beveledRectangleBorder() { return Center( child: Container( width: 240, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(‘lib&#x2F;assets&#x2F;img_flutter.png’), fit: BoxFit.cover, ), shape: BeveledRectangleBorder( borderRadius: BorderRadius.circular(20), side: BorderSide( width: 2, color: Colors.blue, style: BorderStyle.solid, ), ), ), ), );} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748效果如下：![beveled_rectangle_border](/images/flutter_shape_border/beveled_rectangle_border.png)## BoxBorderBoxBorder 主要掌管边线方面的事，自身是 abstract，不能直接用BoxBorder 官方说明&gt; Base class for box borders that can paint as rectangles, circles, or rounded rectangles.### Border继承关系: `Border &gt; BoxBorder &gt; ShapeBorder` Border 官方说明&gt; A border of a box, comprised of four sides: top, right, bottom, left.```dartWidget _border() &#123; return Center( child: Container( margin: EdgeInsets.all(16), padding: EdgeInsets.all(16), decoration: ShapeDecoration( color: Colors.orange, shape: Border( top: BorderSide(width: 6.0, color: Colors.black12), left: BorderSide(width: 6.0, color: Colors.black12), right: BorderSide(width: 6.0, color: Colors.black26), bottom: BorderSide(width: 6.0, color: Colors.black26), ), ), child: Text( &quot;Border&quot;, style: TextStyle(color: Colors.white, fontSize: 20), ), ), );&#125; 效果图： BorderDirectional继承关系: BorderDirectional &gt; BoxBorder &gt; ShapeBorder BorderDirectional 通过 top , bottom , start , end 分别控制上下左右的边线边线对象 BorderSide &#96;&#96;&#96;dartWidget _borderDirectional() { return Center( child: Container( width: 240, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(‘lib&#x2F;assets&#x2F;img_flutter.png’), fit: BoxFit.cover, ), shape: BorderDirectional( start: BorderSide(color: Colors.black, width: 15), end: BorderSide(color: Colors.black, width: 15), top: BorderSide( color: Colors.black, ), bottom: BorderSide( color: Colors.black, ), ), ), ), );} 12345678910111213141516171819202122232425效果如下：![border_directional_01](/images/flutter_shape_border/border_directional_01.png)只设置左右的 `BorderSide` ```dartWidget _borderDirectional2() &#123; return Center( child: Container( width: 240, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(&#x27;lib/assets/img_flutter.png&#x27;), fit: BoxFit.cover, ), shape: BorderDirectional( start: BorderSide(color: Colors.black, width: 15), end: BorderSide(color: Colors.black, width: 15), ), ), ), );&#125; 效果如下： CircleBorder圆形边框。 继承关系: CircleBorder &gt; ShapeBorder &#96;&#96;&#96;dartWidget _circleBorder1() { return Center( child: Container( width: 120, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(‘lib&#x2F;assets&#x2F;img_flutter.png’), fit: BoxFit.cover, ), shape: CircleBorder( side: BorderSide(), ), ), ), );} 1234567891011121314151617181920212223242526272829303132333435效果如下：![circle_border_01](/images/flutter_shape_border/circle_border_01.jpg)上面的是使用默认参数的效果![circle_border_03](/images/flutter_shape_border/circle_border_03.png)通过设置 BorderSide 来设置边框颜色和宽度，以及是否显示边框```dartWidget _circleBorder2() &#123; return Center( child: Container( width: 120, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(&#x27;lib/assets/img_flutter.png&#x27;), fit: BoxFit.cover, ), shape: CircleBorder( side: BorderSide( width: 10, color: Colors.blue, style: BorderStyle.solid, ), ), ), ), );&#125; 效果如下： ContinuousRectangleBorder平滑过渡的矩形边框 继承关系: ContinuousRectangleBorder &gt; ShapeBorder &#96;&#96;&#96;dart Widget _continuousRectangleBorder() { return Center( child: Container( width: 240, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(‘lib&#x2F;assets&#x2F;img_flutter.png’), fit: BoxFit.cover, ), shape: ContinuousRectangleBorder( borderRadius: BorderRadius.circular(40), side: BorderSide( width: 2, color: Colors.blue, style: BorderStyle.solid, ), ), ), ), );} 123456789101112131415161718192021222324252627282930313233343536效果如下：![continuous_rectangle_border](/images/flutter_shape_border/continuous_rectangle_border.png)## RoundedRectangleBorder圆角矩形。继承关系: `RoundedRectangleBorder &gt; ShapeBorder` ```dartWidget _roundedRectangleBorder() &#123; return Center( child: Container( width: 240, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(&#x27;lib/assets/img_flutter.png&#x27;), fit: BoxFit.cover, ), shape: RoundedRectangleBorder( borderRadius: BorderRadius.circular(20), side: BorderSide( width: 2, color: Colors.blue, style: BorderStyle.solid, ), ), ), ), );&#125; 效果如下： StadiumBorder体育场形状。即两边是半圆。 继承关系: StadiumBorder &gt; ShapeBorder &#96;&#96;&#96;dartWidget _stadiumBorder() { return Center( child: Container( width: 240, height: 120, margin: EdgeInsets.all(16), decoration: ShapeDecoration( image: DecorationImage( image: AssetImage(‘lib&#x2F;assets&#x2F;img_flutter.png’), fit: BoxFit.cover, ), shape: StadiumBorder( side: BorderSide( width: 2, color: Colors.blue, style: BorderStyle.solid, ), ), ), ), );} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647效果如下：![stadiu_border_01](/images/flutter_shape_border/stadiu_border_01.png)## InputBorder继承关系: `InputBorder &gt; ShapeBorder` 官方说明：&gt; Defines the appearance of an [InputDecorator]&#x27;s border.&gt;&gt; &gt;&gt; An input decorator&#x27;s border is specified by [InputDecoration.border].&gt;&gt; &gt;&gt; The border is drawn relative to the input decorator&#x27;s &quot;container&quot; which&gt;&gt; is the optionally filled area above the decorator&#x27;s helper, error,and counter.常用的输入边框，有 2 个衍生子类 `OutlineInputBorder` 和 `UnderlineInputBorder` ### OutlineInputBorder继承关系: `OutlineInputBorder &gt; InputBorder &gt; ShapeBorder` ```dartWidget _outlineInputBorder() &#123; return Center( child: Container( margin: EdgeInsets.all(16), padding: EdgeInsets.all(16), decoration: ShapeDecoration( color: Colors.orange, shape: OutlineInputBorder( borderSide: BorderSide(width: 2.0, color: Colors.purple), borderRadius: BorderRadius.circular(20.0), ), ), child: Text( &quot;OutlineInputBorder&quot;, style: TextStyle(color: Colors.white, fontSize: 20), ), ), );&#125; 效果如下： UnderlineInputBorder继承关系: UnderlineInputBorder &gt; InputBorder &gt; ShapeBorder &#96;&#96;&#96;dartWidget _underlineInputBorder() { return Center( child: Container( margin: EdgeInsets.all(16), padding: EdgeInsets.all(16), decoration: ShapeDecoration( color: Colors.orange, shape: UnderlineInputBorder( borderSide: BorderSide(width: 2.0, color: Colors.purple), borderRadius: BorderRadius.circular(20.0), ), ), child: Text( “UnderlineInputBorder”, style: TextStyle(color: Colors.white, fontSize: 20), ), ), );} 效果如下： ![underlineInput_border](/images/flutter_shape_border/underlineInput_border.png) &lt;!-- processed 2 --&gt;","categories":[{"name":"最佳实践","slug":"最佳实践","permalink":"https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"特效","slug":"特效","permalink":"https://blog.wangruofeng007.com/tags/%E7%89%B9%E6%95%88/"}]},{"title":"VSCode Snippets 使用手册","slug":"VSCode-Snippets-使用手册","date":"2020-06-13T08:09:53.000Z","updated":"2024-11-03T05:32:35.304Z","comments":true,"path":"2020/06/13/VSCode-Snippets-使用手册/","permalink":"https://blog.wangruofeng007.com/2020/06/13/VSCode-Snippets-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"VSCode Snippets 使用手册前言当我们为了减少模板代码，我们第一个很可能想到使用 Code Snippets ,很多 IDE 和文件编辑器已经给我们提供了一个预装的代码片段，当预装的代码片段不能瞒着我们的需求，我们可能会自己定制一些自己的专有代码代码片段，下面就为大家介绍如何在 VSCode 定制自己的代码片段以及一些小技巧。","text":"VSCode Snippets 使用手册前言当我们为了减少模板代码，我们第一个很可能想到使用 Code Snippets ,很多 IDE 和文件编辑器已经给我们提供了一个预装的代码片段，当预装的代码片段不能瞒着我们的需求，我们可能会自己定制一些自己的专有代码代码片段，下面就为大家介绍如何在 VSCode 定制自己的代码片段以及一些小技巧。 如何添加方法一：通过控制台 打开 VSCode,按下快捷键组合 shift+command+p 呼出控制台 在控制台输入： Configure User Snippets 选择 输入 new ，找到新建代码片段命令，这里可以选择创建全局的或者为某个项目专属的代码片段,这里我们选择 New Global Snippets file... 。 给片段起一个易于理解的命名，回车 编辑代码片段的内容 例如我们创建一个自己名字的 TODO, 类似这样的风格： // TODO(ruofeng): some comment 最终版本如下： 效果图 方法二：通过首选项 Code -&gt; Preferences-&gt;User Snippets 后面的步骤和第一种的 4，5 一样，这里不再赘述 使用测试新建一个 .dart 结尾的文件,这里就叫 test.dart ,输入 todo，出现了我们刚才定义的代码片段 选择 todo,出现我们刚才定义的代码片段 常用语法 变量， 格式 $+num , 例如： &quot;console.log(&#39;$1&#39;);&quot; 2. 变量占位描述,格式 $&#123;num:desc&#125; ,例如： &quot;$&#123;1:label&#125;, $&#123;2:another&#125;;&quot; 3. 缩进， \\t ,注意缩进的对称性 变量 为了跟进环境动态定制一些片段，我们可以使用系统提供的一些环境变量，官方介绍 示例： 我们来定义一个 Xcode 版本的 OC 默认风格代码片段 新建一个 test.dart 文件，在里面输入 copywright，选择刚才我们的添加的代码片段，效果如下 变量转换语法说明： 1234567891011121314151617181920any ::= tabstop | placeholder | choice | variable | texttabstop ::= &#x27;$&#x27; int | &#x27;$&#123;&#x27; int &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; int transform &#x27;&#125;&#x27;placeholder ::= &#x27;$&#123;&#x27; int &#x27;:&#x27; any &#x27;&#125;&#x27;choice ::= &#x27;$&#123;&#x27; int &#x27;|&#x27; text (&#x27;,&#x27; text)* &#x27;|&#125;&#x27;variable ::= &#x27;$&#x27; var | &#x27;$&#123;&#x27; var &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; var &#x27;:&#x27; any &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; var transform &#x27;&#125;&#x27;transform ::= &#x27;/&#x27; regex &#x27;/&#x27; (format | text)+ &#x27;/&#x27; optionsformat ::= &#x27;$&#x27; int | &#x27;$&#123;&#x27; int &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; int &#x27;:&#x27; &#x27;/upcase&#x27; | &#x27;/downcase&#x27; | &#x27;/capitalize&#x27; &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; int &#x27;:+&#x27; if &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; int &#x27;:?&#x27; if &#x27;:&#x27; else &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; int &#x27;:-&#x27; else &#x27;&#125;&#x27; | &#x27;$&#123;&#x27; int &#x27;:&#x27; else &#x27;&#125;&#x27;regex ::= JavaScript Regular Expression value (ctor-string)options ::= JavaScript Regular Expression option (ctor-options)var ::= [_a-zA-Z] [_a-zA-Z0-9]*int ::= [0-9]+text ::= .* 下面将实现读取文件名称截取掉文件的后缀效果： foo.text &#x3D;&#x3D;&gt; foo &#96;&#96;&#96;${TM_FILENAME&#x2F;(.*)\\..+$&#x2F;$1&#x2F;} | | | | | | | |-&gt; no options | | | | | |-&gt; references the contents of the first | | capture group | | | |-&gt; regex to capture everything before | the final .suffix | |-&gt; resolves to the filename 123456789101112131415161718192021222324252627282930313233343536373839404142434445Transform Example：| Example | Output | Explanation || :------------------------------------ | :------------------------ | :--------------------------------- || `&quot;$&#123;TM_FILENAME/[\\\\.]/_/&#125;&quot;` | `example-123_456-TEST.js` | Replace the first `.` with `_` || `&quot;$&#123;TM_FILENAME/[\\\\.-]/_/g&#125;&quot;` | `example_123_456_TEST_js` | Replace each `.` or `-` with `_` || `&quot;$&#123;TM_FILENAME/(.*)/$&#123;1:/upcase&#125;/&#125;&quot;` | `EXAMPLE-123.456-TEST.JS` | Change to all uppercase || `&quot;$&#123;TM_FILENAME/[^0-9^a-z]//gi&#125;&quot;` | `example123456TESTjs` | Remove non-alphanumeric characters |### Build value 代码片段插件 `bvtf` 的实现 `bvtf` ，是上面变量和变量转换的综合应用，实现了下面功能1. 自动识别文件名称2. 将文件名称去掉后缀，转换为大写驼峰法（pascalcase）源码获取步骤：1. 去 github 官网下载它的源码，[built-value-snippets](https://github.com/GiancarloCode/built-value-snippets)2. 在 vscode-&gt;snippets-&gt;snippets.json 找到对应的源码，如下 ```json &#123; &quot;Built Value Type File&quot;: &#123; &quot;prefix&quot;: &quot;bvtf&quot;, &quot;body&quot;: [ &quot;import &#x27;package:built_collection/built_collection.dart&#x27;;&quot;, &quot;import &#x27;package:built_value/built_value.dart&#x27;;&quot;, &quot;&quot;, &quot;part &#x27;$TM_FILENAME_BASE.g.dart&#x27;;&quot;, &quot;&quot;, &quot;abstract class $&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125; implements Built&lt;$&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125;, $&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125;Builder&gt; &#123;&quot;, &quot; $&#123;2&#125;&quot;, &quot;&quot;, &quot; $&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125;._();&quot;, &quot; factory $&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125;([void Function($&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125;Builder) updates]) = _$$&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125;;&quot;, &quot;&#125;&quot; ], &quot;description&quot;: &quot;Built Value Type File whose name corresponds to the file name&quot; &#125; &#125; 核心的变量如下： 12// file name: home_page.dart =&gt; HomePage&quot;$&#123;TM_FILENAME_BASE/(.*)$/$&#123;1:/pascalcase&#125;/&#125;&quot; 通过上面的学习我们几乎可能编写我们的日常需要各种代码片段 引用 built-value-snippets Built Value Snippets VSCode 插件 Snippets in Visual Studio Code","categories":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/categories/%E6%95%88%E7%8E%87/"}],"tags":[{"name":"Snippets","slug":"Snippets","permalink":"https://blog.wangruofeng007.com/tags/Snippets/"}]},{"title":"用 Typora 的 MarkDown 绘制 Diagrams(图解)","slug":"用Typora的MarkDown绘制Diagrams-图解","date":"2019-11-29T08:38:05.000Z","updated":"2024-11-03T05:32:35.305Z","comments":true,"path":"2019/11/29/用Typora的MarkDown绘制Diagrams-图解/","permalink":"https://blog.wangruofeng007.com/2019/11/29/%E7%94%A8Typora%E7%9A%84MarkDown%E7%BB%98%E5%88%B6Diagrams-%E5%9B%BE%E8%A7%A3/","excerpt":"简介最近在研究软件设计领域常用各种图解，发现Typorad 对 MarkDown 渲染 diagrams 的支持特别好，于是整理了一下，方便以后查阅使用，目前(测试版本 0.9.9.18.1(1088) )支持以下几大类图解: Sequence Flowchart Mermaid sequence (时序图) flowchart (流程图) gantt (甘特图)","text":"简介最近在研究软件设计领域常用各种图解，发现Typorad 对 MarkDown 渲染 diagrams 的支持特别好，于是整理了一下，方便以后查阅使用，目前(测试版本 0.9.9.18.1(1088) )支持以下几大类图解: Sequence Flowchart Mermaid sequence (时序图) flowchart (流程图) gantt (甘特图) Sequence 由js-sequence驱动 Flowchart 由flowchart.js驱动 Mermaid 由mermaid驱动，支持 sequence，flowchart，gantt Sequence – 时序图UML 时序图(sequence)12345对象 A-&gt;对象 B: 对象 B 你好吗?（请求）Note right of 对象 B: 对象 B 的描述Note left of 对象 A: 对象 A 的描述(提示)对象 B--&gt;对象 A: 我很好(响应)对象 A-&gt;对象 B: 你真的好吗？ UML 时序图复杂(sequence)1234567891011Title: 标题：复杂使用对象 A-&gt;对象 B: 对象 B 你好吗?（请求）Note right of 对象 B: 对象 B 的描述Note left of 对象 A: 对象 A 的描述(提示)对象 B--&gt;对象 A: 我很好(响应)对象 B-&gt;小三: 你好吗小三--&gt;&gt;对象 A: 对象 B 找我了对象 A-&gt;对象 B: 你真的好吗？Note over 小三,对象 B: 我们是朋友participant CNote right of C: 没人陪我玩 UML 标准时序图(mermaid)123456789101112%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头sequenceDiagramparticipant 张三participant 李四张三-&gt;王五: 王五你好吗？loop 健康检查王五-&gt;王五: 与疾病战斗endNote right of 王五: 合理 食物 &lt;br/&gt;看医生...李四--&gt;&gt;张三: 很好!王五-&gt;李四: 你怎么样?李四--&gt;王五: 很好! 语法说明： 12345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow flowchart – 流程图横向流程图(mermaid)123456graph LRA[方形] --&gt;B(圆角)B --&gt; C&#123;条件 a&#125;C --&gt;|a=1| D[结果 1]C --&gt;|a=2| E[结果 2]F[横向流程图] 竖向流程图(mermaid)123456graph TBA[方形] --&gt;B(圆角)B --&gt; C&#123;条件 a&#125;C --&gt;|a=1| D[结果 1]C --&gt;|a=2| E[结果 2]F[竖向流程图] 标准流程图(flow)123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op 标准流程图-横向(flow)12345678910st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op 甘特图样例 (gantt)12345678910111213141516171819202122%% 语法示例ganttdateFormat YYYY-MM-DDtitle 软件开发甘特图section 设计需求:done, des1, 2014-01-06,2014-01-08原型:active, des2, 2014-01-09, 3dUI 设计: des3, after des2, 5d未来任务: des4, after des3, 5dsection 开发学习准备理解需求 :crit, done, 2014-01-06,24h设计框架 :crit, done, after des2, 2d开发 :crit, active, 3d未来任务 :crit, 5d耍 :2dsection 测试功能测试 :active, a1, after des3, 3d压力测试 :after a1 , 20h测试报告 : 48h 不错的画图工具网站 https://www.processon.com https://www.draw.io 参考资料 Draw Diagrams With Markdown Typora 画流程图、时序图(顺序图)、甘特图（转） mermaid mermaid-live-editor","categories":[{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/categories/%E6%95%88%E7%8E%87/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"https://blog.wangruofeng007.com/tags/Typora/"}]},{"title":"[转]Objective-C Runtime 大佬系列文章整理","slug":"转-Objective-C-Runtime-大佬系列文章整理","date":"2019-11-17T16:41:40.000Z","updated":"2024-11-03T05:32:35.284Z","comments":true,"path":"2019/11/18/转-Objective-C-Runtime-大佬系列文章整理/","permalink":"https://blog.wangruofeng007.com/2019/11/18/%E8%BD%AC-Objective-C-Runtime-%E5%A4%A7%E4%BD%AC%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E6%95%B4%E7%90%86/","excerpt":"简介此文转自 kangzubin 收集的 runtime 大佬系列文章，特别鸣谢，方便后续查阅。","text":"简介此文转自 kangzubin 收集的 runtime 大佬系列文章，特别鸣谢，方便后续查阅。 kangzubin最近重新温习了下 Objective-C Runtime 相关的知识，自己整理了两篇水文： Objective-C 1.0 中类与对象的定义 Objective-C 2.0 中类与对象的定义 然后在网上搜罗了一圈，发现很多大佬之前都写了一系列关于 Runtime 的文章，深入浅出，真是让人难以望其项背，收集如下，方便日后学习，欢迎补充。 Greg Parker Classes and metaclasses Matt Gallagher What is a meta-class in Objective-C? 南峰子 Objective-C Runtime 运行时之一：类与对象 Objective-C Runtime 运行时之二：成员变量与属性 Objective-C Runtime 运行时之三：方法与消息 Objective-C Runtime 运行时之四：Method Swizzling Objective-C Runtime 运行时之五：协议与分类 Objective-C Runtime 运行时之六：拾遗 halfrost 神经病院 Objective-C Runtime 入院第一天 —— isa 和 Class 神经病院 Objective-C Runtime 住院第二天 —— 消息发送与转发 神经病院 Objective-C Runtime 出院第三天 —— 如何正确使用 Runtime Objc 对象的今生今世 杨萧玉 Objective-C Runtime Objective-C 引用计数原理 Objective-C 消息发送与转发机制原理 雷纯锋 Objective-C 对象模型 Objective-C +load vs +initialize Objective-C Category 的实现原理 Objective-C Autorelease Pool 的实现原理 Objective-C Method Swizzling 的最佳实践 Objective-C Associated Objects 的实现原理 draveness&#x2F;analyze 从 NSObject 的初始化了解 isa 深入解析 ObjC 中方法的结构 从源代码看 ObjC 中消息的发送 你真的了解 load 方法么？ 自动释放池的前世今生 黑箱中的 retain 和 release 关联对象 AssociatedObject 完全解析 懒惰的 initialize 方法 对象是如何初始化的（iOS） CornBallast Runtime 深度解析以及实用技巧 Runtime 奇技淫巧__带你深入理解 Runtime 特有概念 Runtime 奇技淫巧__不受限制的消息发送 Runtime 奇技淫巧__获取类的实例变量以及属性并强势 与 KVC、msgSend 混用 Runtime 奇技淫巧__方法交换 Runtime 奇技淫巧__动态链接对象以及给分类添加属性 Runtime 奇技淫巧__动态添加方法，消息转发改善异常 唐巧 Objective-C 对象模型及应用 ibireme Objective-C 中的类和对象 sunnyxx objc 与鸭子对象（上） objc 与鸭子对象（下） 神经病院 objc runtime 入院考试 重识 Objective-C Runtime - Smalltalk 与 C 的融合 重识 Objective-C Runtime - 看透 Type 与 Value 其他此外，在简书、掘金等技术博客平台，以及 Google 上搜索 Objective-C Runtime 关键词，也能找出成千上万相关的文章。","categories":[],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"https://blog.wangruofeng007.com/tags/Runtime/"}]},{"title":"从零开始创建 cocoaPods 公有库","slug":"从零开始创建cocoaPods公有库","date":"2019-11-17T10:50:41.000Z","updated":"2024-11-03T05:32:35.306Z","comments":true,"path":"2019/11/17/从零开始创建cocoaPods公有库/","permalink":"https://blog.wangruofeng007.com/2019/11/17/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%88%9B%E5%BB%BAcocoaPods%E5%85%AC%E6%9C%89%E5%BA%93/","excerpt":"简介这篇文章记录了一个公共 Pod 库 RFSegmentView的创建过程","text":"简介这篇文章记录了一个公共 Pod 库 RFSegmentView的创建过程 注册 CocoaPods 账号想要创建一个开源 pod 库, 首先我们需要注册 CocoaPods, 这里使用 trunk 方式, 那么只需要在终端执行（这里默认你已经安装好 CocoaPods 环境）: 1pod trunk register 邮箱地址 &#x27;用户名&#x27; --verbose 这里我们一般使用 github 邮箱和用户名, 然后在你的邮箱中会收到确认邮件,下面是确认邮件的内容： 在浏览器中点击链接确认即注册成功, 成功之后可以终端执行: 1pod trunk me 通过上面的命令查看注册信息，里面会展示该账号下的所有的 Pod 库，可以用此方式查看自己发布过的 Pods 12345678➜ myBlog git:(master) ✗ pod trunk me - Name: wangruofeng - Email: wangruofeng007@gmail.com - Since: November 16th, 12:17 - Pods: - RFSegmentView - Sessions: - November 16th, 12:17 - March 24th, 2020 04:54. IP: 119.123.133.39 创建共享库文件并上传到公有仓库共享库需要三个必不可少的部分: 共享文件夹 (文件夹存放着你要共享的内容, 也就是其他人通过 pod 安装得到的文件, .podspec 文件中的 source_files 需要指定此文件路径及文件类型); LICENSE文件 (默认一般选择 MIT); 库名.podspec (本库的各项信息描述, 需要提交给 CocoaPods, pod 通过这个文件查找到你共享的库). 如果没有 podspec 文件可以用下面的命令，初始化 1pod lib create 库名 编辑.podspec 文件以 RFSegmentView.podspec 为例： 1234567891011121314151617181920Pod::Spec.new do |spec| spec.name = &quot;RFSegmentView&quot; spec.version = &quot;1.3.0&quot; spec.summary = &quot;Imitate iOS7 style segmented controls, simple, practical！&quot; spec.homepage = &quot;https://github.com/wangruofeng/RFSegmentView&quot; spec.license = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE.md&quot; &#125; spec.author = &#123; &quot;wangruofeng&quot; =&gt;&quot;wangruofeng007@gmail.com&quot; &#125; spec.platform = :ios, &quot;8.0&quot; spec.source = &#123; :git =&gt; &#x27;https://github.com/wangruofeng/RFSegmentView.git&#x27;, :tag =&gt; spec.version.to_s&#125; spec.source_files = &quot;RFSegmentView/RFSegmentView.&#123;h,m&#125;&quot; # spec.exclude_files = &quot;Classes/Exclude&quot; # spec.public_header_files = &quot;Classes/**/*.h&quot; spec.frameworks = &#x27;UIKit&#x27;, &#x27;CoreGraphics&#x27;, &#x27;Foundation&#x27; spec.requires_arc = true # spec.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot; 添加依赖库end 编写完成后, 我们需要验证.podspec 文件的合法性, 这里需要终端 cd 到.podspec 文件所在文件夹, 执行: 1pod lib lint RFSegmentView.podspec 如有警告或者错误请重新检查你的编写正确性, 如果没有问题会出现 123-&gt; RFSegmentView (1.3.0) RFSegmentView passed validation. 打 tag，发布新版本一切准备就绪后, 我们需要在你的 git 仓库里面存在一个与.podspec 文件中一致的版本, 这里你可以在你的 git 仓库中的准备一个版本, 也可以在当前文件夹下使用终端命令: 12git tag -m &#x27;first release&#x27; &#x27;1.3.0&#x27;git push --tag #推送 tag 到远端仓库 成功之后即可在你分支里面看到这个 tag 的版本. 发布库描述文件下面我们需要发布自己的库描述文件 podspec 给 cocoapods同样在这个文件夹下, 终端执行: 1pod trunk push RFSegmentView.podspec 将你的库文件.podspec 文件提交到公有的 specs 上面, 这一步做的操作是验证你的 podspec 文件是否合法+提交到 specs 中+将上传的 podspec 文件转成 json 格式文件,如果重复提交会出现下面的信息: 1[!] Unable to accept duplicate entry for: RFSegmentView (1.3.0) 为了测试将 RFSegmentView.podspec 里面的 spec.version 修改成 1.3.1,成功后会出现 Congrats 信息: 12345678910111213141516171819➜ RFSegmentView git:(master) pod trunk push RFSegmentView.podspecUpdating spec repo `trunk` Validating podspec -&gt; RFSegmentView (1.3.1) - NOTE | xcodebuild: note: Using new build system - NOTE | [iOS] xcodebuild: note: Planning build - NOTE | [iOS] xcodebuild: note: Constructing build description - NOTE | [iOS] xcodebuild: warning: Skipping code signing because the target does not have an Info.plist file and one is not being generated automatically. (in target &#x27;App&#x27; from project &#x27;App&#x27;)Updating spec repo `trunk` -------------------------------------------------------------------------------- 🎉 Congrats 🚀 RFSegmentView (1.3.1) successfully published 📅 November 17th, 07:08 🌎 https://cocoapods.org/pods/RFSegmentView 👍 Tell your friends!-------------------------------------------------------------------------------- 查找和使用新创建的库成功后需要等待的时间不定, 目前一般比较快, 一般使用 pod setup 和 pod search 查看是否已经可以使用, 如果 pod search RFSegmentView 一直搜索不到，尝试删除 pod setup 成功后生成的 ~/Library/Caches/CocoaPods/search_index.json 文件, 该文是用来查找的索引文件, 终端输入: 1rm ~/Library/Caches/CocoaPods/search_index.json 删除成功后再执行: pod search 库名 , 等待输出： Creating search index for spec repo &#39;master&#39;.. Done! 稍等片刻就会出现你想要的结果,如果还是没有结果需要等待 pod 同步，过一段时间再来尝试。 更新维护 podspec如果有错误或者需要迭代版本,修改工程文件后推送到远端仓库后, 需要修改 podspec 中的版本号, 并重新打 tag 上传, 再进行新一轮的验证和发布。 参考资料 CocoaPods 创建公有和私有 Pod 库方法总结 Podspecs Podspec attributes","categories":[{"name":"包管理","slug":"包管理","permalink":"https://blog.wangruofeng007.com/categories/%E5%8C%85%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://blog.wangruofeng007.com/tags/CocoaPods/"}]},{"title":"Pod 常用命令","slug":"Pod常用命令","date":"2019-11-14T15:45:42.000Z","updated":"2024-11-03T05:32:35.290Z","comments":true,"path":"2019/11/14/Pod常用命令/","permalink":"https://blog.wangruofeng007.com/2019/11/14/Pod%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"简介介绍 Pod 常用的几种命令","text":"简介介绍 Pod 常用的几种命令 pod init第一次调用会初始化项目，如果已经初始化后调用会抛出以下错误。 [!] Existing Podfile found in directory pod install根据 podfile.lock 文件中指定的 pod 依赖库的版更新项目的 pod 依赖库。在首次执行 pod install 命令时，如果不存在 podfile.lock 文件会生成该文件，并且同时生成 xcworkspace 文件和 pods 文件夹。 pod install 执行后，后续的项目需要使用 xxx.xcworkspace 打开 参数：–no-repo-update 不更新 pod 仓库，使用此命令可以加快 pod install 的更新速度。 eg: pod install --no-repo-update pod update这个命令会检查 podfile.lock 文件中的 pod 依赖库的版本，并更新，会重新生成一个新 podfile.lock 文件。 选项：–exclude-pods&#x3D;xxx 只更新 xxx 之外的仓库。 eg: pod update --exclude-pods=AFNetworking 选项：xxx –no-repo-update 只更新 xxx 依赖不更新除它之外的其他依赖。 eg: pod update AFNetworking --no-repo-update 一般没有特别必要时不建议使用 pod update 命令,尽量使用 pod install，如果实在不行再使用带上面选项的 od update，如果更新失败才使用 pod update 命名，这样能明显加快更新流程，节约更新依赖的时间。 pod search后面更新依赖库的名称，搜索指定依赖库 eg: pod search AFNetworking 123456789101112131415161718-&gt; AFNetworking (3.2.1) A delightful iOS and OS X networking framework. pod &#x27;AFNetworking&#x27;, &#x27;~&gt; 3.2.1&#x27; - Homepage: https://github.com/AFNetworking/AFNetworking - Source: https://github.com/AFNetworking/AFNetworking.git - Versions: 3.2.1, 3.2.0, 3.1.0, 3.0.4, 3.0.3, 3.0.2, 3.0.1, 3.0.0, 3.0.0-beta.3, 3.0.0-beta.2, 3.0.0-beta.1, 2.7.0, 2.6.3, 2.6.2, 2.6.1, 2.6.0, 2.5.4, 2.5.3, 2.5.2, 2.5.1, 2.5.0, 2.4.1, 2.4.0, 2.3.1, 2.3.0, 2.2.4, 2.2.3, 2.2.2, 2.2.1, 2.2.0, 2.1.0, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 2.0.0-RC3, 2.0.0-RC2, 2.0.0-RC1, 1.3.4, 1.3.3, 1.3.2, 1.3.1, 1.3.0, 1.2.1, 1.2.0, 1.1.0, 1.0.1, 1.0, 1.0RC3, 1.0RC2, 1.0RC1, 0.10.1, 0.10.0, 0.9.2, 0.9.1, 0.9.0, 0.7.0, 0.5.1 [master repo] - Subspecs: - AFNetworking/Serialization (3.2.1) - AFNetworking/Security (3.2.1) - AFNetworking/Reachability (3.2.1) - AFNetworking/NSURLSession (3.2.1) - AFNetworking/UIKit (3.2.1) pod repo查看所有 pod 仓库的源 1234master- Type: git (master)- URL: https://github.com/CocoaPods/Specs.git- Path: /Users/wangruofeng/.cocoapods/repos/master 选项：remove xxx eg: pod repo remove xxx 移除 xxx repo 源 pod try非常棒，却很少有人知道，使您可以在将库添加到项目之前对其进行测试驱动。 选项：try xxx 1pod try AFNetworking pod outdated显示当前 Podfile.lock 文件中过期的 pods，仅仅是来自 spec repos，不包含来自本地和外部的资源。 gem source 操作当前 gem 源查看 gem source -l 123*** CURRENT SOURCES ***https://gems.ruby-china.com/ 移除指定的 gem 源 gem source - - remove https://rubygems.org/ 添加指定的 gem 源 gem source - a https://gems.ruby-china.com/ 更新 cocoapod sudo gem install cocoapods","categories":[],"tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://blog.wangruofeng007.com/tags/CocoaPods/"},{"name":"Skill","slug":"Skill","permalink":"https://blog.wangruofeng007.com/tags/Skill/"}]},{"title":"从 Octopress 迁移博客到 hexo","slug":"从Octopress迁移博客到hexo","date":"2019-11-10T10:16:11.000Z","updated":"2024-11-03T05:32:35.308Z","comments":true,"path":"2019/11/10/从Octopress迁移博客到hexo/","permalink":"https://blog.wangruofeng007.com/2019/11/10/%E4%BB%8EOctopress%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E5%88%B0hexo/","excerpt":"","text":"简介最近准备更新博客（以前的基于 Octopress），去写的时候突然发现以前的博客跑不起来了…倒腾了一下，在执行博客更新时 rake generate ，一直报错，错误出现在高亮解析模块 Pygments ，尝试升级 jekyll 但是和它相关的依赖模块还是有问题。 1234567➜ Octopress git:(source) ✗ rake generate## Generating Site with JekyllConfiguration file: /Users/wangruofeng/Documents/Git Repositories/Octopress/_config.yml Source: source Destination: public Generating... jekyll 2.5.3 | Error: Pygments can&#x27;t parse unknown language: objective-c. 后面去 Octopress 官网查了了，发现上次更新还是 2015.01.15 的事了，后续也没有更新，于是觉得这个不太靠谱，准备换一个，调研了一下，发现使用 hexo 的挺多，于是开始捣腾起来… 准备环境\b准备 node 和 git 环境， 首先，安装 NodeJS，因为 Hexo 是基于 Node.js 驱动的一款博客框架。 在命令行中输入相应命令验证是否成功，如果成功会有相应的版本号。 123456➜ myBlog git:(master) ✗ git versiongit version 2.24.0➜ myBlog git:(master) ✗ node -vv12.13.0➜ myBlog git:(master) ✗ npm -v6.12.0 安装 Hexo如果以上环境准备好了就可以使用 npm 开始安装 Hexo 了。也可查看 Hexo 的详细文档。 在命令行输入执行以下\b命令： 1npm install -g hexo-cli 没有权限的话可能会出现下面的错误信息: 12345678910111213npm ERR! code EACCESnpm ERR! syscall mkdirnpm ERR! path /Users/wangruofeng/.npm/_cacache/content-v2/sha512/0b/8anpm ERR! errno -13npm ERR! npm ERR! Your cache folder contains root-owned files, due to a bug innpm ERR! previous versions of npm which has since been addressed.npm ERR! npm ERR! To permanently fix this problem, please run:npm ERR! sudo chown -R 501:20 &quot;/Users/wangruofeng/.npm&quot;npm ERR! A complete log of this run can be found in:npm ERR! /Users/wangruofeng/.npm/_logs/2019-11-10T07_21_42_135Z-debug.log 报错的话加上 sudo 重试一次或者执行sudo chown -R 501:20 “&#x2F;Users&#x2F;wangruofeng&#x2F;.npm” 1234➜ Git Repositories sudo npm install -g hexo-cli/usr/local/Cellar/node/5.7.0/bin/hexo -&gt; /usr/local/Cellar/node/5.7.0/lib/node_modules/hexo-cli/bin/hexo+ hexo-cli@3.1.0added 67 packages from 317 contributors in 27.347s 安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123hexo init myBlogcd myBlognpm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 ├── package.json├── scaffolds # 模版文件夹├── source # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到 public 文件夹| ├── _drafts # 草稿文件| └── _posts # 文章 Markdowm 文件 └── themes # 主题文件夹 好了，如果上面的\b命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的\b缩写，在浏览器中输入 http://localhost:4000 回车就可以预览效果了。 1hexo s 至此，你本地的博客就已经搭建成功，接下来就是部署到 Github Page 了。 部署到 GitHub此时，本地和 Github 的工作做得差不了，是时候把它们两个连接起来了。你\b也可以查看官网的部署教程。 先不着急，部署之前还需要修改配置和安装部署插件。 第一：打开项目根目录下的 _config.yml 配置文件\b配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）： 1234567# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repo: github: https://github.com/wangruofeng/wangruofeng.github.io.git branch: master 第二：要安装一个部署\b插件 hexo-deployer-git。 1npm install hexo-deployer-git --save 最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写 1hexo g -d 稍等一会，在浏览器访问网址： https:&#x2F;&#x2F;你的用户名.github.io 就会看到你的博客啦！！ 开始写作博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档可以看 hexo 官网。 新建文章，输入以下命令即可 1hexo new &#x27;文章标题&#x27; 执行完成后可以在 &#x2F;source&#x2F;_posts 下看到一个“文章标题.md”的文章文件啦。.md 就是 Markdown 格式的文件，具体用法可以在网上找一下，语法还是比较简单的。 在 Markdown 文章里面输入你的文章内容 再执行一下以下命令 12hexo g # 生成相关文件hexo s # 部署到本地 最后，只要部署到你的 Github 上就可以了！ 12hexo cleanhexo g -d 部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 另外，如果你的文章暂时不发布可以先保存在草稿里面。生成草稿的方法和文章差不多 hexo new draft “文章标题”，生成后会在 &#x2F;source&#x2F;_drafts 里看到你的草稿文章。当你想发布时只要执行 publish 命令即可发布到博客。 1hexo publish [layout] &lt;filename&gt; 遇到的坑1. Hexo: TypeError: Cannot set property ‘lastIndex’ of undefined解决方案是 将你工程下的 _config.yml (这个不是主题的_config.yml) 文件里面的 auto_detect 设置为 false。 12345highlight: enable: true line_number: true auto_detect: false tab_replace: 2.修改完 hexo 目录下的 _config.yml 文件 重新 generate 文件不生效使用 hexo 的命令 hexo clean ,清除一下。 参考链接 运行 hexo g 出错 #1913 有哪些好看的 Hexo 主题？ 超详细 Hexo+Github Page 搭建技术博客教程【持续更新】","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://blog.wangruofeng007.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.wangruofeng007.com/tags/Hexo/"}]},{"title":"NSNumber 转 NSString 丢精问题","slug":"2017-10-14-nsnumberzhuan-nsstringdiu-jing-wen-ti","date":"2017-10-14T12:53:01.000Z","updated":"2024-11-03T05:32:35.294Z","comments":true,"path":"2017/10/14/2017-10-14-nsnumberzhuan-nsstringdiu-jing-wen-ti/","permalink":"https://blog.wangruofeng007.com/2017/10/14/2017-10-14-nsnumberzhuan-nsstringdiu-jing-wen-ti/","excerpt":"问题引出在开发中，涉及价格金额处理，后台会返回 Number 类型的数据，打印或者经过 JSON 转 Model 后的 NSString 可能出现精度丢失的问题，如果涉及到金额的加减乘除运算问题将暴露得更为明显。这里就 iOS 数据精度处理做一个总结。","text":"问题引出在开发中，涉及价格金额处理，后台会返回 Number 类型的数据，打印或者经过 JSON 转 Model 后的 NSString 可能出现精度丢失的问题，如果涉及到金额的加减乘除运算问题将暴露得更为明显。这里就 iOS 数据精度处理做一个总结。 问题复现NSNumber 转 NSString12345678910111213141516171819202122232425262728293031323334NSArray *numbers = @[ @99.00, @99.09, @99.19, @99.29, @99.39, @99.49, @99.59, @99.69, @99.79, @99.89, @99.99, ];for (int i = 0; i &lt; numbers.count; i++) &#123; NSNumber *number = numbers[i]; NSString *strValue = [number stringValue]; NSLog(@&quot;strValue:%@&quot;,strValue);&#125;/* oldVlue:99.00 strValue:99 oldVlue:99.09 strValue:99.09 oldVlue:99.19 strValue:99.19 oldVlue:99.29 strValue:99.29000000000001 oldVlue:99.39 strValue:99.39 oldVlue:99.48 strValue:99.48999999999999 oldVlue:99.59 strValue:99.59 oldVlue:99.69 strValue:99.69 oldVlue:99.79 strValue:99.79000000000001 oldVlue:99.89 strValue:99.89 oldVlue:99.99 strValue:99.98999999999999 */ 在这里我们发现将 NSNumber 转换成 NSString 的过程中可能会出现精度丢失。 JSON 到 Model12345678910111213141516171819//出现 BUG 的条件必须是两位数，且带两位小数，类型还必须是 float//两位数：十位必须是 7、8、9；个位数随意//两位小数：个位数随意；十位数必须是 0NSString *jsonStr = @&quot;&#123;\\&quot;71.40\\&quot;:71.40, \\&quot;97.40\\&quot;:97.40, \\&quot;80.40\\&quot;:80.40, \\&quot;188.40\\&quot;:188.40&#125;&quot;;NSLog(@&quot;json:%@&quot;, jsonStr);NSData *jsonData = [jsonStr dataUsingEncoding:NSUTF8StringEncoding];NSError *jsonParsingError = nil;NSDictionary *dic = [NSMutableDictionary dictionaryWithDictionary:[NSJSONSerialization JSONObjectWithData:jsonData options:0 error:&amp;jsonParsingError]];NSLog(@&quot;dic:%@&quot;, dic);/*2017-10-14 18:29:19.434 FloatTransferDemo[62722:3093992] dic:&#123; &quot;188.40&quot; = &quot;188.4&quot;; &quot;71.40&quot; = &quot;71.40000000000001&quot;; &quot;80.40&quot; = &quot;80.40000000000001&quot;; &quot;97.40&quot; = &quot;97.40000000000001&quot;;&#125;*/ 在这里我们发现将 JSON 解析成 Model 的过程中可能会出现精度丢失。 问题分析因为浮点数在计算机中是采用 IEEE 规定的标准浮点格式，即二进制科学表示法。在这种表示法中，一个数 S = M * 2 ^ N 。 其中 N 表示阶码，M 表示位数(有效数字位)。例如一个 float 类型的浮点，在 32bit 位上，占 4 个字节，字节表示为 【31】N:【30 ~ 23】 M:【22~0】 31 位表示符号位: 0 正，1 负 中间 8 位是阶码位: 表示范围【-128 ~ 127】,对于 float 类型数据规定其偏移量为 127 后面 23 位是有效数字位: 因为科学计数法，整数位定死了是 1，所以这里记录的是小数点后面的二进制为 指数 N 决定它的范围，因为 M 总是一个以 1 开头的小数，以 float 来说即是：-2 ^ 128 ~ 2 ^ 128,即 float 能表示的数的大小的范围。 而它的精度是由位数(也就是有效的数据位)来决定的， 2 ^ 23 &#x3D; 8388608，总共 7 位，表示最多能用 7 位有效数字，最多能表示到.8388708 即小数点后 7 位，由于不能完全表示全部的 7 位数，所以它的精度范围是 6 位~7 位。 同理可得 double 的精度是 2 ^ 52 &#x3D; 4503599627370496， 共 16 位，所以精度为 15 ~ 16 位。 总结：float&#x2F;double 类型的范围和精度的计算方式不同机器字节序的规定 公式： S = M * 2 ^ N 二进制在内存中是以补码形式存储，负数要对其二进制绝对值按位取反再加一，正数的补码与原码形式相同 也就是说 float 和 doublel 类型数据在计算机中存储可能是不精确的。当我们需要转换成浮点类型是数据时，最好用 double，因为 double 的精度更高，出现丢精度的概率相对是较小的。 在 iOS 中提供一个专用的类来处理浮点数据相关的运算： NSDecimalNumber ### 解决方案 使用 NSDecimalNumber 来进行浮点数处理。我们给 NSString 添加一个分类来处理浮点运算问题 1234567891011121314151617181920212223242526272829///.h@interface NSString (DecimalNumber)+ (NSString *)decimalNumberWithNSNumber:(NSNumber * )number;+ (NSString *)decimalNumberWithDouble:(double)conversionValue;@end///.m#import &quot;NSString+DecimalNumber.h&quot;@implementation NSString (DecimalNumber)+ (NSString *)decimalNumberWithNSNumber:(NSNumber * )number&#123; double conversionValue = [number doubleValue]; NSString *doubleString = [NSString stringWithFormat:@&quot;%lf&quot;, conversionValue]; NSDecimalNumber *decNumber = [NSDecimalNumber decimalNumberWithString:doubleString]; return [decNumber stringValue];&#125;+ (NSString *)decimalNumberWithDouble:(double)conversionValue&#123; NSString *doubleString = [NSString stringWithFormat:@&quot;%lf&quot;, conversionValue]; NSDecimalNumber *decNumber = [NSDecimalNumber decimalNumberWithString:doubleString]; return [decNumber stringValue];&#125;@end 如何使用12345678910111213141516171819202122232425262728293031323334NSArray *numbers = @[ @99.00, @99.09, @99.19, @99.29, @99.39, @99.49, @99.59, @99.69, @99.79, @99.89, @99.99, ];for (int i = 0; i &lt; numbers.count; i++) &#123; NSNumber *number = numbers[i]; NSString *strValue = [NSString decimalNumberWithNSNumber:number]; NSLog(@&quot;strValue:%@&quot;,strValue);&#125;/* oldVlue:99.00 strValue:99 oldVlue:99.09 strValue:99.09 oldVlue:99.19 strValue:99.19 oldVlue:99.29 strValue:99.29 oldVlue:99.39 strValue:99.39 oldVlue:99.48 strValue:99.49 oldVlue:99.59 strValue:99.59 oldVlue:99.69 strValue:99.69 oldVlue:99.79 strValue:99.79 oldVlue:99.89 strValue:99.89 oldVlue:99.99 strValue:99.99 */ 问题得以解决。☕️ 参考资料： https://developer.apple.com/documentation/foundation/nsdecimalnumber http://www.jianshu.com/p/4703d704c953 https://eezytutorials.com/ios/nsdecimalnumber-by-example.php http://www.skyfox.org/ios-nsdecimalnumber-use.html https://stackoverflow.com/questions/421463/should-i-use-nsdecimalnumber-to-deal-with-money","categories":[{"name":"最佳实践","slug":"最佳实践","permalink":"https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"精度","slug":"精度","permalink":"https://blog.wangruofeng007.com/tags/%E7%B2%BE%E5%BA%A6/"}]},{"title":"NSSortDescriptor 正确的打开方式","slug":"2017-06-07-nssortdescriptorzheng-que-de-da-kai-fang-shi","date":"2017-06-06T16:09:44.000Z","updated":"2024-11-03T06:02:57.857Z","comments":true,"path":"2017/06/07/2017-06-07-nssortdescriptorzheng-que-de-da-kai-fang-shi/","permalink":"https://blog.wangruofeng007.com/2017/06/07/2017-06-07-nssortdescriptorzheng-que-de-da-kai-fang-shi/","excerpt":"排序是应用常见需求之一，如何正确优雅的实现一个排序， NSSortDescriptor 或许是一个非常好的选择。 NSSortDescriptor 由3个参数组成： key(键):对于一个给定的集合，将对集合种的每个对象按照该键来进行排序 ascending(升序):指定集合按照升序(YES)还是降序(NO)进行排序 selector(方法子):排序时的比较函数，当对字符串进行排序时，应当加入 localizedStandardCompare: 选择器，它将根据语言规则进行排序(例如大小写，变音符号等等的顺序)","text":"排序是应用常见需求之一，如何正确优雅的实现一个排序， NSSortDescriptor 或许是一个非常好的选择。 NSSortDescriptor 由3个参数组成： key(键):对于一个给定的集合，将对集合种的每个对象按照该键来进行排序 ascending(升序):指定集合按照升序(YES)还是降序(NO)进行排序 selector(方法子):排序时的比较函数，当对字符串进行排序时，应当加入 localizedStandardCompare: 选择器，它将根据语言规则进行排序(例如大小写，变音符号等等的顺序) 如何使用NSSortDescriptor 主要针对各种集合排序 NSArray NSMutableArray NSSet NSOrderedSet NSMutableOrderedSet 如果集合是可变的，则对集合本身排序例如 NSMutableOrderedSet 的 sortUsingDescriptors: NSMutableArray 的 sortUsingDescriptors: 如果集合是可变的，则返回一个排好序的新集合例如 NSArray 的 sortedArrayUsingDescriptors: NSSet 的 sortedArrayUsingDescriptors: NSOrderedSet 的 sortedArrayUsingDescriptors: 注意排序描述是一个数组，也就是排序可以支持按照多个描述综合排序。如果存在多个规则先满足前面的规则再满足后面的规则。例如两个元素按照第一天规则顺序一致，那么如果还存在第二天规则，它们将按照第二条规则继续排序，如果前面的规则已经区分出顺序后面的规则将失效。 实例说明为了更好的描述，假如我们有一个 Person 对象，它有 NSString * 类型的姓和名属性，以及一个 NSNumber 类型的年龄属性。 1234567@interface Person : NSObject@property (nonatomic, copy ) NSString *firstName;@property (nonatomic, copy ) NSString *lastName;@property (nonatomic, strong) NSNumber *age;@end 给定以下数据集： index 0 1 2 3 4 firstName Alice Bod Charlie Quentin lastName Smith Jones Smith Alberts age 24 27 33 31 19 使用不同的 NSSortDescriptor 的不同组合来将它们排序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950NSArray *firstNames = @[@&quot;Alice&quot;, @&quot;Bod&quot;, @&quot;Charlie&quot;, @&quot;Quentin&quot;, @&quot;&quot;];NSArray *lastNames = @[@&quot;Smith&quot;, @&quot;Jones&quot;, @&quot;Smith&quot;, @&quot;&quot;, @&quot;Alberts&quot;];NSArray *ages = @[@24, @27, @33, @31, @12];NSMutableArray *people = [NSMutableArray array];[firstNames enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; Person *person = [[Person alloc] init]; person.firstName = [firstNames objectAtIndex:idx]; person.lastName = [lastNames objectAtIndex:idx]; person.age = [ages objectAtIndex:idx]; [people addObject:person];&#125;];NSSortDescriptor *firstNameSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;firstName&quot; ascending:YES selector:@selector(localizedStandardCompare:)];NSSortDescriptor *lastNameSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;lastName&quot; ascending:YES selector:@selector(localizedStandardCompare:)];NSSortDescriptor *ageSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;age&quot; ascending:NO];NSLog(@&quot;By age: %@&quot;,[people sortedArrayUsingDescriptors:@[ageSortDescriptor]]);/* 2017-06-06 23:15:02.101 NSSort​Descriptor_Demo[9103:1255482] By age: ( &quot;Charlie Smith 33&quot;, &quot;Quentin 31&quot;, &quot;Bod Jones 27&quot;, &quot;Alice Smith 24&quot;, &quot; Alberts 12&quot; ) */NSLog(@&quot;By first name: %@&quot;,[people sortedArrayUsingDescriptors:@[firstNameSortDescriptor]]);/* 2017-06-06 23:15:02.102 NSSort​Descriptor_Demo[9103:1255482] By first name: ( &quot; Alberts 12&quot;, &quot;Alice Smith 24&quot;, &quot;Bod Jones 27&quot;, &quot;Charlie Smith 33&quot;, &quot;Quentin 31&quot; )*/ NSLog(@&quot;By last name, first name: %@&quot;,[people sortedArrayUsingDescriptors:@[lastNameSortDescriptor ,firstNameSortDescriptor]]);/* 2017-06-06 23:15:02.102 NSSort​Descriptor_Demo[9103:1255482] By last name, first name: ( &quot;Quentin 31&quot;, &quot; Alberts 12&quot;, &quot;Bod Jones 27&quot;, &quot;Alice Smith 24&quot;, &quot;Charlie Smith 33&quot; ) */ 注意事项 空字符是排在普通字符之前的 基本数据类型需要包装成 NSNumber 对象来排序 字符串类型排序需要加入 localizedStandardCompare: 选择器 参考链接 NSSort​Descriptor – NSHipster","categories":[{"name":"系统 API","slug":"系统-API","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F-API/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://blog.wangruofeng007.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"从 OC 到 Swift 你要知道的事","slug":"2017-03-10-cong-ocdao-swiftni-yao-zhi-dao-de-shi","date":"2017-03-10T15:04:24.000Z","updated":"2024-11-03T05:32:35.298Z","comments":true,"path":"2017/03/10/2017-03-10-cong-ocdao-swiftni-yao-zhi-dao-de-shi/","permalink":"https://blog.wangruofeng007.com/2017/03/10/2017-03-10-cong-ocdao-swiftni-yao-zhi-dao-de-shi/","excerpt":"枚举概述Swift 中枚举和结构体也上升到对象的位置，但是却不具备完整的对象特征，比如说他们不能继承。 在 OC 中枚举本质其实是整数类型，只是给他们取了一些意义直观的名称而已，而 Swift 完全摆脱以前的思想的束缚编的更自由，拥有了以下特征。 类型更广，不限于整形，可以是 Character ， String ， Float ， Double 等，这些叫做原始值 可以拥有自己的静态成员变量来储存一些常量 可以拥有自己的方法和变量 case 条件匹配可以定义参数，可以使用 where 来过滤 通过 rawValue 可以拿到枚举的原始值","text":"枚举概述Swift 中枚举和结构体也上升到对象的位置，但是却不具备完整的对象特征，比如说他们不能继承。 在 OC 中枚举本质其实是整数类型，只是给他们取了一些意义直观的名称而已，而 Swift 完全摆脱以前的思想的束缚编的更自由，拥有了以下特征。 类型更广，不限于整形，可以是 Character ， String ， Float ， Double 等，这些叫做原始值 可以拥有自己的静态成员变量来储存一些常量 可以拥有自己的方法和变量 case 条件匹配可以定义参数，可以使用 where 来过滤 通过 rawValue 可以拿到枚举的原始值 原始值如果提供了原始值，就可以在 case 声明成员时提供默认值，这样跟 OC 的枚举在结构上一些类似 1234567enum WeekDays : Int &#123; case Monday = 0 case Tuesday = 1 case Wednesday = 2 case Thursday = 3 case Friday = 4&#125; 1.声明一个枚举值 1let monday = WeekDays.Monday 2.获取原始值 1let rawVlaue = WeekDays.Tuesday.rawValue 3.通过原始值构造某个枚举变量 1let wednesday = WeekDays.init(rawValue: 2) 相关值和 C 的联合体有点类似 1.声明 1234enum Figure &#123; case Rectangle(Int, Int) case Circle(Int)&#125; 2.使用 123456789101112131415func printFigure(figure: Figure) &#123; switch figure &#123; case .Rectangle(let width, let height): print(&quot;width:\\(width), height:\\(height)&quot;) case .Circle(let radius): print(&quot;the circle&#x27;s radius is:\\(radius)&quot;) &#125;&#125;var figure = Figure.Rectangle(1024, 768)printFigure(figure)figure = .Circle(600)printFigure(figure) OC 与 Swift 中 Options 枚举的不同定义OC 版本 NS_OPTIONS123456789typedef NS_OPTIONS(NSUInteger, NSVolumeEnumerationOptions) &#123; /* The mounted volume enumeration will skip hidden volumes. */ NSVolumeEnumerationSkipHiddenVolumes = 1UL &lt;&lt; 1, /* The mounted volume enumeration will produce file reference URLs rather than path-based URLs. */ NSVolumeEnumerationProduceFileReferenceURLs = 1UL &lt;&lt; 2&#125; Swift 版本 OPTIONS12345struct NSVolumeEnumerationOptions : OptionSetType &#123; init(rawValue rawValue: UInt) static var SkipHiddenVolumes: NSVolumeEnumerationOptions &#123; get &#125; static var ProduceFileReferenceURLs: NSVolumeEnumerationOptions &#123; get &#125;&#125; 使用 12345UIView.animateWithDuration(0.3, delay: 0.0, options: [.CurveEaseIn, .AllowUserInteraction], animations: &#123;&#125;, completion: nil) 结构体Swift 中加强了结构体的能力，可以定义和使用属性，方法，下标，构造器等，但是不能被继承，没有强制类型抓换，使用析构器和引用计数等能力 通常使用结构体来充当数据模型，常量可以使用静态关键词 static 标示 循环引用Swift 中解决循环强引用的方式 弱引用 – weak * 无主引用 – unowned ## 解决闭包中循环引用 [unowned 捕获对象]或者[weak 捕获对象] 使用实例 123456789101112131415161718192021222324252627class Person &#123; let name: String // 写法 1// lazy var printName: () -&gt;() = &#123;// [weak self] in if let strongSelf = self &#123;// print(&quot;The name is \\(strongSelf.name)&quot;)// &#125;// &#125; // 写法 2 lazy var printName: () -&gt;() = &#123; [unowned self] in print(&quot;The name is \\(self.name)&quot;) &#125; init(personName: String) &#123; name = personName &#125; deinit &#123; print(&quot;Person deinit \\(self.name)&quot;) &#125;&#125;var xiaoMing: Person? = Person(personName: &quot;xiaoMing&quot;)xiaoMing!.printNamexiaoMing = nil 二者的区别 如果我们可以确定在整个过程中 self 不会被释放的话，我们可以将上面的 weak 改为 unowned，这样就不再需要 strongSelf 的判断。但是如果在过程中 self 被释放了而 printName 这个闭包没有被释放的话 (比如 生成 Person 后，某个外部变量持有了 printName，随后这个 Persone 对象被释放了，但是 printName 已然存在并可能被调用)，使用 unowned 将造成崩溃。在这里我们需要根据实际的需求来决定是使用 weak 还是 unowned。 OC 和 Swift 中常用数据类型字符串 OC： NSString， NSMutableString Swift： String NSString 和 String 的关系：在 Swift 中，使用字符串可以使用 Foundatio 中的 NSString 和 Swift 中的 String。 Swift 在底层能够将 String 与 NSString 无缝地桥接起来，String 可以调用 NSString 的全部 API。 数组类 OC： NSArray, NSMutableArray Swift： Array [AnyObject] NSArray 和 Array 的关系：Swift 能在底层将他们自动桥接起来，一个 NSArray 对象桥接后的结果是[AnyObject]。 字典 OC： NSDictionary， NSMutableDictionary Swift： Dictionary [Object: AnyObject] NSDictionary 和 Dictionary 的关系： 底层自动桥接，一个 NSDictionary 对象桥接后的结果是[Object: AnyObject]。 类型转换类的转换使用 as 数据类型加括号 Int() OC 使用 （新的类型）原来的变量 # 类型判断 is 关键词 相当于 OC 的 isKindofClass: # 辅助命令 #file –&gt; _FILE_ #line –&gt; _LINE_ #function –&gt; _func_ 或者 _FUNCTION_ 退出程序 C: exit（0） Swift: fatalError() 或者 fatalError(message: String) 断言 OC: NSAssert * Swift: assert()","categories":[{"name":"系统 API","slug":"系统-API","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F-API/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://blog.wangruofeng007.com/tags/Swift/"}]},{"title":"Layer Animations Tips","slug":"2017-03-10-layer-animations-tips","date":"2017-03-10T14:49:01.000Z","updated":"2024-11-03T05:34:37.014Z","comments":true,"path":"2017/03/10/2017-03-10-layer-animations-tips/","permalink":"https://blog.wangruofeng007.com/2017/03/10/2017-03-10-layer-animations-tips/","excerpt":"beginTime 的妙用创建一个动画，添加到不同的图层上，可以实现复用，通过调节 beginTime 可以调节动画开始执行的时间。 例如，我们创建一个水平位移动画，添加到不同的图层对象上，并且让他们轮流执行。","text":"beginTime 的妙用创建一个动画，添加到不同的图层上，可以实现复用，通过调节 beginTime 可以调节动画开始执行的时间。 例如，我们创建一个水平位移动画，添加到不同的图层对象上，并且让他们轮流执行。 1234567891011121314151617let flyRight = CABasicAnimation(keyPath: &quot;position.x&quot;)flyRight.fromValue = 0flyRight.toValue = 100flyRight.duration = 0.5flyRight.fillMode = kCAFillModeBothfirstView.layer.addAnimation(flyRight, forKey: nil)// make secondView perform animation on delay 0.3 seconds.flyRight.beginTime = CACurrentMediaTime() + 0.3secondView.layer.addAnimation(flyRight, forKey: nil)secondView.layer.position.x = 100// make thirdView perform animation on delay 0.4 seconds.flyRight.beginTime = CACurrentMediaTime() + 0.4thirdView.layer.addAnimation(flyRight, forKey: nil)thirdView.layer.position.x = 100 动画的 beginTime 属性可以设置将要执行的动画的绝对开始时间，通过 CACurrentMediaTime() 函数获取当前时间再加上你想要延迟执行的时间的，单位秒。 动画代理动画代理可以监听动画的进行状态，在动画开始和结束的时候回通知代理.也就是会调用以下两个函数： 12func animationDidStart(anim: CAAnimation)func animationDidStop(anim: CAAnimation, finished flag: Bool) CAAnimation CAAnimation 和它的子类遵循KVO，也就意味着你可以把它们当成字典一样使用来添加新的接口在运行时。 例如你可以使用这种机制来给某个动画指定一个名字，以便你能够把它和其它动画区分开。 1flyRight.setValue(&quot;somename&quot;, forKey: &quot;name&quot;) CASpringAnimation Property Default Value damping 10.0 mass 1.0 stiffness 100.0 initialVelocity 0.0 参数说明： damping - 应用给系统的阻尼 mass - 在系统中重物的质量 stiffness - 附加在重物上的弹簧的硬度 initialVelocity - 附加在重物上的初始速度 使用实例： 12345678910let jump = CASpringAnimation(keyPath: &quot;position.y&quot;)jump.initialVelocity = 100.0jump.mass = 10.0jump.stiffness = 1500.0jump.damping = 50.0jump.fromValue = textField.layer.position.y + 1.0jump.toValue = textField.layer.position.yjump.duration = jump.settlingDurationtextField.layer.addAnimation(jump, forKey: nil) 备注：此动画的 duration 参数可以通过前面几个参数自动计算得出 jump.duration = jump.settlingDuration 使用 CAGradientLayer 的 locations 实现滑动解锁对 CAGradientLayer 的 locations 属性做动画轻松的实现 iPhone 自带的滑动解锁效果 a.创建一个渐变图层 123456789101112131415161718192021222324let gradientLayer: CAGradientLayer = &#123; let gradientLayer = CAGradientLayer() // Configure the gradient here gradientLayer.startPoint = CGPoint(x: 0.0, y: 0.5) gradientLayer.endPoint = CGPoint(x: 1.0, y: 0.5) let colors = [ UIColor.blackColor().CGColor, UIColor.whiteColor().CGColor, UIColor.blackColor().CGColor ] gradientLayer.colors = colors let locations = [ 0.25, 0.5, 0.75 ] gradientLayer.locations = locations return gradientLayer&#125;() b.创建一个文本样式字典 123456789let textAttributes : [String: AnyObject] = &#123; let style = NSMutableParagraphStyle() style.alignment = .Center return [ NSFontAttributeName:UIFont(name: &quot;HelveticaNeue-Thin&quot;, size: 28.0)!, NSParagraphStyleAttributeName:style ]&#125;() c.当设置文本时绘制内容，添加 @IBInspectable 方便看实时效果 1234567891011121314151617@IBInspectable var text: String! &#123;didSet &#123; setNeedsDisplay() UIGraphicsBeginImageContextWithOptions(frame.size, false, 0) text.drawInRect(bounds, withAttributes: textAttributes) let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() let maskLayer = CALayer() maskLayer.backgroundColor = UIColor.clearColor().CGColor maskLayer.frame = CGRectOffset(bounds, bounds.size.width, 0) maskLayer.contents = image.CGImage gradientLayer.mask = maskLayer &#125;&#125; d.重新布局 gradientLayer 1234567override func layoutSubviews() &#123; gradientLayer.frame = CGRect( x: -bounds.size.width, y: bounds.origin.y, width: 3 * bounds.size.width, height: bounds.size.height)&#125; e.添加到 window 时向渐变层添加动画 12345678910111213override func didMoveToWindow() &#123; super.didMoveToWindow() layer.addSublayer(gradientLayer) let gradientAnimation = CABasicAnimation(keyPath: &quot;locations&quot;) gradientAnimation.fromValue = [0.0, 0.0, 0.25] gradientAnimation.toValue = [0.75, 1.0, 1.0] gradientAnimation.duration = 3.0 gradientAnimation.repeatCount = Float.infinity gradientLayer.addAnimation(gradientAnimation, forKey: nil)&#125;","categories":[{"name":"动画","slug":"动画","permalink":"https://blog.wangruofeng007.com/categories/%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"CALayer","slug":"CALayer","permalink":"https://blog.wangruofeng007.com/tags/CALayer/"}]},{"title":"VFL 深入浅出","slug":"2017-03-02-vflshen-ru-qian-chu","date":"2017-03-02T13:19:49.000Z","updated":"2024-11-03T05:32:35.300Z","comments":true,"path":"2017/03/02/2017-03-02-vflshen-ru-qian-chu/","permalink":"https://blog.wangruofeng007.com/2017/03/02/2017-03-02-vflshen-ru-qian-chu/","excerpt":"使用场景给视图对象快速创建约束，可以使用比较冷门的 VFL(Visual Format Language),本质是是基于自动布局(AutoLayout)。","text":"使用场景给视图对象快速创建约束，可以使用比较冷门的 VFL(Visual Format Language),本质是是基于自动布局(AutoLayout)。 解决的问题以一种直观的方式，为视图创建约束 怎样解决核心方法： 1234+ (NSArray&lt;__kindof NSLayoutConstraint *&gt; *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(nullable NSDictionary&lt;NSString *,id&gt; *)metrics views:(NSDictionary&lt;NSString *, id&gt; *)views; Example: 1234[NSLayoutConstraint constraintsWithVisualFormat:@&quot;|-[button1]-[button2]-[textField(&gt;=20)]-|&quot; options:0 metrics:metrics views:views] 参数： format: 指定约束的格式。更多信息，在 Auto Layout Guide 查看 Visual Format Language。 opts: 描述在视觉格式化字符串中的布局属性和方向 metrics: 将出现在视觉格式化字符串的常量字典。字典的 Keys 必须是在出现在视觉格式化字符串的字符串类型，对应的 values 必须是 NSNumber 对象。 views: 出现的视觉格式化字符串的字典 view，所有的 Keys 必须是使用在视觉格式化字符串的字符串类型，对应的 values 必须是 view 对象。 返回值： 一个约束组合的数组，像视觉格式化字符串描述的一样表述了在提供的视图和它们的父视图之间的关系。所有的约束以在视觉格式化字符串被指定的约束顺序一致。 效率和可维护性需要对 VFL 理解比较全面和深入，有一定的学习成本，维护起来比较困难，但是如果理解的比较深刻，对于简单的布局效率非常高，比直接创建约束要直观。 最佳实践 每条约束格式字符串分水平( H ，可省略)和垂直方向( V )。 | 代表父视图。 - 代表标准间距，两个子视图直接的值是 8，与父视图之间的值是 16。 [view] 每个视图必须用[]包裹起来，否则语法错误。 [view(&gt;=44)] 可以为每个视图设置一些属性或者关系，写一个紧跟 view 后的括号集合，支持宽高，优先级，和其它视图之间的关系。 [view@20] 可以设置视图的约束的优先级，以@开头，取值范围(0 1000]。 [view1]-20-[view2] 可以指定 view 之间的水平或者垂直间距，写在一对 - 即可。 [view1][view2] 如果 - 省略则他们之间的距离为 0。 [flexibleButton(&gt;=70,&lt;=100)] 多个条件之间用 , 连接并且之间不能有空格。 其它方案 使用 NSLayoutConstraint 的类方法创建(iOS96.0 及以上可用) 1234567+ (instancetype)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(nullable id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c; 使用 NSLayoutAnchor 的工厂方法创建(iOS9.0 及以上可用) 1234567- (NSLayoutConstraint *)constraintEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor;- (NSLayoutConstraint *)constraintGreaterThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor;- (NSLayoutConstraint *)constraintLessThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor;- (NSLayoutConstraint *)constraintEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor constant:(CGFloat)c;- (NSLayoutConstraint *)constraintGreaterThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor constant:(CGFloat)c;- (NSLayoutConstraint *)constraintLessThanOrEqualToAnchor:(NSLayoutAnchor&lt;AnchorType&gt; *)anchor constant:(CGFloat)c; 使用注意事项 使用时，必须把 view 的 translatesAutoresizingMaskIntoConstraints 属性设置为 NO ，否则约束可能更预期不一致。这是一个历史遗留的问题，由于在 AutoLayout 诞生以前一直使用 Autoresizing 来控制布局. 重写 updateConstraints() 方法，在里面计算约束，然后调用 setNeedsUpdateConstraints() 触发更新约束。 系统计算布局顺序: updateConstraints() layoutSubviews() drawRect(_:) 系统计算布局顺序参考 具体使用示例，查看下面的 Demo，样品工程 Demo 地址：VFLDemo 参考链接 coding-auto-layout Visual Format Language","categories":[{"name":"系统 API","slug":"系统-API","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F-API/"}],"tags":[{"name":"VFL","slug":"VFL","permalink":"https://blog.wangruofeng007.com/tags/VFL/"}]},{"title":"UIActivity​View​Controller 详解","slug":"2017-02-23-uiactivityviewcontroller-xiang-jie","date":"2017-02-23T15:23:12.000Z","updated":"2024-11-03T06:33:43.006Z","comments":true,"path":"2017/02/23/2017-02-23-uiactivityviewcontroller-xiang-jie/","permalink":"https://blog.wangruofeng007.com/2017/02/23/2017-02-23-uiactivityviewcontroller-xiang-jie/","excerpt":"翻译自 NSHipster 的UIActivity​View​Controller","text":"翻译自 NSHipster 的UIActivity​View​Controller 一直非常好奇代码和数据之间的联系。 某些编程语言，例如Lisp，Io和Mathematica他们是同型性(代码即数据)，那就意味着它们的代码是原始数据的呈现形式，它们本身在代码中也能够被维护。然而大多数其它语言，包括 Objective-C，然而，在这两者之间有严格的边界，避免 eval() 和其它有动态引导加载的潜在危险方法。 当数据出现太大和呈现一些东西过于笨重除了使用二进制流的问题时代码和数据之间的不安被推向到了一个全新的高度。自从第一个操作系统出现开始，怎样编码，解码，解释二进制代表的图片，文档，和媒体一直是一个问题。 在 OS X 上的核心服务框架和 iOS 上提供标识功能和通过文件拓展和MIMIE type–根据通用数据标示，给数据类型的分类核心服务框架。UTIs 提供了一种可拓展，阶梯分层系统，这给开发者在处理大量不同的文件类型提供了巨大的灵活性。例如，一个 Ruby 的源文件(.rb)被归类为：Ruby Source Code &gt; Source Code &gt; Text &gt; Content &gt; Data；一个 QuickTime 电影文件(.mov)被归类为 Video &gt; Movie &gt; Audiovisual Content &gt; Content &gt; Data。 UTIs 表现得非常好在桌面的抽象文件系统中。然而，在一个移动范例中这就崩溃得很快，因为文件和目录是对用户隐藏的。还有，随着云服务和社交媒体扮演着越来越重要的角色在远程实体通过本地文件。因此，UTIs 和 URLs 之间很紧张。 我们非常清楚我们需要一些别的东西。 UIActivityViewController 能否成为我们正在急切寻找的解决方案呢? UIActivityViewController ，在 iOS6 中被引入，提供了一套分享和在应用内执行数据操作的统一服务界面。 考虑到可操作的数据集合，一个 UIActivityViewController 实例通过如下方式创建： 12345678910NSString *string = ...;NSURL *URL = ...;UIActivityViewController *activityViewController = [[UIActivityViewController alloc] initWithActivityItems:@[string, URL] applicationActivities:nil];[navigationController presentViewController:activityViewController animated:YES completion:^&#123; // ...&#125;]; 默认情况下， UIActivityViewController 将会显示所有支持的可用服务类型，但是某些活动类型也可以排除： 1activityViewController.excludedActivityTypes = @[UIActivityTypePostToFacebook]; 活动类型被划分“动作”(action)和“分享”(share)类型： UIActivityCategoryAction UIActivityTypePrint UIActivityTypeCopyToPasteboard UIActivityTypeAssignToContact UIActivityTypeSaveToCameraRoll UIActivityTypeAddToReadingList UIActivityTypeAirDrop UIActivityCategoryShare UIActivityTypeMessage UIActivityTypeMail UIActivityTypePostToFacebook UIActivityTypePostToTwitter UIActivityTypePostToFlickr UIActivityTypePostToVimeo UIActivityTypePostToTencentWeibo UIActivityTypePostToWeibo 每种活动类型，支持一系列不同的数据类型。例如，一个 Tweet 可能由一个 NSString 并附带一个 image 和或者 URL 。 不同活动类型支持的数据类型 Activity Type String Attributed String URL Data Image Asset Other Post To Facebook ✓ ✓ ✓ ✓ Post To Twitter ✓ ✓ ✓ ✓ Post To Weibo ✓ ✓ ✓ ✓ ✓ Message ✓ ✓ ✓* ✓* ✓ sms:&#x2F;&#x2F; NSURL Mail ✓+ ✓+ ✓+ Print ✓+ ✓+ UIPrintPageRenderer, UIPrintFormatter, &amp; UIPrintInfo Copy To Pasteboard ✓ ✓ ✓ UIColor, NSDictionary Assign To Contact ✓ Save To Camera Roll ✓ ✓ Add To Reading List ✓ Post To Flickr ✓ ✓ ✓ ✓ Post To Vimeo ✓ ✓ ✓ ✓ ✓ Post To Tencent Weibo ✓ ✓ ✓ ✓ ✓ AirDrop ✓ ✓ ✓ ✓ ✓ UIActivityItemSource &amp; UIActivityItemProvider当必要时和一个粘贴板项目能用来提供的数据类似，为了避免过度的内测开销或处理时间，活动类型可以是一种自定义类型。 任何遵循 &lt;UIActivityItemSource&gt; 协议的对象，包括内构 UIActivityItemProvider 类，可以用来动态提供不同类型的数据根据活动的类型。 UIActivityItemSource获取数据项目： activityViewControllerPlaceholderItem: activityViewController:itemForActivityType: 提供数据项目信息： activityViewController:subjectForActivityType: activityViewController:dataTypeIdentifierForActivityType: activityViewController:thumbnailImageForActivityType:suggestedSize: 下面是一个例子，根据是否分享到 FaceBook 或者 Twitter 来展示自定义一条消息是怎样使用的: 1234567891011- (id)activityViewController:(UIActivityViewController *)activityViewController itemForActivityType:(NSString *)activityType&#123; if ([activityType isEqualToString:UIActivityTypePostToFacebook]) &#123; return NSLocalizedString(@&quot;Like this!&quot;); &#125; else if ([activityType isEqualToString:UIActivityTypePostToTwitter]) &#123; return NSLocalizedString(@&quot;Retweet this!&quot;); &#125; else &#123; return nil; &#125;&#125; 创建一个自定义 UIActivity除了上述的系统提供的活动，你也可以创建你自己的活动。 例如，让我们创建一个自定义活动类型，它能使一个 URL 中的图片添加上胡须通过使用mustache.me。 首先，我们定义一个反向域名解析的标识符给活动类型： 1static NSString * const HIPMustachifyActivityType = @&quot;com.nshipster.activity.Mustachify&quot;; 然后指定它的分类为 UIActivityCategoryAction 并且提供一个本地化标题和 iOS 版本相应的图片： 123456789101112131415161718192021#pragma mark - UIActivity+ (UIActivityCategory)activityCategory &#123; return UIActivityCategoryAction;&#125;- (NSString *)activityType &#123; return HIPMustachifyActivityType;&#125;- (NSString *)activityTitle &#123; return NSLocalizedString(@&quot;Mustachify&quot;, nil);&#125;- (UIImage *)activityImage &#123; if (NSFoundationVersionNumber &gt; NSFoundationVersionNumber_iOS_6_1) &#123; return [UIImage imageNamed:@&quot;MustachifyUIActivity7&quot;]; &#125; else &#123; return [UIImage imageNamed:@&quot;MustachifyUIActivity&quot;]; &#125;&#125; 下一步，我们创建一个辅助函数， HIPMatchingURLsInActivityItems ，通过它返回一个支持类型的图片 URL 的数组。 123456789101112static NSArray * HIPMatchingURLsInActivityItems(NSArray *activityItems) &#123; return [activityItems filteredArrayUsingPredicate:[NSPredicate predicateWithBlock: ^BOOL(id item, __unused NSDictionary *bindings) &#123; if ([item isKindOfClass:[NSURL class]] &amp;&amp; ![(NSURL *)item isFileURL]) &#123; return [[(NSURL *)item pathExtension] caseInsensitiveCompare:@&quot;jpg&quot;] == NSOrderedSame || [[(NSURL *)item pathExtension] caseInsensitiveCompare:@&quot;png&quot;] == NSOrderedSame; &#125; return NO; &#125;]];&#125; 这个函数让后被用在 -canPerformWithActivityItems: 和 prepareWithActivityItems: 来获取小胡子的第一张 PNG 或 JPEG 图片的 URL，假如有的话。 123456789- (BOOL)canPerformWithActivityItems:(NSArray *)activityItems &#123; return [HIPMatchingURLsInActivityItems(activityItems) count] &gt; 0;&#125;- (void)prepareWithActivityItems:(NSArray *)activityItems &#123; static NSString * const HIPMustachifyMeURLFormatString = @&quot;http://mustachify.me/%d?src=%@&quot;; self.imageURL = [NSURL URLWithString:[NSString stringWithFormat:HIPMustachifyMeURLFormatString, self.mustacheType, [HIPMatchingURLsInActivityItems(activityItems) firstObject]]];&#125; 我们的网站服务提供了各种胡须选项，它被定义在一个枚举中： 12345678typedef NS_ENUM(NSInteger, HIPMustacheType) &#123; HIPMustacheTypeEnglish, HIPMustacheTypeHorseshoe, HIPMustacheTypeImperial, HIPMustacheTypeChevron, HIPMustacheTypeNatural, HIPMustacheTypeHandlebar,&#125;; 最终，我们提供了一个 UIViewController 来显示图片。在这个例子中，一个简单的 UIWebView 控制器就够用了。 123456789101112@interface HIPMustachifyWebViewController : UIViewController &lt;UIWebViewDelegate&gt;@property (readonly, nonatomic, strong) UIWebView *webView;@end- (UIViewController *)activityViewController &#123; HIPMustachifyWebViewController *webViewController = [[HIPMustachifyWebViewController alloc] init]; NSURLRequest *request = [NSURLRequest requestWithURL:self.imageURL]; [webViewController.webView loadRequest:request]; return webViewController;&#125; 为了使用我们加了新胡须的活动，我们简单把它传递到 UIActivityViewController 构造器中： 1234HIPMustachifyActivity *mustacheActivity = [[HIPMustachifyActivity alloc] init];UIActivityViewController *activityViewController = [[UIActivityViewController alloc] initWithActivityItems:@[imageURL] applicationActivities:@[mustacheActivity]]; 手动执行动作现在是一个提醒的好时机，当 UIActivityViewController 允许用户执行他们选择的动作，分享也能通过手动执行，当场景出现时。 所有为了完整性，下面是怎样手动执行这些动作示例： Open URL12NSURL *URL = [NSURL URLWithString:@&quot;http://nshipster.com&quot;];[[UIApplication sharedApplication] openURL:URL]; 系统支持的 URL 协议包括： mailto: ， tel: ， sms: 和 maps: 。 添加到 Safari 阅读列表1234567@import SafariServices;NSURL *URL = [NSURL URLWithString:@&quot;http://nshipster.com/uiactivityviewcontroller&quot;];[[SSReadingList defaultReadingList] addReadingListItemWithURL:URL title:@&quot;NSHipster&quot; previewText:@&quot;...&quot; error:nil]; 保存到相册12345UIImage *image = ...;id completionTarget = self;SEL completionSelector = @selector(didWriteToSavedPhotosAlbum);void *contextInfo = NULL;UIImageWriteToSavedPhotosAlbum(image, completionTarget, completionSelector, contextInfo); 发送 SMS123456789@import MessageUI;MFMessageComposeViewController *messageComposeViewController = [[MFMessageComposeViewController alloc] init];messageComposeViewController.messageComposeDelegate = self;messageComposeViewController.recipients = @[@&quot;mattt@nshipster•com&quot;];messageComposeViewController.body = @&quot;Lorem ipsum dolor sit amet&quot;;[navigationController presentViewController:messageComposeViewController animated:YES completion:^&#123; // ...&#125;]; 发送 Email12345678910@import MessageUI;MFMailComposeViewController *mailComposeViewController = [[MFMailComposeViewController alloc] init];mailComposeViewController.mailComposeDelegate = self;[mailComposeViewController setToRecipients:@[@&quot;mattt@nshipster•com&quot;]];[mailComposeViewController setSubject:@&quot;Hello&quot;];[mailComposeViewController setMessageBody:@&quot;Lorem ipsum dolor sit amet&quot; isHTML:NO];[navigationController presentViewController:mailComposeViewController animated:YES completion:^&#123; // ...&#125;]; 发送 Tweet123456789@import Social;SLComposeViewController *tweetComposeViewController = [SLComposeViewController composeViewControllerForServiceType:SLServiceTypeTwitter];[tweetComposeViewController setInitialText:@&quot;Lorem ipsum dolor sit amet.&quot;];[self.navigationController presentViewController:tweetComposeViewController animated:YES completion:^&#123; // ... &#125;]; IntentKit当所有的这些都是印象深刻和非常有用，它在 iOS 中的活动范例特别缺乏，当和在 Android 中的丰富的Intents Model相比。 在 Android 中，apps 能够注册不同的 intents，来指示它们能够用在 Maps，或者充当一个浏览器，能够被涉及到相关活动的默认 app 选中，比如指引方向，或者一个书签的 URL。 然而 iOS 缺乏来支持这些的可拓展的基础架构，有一个叫IntentKit第三方库，作者@lazerwalker(因f*ingblocksyntax.com成名)，这是一个有趣的例子关于我们怎样缩小这方面的差距。 通常，一个开发者可能已经做了很多第一步的工作，来决定是否某个 app 是否安装，然后怎样构造一个 URL 来支持某个特殊的活动。 IntentKit 加强了连结到大多数流行的 Web，Maps,Mail,Twitter,Facebook,和 Google+客户的的逻辑，以和 UIActivityViewController 相似的 UI。 任何寻找提升他们的分享体验到下一个级别的人都应该仔细看看这个。 – 在 iOS 长期生存能力作为一个平台取决于像 UIActivityViewController 类型的分享机制存上在很大的争论。正如俗语所言：“资讯应该免费”。任何阻碍方式统一的东西，最终都会失去一些没有的东西。 将来的景象是公共的远程视图控制器 APIs 带给我希望，对于将来在 iOS 平台上的分享功能。然而现在我们做的和 UIActivityViewController 相比糟糕得多。","categories":[{"name":"系统 API","slug":"系统-API","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F-API/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://blog.wangruofeng007.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Loading","slug":"Loading","permalink":"https://blog.wangruofeng007.com/tags/Loading/"}]},{"title":"2016 个人年度总结","slug":"2017-01-10-2016ge-ren-nian-du-zong-jie","date":"2017-01-09T15:48:07.000Z","updated":"2024-11-03T05:32:35.297Z","comments":true,"path":"2017/01/09/2017-01-10-2016ge-ren-nian-du-zong-jie/","permalink":"https://blog.wangruofeng007.com/2017/01/09/2017-01-10-2016ge-ren-nian-du-zong-jie/","excerpt":"前言2016 对于我来说的意义，就像 10 年前的今天， iPhone 之余乔布斯， iPhone 发布后 10 年后的今天，小程序之余张小龙。它跨越了一道深深的鸿沟，并向自己理想的方向坚定前行。 一直相信努力就会有回报，付出就会有收获，是金子总会发光。 2016 是我加入客路一周年的时间，认识了很多有趣的朋友和同事的一 2016 是我迈出自我，走出中国探索未知的世界的一年。 2016 是旅行，工作，生活，学习，社交一样都没落下的一年。 曾经的铁哥们也即将回归东莞，这样我们的距离又进了一步，以后有更多的时间聊理想谈人生，想想突然好激动。","text":"前言2016 对于我来说的意义，就像 10 年前的今天， iPhone 之余乔布斯， iPhone 发布后 10 年后的今天，小程序之余张小龙。它跨越了一道深深的鸿沟，并向自己理想的方向坚定前行。 一直相信努力就会有回报，付出就会有收获，是金子总会发光。 2016 是我加入客路一周年的时间，认识了很多有趣的朋友和同事的一 2016 是我迈出自我，走出中国探索未知的世界的一年。 2016 是旅行，工作，生活，学习，社交一样都没落下的一年。 曾经的铁哥们也即将回归东莞，这样我们的距离又进了一步，以后有更多的时间聊理想谈人生，想想突然好激动。 业绩2016-2017 年间一共发布 17 个版本，多次被 Apple 推荐，崩溃率小于 0.2% ，这就是给自己和公司交出最满意的答卷。 下面是 Klook App 上 Apple 的推荐页截图： 下面是 Klook iMessage App 上 Apple 的推荐页截图： 有时发现互联网真的很奇妙，他能让很多人迅速积累大量的财富成名走上人生的巅峰，过上自己想要的生活，只要你一个好的 idea 和一个强大的执行力。 这一年来个人技术博客一共写了 46 遍文章，也算一点小积蓄，希望来年继续坚持，能够影响和帮助更多的人，因为技术这条道路上坑实在是太多。 Github 上 405 次commit还算中规中矩，希望来年分享更多的有价值的东西给有需要的小伙伴，也留给自己方便以后查阅。 当然现在 Github 上的内容 Fork 和博客居多，原创开源项目还比较少，希望来年多输出一点东西。 未来愿望这东西还真神奇，许一个试试吧，或许它真的实现了呢，就非常有趣了。给自己定下的旅行清单，学习清单，阅读清单，电影清单基本都完成，这是一件非常棒的事情，为自己点个赞。单反已经从风光转人像，希望来年多出点片，新年即将来临，希望自己坚持一周 2 次的锻炼，保持精力充沛以便好投入到感情，生活中以及学习中，毕竟互联网是一门终生学习的职业，也是容易产生奇迹的职业，说不定一下个就是你呢。 来年希望和自己喜欢的人旅拍，多尝试一些没尝试过的事情，交更多有趣的朋友。干巴爹😁😁😁","categories":[{"name":"总结复盘","slug":"总结复盘","permalink":"https://blog.wangruofeng007.com/categories/%E6%80%BB%E7%BB%93%E5%A4%8D%E7%9B%98/"}],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"https://blog.wangruofeng007.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"}]},{"title":"视频播放 Tips","slug":"2016-12-08-shi-pin-bo-fang-tips","date":"2016-12-08T15:44:02.000Z","updated":"2024-11-03T06:35:03.909Z","comments":true,"path":"2016/12/08/2016-12-08-shi-pin-bo-fang-tips/","permalink":"https://blog.wangruofeng007.com/2016/12/08/2016-12-08-shi-pin-bo-fang-tips/","excerpt":"","text":"获取设备音量播放音频可以通过： 12MPMusicPlayerController *iPod = [MPMusicPlayerController systemMusicPlayer];float volumeLevel = iPod.volume; 播放视频可以通过： 1float outputVolume = [[AVAudioSession sharedInstance] outputVolume]; 推荐下面的方法，上面的在某些版本可能有问题，下面的方法兼容iOS6 及以上。 静音模式失效通过设置音频会话的 category 实现： 12345NSError *setCategoryError = nil;BOOL success = [[AVAudioSession sharedInstance] setCategory: AVAudioSessionCategoryPlayback error: &amp;setCategoryError]; if (!success) &#123; /* handle the error in setCategoryError */ &#125; 这样 App 就不会随着手机静音键打开而静音，可在手机静音下播放声音😁 监听音量改变监听音频改变私有通知： 1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(volumeChanged:) name:@&quot;AVSystemController_SystemVolumeDidChangeNotification&quot; object:nil]; 实现通过回调： 1234567- (void)volumeChanged:(NSNotification *)notification&#123; float volume = [[[notification userInfo] objectForKey:@&quot;AVSystemController_AudioVolumeNotificationParameter&quot;] floatValue]; // do something&#125; 设置设备音量使用 MPVolumeView 类，便利它的子 views 找到类为 MPVolumeSlider 的滑竿。 12345678MPVolumeView *volumeView = [[MPVolumeView alloc] init];UISlider *volumeViewSlider = nil; for (UIView *view in [volumeView subviews])&#123; if ([view.class.description isEqualToString:@&quot;MPVolumeSlider&quot;]) &#123; volumeViewSlider = (UISlider *)view; break; &#125; &#125; 然后再通过设置 volumeViewSlider 的 value 即可。 1_volumeViewSlider.value = someVolume; 监听静音按钮参考Sound Switch - Sharkfood的实现。 使用很简单，判断是否为静音模式： 123if ([SharkfoodMuteSwitchDetector shared].isMute) &#123; // do something&#125; 动态监听，通过 block 回调： 123[SharkfoodMuteSwitchDetector shared].silentNotify = ^(BOOL silent)&#123; // do something&#125;; 监听耳机拔插监听 AVAudioSessionRouteChangeNotification 通知： 123[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(audioRouteChangeListenerCallback:) name:AVAudioSessionRouteChangeNotification object:nil]; 实现回调： 1234567891011121314151617181920- (void)audioRouteChangeListenerCallback:(NSNotification*)notification&#123; NSDictionary *interuptionDict = notification.userInfo; NSInteger routeChangeReason = [[interuptionDict valueForKey:AVAudioSessionRouteChangeReasonKey] integerValue]; switch (routeChangeReason) &#123; case AVAudioSessionRouteChangeReasonNewDeviceAvailable: // 耳机插入 break; case AVAudioSessionRouteChangeReasonOldDeviceUnavailable: // 耳机拔掉 break; case AVAudioSessionRouteChangeReasonCategoryChange: // called at start - also when other audio wants to play NSLog(@&quot;AVAudioSessionRouteChangeReasonCategoryChange&quot;); break; &#125;&#125;","categories":[{"name":"最佳实践","slug":"最佳实践","permalink":"https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"音视频","slug":"音视频","permalink":"https://blog.wangruofeng007.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"}]},{"title":"动画切换 Image 最佳实践","slug":"2016-11-26-dong-hua-qie-huan-imagezui-jia-shi-jian","date":"2016-11-26T12:42:40.000Z","updated":"2024-11-03T05:32:35.284Z","comments":true,"path":"2016/11/26/2016-11-26-dong-hua-qie-huan-imagezui-jia-shi-jian/","permalink":"https://blog.wangruofeng007.com/2016/11/26/2016-11-26-dong-hua-qie-huan-imagezui-jia-shi-jian/","excerpt":"","text":"前言 UIImageView 应该是iOS中使用最频换的控件，就如日常吃饭一样，天天都在重复，有时或许应该反思一下，怎么使用这个控件，达到低能耗，最佳用户体验。 针对单张图片来说，常见的处理是在图片准备显示时增加一个淡出动画，能使图片显示闲的很平滑。 多张图片也一样，在第一张图片的基础上淡出原来的图片，淡入新的图片。也可以说是溶解效果。 很多人喜欢对图片的 alpha 做淡出动画，使 alpha 从 0 到 1 动画改变。这种动画有一点不好的是，在动画结束后，图片会明显的出现一闪，这样使动画看起来有点突兀。比较好的做法时，在将要显示时给图片做一个转场动画。 淡出动画实现下面是其中一种简单的实现： 12345678910111213@implementation UIImageView (RFWebImage)- (void)animatedChangeToImage:(UIImage *)img&#123; [UIView transitionWithView:self duration:0.3f options:UIViewAnimationOptionTransitionCrossDissolve animations:^&#123; self.image = img; &#125; completion:NULL];&#125;@end 思路：在 ImageView 将要显示是使用转场动画函数来实现淡出动画效果，体验应该是是各种动画中最好的了，而且使用起来很简单。 在淡出显示的动画基础上，我们引出今天的主角，动画切换 Image。 思路：单张图片淡出我们已经实现，现在做的就是在切换一张新的图片时同时再加入淡出或者说溶解效果即可。 动画切换 Image比较常见的有下面 3 种实现： CATransition 类实现 UIView 动画转场 API 实现 CABasicAnimation 类实现 CATransition 实现 CATransition 类是iOS中很好用的控制转场动画的类，通过简单的配置可以实现常见而炫酷的动画效果，变换类型通过 type 字段控制， subtype 可以很细化控制动画的方向（比如动画开始的上下左右方向）。 CATransition 继承至 CAAnimation 可以对动画设置动画曲线（timingFunction），可以通过代理获取动画状态（是已经开始，还是已经停止，已经是否完成）。 type 支持四种类型： kCATransitionFade &#x2F;&#x2F; 淡入淡出 kCATransitionMoveIn &#x2F;&#x2F; 从某个方向向终点平移知道覆盖在上方 kCATransitionPush &#x2F;&#x2F; 把原来的推出去，自己推出去 kCATransitionReveal &#x2F;&#x2F; 把原来的从正上方解开，自己在下面 下面是样板代码： 12345678910111213- (void)animatedSwichImageMethodOne &#123; UIImage *toImage = [self getRadomImage]; CATransition *transition = [CATransition animation]; transition.duration = 0.3f; transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; transition.type = kCATransitionFade; transition.subtype = kCATransitionFromTop; [self.imageViewOne.layer addAnimation:transition forKey:nil]; [self.imageViewOne setImage:toImage];&#125; UIView 动画转场1+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0); 通过上面的函数实现，其实是对第一种的高级封装。通过设置 options 为 UIViewAnimationOptionTransitionCrossDissolve 即可。 下面是样板代码： 1234567891011- (void)animatedSwichImageMethodTwo &#123; UIImage *toImage = [self getRadomImage]; [UIView transitionWithView:self.imageViewTwo duration:0.3f options:UIViewAnimationOptionTransitionCrossDissolve | UIViewAnimationOptionCurveEaseInOut animations:^&#123; self.imageViewTwo.image = toImage; &#125; completion:nil];&#125; CABasicAnimation 实现 CABasicAnimation 是核心动画一个重要的类，继承至 CAPropertyAnimation ，可以对所有的可动画属性做动画，可以通过 fromValue ， toValue ， byValue 字段控制动画的进度。在这里我们是对 CALayer 的 contents 属性做动画，在改变图片时，创建一个 CABasicAnimation 对象添加到 ImageView 的图层上即可。 下面是样板代码： 1234567891011- (void)animatedSwichImageMethodThree &#123; UIImage *toImage = [self getRadomImage]; CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@&quot;contents&quot;]; animation.toValue = toImage; animation.duration = 0.3f; [self.imageViewThree.layer addAnimation:animation forKey:@&quot;contentsAnimationKey&quot;]; [self.imageViewThree setImage:toImage];&#125; 更多内容请下载Demo查看（🤔Bonus： Flip 效果🤔）","categories":[{"name":"动画","slug":"动画","permalink":"https://blog.wangruofeng007.com/categories/%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"UIImage","slug":"UIImage","permalink":"https://blog.wangruofeng007.com/tags/UIImage/"}]},{"title":"iOS 无缝桥接【翻译 Apple 官方文档】","slug":"2016-11-17-ioswu-feng-qiao-jie","date":"2016-11-17T15:52:46.000Z","updated":"2024-11-03T05:32:35.293Z","comments":true,"path":"2016/11/17/2016-11-17-ioswu-feng-qiao-jie/","permalink":"https://blog.wangruofeng007.com/2016/11/17/2016-11-17-ioswu-feng-qiao-jie/","excerpt":"","text":"Toll-Free Bridged Types在 Core Foundation 框架和 Foundation 框架中有很多数据类型可以交替转换。能够被交替转换的数据类型也被叫做 Toll-Free Bridged 数据类型。这意味着你能像参数一样使用相同的数据结构对一个 Core Foundation 的函数进行调用，或者像 Objective-C 的消息接受模式一样执行。例如， NSLocale （查看NSLocale Class Reference）可以与在 Core Foundation 中对应的 CFLocale （查看CFLocale Reference）之间互相转换。 不是所有数据类型都是 Toll-Free Bridged ,即使它们的名字可能让你认为它们是。例如， NSRunLoop 是没有对应的桥接类型 CFRunLoop , NSBundle 也没有对应的桥接类型 CFBundle ， NSDateFormatter 同样没有对应的桥接类型 CFDateFormatter 。 文章末尾表 1 提供了一份支持无缝桥接的数据类型的列表。 注意：假如你使用一个自定义回调在一个 Core Foundation 框架的集合中，包含一个 NULL 回调，当使用 Objective-C 的方式接入它，它的内存管理方式是未定义的。 类型转换和对象语义周期声明通过无缝桥接技术，在一个你以 NSLocale * 做为一个参数的方法的例子中，你能传递一个 CFLocaleRef 结构体，并且当你看到有一个 CFLocaleRef 参数的函数中，你能够传递一个 NSLocale 实例对象。当然你也必须提供给编译器相关的一些其它信息:第一，你必须转换一种类型成其它；第二，你可能必须指明对象的语义生命周期。 编译器理解 Objective-C 的方法并且返回 Core Foundation 数据类型，下面是 Cocoa 命名转换的历史（查看Advanced Memory Management Programming Guide）。例如，编译器知道，在 iOS 中，通过 UIColor 的 CGColor 方法返回的 CGColor 并不应该被持有。你必须使用恰当的类型转换，像下面例子演示的那样： 12NSMutableArray *colors = [NSMutableArray arrayWithObject:(id)[[UIColor darkGrayColor] CGColor]];[colors addObject:(id)[[UIColor lightGrayColor] CGColor]]; 编译器并不会自动管理 Core Foundation 对象的生命周期。你必须告诉编译器对象的语义所属关系通过使用一种转换（定义在objc&#x2F;runtime.h）或者 Core Foundation 风格的宏（定义在 NSObject.h）： __bridge 关键字表示转换指针在 Objective-C 和 Core Foundation 之间而不会转换所属关系。 __bridge_retained 关键字或者 CFBridgingRetain 表示转换指针在 Objective-C 和 Core Foundation 之间并且把所属权交给你。你负责调用 CFRelease 或者相关的函数来交出对象的所属权。 __bridge_transfer 关键字或者 CFBridgingRelease 表示转换一个非 Objective-C 的指针到 Objective-C 并且转换所属权给ARC。ARC负责交出对象的所属权。 下面是一些例子： 1234567891011NSLocale *gbNSLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_GB&quot;];CFLocaleRef gbCFLocale = (__bridge CFLocaleRef)gbNSLocale;CFStringRef cfIdentifier = CFLocaleGetIdentifier(gbCFLocale);NSLog(@&quot;cfIdentifier: %@&quot;, (__bridge NSString *)cfIdentifier);// Logs: &quot;cfIdentifier: en_GB&quot; CFLocaleRef myCFLocale = CFLocaleCopyCurrent();NSLocale *myNSLocale = (NSLocale *)CFBridgingRelease(myCFLocale);NSString *nsIdentifier = [myNSLocale localeIdentifier];CFShow((CFStringRef)[@&quot;nsIdentifier: &quot; stringByAppendingString:nsIdentifier]);// Logs identifier for current locale 下面的例子显示了使用口述的 Core Foundation 内存管理规则来管理 Core Foundation 内存： 123456789101112131415- (void)drawRect:(CGRect)rect &#123; CGContextRef ctx = UIGraphicsGetCurrentContext(); CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray(); CGFloat locations[2] = &#123;0.0, 1.0&#125;; NSMutableArray *colors = [NSMutableArray arrayWithObject:(id)[[UIColor darkGrayColor] CGColor]]; [colors addObject:(id)[[UIColor lightGrayColor] CGColor]]; CGGradientRef gradient = CGGradientCreateWithColors(colorSpace, (__bridge CFArrayRef)colors, locations); CGColorSpaceRelease(colorSpace); // Release owned Core Foundation object. CGPoint startPoint = CGPointMake(0.0, 0.0); CGPoint endPoint = CGPointMake(CGRectGetMaxX(self.bounds), CGRectGetMaxY(self.bounds)); CGContextDrawLinearGradient(ctx, gradient, startPoint, endPoint, kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation); CGGradientRelease(gradient); // Release owned Core Foundation object.&#125; 无缝桥接类型下面的表格提供了一个在 Core Foundation 和 Foundation 中可以交替转换数据类型列表。对每一对桥接类型，表也列举出了这些无缝桥接类型在 OS X 中的可用版本。 Core Foundation 类型 Foundation 类型 可用性 CFArrayRef NSArray OS X v10.0 CFAttributedStringRef NSAttributedString OS X v10.4 CFCalendarRef NSCalendar OS X v10.0 CFCharacterSetRef NSCharacterSet OS X v10.4 CFDataRef NSData OS X v10.0 CFDateRef NSDate OS X v10.4 CFDictionaryRef NSDictionary OS X v10.0 CFErrorRef NSError OS X v10.4 CFLocaleRef NSLocale OS X v10.0 CFMutableArrayRef NSMutableArray OS X v10.4 CFMutableAttributedStringRef NSMutableAttributedString OS X v10.0 CFMutableCharacterSetRef NSMutableCharacterSet OS X v10.4 CFMutableDataRef NSMutableData OS X v10.0 CFMutableDictionaryRef NSMutableDict OS X v10.4 CFMutableSetRef NSMutableSet OS X v10.0 CFMutableStringRef NSMutableString OS X v10.4 CFNumberRef NSNumber OS X v10.0 CFReadStreamRef NSInputStream OS X v10.4 CFRunLoopTimerRef NSTimer OS X v10.0 CFSetRef NSSet OS X v10.4 CFStringRef NSString OS X v10.0 CFTimeZoneRef NSTimeZone OS X v10.4 CFURLRef NSURL OS X v10.0 CFWriteStreamRef NSOutputStream OS X v10.4 参考资料 Toll-Free Bridged Types","categories":[{"name":"系统原理","slug":"系统原理","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://blog.wangruofeng007.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"bridge","slug":"bridge","permalink":"https://blog.wangruofeng007.com/tags/bridge/"}]},{"title":"block 备忘录","slug":"2016-11-17-blockbei-wang-lu","date":"2016-11-17T15:10:08.000Z","updated":"2024-11-03T05:32:35.298Z","comments":true,"path":"2016/11/17/2016-11-17-blockbei-wang-lu/","permalink":"https://blog.wangruofeng007.com/2016/11/17/2016-11-17-blockbei-wang-lu/","excerpt":"","text":"前言随著 block 在iOS4.0和OS X 10.6的引入，给事件传递一种新的方式实现，在开发中用得最多的场景莫过于事件回调。使用 block 相对与 delegate 的优势在于，业务集中，可读性强，代码内联，不像代理需要实现很多函数，在适当的场景选择这种方式实现事件传递或者传参效果非常好，现在很多开源项目都实现了两种方法的事件回调。 block 用起来虽然很爽，但也有它的不足，存在循环引用，轻者内存泄露，甚至导致App崩溃，不易调试追溯，因此使用它使一定要小心。鉴于实践中的踩过各种坑，总结下来，方便自己和他人以后查阅，这就是block备忘录写作的初衷。 block 的本质 block 实际上是指向结构体的指针，编译时， block 的内部代码生产对应的函数。 具体结构如下： 与 C 语言的函数指针的区别 block 的代码是内联的，效率高于函数调用 block 对于外部变量默认是只读属性 block 被 Objective-C 看成是对象处理 block 声明 作为 property &gt; @property (nonatomic, copy) returnType (^blockName)(parameterTypes); 作为方法参数 - (void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName; 作为一个方法调用参数 [someObject someMethodThatTakesABlock:^returnType (parameters) {…}]; 作为一个 typedef &gt; typedef returnType (^TypeName)(parameterTypes); TypeName blockName &#x3D; ^returnType(parameters) {…}; 作为函数参数 int (^sumOfNumbers)(int a, int b) &#x3D; ^(int a, int b) { return a + b;}; SDWebImage 中使用的 block 示例：12345typedef void(^SDWebImageCompletionBlock)(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL);typedef void(^SDWebImageCompletionWithFinishedBlock)(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL);typedef NSString *(^SDWebImageCacheKeyFilterBlock)(NSURL *url); block 调用跟 C 函数类似使用 （） ，括号里面还可以带一个或者多个参数 12345678910// block 声明（void）(^loggerBlock)(void); // block 定义loggerBlock = ^&#123; NSLog(&quot;hello world&quot;)&#125;;// block 调用loggerBlock(); block 内存管理默认情况下， block 是在栈内存中，它不会对所引用的对象进行任何操作；如果对 block 进行一次 copy 操作， block 就会在堆内存中，并且它会它所有的引用的对象做一次 retain 操作 对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的 对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的 而 block 会捕获代码外的局部变量，并且仅限于只读操作 在 block 中希望修改的外界局部对象，必须加上 __block 关键词 ARC 如果对象使用 `__unsafe_unretained` 或 `__weak` 修饰，就不会对其做 `retain` 操作 MRC 如果对象使用了 `__block` 修饰, 就不会对其做 `retain` 操作 为了防止 block 中的循环引用，可以用 __weak 关键词把相应的对象声明为弱引用,在 block 快内部需要多次访问，防止该对象被释放，可以用 __strong 关键词将声明为强引用： 123456789__weak __typeof__(self) weakSelf = self;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; __strong __typeof(self) strongSelf = weakSelf; [strongSelf doSomething]; [strongSelf doOtherThing];&#125;); 参考链接 谈 Objective-C block 的实现 A look inside blocks: Episode 1 A look inside blocks: Episode 2 A look inside blocks: Episode 3 对 Objective-C 中 Block 的追探 LLVM 中 block 实现源码 objective-c-blocks-quiz Blocks iOS 开发-由浅至深学习 block","categories":[{"name":"系统原理","slug":"系统原理","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"block","slug":"block","permalink":"https://blog.wangruofeng007.com/tags/block/"}]},{"title":"App 常见崩溃问题分析","slug":"2016-10-23-appchang-jian-beng-kui-wen-ti-fen-xi","date":"2016-10-23T15:18:01.000Z","updated":"2024-11-03T05:32:35.307Z","comments":true,"path":"2016/10/23/2016-10-23-appchang-jian-beng-kui-wen-ti-fen-xi/","permalink":"https://blog.wangruofeng007.com/2016/10/23/2016-10-23-appchang-jian-beng-kui-wen-ti-fen-xi/","excerpt":"","text":"前言此文是基于这些年工作中项目里面常见崩溃的一些总结，整理出来方便查阅，希望对大家都有所帮助。 App 常见崩溃 数组下标越界 字典构造与修改 NSAttributedString 相关 呈现一个空控制器 unrecognized selector 操作 tableView 数据 Push 到同一个控制器多次 1.数组下标越界示例代码： 12345- (void)testArrayOutOfBounds&#123; NSArray *testArray = @[@1,@2,@3]; NSNumber *num = testArray[3];&#125; 异常现象： Terminating app due to uncaught exception ‘NSRangeException’, reason: ‘** -[__NSArrayI objectAtIndex:]: index 3 beyond bounds [0 .. 2]’* 预防方案： 在数组中取值时需要先进组下标索引边界检查，如果没有越界方可取值。 2.字典构造造与修改示例代码： 12345678- (void)testDicSetNilValueCrash&#123; // 构造不可变字典时 key 和 value 都不能为空 NSString *nilValue = nil; NSString *nilKey = nil; NSDictionary *dic1 = @&#123;@&quot;key&quot; : nilValue&#125;; NSDictionary *dic2 = @&#123;nilKey : @&quot;value&quot;&#125;;&#125; 异常现象： Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘** -[__NSPlaceholderDictionary initWithObjects:forKeys:count:]: attempt to insert nil object from objects[0]’* 预防方案： 在我们使用字面量快速创建一个字典的时候需要特别小心，因为很可能字典的键和值不能保证同时不为空。有潜在崩溃的风险，这种崩溃非常容易出现，需要特别小心，但是当你留心的话也非常好避免，就是设置字典的键或者值的时候判断是否非空，可变字典设置某个键的值是可以为空，相当于删除字典中的某个键值。为了使 App 保持健壮推荐使用 KVO 或者字面量的方式来设置字典的值 1234567891011121314- (void)testMutableDicSetNilValueCrash&#123; NSString *value = nil; NSMutableDictionary *mDic = [NSMutableDictionary dictionary]; // via Dic set, leading crash [mDic setObject:value forKey:@&quot;key&quot;]; // via KVO set, it&#x27;s safe [mDic setValue:value forKey:@&quot;key&quot;]; // or via literal set, it&#x27;s safe mDic[@&quot;key&quot;] = value;&#125; 3.NSAttributedString 相关示例代码： 1234567891011121314- (void)testAttributedStringInitCrash&#123; NSString *nilStr = nil; NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:nilStr];&#125;- (void)testAttributedStringAddAttributeCrash&#123; NSString *nonnullStr = @&quot;str&quot;; NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:nonnullStr]; NSString *nilValue = nil; [attributedStr addAttribute:NSAttachmentAttributeName value:nilValue range:NSMakeRange(0, 1)];&#125; 异常现象： Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘NSConcreteMutableAttributedString initWithString:: nil value’ 预防方案： 在构造 NSMutableAttributedString 或者 NSAttributedString 需要留意，设置的属性的值是否有可能存在 nil 的情况。这个很容易被人忽视，值得注意。 4.呈现一个空控制器示例代码： 1234567- (void)testPresentNilControllerCrash&#123; UIViewController *someVC = [UIViewController new]; UIViewController *presentVC = nil; [someVC presentViewController:presentVC animated:YES completion:nil];&#125; 异常现象： present 一个空的控制器导致 App crash 预防方案： present 一个新控制器时，判断是否存在，存在才执行，否则直接返回 123456789- (void)testPresentNilControllerCrashFixed&#123; UIViewController *someVC = [UIViewController new]; UIViewController *presentVC = [UIViewController new]; if (presentVC) &#123; [someVC presentViewController:presentVC animated:YES completion:nil]; &#125;&#125; 5.unrecognized selector示例代码： 1234- (void)testUnrecogernizedSelectorCash&#123; [self performSelector:@selector(testSel) withObject:nil afterDelay:0];&#125; 异常现象： Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘-[ViewController testSel]: unrecognized selector sent to instance 0x7ffd41609d10’ 预防方案： 此类崩溃经常出现，特别是当服务器数据放回异常时，比如本来应该返回一个 NSString 类型字符串，结果返回 NULL ,当你调用字符串的 length 方式时，导致 App 崩溃。预防方法，重要的地方对类型进行判断再调用该类的相关方法，或者写一个分类统一处理此类逻辑。 6.操作 tableView 数据示例代码： 12345678910111213141516- (void)testTableViewUpdateCrash&#123; NSIndexPath *insertIndexPath = [NSIndexPath indexPathForRow:0 inSection:0]; NSIndexPath *deleteIndexPath = [NSIndexPath indexPathForRow:1 inSection:0]; NSIndexPath *reloadIndexPath = [NSIndexPath indexPathForRow:2 inSection:0]; NSIndexPath *moved1IndexPath = [NSIndexPath indexPathForRow:3 inSection:0]; NSIndexPath *moved2IndexPath = [NSIndexPath indexPathForRow:4 inSection:0]; [self.tableView beginUpdates]; [self.tableView insertRowsAtIndexPaths:@[insertIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic]; [self.tableView deleteRowsAtIndexPaths:@[deleteIndexPath]withRowAnimation:UITableViewRowAnimationAutomatic]; [self.tableView reloadRowsAtIndexPaths:@[reloadIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic]; [self.tableView moveRowAtIndexPath:moved1IndexPath toIndexPath:moved2IndexPath]; [self.tableView endUpdates];&#125; 异常现象： Fatal Exception: NSInternalInconsistencyException Invalid update: invalid number of sections. The number of sections contained in the table view after the update (1) must be equal to the number of sections contained in the table view before the update (1), plus or minus the number of sections inserted or deleted (1 inserted, 0 deleted). 预防方案： 当需要动态更新 tableView 的数据时，计算好模型的数据使模型的数据和更新 tableView 的后的数据保持同步。 7.Push 到同一个控制器多次异常现象： Fatal Exception: NSInvalidArgumentException Pushing the same view controller instance more than once is not supported (&lt;PPSelectPayMethodViewControllerIOS7: 0x10d7e7f10&gt;) 参考链接： 防止点击 Cell 时 ViewController 被重复 Push 以上就是工作中常见的异常崩溃以及处理方案，下面的异常分类内容来自 Apple 的官方文档，有兴趣的可以查阅。☕️ Apple 官方常见异常类型(Exception types) 访问一块坏内存 [EXC_BAD_ACCESS] // SIGSEGV // SIGBUS] 2. 异常退出 [EXC_CRASH // SIGABRT] 3. 追踪受限 [EXC_BREAKPOINT // SIGTRAP] 4. 非法指令 [EXC_BAD_INSTRUCTION // SIGILL] 5. 被保护的资源遭到侵害 [EXC_GUARD] 6. 资源限制 [EXC_RESOURCE] 7. 其他异常类型 1.访问一块坏内存(Bad Memory Access)当程序试图接入无效内容或者尝试以不被允许的方式接入由于内存的保护等级(例如，尝试写入只读的内存)。 Exception Subtype 字段包含一个kern_return_t结构体用来描述错误和不正确接入的内存地址。 下面是一些调试坏内存接入导致崩溃的建议： 假如objc_msgSend或者objc_release在崩溃线程回溯(Backtraces)的顶部附近,这个线程可能尝试给一个释放的对象发消息。你应该 profile 应用使用Zombies instrument来更好的理解这个崩溃发生的条件。 假如gpus_ReturnNotPermittedKillClient在崩溃线程回溯(Backtraces)的顶部附近，线程被终结因为它尝试用OpenGL ES或者Metal执行渲染当程序处于后台时。查看QA1766: How to fix OpenGL ES application crashes when moving to the background 打开 Address Sanitizer 运行你的应用。Address Sanitizer 添加了额外的说明在内容接入当你编译代码的时候。随着你应用的运行，Xcode 将⚠️你假如内存以一种可能导致崩溃的方式接入。 2.异常退出（Abnormal Exit）程序异常退出，是最常见导致这类异常崩溃的原因是捕获到 Objective-C/C++ 异常和调用了 abort() 函数。 App Extensions将被终结发生这种类型的异常，假如他们初始化花费太多的时间(watchdog终结)。假如一个extension由于载入时间太长被终结，产生崩溃报告的Exception Subtype将是LAUNCH_HANG。因为extensions并没有一个 main 函数，任何花销在初始化的时间都发生在static constructors和呈现在你的extensions和依赖库的 +load 方法。你应该尽可能的延迟做这些工作。 3.追踪受限（Trace Trap）和异常退出类似，这种异常的目的是给一个追加的调试器，让它有机会来打断在一个当它执行时候指定的点的进程。你可以使用 __builtin_trap() 函数在你的代码中来触发这个异常。假如没有调试器追加的话，线程将被终结并且产生一个崩溃报告。 低等级的库（例如libdispatch）将受限这个进程一旦遇到一个重大的错误。关于错误的额外信息可以在Additional Diagnostic Information章节中的崩溃报告找到，或者在设备的控制台。 假如在 runtime 遇到诸如下面的一个意外的条件， Swift 代码将终结出现这种类型的异常： 非可选类型带有一个 nil 值 错误的强制类型转换 查看Backtraces来决发生定异常条件的位置。额外的信息可能已经在设备的控制台打印出来了。你应该修改崩溃处的代码来优雅的处理 runtime 错误。例如，使用Optional Binding而不是强制解包一个可选变量。 4.非法指令（Illegal Instruction）进程尝试执行一个非法或者未定义的指令。进程可能已经尝试跳进到一个无效的地址通过一个配置错误的函数指针。在 Intel 处理器中， ud2 操作码导致一个EXC_BAD_INSTRUCTION异常，但是它通常被用来困住进程达到调试的目的。 Swift 代码在 Intel 处理器中将以这种异常终结，假如在 runtime 位置条件发生。更多详情查看Trace Trap。 5.被保护的资源遭到侵害（Guarded Resource Violation）进程侵犯一个被保护的资源。系统库可能某个文件的描述器成 guarded ，在那以后，所有不正常的操作在这些描述器上都将触发一个EXC_GUARD异常（当它想操作在这些文件描述器上，系统可以使用特殊的 guarded 标记的私有 APIs）。这可以帮你向下快速追踪问题，例如关闭一个已经被系库打开的文件描述器。例如，假如一个 app 关闭文件秒杀器通过使用截图 SQLite 文件到一个 Core Data 存储， Core Data 将会在随后诡异的崩溃。guard exception将让这些问题尽早引起你的注意，这样也让他们变得更容易调试。 崩溃报告来自新版的 iOS 包含了人类可读的详细信息关于引起 EXC_GUARD 异常的操作在 Exception Subtype 和 Exception Message 字段中。在来自 macOS 或者老版本的 iOS 的崩溃报告中，这些信息被编码到第一个 Exception Code 就像一个分解成如下的位段： [63:61] - Guard Type：被保护的资源类型。 0x2 代表一个文件描述器资源。 [60:32] - Flavor：侵害被处罚时的条件 假如第一个 (1 &lt;&lt; 0) 位被设置，进程尝试执行 close() 函数在一个受保护的文件描述器。 假如第二个 (1 &lt;&lt; 1) 位被设置，进程尝试执行 dup() ， dup2() ，或者 fcntl() 带 F_DUPFD 或者 F_DUPFD_CLOEXEC 命令在一个受保护的文件描述器。 假如第三个 (1 &lt;&lt; 2) 位被设置，进程尝试通过一个 socket 发送给一个受保护的文件描述器。 假如第三个 (1 &lt;&lt; 3) 位被设置，进程尝试写入到一个受保护的文件描述器。 [31:0] - File Descriptor：进程尝试修改的受保护的文件描述器。 6.资源限制（Resource Limit）进程超出了一个资源消耗的限制。这是一个来自操作系统通知，告诉进程正在使用的资源过多。精确的资源列在 Exception Subtype 字段中。假如 Exception Note 字段包含 NON-FATAL CONDITION ，进程不会被终结即使产生了一个崩溃报告。 异常子类型 MEMORY 表明进程已经越过系统应用的内存限制。这可能是一个终结的先兆由于超额的使用内存。 异常子类型 WAKEUPS 表明在进程中的线程每秒被唤醒太多次，这强制 CPU 非常频繁的唤醒消耗电池寿命。 典型的，这个通过由线程与线程的通信产生（通常是使用 peformSelector:onThread: 或 dispatch_async ）,那样无意的发生了远远超出它正常应该的切换频率。因为通信的协调发生得非常频繁而出发此类的异常，这个通常和多个后台线程有着相似 Backtraces – 表明那些地方发生过通信。 7.其他异常类型（Other Exception Types）一些崩溃报告可能含有一个未命名的 Exception Type ，将以一个 16 进制的值（例如，00000020）的形式打印。假如你的设备收到了一个这样的崩溃报告，直接查看 Exception Codes 字段寻找更多的信息。 异常代码 0xbaaaaaad 表明记录是整个系统的 stackshot ，不是一个崩溃报告。为了获得一个 stackshot ，按 Home 键和任意音量键。这些记录经常被用户偶然创建，并不表明是一个错误。 异常代码 0xbad22222 表明一个 VoIP 应用已经被 iOS 终结，因为它启动得太频繁。 异常代码 0x8badf00d 表明应用已经被 iOS 终结因为发生 watchdog 超时。应用花费太长时间启动，终结，或者响应系统事件。通常导致这歌问题是做了在主线程执行了同步的网络请求。无论什么操作在 Thread 0 都需要移动到后台线程，或者异步处理，以免它阻塞主线程。 异常代码 0xc00010ff 表明引用被操作系统终结为了响应一个发热事件。这个可能由于一个发生崩溃的特定的设备的问题或者环境被操作导致。为了使你的应用更高效运行的建议，查看WWDC session iOS Performance and Power Optimization with Instruments。 异常代码 0xdead10cc 表明应用被 iOS 终结，由于当在后台运行时它持有了一个系统的资源（像通信录数据库）。 异常代码 0xdeadfa11 表明应用被用户强制退出。强制退出发生在当用户第一次按下开关机按钮直到”滑动来关机”出现，然后在按下 Home 键。这是合理的假如用户这样做了，因为应用已经变得不可响应，但是这并不能保证 - 强制退出任何正在运行的任务。 注意：终结一个挂起的 app 通过从多任务关系面板中移除并不会产生一个崩溃报告。一旦一个 app 被挂起，iOS它有资格在任何时候终结它，所有没有崩溃报告产生。 参考资料 Understanding and Analyzing Application Crash Reports Analyzing Crash Reports","categories":[{"name":"最佳实践","slug":"最佳实践","permalink":"https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"奔溃分析","slug":"奔溃分析","permalink":"https://blog.wangruofeng007.com/tags/%E5%A5%94%E6%BA%83%E5%88%86%E6%9E%90/"}]},{"title":"快速封装 Airbnb 风格 Loadingview","slug":"2016-09-10-kuai-su-feng-zhuang-airbnbfeng-ge-loadingview","date":"2016-09-10T05:54:15.000Z","updated":"2024-11-03T05:32:35.285Z","comments":true,"path":"2016/09/10/2016-09-10-kuai-su-feng-zhuang-airbnbfeng-ge-loadingview/","permalink":"https://blog.wangruofeng007.com/2016/09/10/2016-09-10-kuai-su-feng-zhuang-airbnbfeng-ge-loadingview/","excerpt":"","text":"前言一直在观察各种 App 的 LoadingView ，比较有代表性的是 MBProgressVHUD ， SVProgressHUD ，这两个使用得非常广泛，大到 QQ，支付宝，小到各种不知道名的 App，长时间的迭代让它们的逻辑非常完善，同时也导致了有些累赘，如果把它们当一个产品来分析，可以看出，它们在不断地增加需求和使用场景，有没有一个非常简洁的 HUD 没有我们不需要的那些多余的逻辑只是负责显示指示和隐藏呢？ 好像没有，所有今天动手准备自己封装一个 LoadingView ，灵感来自 Airbnb，用过 Airbnb 的同学都知道，它的 LoadingView 很有风格,Airbnb 是几张图片循环翻转切换，当然我不准备复制他们的 idea，我准备做一个循环左右上下切换的 LoadingView 。 废话不多说，先来看一下，最终效果的原型图 思路分析一下思路： 四条虚线交叉形成的区域就是我们能够看到的图片 首先准备两张图片，位置 中+上 开始第一段动画，向下切换，位置 变成 中+下 第一段动画结束，将下面的图片移动到右边，准备开始第二段动画 第二动画跟第一段类似，只是方向是从右向左，动画结束后 位置变成 中+左 将左边的图片移动到上方位置，完成一个循环 为了使动画更流畅不至于生硬，我们使用 iOS7 推出的带弹簧效果的 API 123 + (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0); API 接口在 API 接口设计上，我希望尽量简单实用，封装了两个方法，一个用来显示，一个用来隐藏，可以指定显示到某个 view，以及指定显示和隐藏时是否使用动画。 1234 + (void)showViewAddedTo:(UIView *)view animated:(BOOL)animated;+ (void)hideViewForView:(UIView *)view animated:(BOOL)animated; API 实现根据刚才的分析，核心的动画实现已经有了思路，现在就是怎么设计内部代码实现，为了方便显示蒙版阻止加载的时候用户交互，我把 view 的背景颜色设置了一个淡灰色，view 的中间有三个子 view，一个是位于中间的容器 centralView ,负责显示我们所看到的区域，方便实现圆角和动画效果，里面加入两个子 view， firstView 和 secondView 用于显示动画切换的图片。 内部接口大概这样 12345@property (nonatomic, strong) UIView *centralView;@property (nonatomic, strong) UIImageView *firstView;@property (nonatomic, strong) UIImageView *secondView; 为了防止多次添加 LoadingView ，在每次添加前，我们会查找该 view 是否存在，如果不存在，创建一个新的对象，如果存在直接跳过添加操作。反向遍历，快速查找。 12345678910111213+ (RFLoadingView *)loadingViewForView:(UIView *)view&#123; NSEnumerator *subviewsEnum = [view.subviews reverseObjectEnumerator]; for (UIView *subview in subviewsEnum) &#123; if ([subview isKindOfClass:self]) &#123; return (RFLoadingView *)subview; &#125; &#125; return nil;&#125; 动画核心实现,两端动画，封装成两个方法 - (void)animatedImageFromTopToBottom * - (void)animatedImageFromTopToBottom 具体实现如下 123456789101112131415161718192021222324252627282930313233- (void)animatedImageFromTopToBottom&#123; [UIView animateWithDuration:0.3 delay:0.5 usingSpringWithDamping:0.7 initialSpringVelocity:0 options:UIViewAnimationOptionCurveEaseInOut animations:^&#123; _firstView.centerY += kCenterViewSize; _secondView.centerY += kCenterViewSize; &#125; completion:^(BOOL finished) &#123; _firstView.centerX += kCenterViewSize; _firstView.centerY -= kCenterViewSize; [self changeFirstImage]; [self animatedImageFromRightToLeft]; &#125;];&#125;- (void)animatedImageFromRightToLeft&#123; [UIView animateWithDuration:0.3 delay:0.5 usingSpringWithDamping:0.7 initialSpringVelocity:0 options:UIViewAnimationOptionCurveEaseInOut animations:^&#123; _firstView.centerX -= kCenterViewSize; _secondView.centerX -= kCenterViewSize; &#125; completion:^(BOOL finished) &#123; _secondView.centerX += kCenterViewSize; _secondView.centerY -= kCenterViewSize; if (self.alpha &amp;&amp; self) &#123; [self changeSecondImage]; [self animatedImageFromTopToBottom]; &#125; &#125;];&#125; 需要非常注意的是，一定要写上终止动画的条件，不然会无限循环，影响性能 show 和 hide123456789101112131415161718192021222324- (void)showAnimated:(BOOL)animated&#123; RFMainThreadAssert(); self.alpha = 1; [UIView animateWithDuration:animated ? 0.3 : 0 animations:^&#123; _centralView.alpha = 1; &#125; completion:^(BOOL finished) &#123; [self animatedImageFromTopToBottom]; &#125;];&#125;- (void)hideAnimated:(BOOL)animated&#123; RFMainThreadAssert(); [UIView animateWithDuration:animated ? 0.3 : 0 animations:^&#123; self.alpha = 0; &#125; completion:^(BOOL finished) &#123; [self removeFromSuperview]; &#125;];&#125; 最终效果 Github Demo 地址:RFLoadingViewDemo","categories":[{"name":"动画","slug":"动画","permalink":"https://blog.wangruofeng007.com/categories/%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"Loading","slug":"Loading","permalink":"https://blog.wangruofeng007.com/tags/Loading/"}]},{"title":"iOS 第三方库汇总","slug":"2016-04-15-iosdi-san-fang-ku-hui-zong","date":"2016-04-15T09:23:38.000Z","updated":"2024-11-03T05:32:35.289Z","comments":true,"path":"2016/04/15/2016-04-15-iosdi-san-fang-ku-hui-zong/","permalink":"https://blog.wangruofeng007.com/2016/04/15/2016-04-15-iosdi-san-fang-ku-hui-zong/","excerpt":"","text":"简介此文用于总结，本人使用过或者收藏过的 Github 第三方类库，以便日后查阅，也便他人借鉴。 资料整理中不定期更新… 开源项目 CodeHub browse and maintain your GitHub repositories on any iOS device! Open-Source iOS Apps 开源 iOS apps 列表 APP 相关 iVersion 提示版本更新 BonMot 字体相关的库，设置字体样式 FontAwesomeKit FontAwesomeKit 提供一些简单的助手类用来帮助在 iOS 上使用FontAwesome Font-Awesome The iconic font and CSS toolkit JMHoledView 首次启动 APP 的新手指引 自动布局 Masonry 最优雅的自动布局解决方案，支持链式编程 PureLayout 又一强大的自动布局解决方案 网络请求 AFNetworking 地球人都在用 CocoaAsyncSocket 封装最完善的 Socket 类库 RxAlamofire 封装 Alamofire 基础工具类以及 Category sstoolkit 一个不错的工具包，提供各种比如编码、加密、字符串处理等等东西 BFKit Swift 版本 国外的一个大神写的很好用的分类，比较齐全 YYKit ibireme用心之作 BlocksKit 为基础类提供 Block 支持，很好用 DateTools 非常强大的日期处理工具 FlatUIKit 扩展 Foundation 基本 UI 主件，扁平化风格 iOS-Categories iOS Objective-C Category, a collection of useful Objective-C Categories extending iOS Frameworks such as Foundation,UIKit,CoreData,QuartzCore,CoreLocation,MapKit Etc. PinYin4Objc 拼音解析 ZipArchive 解压缩 Chameleon 扁平颜色框架，可以创建非常漂亮的颜色 CYLTabBarController 低耦合集成 TabBarController RKNotificationHub 在右上方显示通知小角标 Material-Controls-For-iOS Google 风格的控件 YYKit A collection of iOS components. 弹框 TYAlertController 各种风格的弹框，满足你的各种需求 JKPopMenuView 简单的弹出菜单 MMPopupView 精简的弹框，非常漂亮，和喜欢 MJPopupViewController A UIViewController Category to display a ViewController as a popup with different transition effects. QBPopupMenu 自定义 popup menu，外观和 iOS7 上的 UIMenuController 类似 CWStatusBarNotification 状态栏通知 DOPDropDownMenu 下拉列表菜单 KLCPopup 非常漂亮的弹出控件 动画 JHChainableAnimations 链式动画编程，有点 Masonry 的味道 Canvas 非常强大的动画框架 VCTransitionsLibrary 转场动画库 iCarousel 各种 3D 变换的动画，以前用过，炫酷得没朋友 tapkulibrary Tapku remain home to the things like the calendar UIs, coverflow, and any legacy classes, ect. TBIconTransitionKit 点击按钮过渡动画 + –&gt; x - –&gt; + Spring A library to simplify iOS animations in Swift * awesome-iOS-animationiOS 动画库整理收集 FeSpinner Rocket Loader Collection for iOS app,有一些非常有趣的 loading 动画 SDECollectionViewAlbumTransition CollectionView 相册自定义转场 RZTransitions A library of custom iOS View Controller Animations and Interactions. AnimatedTransitionGallery 各种自定义转场动画收集，非常值得学习 StarWars.iOS 非常炫酷的 CAShapeLayer 动画，非常炫酷😘 Animations 来自极客学院的 YouXianMing 的一些动画收集 ZFDragableModalTransition Custom animation transition for present modal view controller Gif 引擎 FLAnimatedImage Flipboard开源的 Gif 引擎 缓存 RENCache 简单的缓存解决方案 RNCachingURLProtocol webView 离线缓存库 HanekeSwift Swift 语言书写的轻量级图片缓存框架 FastImageCache Path官方开源的图片缓存框架 Kingfisher 猫神用 Swift 实现图片下载缓存框架 文本相关 TTTAttributedLabel 非常强大的 Label，支持属性，数据诊断和链接 SlackTextViewController Slack 开源的 drop-in UIViewController subclass with a growing text input view and other useful messaging features RTLabel 可以展示 Html 的 Label TYAttributedLabel 强大的属性文本控件(无需了解 CoreText )，支持图文混排显示，支持添加链接，image 和 UIView 控件，支持自定义排版显示 CSGrowingTextView 文本框会随着输入字数改变高度 LTMorphingLabel 效果非常炫的文本框 TextFieldEffects 动效非常不错的文本输入框 DDRichText 图文混排 BMLine 为你的 View 增加线条 UITextView-Placeholder A missing placeholder for UITextView. 加载进度 DACircularProgress 各种圆形和圆环型进度指示 NJKWebViewProgress UIWebView progress interface MBProgressHUD 这个不用讲，基本上都会用 SVProgressHUD 又一个进度指示 Toast 和 MBProgressHUD 差不多 LCProgressHUD 对 MBProgressHUD 的简单封装，非常实用 TSMessages 消息通知提醒框，非常好用 PINRemoteImage Pinterest 抓取远程图片类 SDWebImage 最广泛使用的图片缓存框架 AlamofireImage Swift 版本的 SDWebImage ### 键盘类 DAKeyboardControl 一个键盘管理框架 IQKeyboardManager 全局键盘管理 TPKeyboardAvoiding 使用时设置 scrollView 的类为 TPKeyboardAvoidingScrollView 即可支持 xib * RDRStickyKeyboardView作者已经停止维护… 抽屉 ViewDeck 功能强大的抽屉效果 MMDrawerController 又一个抽屉 SWRevealViewController A UIViewController subclass for revealing a rear (left and&#x2F;or right) view controller behind a front controller, inspired by the Facebook app, done right! MSDynamicsDrawerViewController Container view controller that leverages UIKit Dynamics to provide a realistic drawer navigation paradigm. PKRevealController 安装简便，高度定制且对手势识别良好 NavigationBar AMScrollingNavbar Swift 语言编写上下滑动时动态隐藏标题栏 LTNavigationbar 导航栏颜色动态改变 JZNavigationExtension Navigation 的扩展，推荐 ScrollView 相关 SwipeView SwipeView is a class designed to simplify the implementation of horizontal, paged scrolling views on iOS. It is based on a UIScrollView, but adds convenient functionality such as a UITableView-style dataSource&#x2F;delegate interface for loading views dynamically, and efficient view loading, unloading and recycling. SWTableViewCell 自定义 Cell 侧滑动作 MGSwipeTableCell 自定义 Cell 侧滑动作，效果多样 CHTCollectionViewWaterfallLayout 瀑布流布局 TYSlidePageScrollView An easy solution to page views or controllers with header and page tabbar,footer XLPagerTabStrip Android PagerTabStrip for iOS. nice MJ 系列 MJExtension model &lt;–&gt; dic &lt;–&gt; json 框架 MJRefresh 刷新控件 数据库 realm-cocoa 跨平台轻量级数据库解决方案,励志取代 Core Data &amp; SQLite * fmdb对 sqlite 实现面向对象的封装 图标库 PNChart 提供各种图标样式，性能还非常不错 Charts Beautiful charts for iOS&#x2F;tvOS&#x2F;OSX! The Apple side of the crossplatform MPAndroidChart. 图片处理以及展示相关 GPUImage 开源基于 GPU 的图片渲染引擎，带有很多款滤镜 FXBlurView 背景模糊 IDMPhotoBrowser 照片浏览器 AGImagePickerController 相册选择 DNImagePicker 仿照微信的照片选取器 JFImagePickerController 又一个照片选取器 Nuke Image loading, processing, caching and preheating 日历选择 FSCalendar iOS7+风格的日历控件，非常漂亮 音频&#x2F;视频 KRVideoPlayer 36 氪开源的视频播放器 DOUAudioStreamer 豆瓣开源的音频播放器 内购&#x2F;推广 IAPHelper in app purchases helper for iOS DAAppsViewController 应用推广界面，填写合作 app 的 appleId 即可 TAPromotee 交叉推广应用是你可以免费实现的最佳市场推广策略之一。 存储相关 SSKeychain 钥匙串存储 PINCache Pinterest出品的非阻塞式异步缓存工具 TMCache tumblr出品的对象快速异步缓存，支持 iOS 和 OS X * MagicalRecord简化 Core Data 抓取数据的逻辑，推荐 KeychainAccess Simple Swift wrapper for Keychain that works on iOS and OS X UICKeyChainStore UICKeyChainStore 的简单封装 实用控件 HCSStarRatingView 简单的评分控件 LNNotificationsUI 模仿 iOS 标准通知界面，可以以假乱真 SCLAlertView-Swift 非常漂亮的动画 Alert View ，使用 Swift 书写 Wonderful 跑马灯,彩色标签,渐变等… VVeboTableViewDemo VVebo 剥离的 TableView 绘制 FXForms 快速创建表单,设置页,用户数据任务,非常棒 SVPullToRefresh 一行代码实现 UIScrollView 下拉刷新或者无限滚动 辅助类 Surge 利用 Accelerate 高性能数学计算框架 KMCGeigerCounter 显示当前动画的帧率 XNGMarkdownParser Markdown 解析器，将 Markdown 格式的字符串解析成 NSAttributedString 格式的字符串 TransformerKit 封装了一些常用的 NSValueTransformer 类 RuntimeBrowser Objective-C Runtime Browser, for Mac OS X and iOS iOS-Runtime-Headers iOS Objective-C headers as derived from runtime introspection appledoc Objective-C 代码，苹果风格文档生成器 Markingbird Markdown processor written in Swift (translation of MarkdownSharp) Swift 30DaysofSwift allenwong 自学 Swift 的 30 个工程 👍 SwiftGuide 这份指南汇集了 Swift 语言主流学习资源，并以开发者的视角整理编排 swift-package-manager Swift 包管理工具 Carthage Swift 依赖管理工具，类似 OC 的 CocoaPods * swift-style-guideraywenderlich.com官方 Swift 编程风格规 RxSwift Reactive Programming in Swift 其它 FreeCodeCamp The https://FreeCodeCamp.com open source codebase and curriculum. Learn to code and help nonprofits. libextobjc 拓展了一些 Cocoa 类库 ParseSourceCodeStudy Facebook 开源的 Parse 源码分析【系列】 hugo 使用 Google Go 语言书写的静态博客网站生成器 CocoaPods Cocoa 包依赖管理工具 MDCSwipeToChoose 实现某 App，左滑不喜欢，右滑喜欢的卡片堆叠功能 Dash-Plugin-for-Xcode Xcode 的一个插件，整合 Dash ，方便快速查阅文档 iOS 开发面试问题 汇总一些常见的 iOS 面试问题 XMPPFramework XMPP 即时通信协议框架 WebViewJavascriptBridge Objective-C 与 JavaScript 在 UIWebViews &#x2F; WKWebView 之间交互解决方案 articles-1 Articles for objccn.io. objc.io 的完整、准确、优雅的中文翻译版本 articles Weekly articles for NSHipster.com ebook 收集了一些 coding 相关的电子书 dev-blog nixzhu 的一些 iOS &#x2F; Web 开发相关的翻译或原创博客文章 KVOController Simple, modern, thread-safe key-value observing for iOS and OS X. LBXScan 二维码、扫码、扫一扫、ZXing 和 ios 系统自带扫码封装，扫码界面效果封装 参考链接： iOS 学习资源汇总 – 鹏威の博客博客","categories":[{"name":"资料收集","slug":"资料收集","permalink":"https://blog.wangruofeng007.com/categories/%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://blog.wangruofeng007.com/tags/%E7%BD%91%E7%AB%99/"}]},{"title":"如何利用 LLDB 来 Debug","slug":"2016-04-15-ru-he-li-yong-lldblai-debug","date":"2016-04-15T02:58:26.000Z","updated":"2024-11-03T05:32:35.289Z","comments":true,"path":"2016/04/15/2016-04-15-ru-he-li-yong-lldblai-debug/","permalink":"https://blog.wangruofeng007.com/2016/04/15/2016-04-15-ru-he-li-yong-lldblai-debug/","excerpt":"","text":"介绍鉴于现在调试的频繁性和重要性，此文记录了一些基本的 LLDB 调试命令，方便日后查阅。 常用命令 p、po、call、print123456789101112p -- (&#x27;expression --&#x27;) Evaluate an expression (ObjC++ or Swift) in the current program context, using user defined variables and variables currently in scope.po -- (&#x27;expression -O -- &#x27;) Evaluate an expression (ObjC++ or Swift) in the current program context, using user defined variables and variables currently in scope.print -- (&#x27;expression --&#x27;) Evaluate an expression (ObjC++ or Swift) in the current program context, using user defined variables and variables currently in scope.call -- (&#x27;expression --&#x27;) Evaluate an expression (ObjC++ or Swift) in the current program context, using user defined variables and variables currently in scope. 从官方的描述来看， p 、 print 、 call 是一样的，但是 po 就不太一样了，输入一样但是输出不一样。 po 的输出的是具体对象的内容。 如果想要按照特定的格式来打印，如下： 12345678910(lldb) p/s self.title(__NSCFString *) $0 = @&quot;目的地&quot;(lldb) p self.title(__NSCFString *) $1 = 0x00007fe0c0d4d230 @&quot;目的地&quot;(lldb) p/x self.title(__NSCFString *) $2 = 0x00007fe0c0d4d230 @&quot;目的地&quot;(lldb) p/t self.title(__NSCFString *) $3 = 0b0000000000000000011111111110000011000000110101001101001000110000 @&quot;目的地&quot;(lldb) p/a self.title(__NSCFString *) $4 = 0x00007fe0c0d4d230 -&gt; 0x000000010d2fd2c8 (void *)0x000000010d2fd278: __NSCFString @&quot;目的地&quot; 打印输出格式化 name description x Regard the bits of the value as an integer, and print the integer in hexadecimal. d Print as integer in signed decimal. u Print as integer in unsigned decimal. o Print as integer in octal. t Print as integer in binary. The letter ‘t’ stands for “two”. a Print as an address, both absolute in hexadecimal and as an offset from the nearest preceding symbol. You can use this format used to discover where (in what function) an unknown address is located:(gdb) p&#x2F;a 0x54320 $3 &#x3D; 0x54320 &lt;_initialize_vx+396&gt; c Regard as an integer and print it as a character constant. This prints both the numerical value and its character representation. The character representation is replaced with the octal escape ‘\\nnn’ for characters outside the 7-bit ascii range.Without this format, gdb displays char, unsigned char, and signed char data as character constants. Single-byte members of vectors are displayed as integer data. f Regard the bits of the value as a floating point number and print using typical floating point syntax. s Regard as a string, if possible. With this format, pointers to single-byte data are displayed as null-terminated strings and arrays of single-byte data are displayed as fixed-length strings. Other values are displayed in their natural types.Without this format, gdb displays pointers to and arrays of char, unsigned char, and signed char as strings. Single-byte members of a vector are displayed as an integer array. z Like ‘x’ formatting, the value is treated as an integer and printed as hexadecimal, but leading zeros are printed to pad the value to the size of the integer type. r Print using the ‘raw’ formatting. By default, gdb will use a Python-based pretty-printer, if one is available (see Pretty Printing). This typically results in a higher-level display of the value’s contents. The ‘r’ format bypasses any Python pretty-printer which might exist. 格式： p/x $pc 参考链接：打印输出格式化 lldb 声明变量123(lldb) e NSString *$str = @&quot;http://www.baidu.com&quot;(lldb) po $strhttp://www.baidu.com 我们使用 e 开头声明了变量 调用变量的 API1(lldb) po [self.title uppercaseString] 强转返回值类型1234567891011121314(lldb) po [self.title characterAtIndex:0]U+76ee u&#x27;目&#x27;(lldb) po (unsigned int)[self.title characterAtIndex:0]30446(lldb) po (char)[self.title characterAtIndex:0]&#x27;\\xee&#x27;(lldb) po (NSString *)[self.title characterAtIndex:0]0x00000000000076ee(lldb) po (unichar)[self.title characterAtIndex:0]U+76ee u&#x27;目&#x27; 添加断点12b 120b [KLNewDestinationVC setupUI] b 命令后面加行号，或者指定某个对象调用的方法 设置断点触发条件右键断点处,在 condition 处编辑，如果设置了条件，只要当条件满足时，才会进入断点，也可以设置条件满足时发出声音和打印提示语。 常用打印视图层次结构1(lldb) po [self.view recursiveDescription] 临时刷新界面 UI123(lldb) e ((UIButton *)sender).backgroundColor = [UIColor redColor](UICachedDeviceRGBColor *) $41 = 0x00007fdd10715b00(lldb) e (void)[CATransaction flush]","categories":[{"name":"调试","slug":"调试","permalink":"https://blog.wangruofeng007.com/categories/%E8%B0%83%E8%AF%95/"}],"tags":[{"name":"LLDB","slug":"LLDB","permalink":"https://blog.wangruofeng007.com/tags/LLDB/"}]},{"title":"使用 facebook 的 chisel 来调试","slug":"2016-04-15-shi-yong-facebookde-chisellai-diao-shi","date":"2016-04-15T02:23:44.000Z","updated":"2024-11-03T05:32:35.291Z","comments":true,"path":"2016/04/15/2016-04-15-shi-yong-facebookde-chisellai-diao-shi/","permalink":"https://blog.wangruofeng007.com/2016/04/15/2016-04-15-shi-yong-facebookde-chisellai-diao-shi/","excerpt":"","text":"介绍 chisel 是 facebook 开源的调试框架，封装了很多方便的 LLDB 命令便于调试 iOS App，今天介绍一下使用心得以及一些常用的命令，希望对你有写帮助。 测试环境： Xcode 7.3 and iOS 9.3 simulator.OS:OSX 10.11.4 pviews and presponder doesn’t work and no output. Chisel issue on Xcode 7.3 #149 作者正在努力修复中… Xcode7.2 版本没有问题 安装brew update brew install chisel 创建 ~/.lldbinit 假如不存在编辑内容: command script import &#x2F;usr&#x2F;local&#x2F;opt&#x2F;chisel&#x2F;libexec&#x2F;fblldb.py 查看命令（lldb）help 查看具体怎样使用(lldb) help border 常用命令说明 Command Description pviews Print the recursive view description for the key window. pvc Print the recursive view controller description for the key window. visualize Open a UIImage , CGImageRef , UIView , CALayer , NSData (of an image), UIColor , CIColor , or CGColorRef in Preview.app on your Mac. fv Find a view in the hierarchy whose class name matches the provided regex. fvc Find a view controller in the hierarchy whose class name matches the provided regex. show&#x2F;hide Show or hide the given view or layer. You don’t even have to continue the process to see the changes! mask&#x2F;unmask Overlay a view or layer with a transparent rectangle to visualize where it is. border&#x2F;unborder Add a border to a view or layer to visualize where it is. caflush Flush the render server (equivalent to a “repaint” if no animations are in-flight). bmessage Set a symbolic breakpoint on the method of a class or the method of an instance without worrying which class in the hierarchy actually implements the method. wivar Set a watchpoint on an instance variable of an object. presponder Print the responder chain starting from the given object. Tips：直接点控制台上方第三个按钮呼出 LLDB 。 pviews(暂不可用)显示 view 的层级。 border&amp;unborder border :给view或者layer添加边框颜色和边框的宽度。 使用如下： (lldb) border 0x7ffc017b2970 -c green -w 10 标示设置 0x7ffc017b2970 视图或者图层一个宽度为 2 的绿色边框。 unborder :去掉view或者layer的边框颜色和边框宽度。 使用如下： unborder 0x7ffc017b2970 pinternals这个命令就是打印出来的一个控件（ id ）类型的内部结构。 使用如下： pinternals 0x7ffc017b2970 presponder（暂不可用）打印出一个继承于 UIResponder 控件的消息传递链。 visualize可以使用 mac 下的预览 app 打开我们的图片 UIImage , CGImageRef 格式的图片，甚至 view 和 layer 的图片。 使用如下： visualize 0x79ec3140 // 或者变量名，此地址是 id 类型的 pclasspclass 可以打印出一个对象的继承关系。 使用如下： pclass 0x7fcd15108800 taplog这个命令是模拟敲击一下屏幕，并且打印出你敲击屏幕时候事件接收的对象。 hide&amp;showhide 命令可以直接隐藏一个对象,移除当前遮挡的对象便于你观察后面的对象。show 命令会让它再次显示出来。 bmessage这个命令就是 LLDB 添加一个断点，譬如 -viewWillAppear: 这个方法，在当前控制器中你没有实现它，但是你又想在调用它的时机触发中断。 这个我就不解释了，需要补充一点的是 Objectiv-c 的方法是带 ： 的。 pvc打印出当前的控制器层级。 wivar这个命令是加 watchPoint 。 参考链接： Chisel 常用命令总结 – 简书 与调试器共舞 - LLDB 的华尔兹 – objccn.io Dancing in the Debugger — A Waltz with LLDB – objc.io","categories":[{"name":"调试","slug":"调试","permalink":"https://blog.wangruofeng007.com/categories/%E8%B0%83%E8%AF%95/"}],"tags":[{"name":"chisel","slug":"chisel","permalink":"https://blog.wangruofeng007.com/tags/chisel/"}]},{"title":"Associated Objects 关联对象","slug":"2016-04-14-associated-objects-guan-lian-dui-xiang","date":"2016-04-14T15:56:39.000Z","updated":"2024-11-03T06:08:17.413Z","comments":true,"path":"2016/04/14/2016-04-14-associated-objects-guan-lian-dui-xiang/","permalink":"https://blog.wangruofeng007.com/2016/04/14/2016-04-14-associated-objects-guan-lian-dui-xiang/","excerpt":"","text":"Associated Objects 介绍 &lt;objc/runtime.h&gt; 中的函数号称是iOS中最后一把神兵利刃，具有其他方式做不到的，能为应用和框架提供强大功能的能力。但使用不当也可能废掉代码的,一切代码和逻辑都可能被异常糟糕的副作用影响。 就像和魔鬼做交易一样常常让人怀着巨大的恐惧。 历史对象关联（或称为关联引用）本来是 Objective-C 2.0 运行时的一个特性，起始于 OS X Snow Leopard 和 iOS4 。 核心函数 3 个 – 允许将任何键值在允许时关联到对象上 objc_setAssociatedObject objc_getAssociatedObject objc_removeAssociatedObjects 这有什么用呢？这允许开发者对已经存在的类在扩展中添加自定义的属性 实现的 3 种方式 static char selector _cmd_ 使用 static char 实现NSObject+AssociatedObject.h 123@interface NSObject (AssociatedObject)@property (nonatomic, strong) id associatedObject;@end NSObject+AssociatedObject.m 123456789101112131415@implementation NSObject (AssociatedObject)static char kAssociatedObjectKey;- (id)associatedObject&#123; return objc_getAssociatedObject(self,&amp;kAssociatedObjectKey);&#125;- (void)setAssociatedObject:(id)associatedObject&#123; objc_setAssociatedObject(self, &amp;kAssociatedObjectKey, associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 使用 selector 实现NSObject+AssociatedObject.h 123@interface NSObject (AssociatedObject)@property (nonatomic, strong) id associatedObject;@end NSObject+AssociatedObject.m 12345678910111213@implementation NSObject (AssociatedObject)- (id)associatedObject&#123; return objc_getAssociatedObject(self, @selector(associatedObject));&#125;- (void)setAssociatedObject:(id)associatedObject&#123; objc_setAssociatedObject(self, @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 使用 _cmd_ 实现NSObject+AssociatedObject.h 123@interface NSObject (AssociatedObject)@property (nonatomic, strong) id associatedObject;@end NSObject+AssociatedObject.m 12345678910111213@implementation NSObject (AssociatedObject)- (id)associatedObject&#123; return objc_getAssociatedObject(self, _cmd_);&#125;- (void)setAssociatedObject:(id)associatedObject&#123; objc_setAssociatedObject(self, @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 关联对象的行为属性根据枚举类型 objc_AssociationPolicy 来决定被关联在对象上的行为： Behavior 与之等效的@property OBJC_ASSOCIATION_ASSIGN @property (assign) 或 @property (unsafe_unretained) OBJC_ASSOCIATION_RETAIN_NONATOMIC @property (nonatomic, strong) OBJC_ASSOCIATION_COPY_NONATOMIC @property (nonatomic, copy) OBJC_ASSOCIATION_RETAIN @property (atomic, strong) OBJC_ASSOCIATION_COPY @property (atomic, copy) OBJC_ASSOCIATION_ASSIGN 类型关联对象的弱引用不代表weak的弱引用，行为上更像 unsafe_unretained 属性。 对象销毁时间被关联的对象在声明周期内比对象本身释放要晚很多，在对象调用 -dealloc 中的 object_dispose() 中释放。 删除属性你或许想要使用 objc_removeAssociatedObjects（） 来进行删除操作，但官方文档不建议手动调用这个函数。 这个函数可能会把其他用户对其添加的属性也移除了，正确的方式是调用 objc_setAssociatedObject 方法，传入 nil 值来清除一个关联属性。 优秀样例 添加私有属性用于更好地去实现细节。 添加 public 属性来增强 category 的功能。 创建一个用于 KVO 的关联观察者。 应用举例UIImagePickerController 图片选择回调关联一个 block 实现完成选择图片后的回调。 UIImagePickerController+RFBlocks.h123456789@interface UIImagePickerController (RFBlocks)&lt;UIImagePickerControllerDelegate, UINavigationControllerDelegate&gt;typedef void(^RFImagePickerFinishBlock)(NSDictionary *info);@property (nonatomic, copy) RFImagePickerFinishBlock rf_finishBlock;+ (UIImagePickerController *)rf_imagePickerWithFinishBlock:(RFImagePickerFinishBlock)finishBlock;@end UIImagePickerController+RFBlocks.m123456789101112131415161718192021222324252627282930313233343536static const char kFinishBlockKey;@implementation UIImagePickerController (RFBlocks)+ (UIImagePickerController *)rf_imagePickerWithFinishBlock:(RFImagePickerFinishBlock)finishBlock&#123; UIImagePickerController *picker = [[UIImagePickerController alloc] init]; picker.rf_finishBlock = finishBlock; return picker;&#125;- (RFImagePickerFinishBlock)rf_finishBlock &#123; return objc_getAssociatedObject(self, &amp;kFinishBlockKey);&#125;- (void)setRf_finishBlock:(RFImagePickerFinishBlock)rf_finishBlock &#123; self.delegate = self; objc_setAssociatedObject(self, &amp;kFinishBlockKey, rf_finishBlock, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;#pragma mark - UIImagePickerControllerDelegate- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info&#123; RFImagePickerFinishBlock block = self.rf_finishBlock; if (block) block(info); [self dismissViewControllerAnimated:YES completion:nil]; self.rf_finishBlock = nil;&#125;@end 使用： 123456789__weak typeof(self)weakSelf = self;UIImagePickerController *picker = [UIImagePickerController rf_imagePickerWithFinishBlock:^(NSDictionary *info) &#123; NSLog(@&quot;finish picke image\\n info:%@&quot;,info); UIImage *img = info[@&quot;UIImagePickerControllerOriginalImage&quot;]; weakSelf.view.layer.contents = (id)img.CGImage; &#125;];[self presentViewController:picker animated:YES completion:nil]; 或者 12345678910111213UIImagePickerController *picker = [[UIImagePickerController alloc] init]; __weak typeof(self)weakSelf = self;picker.rf_finishBlock = ^(NSDictionary *info) &#123; NSLog(@&quot;finish picke image\\n info:%@&quot;,info); UIImage *img = info[@&quot;UIImagePickerControllerOriginalImage&quot;]; weakSelf.view.layer.contentsGravity = kCAGravityResizeAspect; weakSelf.view.layer.contents = (id)img.CGImage;&#125;;[self presentViewController:picker animated:YES completion:nil]; UIButton 按钮事件回调关联一个按钮事件 block，当触发按钮 UIControlEventTouchUpInside 事件时回调。 UIButton+RFBlcoks.h1234567@interface UIButton (RFBlcoks)typedef void(^RFButtonClickBlock)(UIButton *button);@property (nonatomic, copy) RFButtonClickBlock rf_buttonClickBlock;@end UIButton+RFBlcoks.m123456789101112131415161718192021222324static char kButttonClickBlockKey;@implementation UIButton (RFBlcoks)- (RFButtonClickBlock)rf_buttonClickBlock&#123; return objc_getAssociatedObject(self, &amp;kButttonClickBlockKey);&#125;- (void)setRf_buttonClickBlock:(RFButtonClickBlock)rf_buttonClickBlock&#123; objc_setAssociatedObject(self, &amp;kButttonClickBlockKey, rf_buttonClickBlock, OBJC_ASSOCIATION_COPY_NONATOMIC); [self addTarget:self action:@selector(buttonClicked) forControlEvents:UIControlEventTouchUpInside];&#125;- (void)buttonClicked&#123; if (self.rf_buttonClickBlock) &#123; self.rf_buttonClickBlock(self); &#125;&#125;@end 使用： 123self.button.rf_buttonClickBlock = ^(UIButton *button)&#123; NSLog(@&quot;%@ clicked&quot;,button);&#125;; Demo 地址： AssociatedObjectDemo 参考资料： Associated Objects – NSHipster Objective-C Associated Objects – King’s Cocoa Objective-C Associated Objects 的实现原理– 雷纯峰的技术博客 Associated Objects by Example – Sebastian Rehnby","categories":[{"name":"系统原理","slug":"系统原理","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"https://blog.wangruofeng007.com/tags/Runtime/"}]},{"title":"玩转 iOS 剪切板","slug":"2016-04-14-wan-zhuan-iosjian-qie-ban","date":"2016-04-14T14:20:52.000Z","updated":"2024-11-03T07:53:52.666Z","comments":true,"path":"2016/04/14/2016-04-14-wan-zhuan-iosjian-qie-ban/","permalink":"https://blog.wangruofeng007.com/2016/04/14/2016-04-14-wan-zhuan-iosjian-qie-ban/","excerpt":"","text":"前言移动应用风靡的今天，大家越来越觉得，一个 App 的处理事情的效率至关重要，包括一些细节处理，像 本地化 （localization）和 辅助功能 （accessibility）的支持是高品质的应用和其它应用区分开的两个特性，今天我们来聊聊一个增加用户体验和效率的功能– 编辑操作 编辑操作标准编辑动作处理复制，剪切，删除和粘贴命令 复制 （copy:） 剪切 （cut:） 删除 （delete:） 粘贴 （paste:） 处理选择命令 选择 （select:） 全选 （selectAll:） 富文本编辑命令 加粗 （toggleBoldface:） 斜体 （toggleItalics:） 下划线 （toggleUnderline:） 改变书写方向命令 书写方向左到右 （makeTextWritingDirectionLeftToLeft:） 书写方向右到左 （makeTextWritingDirectionRightToLeft:） 改变文本尺寸命令 变大 （increaseSize:） 变小 （decreaseSize:） 实现 label 的复制粘贴功能1234567891011121314151617181920212223242526272829// RFLabel.h@interface RFLabel : UILabel@end// RFLabel.m@implementation RFLabel- (BOOL)canBecomeFirstResponder &#123; return YES;&#125;- (BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; return (action == @selector(copy:) || action == @selector(paste:));&#125;#pragma mark - UIResponderStandardEditActions- (void)copy:(id)sender &#123; [[UIPasteboard generalPasteboard] setString:self.text];&#125;- (void)paste:(id)sender &#123; NSString *toBePastedString = [[UIPasteboard generalPasteboard] string]; self.text = toBePastedString;&#125;@end 在控制器中使用它： 1234567891011121314151617181920212223242526272829303132333435363738#import &quot;ViewController.h&quot;#import &quot;RFLabel.h&quot;@interface ViewController ()@property (weak, nonatomic) IBOutlet RFLabel *topLabel;@property (weak, nonatomic) IBOutlet RFLabel *bottomLabel;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.topLabel.userInteractionEnabled = YES; self.bottomLabel.userInteractionEnabled = YES; UIGestureRecognizer *gestureRecognizer1 = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handleLongPressGesture:)]; UIGestureRecognizer *gestureRecognizer2 = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handleLongPressGesture:)]; [self.topLabel addGestureRecognizer:gestureRecognizer1]; [self.bottomLabel addGestureRecognizer:gestureRecognizer2];&#125;- (void)handleLongPressGesture:(UIGestureRecognizer *)recognizer&#123; if (recognizer.state == UIGestureRecognizerStateRecognized) &#123; [recognizer.view becomeFirstResponder]; UIMenuController *menuController = [UIMenuController sharedMenuController]; [menuController setTargetRect:recognizer.view.frame inView:recognizer.view.superview]; [menuController setMenuVisible:YES animated:YES]; &#125;&#125;@end 总结一下，为了能够支持复制粘贴一个 label 的文字，需要完成下面几步： 必须继承 UILabel ,在子类中实现 canBecomeFirstResponder 和 canPerformAction:withSender: 方法 实现每个可以执行的操作，在方法中和 UIPasteboard 进行交互 初始化 label 时，将 label 的 userInteractionEnabled 属性设置为 YES * 向 label 添加一个手势（或者手动在子类中实现 UIResponder 的方法，例如 touchesBegan:withEvent: ） 响应手势识别事件，指明 UIMenuController 的位置，设置为可见 最后，使 label 成为第一响应者 UIMenuController UIMenuController 负责展示编辑动作的菜单项。每个应用都持有自己的一个单例对象 sharedMenuController。默认情况下，菜单控制器会展示 UIResponderStandardEditActions 这个非正式协议（即不需要对应实现的协议）中的方法，假如 canPerformAction:withSender: 返回 YES 。 UIMenuItem可以通过 UIMenuController 的 menuItems 属性添加自定义的命令，每一个都是 UIMenuItem 对象，只需要指定每个动作的 title 和 action 1- (instancetype)initWithTitle:(NSString *)title action:(SEL)action NS_DESIGNATED_INITIALIZER; UITableView 和 UICollectionView UITableView 和 UICollectionView 可以在cell上调出编辑菜单,其实任何自定义的 UIView 都能实现， UIViewController 的子类只是以不同的方式实现而已。为了让 UITableView 和 UICollectionView 也能实现，你需要使用一些额外的方法否则屏幕上不会显示任何东西。这些方法给予了你更多的控制在显示指定的上下文菜单基于你将要显示在 UITableView 和 UICollectionView 的内容。 UITableViewDelegate 方法 – tableView:shouldShowMenuForRowAtIndexPath: – tableView:canPerformAction:forRowAtIndexPath:withSender: – tableView:performAction:forRowAtIndexPath:withSender: UICollectionViewDelegate 方法 – collectionView:shouldShowMenuForItemAtIndexPath: – collectionView:canPerformAction:forItemAtIndexPath:withSender: – collectionView:performAction:forItemAtIndexPath:withSender: Bonus实现 UIImageView 图片的复制粘贴功能 Demo 地址： Menu_Controller_Demo 参考链接 UIMenuController – nshipster UIMenuController_Class – UIMenuController Class Reference Show the UIMenuController and Display Custom Edit Menus UITableViewCell on iOS 5 UITableViewController – Demo","categories":[{"name":"系统原理","slug":"系统原理","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"剪切板","slug":"剪切板","permalink":"https://blog.wangruofeng007.com/tags/%E5%89%AA%E5%88%87%E6%9D%BF/"}]},{"title":"创建自定义 View 在 IB 中实时渲染","slug":"2016-04-10-chuang-jian-zi-ding-yi-viewzai-ibzhong-shi-shi-xuan-ran","date":"2016-04-10T05:22:56.000Z","updated":"2024-11-03T05:32:35.286Z","comments":true,"path":"2016/04/10/2016-04-10-chuang-jian-zi-ding-yi-viewzai-ibzhong-shi-shi-xuan-ran/","permalink":"https://blog.wangruofeng007.com/2016/04/10/2016-04-10-chuang-jian-zi-ding-yi-viewzai-ibzhong-shi-shi-xuan-ran/","excerpt":"","text":"曾想自定义的 View，可以像系统自带属性一样，并且实时渲染，动态更新内容，现在在 Xcode6 终于让你可以轻松的做到。 你不用编译就能实时预览，现在配置自定义界面方便多了， IBInspectable 和 IBDesignable 使它成为可能。 IBInspectable IBInspectable 属性提供访问旧功能的新方法：用户自定义的运行时属性。从目前的身份检查器（identity inspector）中访问，这些属性在Interface Builder整合到Xcode。可以通过它来配置Nib，Xib，storyboard实例中的任何键值编码（key-value-coded）属性： 以前想实现，只能点+号手动添加例如想给 UIView 添加一个圆角半径，设置 Key Path 为：layer.cornerRadius,type 为 Number ，Value 为 4，如果使用 IBInspectable 只需要在 @property 声明后加上 IBInspectable（或者 swift 加上 @IBInspectable ），就可以在 IB 的观察面板中（inspector pannel）里直接编辑。其他交由 Xcode 自动完成，属性名字会自动分组，名称从驼峰（camel-）转换成 title-模式。 目前可检查属性支持 备注 : 经本人亲测，除 NSNumber , NSRange 不会产生观察面板属性， NSRange 不会在 runtime Attributes 中自动添加，其他都会自动生成。 支持颜色类型 UIColor 但是不支持 CALayer 的 CGColor ，设置颜色时只需设置 UIColor ，不要要设置 CGColor ，系统会自动将 UIColor 转换，例如设置 borderColor。 IBDesignable当你应用到 UIView 或者 UIView 的子类中的时候，只需加上 IBDesignable ，就可以让 IB 在画布上实时渲染视图。当你更新属性后，视图会自动更新不需要重新运行程序。 标记一个自定义视图为 IBDesignable ，只需要在类名前面加上 IB_DESIGNABLE （ Swift 里加上 @IBDesignable ）。你的初始化，布置和绘制方法都将用来在画布上渲染你的自定义视图: 123456789101112IB_DESIGNABLE@interface CustomView :UIView &#123;@property (nonatomic, strong) IBInspectable UIColor *borderColor; @property (nonatomic, assign) IBInspectable CGFloat borderWidth;...&#125;@end 实时效果： 有了这个功能，一个设计师或者开放人员可以轻松调整自定义的控件呈现。任何改变，都将立即呈现，有的想 Swift 里面的 playground 功能，实现：所见即所得。 由于在 Interface Builder 中呈现自定义视图不会有应用程序的完整上下文，你可能需要生成模拟数据以便显示，例如一个默认用户头像图片或仿制的天气数据。有两种方法可以为这个特殊的上下文添加代码： prepareForInterfaceBuilder() :此方法与你代码的其余部分一起编译，但只有当视图正在准备在 Interface Builder 显示时执行 TARGET_INTERFACE_BUILDER:#if TARGET_INTERFACE_BUILDER 预处宏,在 Objective-C 或 Swift 下都是工作的，它会视情况编译正确代码 12345678#if !TARGET_INTERFACE_BUILDE// this code will run in the app it self#els// this code will execute only in IB#endif 参考资料: IBInspectable-IBDesignable Apple 官方介绍 Demo 地址: IBInspectable_IBDesignable_Demo","categories":[{"name":"系统 API","slug":"系统-API","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F-API/"}],"tags":[{"name":"IB","slug":"IB","permalink":"https://blog.wangruofeng007.com/tags/IB/"}]},{"title":"Unix Shell 常用命令","slug":"2016-03-27-unixshellchang-yong-ming-ling","date":"2016-03-27T10:29:44.000Z","updated":"2024-11-03T05:32:35.300Z","comments":true,"path":"2016/03/27/2016-03-27-unixshellchang-yong-ming-ling/","permalink":"https://blog.wangruofeng007.com/2016/03/27/2016-03-27-unixshellchang-yong-ming-ling/","excerpt":"","text":"输出文件内容到基本输出 cat filename 改变文件的权限 chmod 或 change mode 当前的时间和日期 date 拷贝 copy 显示当前目录下所有文件以及文件夹 ls 显示 dir 文件夹下所有文件以及文件夹 ls dir 查看磁盘空间状况 du 查看当前进程状况 ps 你的用户名和终端类型 who 创建目录 mkdir dir 删除目录 rmdir dir 进入目录 cd dir 删除文件 rm file 显示文件 more file 显示指定文本 echo 改文件名、移动文件 mv source target 显示目录路径命令 pwd 清屏 clear 退出输入命令 Ctrl + c 改变文件或目录之最后修改时间 touch name 删除目录 rmdir directory-name 或 rm -r directory-name rmdir dir1 删除目录 dir1，但 dir1 下必须没有文件存在，否则无法删除。 rm -r dir1 删除目录 dir1，及其下所有文件及子目录。 删除文件 rm filename (filename 可为文件名，或文件名缩写符号。) rm file1 删除文件名为 file1 之文件。 rm file? 删除文件名中有五个字符，前四个字符为 file 之所有文件。 rm f* 删除文件名中，以 f 为字首之所有文件。 rm -rf file 删除名为 file 的文件夹及其里面的内容","categories":[{"name":"CLI","slug":"CLI","permalink":"https://blog.wangruofeng007.com/categories/CLI/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://blog.wangruofeng007.com/tags/shell/"}]},{"title":"Git 常用命令","slug":"2016-03-27-gitchang-yong-ming-ling","date":"2016-03-27T09:08:45.000Z","updated":"2024-11-03T05:32:35.293Z","comments":true,"path":"2016/03/27/2016-03-27-gitchang-yong-ming-ling/","permalink":"https://blog.wangruofeng007.com/2016/03/27/2016-03-27-gitchang-yong-ming-ling/","excerpt":"","text":"创建新的仓库 新建文件夹，打开，执行 git init 检出仓库 创建一个本地仓库克隆版本 git clone /path/to/repository 创建远程服务器上的仓库 git clone username@host:/path/to/repository Git 工作流一个本地仓库由 git 维护的 3 客”树”组成。 工作目录 working dic 。 – 它持有实际文件 暂存区 Index 。 – 它像个缓冲区域，临时保存你的改动 HEAD 。 – 它指向你最后一次提交的结果 work flow： working dic –add– &#x3D;&#x3D;&gt; Index –commit– &#x3D;&#x3D;&gt; HEAD ### 添加和提交 添加到暂存区 123456# 针对单个文件。git add &lt;filename&gt;# 添加当前目录下非隐藏文件及文件夹的所有更改，但不包含隐藏文件。git add *# 添加当前目录及其子目录中所有文件的更改，包括隐藏文件。git add . 提交到 HEAD git commit -m &#39;some comment&#39; 添加提交二合一 git commit -a -m &#39;some comment&#39; 查看仓库修改状态git status 推送更改 现在的改动已经提交到本地仓库的 HEAD 中，提交到远程仓库 git push 格式 git push (remote) (branch) ,第一次 push 必须这样写 git push origin master:master ### 推送到具体某一分支 git push origin someBranch 分支操作 查看分支 git branch 查看分支最后提交状态 git branch -v --merged 与 --no-merged 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 git branch --merged aBranch iss53 master 新建分支 git branch aBranch 切换到 aBranch 分支 git checkout aBranch 新建切换分支 2 合一 git checkout -b aBranch 删除分支 git branch -d aBranch 如果将要删除的分支还有没有合并的内容，删除将会失败，使用 -D 强制删除 error: The branch &#39;testBranch&#39; is not fully merged. If you are sure you want to delete it, run &#39;git branch -D testBranch&#39;. 分支重命名 git branch -m oldBranchName newBranchName 分支操作实例 master 是默认的分支。在其他分支上进行开发，完成后再将他们合并到主分支上。 创建一个叫“feature_x”的分支，并切换过去 git checkout -b feature_x 切换回主分支： git checkout master 删除新建分支 git branch -d feature_x 将分支推送到远程仓库 git push origin &lt;branch&gt; 更新与合并 更新你的本地仓库到最新改动 git pull 会在你的工作目录 抓取 fetch 并合并 merge 远端的改动 合并 aBranch 分支回 master 分支 git checkout master git merge aBranch 这种方式叫做直接合并（straight merge）注意没参数的情况下 merge 是 fast-forward 的，即 Git 将 master 分支的指针直接移到 aBranch 的最前方。 换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单移动指针，所以这种合并成为快进式( Fast-forward ) 如何避免每次输入密码如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。 如果不想在每一次推送时都输入用户名与密码，你可以设置一个 credential cache 。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config --global credential.helper cache 来设置它。 压合合并 squashed commits 将一条分支上的若干个提交条目压合成一个提交条目，提交到另一条分支的末梢。把 aBranch 分支上的所有提交压合成主分支上的一个提交，即压合提交： git checkout master git merge --squash aBranch 此时， aBranch 上的所有提交已经合并到当前工作区并暂存，但还没有作为一个提交，可以像其他提交一样，把这个改动提交到版本库中： git commit -m &#39;some comment&#39; 拣选合并 cherry-picking 拣选另一条分支上的某个提交条目的改动带到当前分支上。每一次提交都会产生一个全局唯一的提交名称，利用这个名称就可以进行拣选提交。 比如在 dev 上的某个提交叫： 321d76f 把它合并到 master 中： git checkout master git cherry-pick 321d76f 要拣选多个提交，可以给 git cherry-pick 命令传递 -n 选项，比如： git cherry-pick –n 321d76f 这样在拣选了这个改动之后，进行暂存而不立即提交，接着可以进行下一个拣选操作，一旦拣选完需要的各个提交，就可以一并提交。 如果发生冲突，解决冲突完后执行 git cherry-pick --continue 继续拣选合并。 解决冲突（conflicts） 通过 CONFLICT (content): 找到冲突文件所在的位置 打开冲突文件，修改冲突后保存 通过 git status 查看冲突是否解决 通过 git diff &lt;source_branch&gt; &lt;target_banch&gt; 预览差异 提交更改 git commit -a -m &#39;some comment&#39; ### 查看远程分支的完整列表 git ls-remote 获取远程分支更多信息git remote show 新建远程分支git push --set-upstream origin newBranch 提交分支数据到远程服务器git push origin &lt;local_branch_name&gt;:&lt;remote_branch_name&gt; 删除远程分支git push origin :develop git push origin --delete develop 标签创建一个 1.0.0 的标签 git tag 1.0.0 1b2e1d63ff 1b2e1d63ff是你想要标记的提交 ID 的前 10 位字符，可使用下列命令获取提交 ID git log 替换本地改动git checkout -- &lt;filename&gt; 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。 假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它 git fetch orgin git reset --hard origin/master 参考链接 Git - 简明指南 Git 社区参考指南 Github Help 图解 Git Think like a git","categories":[{"name":"CLI","slug":"CLI","permalink":"https://blog.wangruofeng007.com/categories/CLI/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.wangruofeng007.com/tags/Git/"}]},{"title":"使用 Mantle 高效构建 Model","slug":"2016-03-03-shi-yong-mantlegao-xiao-gou-jian-model","date":"2016-03-02T17:05:21.000Z","updated":"2024-11-03T05:32:35.293Z","comments":true,"path":"2016/03/03/2016-03-03-shi-yong-mantlegao-xiao-gou-jian-model/","permalink":"https://blog.wangruofeng007.com/2016/03/03/2016-03-03-shi-yong-mantlegao-xiao-gou-jian-model/","excerpt":"","text":"概述在 iOS 开发中，从服务器获取数据，然后解析成本地的模型是经常的要做事，而且重复次数特别多，每次增加一个网络请求或者增加一个模型都需要完成 JSON 到 Model 层的转换，手写通过字典 valueForKey: 直接解析已经更不上时代的步伐，学会利用工具提高自己的工作效率，今天就分享一下 Mantle 这个框架解析的心得。 Mantle 解决的痛点： 服务器经常更新（添加或者删除）字段，客服端需要在 Model 层初始化的时候修改取值字段，易出错，而且繁琐。 实现自定义的 Model 的序列化，以便将数据保存到本地，也就是说实现 NSCoding 协议，在模型复制的情况下添加或者修改字段非常麻烦。 自定义的 Model 的 Copy ,你必须手动实现 NSCopying 协议,而且没有办法反序列化成 JSON 。 Mantle 很好的解决的以上痛点： 实现了 NSCopying 协议。 实现了 NSCoding 协议，可以通过 NSKeyedArchiver 将数据归档到本地。 提供了 isEqual: 和 hash 的默认实现。 可以在 Model 和 JSON 之间互相转换。 以一个 CATProfile 模型类为例，演示这个框架怎样以一种非常简单的方式将一个 NSDictionary 对象映射成一个 Objective-C ,反之亦然。 下面的 CATProfile 模型 123456789&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Objective Cat&quot;, &quot;birthday&quot;: &quot;2013-09-12 13:29:36 +0100&quot;, &quot;website&quot;: &quot;http://objc.at&quot;, &quot;location&quot;: &#123; &quot;lat&quot;: &quot;48.2083&quot;, &quot;lon&quot;: &quot;16.3731&quot; &#125;, &quot;relationship_status&quot;: &quot;single&quot;, &quot;awesome&quot;: true&#125; 下面我们创建一个 MTLModel 子类代表以上的 Json 对象。 1234567891011121314151617181920// CATProfile.htypedef NS_ENUM(NSInteger, CATRelationshipStatus) &#123; CATRelationshipStatusSingle = 0, CATRelationshipStatusInRelationship, CATRelationshipStatusComplicated&#125;;@interface CATProfile : MTLModel&lt;MTLJSONSerializing&gt;@property(strong, nonatomic) NSNumber *profileId;@property(strong, nonatomic) NSString *name;@property(strong, nonatomic) NSDate *birthday;@property(strong, nonatomic) NSURL *website;@property(nonatomic) CLLocationCoordinate2D locationCoordinate;@property(nonatomic) CATRelationshipStatus relationshipStatus;@property(nonatomic, getter=isAwesome) BOOL awesome;@end CATProfile 类继承自 MTLModel 并且实现了 MTLJSONSerializing ，协议要求实现 +JSONKeyPathsByPropertyKey 方法 12345678910111213141516// CATProfile.m@implementation+ (NSDictionary *)JSONKeyPathsByPropertyKey &#123; // properties defined in header &lt; : &gt; key in JSON Dictionary return @&#123; @&quot;profileId&quot;: @&quot;id&quot;, @&quot;websiteURL&quot;: @&quot;website&quot;, @&quot;locationCoordinate&quot;: @&quot;location&quot;, @&quot;relationshipStatus&quot;: @&quot;relationship_status&quot;, &#125;;&#125;@end +JSONKeyPathsByPropertyKey 方法返回一个在JSON数据中需要模型的属性匹配的值的字典，这能确保 Mantle 知道那个JSON键键使用来构成一个指定的模型接口。 很明显除了这个列表中的 name , birthday 和 awesome 属性。假如一个属性在字典中被忽略， Mantle 将自动在 JSON 中查找带有相同名称的接口。 NSValueTransformer Mantle 还能够处理任意类型的转换，例如 NSString 和 NSNumber 默认支持。然而，它也需要一些帮助对于处理非任意的类型例如 NSURL 和 枚举 还有自定义的结构体像 CLLocationCoordinate2D 。 Mantle 依赖Foundation框架下 NSValueTransformer 对象来实现在模型代表的JSON层和OC对象的实际接口之间的值的映射。 创建一个自定义transformer给某个属性，我们需要实现一个叫做 +&lt;propertyName&gt;JSONTransformer 的类方法并且返回一个想要的 NSValueTransformer 对象。 12345678910111213141516// mapping birthday to NSDate and vice-versa+ (NSValueTransformer *)birthdayJSONTransformer &#123; return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSString *dateString) &#123; return [self.dateFormatter dateFromString:dateString]; &#125; reverseBlock:^(NSDate *date) &#123; return [self.dateFormatter stringFromDate:date]; &#125;];&#125;+ (NSDateFormatter *)dateFormatter &#123; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; dateFormatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US_POSIX&quot;]; dateFormatter.dateFormat = @&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;Z&#x27;&quot;; return dateFormatter;&#125; Mantle 在 runtime 调用这个方法来决定怎样变换 birthday 属性，正向转换block从一个字符串对象到一个 NSDate 对象，反向转换block将 NSDate 对象转换回一个字符串对象，非常棒！ 下面列举了一些变换方法，对于所有的我们需要注意的非任意属性以供参考。 NSURL ↔︎ JSON string123+ (NSValueTransformer *)websiteURLJSONTransformer &#123; return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];&#125; CLLocationCoordinate2D ↔︎ JSON object12345678910+ (NSValueTransformer *)locationCoordinateJSONTransformer &#123; return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSDictionary *coordinateDict) &#123; CLLocationDegrees latitude = [coordinateDict[@&quot;lat&quot;] doubleValue]; CLLocationDegrees longitude = [coordinateDict[@&quot;lon&quot;] doubleValue]; return [NSValue valueWithMKCoordinate:CLLocationCoordinate2DMake(latitude, longitude)]; &#125; reverseBlock:^(NSValue *coordinateValue) &#123; CLLocationCoordinate2D coordinate = [coordinateValue MKCoordinateValue]; return @&#123;@&quot;lat&quot;: @(coordinate.latitude), @&quot;lon&quot;: @(coordinate.longitude)&#125;; &#125;];&#125; enum ↔︎ JSON string1234567+ (NSValueTransformer *)relationshipStatusJSONTransformer &#123; return [NSValueTransformer mtl_valueMappingTransformerWithDictionary:@&#123; @&quot;single&quot;: @(CATRelationshipStatusSingle), @&quot;relationship&quot;: @(CATRelationshipStatusInRelationship), @&quot;complicated&quot;: @(CATRelationshipStatusComplicated) &#125;];&#125; BOOL ↔︎ JSON boolean123+ (NSValueTransformer *)awesomeJSONTransformer &#123; return [NSValueTransformer valueTransformerForName:MTLBooleanValueTransformerName];&#125; 从 JSON 创建模型对象一旦模型配置完成，就该获得 JSON 对象从 API 中，并且把它转换成我们模型的一个实例。首先，我们需要把 JSON 呈现转换成一个 NSDictionary ,它能够用来通过 Mantle 来创建我们的模型，很幸运的是 iOS 提供了一个非常棒的方法来处理它，就是通过 NSJSONSerialization 。 那样以后， MTLJSONAdapter 类就能利用 Mantle 做繁重的工作来创建我们的模型。 123456// create NSDictionary from JSON dataNSData JSONData = ... // the JSON response from the APINSDictionary *JSONDict = [NSJSONSerialization JSONObjectWithData:JSONData options:0 error:NULL];// create model object from NSDictionary using MTLJSONSerialisationCATProfile *profile = [MTLJSONAdapter modelOfClass:CATProfile.class fromJSONDictionary:JSONDict error:NULL]; 从模型对象创建 JSON MTLJSONAdapter 也有能力创建一个字典从我们的的模型类中，以便能直接编码回一个JSON字符串。 123456// create NSDictionary from model class using MTLJSONSerialisationCATProfile *profile = ...NSDictionary *profileDict = [MTLJSONAdapter JSONDictionaryFromModel:profile];// convert NSDictionary to JSON dataNSData *JSONData = [NSJSONSerialization dataWithJSONObject:profileDict options:0 error:NULL]; 假如当创建一个 JSON 呈现你的模型是在你的模型中有一个属性不应该包括，你应该返回 NSNull.null ,例如。在 +JSONKeyPathsByPropertyKey 的@{“name” : “NSNull.null”}。 Mantle 将安全的忽略这个属性。 映射数组和字典大多数情况，模型和其他模型有关系，这些关系普遍通过 JSON 数组或者对象来呈现。 1234567891011121314151617181920&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Objective Cat&quot;, ..., &quot;owner&quot;: &#123; &quot;id&quot;: 99, &quot;name&quot;: &quot;Alexander Schuch&quot; &#125;, &quot;friends&quot;: [ &#123; &quot;name&quot;: &quot;Owly&quot;, &quot;type&quot;: &quot;bird&quot; &#125;, &#123; &quot;name&quot;: &quot;Hedgy&quot;, &quot;type&quot;: &quot;mammal&quot; &#125; ]&#125; Mantle 支持映射这些关系到新的模型，为了让 Mantle 知道怎样变换关系，我们可以使用下面提供的分类方法中的一个来返回 NSValueTransformer 。 12+ (NSValueTransformer *)mtl_JSONDictionaryTransformerWithModelClass:(Class)modelClass;+ (NSValueTransformer *)mtl_JSONArrayTransformerWithModelClass:(Class)modelClass; 当然 Mantle 需要知道这些官和他们的将要转换的 MTLModel 子类，就像和创建一个新的 MTLModel 子类并且实现将要映射到这些对象的 MTLJSONSerializing 协议一样简单。然后我们可以添加一些新的属性到我们 CATProfile 类中并且实现两个新的转换器。 123456789101112// CATProfile.h@property(strong, nonatomic) CATOwner *owner; // CATOwner is a MTLModel subclass@property(strong, nonatomic) NSArray *friends; // Array of CATFriend objects// CATProfile.m+ (NSValueTransformer *)ownerJSONTransformer &#123; return [NSValueTransformer mtl_JSONDictionaryTransformerWithModelClass:CATOwner.class];&#125;+ (NSValueTransformer *)friendsJSONTransformer &#123; return [NSValueTransformer mtl_JSONArrayTransformerWithModelClass:CATFriend.class];&#125; 一些有用的补充我们简单的聊了一下 NSValueTransformer 在前面, NSValueTransformer 有一个非常棒的特征让通过名字全局注册一个变换器成为可能。假如你正在使用相同的变换器在你整个 app 中，确保子类化 NSValueTransformer ，注册你的自定义变换器一次并且在你随后的 MTLModels 中使用它。 12345678910111213141516// In CATProfile.mNSString * const kCATCustomValueTransformerName = @&quot;CATCustomValueTransformer&quot;;+ (void)initialize&#123; // Register NSValueTransformer if (self == CATProfile.class) &#123; CATCustomValueTransformer *transformer = [CATCustomValueTransformer new]; [NSValueTransformer setValueTransformer:transformer forName:kCATCustomValueTransformerName]; &#125;&#125;// Then use the custom transformer to translate properties using Mantle+ (NSValueTransformer *)whateverPropertyJSONTransformer &#123; return [NSValueTransformer valueTransformerForName:kCATCustomValueTransformerName];&#125; 结论 Mantle 是一个非常棒的补充处理 JSON APIs，然而，你也必须意识到假如你不得不处理非常复杂的数据或者不稳定的APIs它也是不合适的。 参考资料 Mantle-Cat Mantle Framework on Github NSValueTransformer at NSHipster Mantle as a Model Layer for iOS and OS X Apps iOS JSON 模型转换库评测","categories":[{"name":"三方 API","slug":"三方-API","permalink":"https://blog.wangruofeng007.com/categories/%E4%B8%89%E6%96%B9-API/"}],"tags":[{"name":"序列化","slug":"序列化","permalink":"https://blog.wangruofeng007.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"4 种方式实现 iOS 模糊效果","slug":"2016-01-31-3chong-fang-shi-shi-xian-iosmo-hu-xiao-guo","date":"2016-01-31T15:12:52.000Z","updated":"2024-11-03T05:32:35.295Z","comments":true,"path":"2016/01/31/2016-01-31-3chong-fang-shi-shi-xian-iosmo-hu-xiao-guo/","permalink":"https://blog.wangruofeng007.com/2016/01/31/2016-01-31-3chong-fang-shi-shi-xian-iosmo-hu-xiao-guo/","excerpt":"","text":"介绍 iOS 中以下四种方式实现： CoreImage 中的模糊滤镜 UIImage + ImageEffects 的 category 模糊效果 iOS8 中 UIVisualEffectView 模糊效果 iOS7 以后通过 UIToolBar 实现模糊效果 CoreImage 中的模糊滤镜实现 CoreImage 主要通过 CIFilter 这个类来实现。 这个类支持的滤镜多达 14 类，每个类又细分多款滤镜： CICategoryBlur CIBoxBlur CIDiscBlur CIGaussianBlur CIMaskedVariableBlur CIMedianFilter CIMotionBlur CINoiseReduction CIZoomBlur CICategoryColorAdjustment CIColorClamp CIColorControls CIColorMatrix CIColorPolynomial CIExposureAdjust CIGammaAdjust CIHueAdjust CILinearToSRGBToneCurve CISRGBToneCurveToLinear CITemperatureAndTint CIToneCurve CIVibrance CIWhitePointAdjust CICategoryColorEffect CICategoryCompositeOperation CICategoryDistortionEffect CICategoryGenerator CICategoryGeometryAdjustment CICategoryGradient CICategoryHalftoneEffect CICategoryReduction CICategorySharpen CICategoryStylize CICategoryTileEffect CICategoryTransition 我们这里使用的是高斯模糊，也就是 CIGaussianBlur 。 Sample Code： 1234567891011121314151617181920212223242526272829303132333435UIImage *avatar = [UIImage imageNamed:@&quot;avatar&quot;];/********** CoreImage ************/// CIImageCIImage *ciImage = [[CIImage alloc] initWithImage:avatar];// CIFilterCIFilter *blurFilter = [CIFilter filterWithName:@&quot;CIGaussianBlur&quot;];// 设置模糊滤镜半径[blurFilter setValue:@(20) forKey:@&quot;inputRadius&quot;];// 将图片输入到滤镜[blurFilter setValue:ciImage forKey:kCIInputImageKey];// 将处理好的图片输出CIImage *outCiImage = [blurFilter valueForKey:kCIOutputImageKey];// 查询可以设置的参数和一些信息NSLog(@&quot;%@&quot;,[blurFilter attributes]);// CIContextCIContext *contex = [CIContext contextWithOptions:nil];// 获取 CGImage 句柄CGImageRef outCGImage = [contex createCGImage:outCiImage fromRect:[outCiImage extent]];// 最终获取到图片UIImage *blurImage = [UIImage imageWithCGImage:outCGImage];// 释放 CGImage 句柄CGImageRelease(outCGImage); 此时 blurImage 图片就是经过滤镜处理后的图片，在放在 ImageView 上加载即可看到效果。 UIImage + ImageEffects 的 category 模糊效果使用 Apple 开源的一个图片处理分类来实现，这个使用起来只需一行代码，简洁明了。 123UIImage *blurImage = [sourceImage blurImage]; 这里封装了一个区域模糊效果的方法 123- (UIImage *)blurImageAtFrame:(CGRect)frame; iOS8 中 UIVisualEffectView 模糊效果这个效果只支持 iOS8.0 以上的版本，通过 UIVisualEffectView 来实现。 Sample Code： 12345678910// 1.创建模糊 view UIVisualEffectView *effectView = [[UIVisualEffectView alloc] initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]]; // 2.设置尺寸 effectView.frame = CGRectMake(0, 100, [UIScreen mainScreen].bounds.size.width, 200); // 3.添加到 view 当中 [self.view addSubview:effectView]; 😊Bonus:实现 iOS 高版本通知中心炫酷的 Label 模糊效果。 12345678910111213141516171819202122// 添加一个文本标签 UILabel *label = [[UILabel alloc] initWithFrame:effectView.bounds]; label.text = @&quot;www.blog.wangruofeng007&quot;; label.textAlignment = NSTextAlignmentCenter; label.font = [UIFont systemFontOfSize:30]; [effectView.contentView addSubview:label]; /***************** 添加模糊效果 *****************/ // 1.创建子模糊 view UIVisualEffectView *subEffectView = [[UIVisualEffectView alloc] initWithEffect:[UIVibrancyEffect effectForBlurEffect:(UIBlurEffect *)effectView.effect]]; // 2.设定尺寸 subEffectView.frame = effectView.bounds; // 3.将子模糊 view 添加到 effectView 的 contenView 才能生效 [effectView.contentView addSubview:subEffectView]; // 4.添加要显示的 view 来达到特殊的效果 [subEffectView.contentView addSubview:label]; 效果图： Demo 地址： BlurEffectDemo – 本文效果 Demo UIVisualEffects_Objective-c – 详细介绍 UIVisualEffects 的使用 iOS7 以后通过 UIToolBar 实现模糊效果在 iOS7 以后， UINavigationBar 和 UIToolBar 自带毛玻璃模糊效果，可以通过手动创建 UIToolBar 对象，然后添加到 view 中实现，UIToolBar 区域就可以实现动态毛玻璃模糊效果。 例如在一个状态栏后方添加一个模糊 view,可以在控制器中这样实现，假设没有导航栏 12UIToolbar *statusBar = [[UIToolbar alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 20)];[self.view addSubview:statusBar]; 这个方法非常简单实用😊，快去试试吧。 参考资料： Core Image Programming Guide Core Image Filter Reference UIImageBlur","categories":[{"name":"最佳实践","slug":"最佳实践","permalink":"https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"特效","slug":"特效","permalink":"https://blog.wangruofeng007.com/tags/%E7%89%B9%E6%95%88/"}]},{"title":"Watch App 开发之 Interface Elements 详解","slug":"2016-01-29-watch-app-kai-fa-zhi-interface-elements-xiang-jie","date":"2016-01-29T09:36:26.000Z","updated":"2024-11-03T05:32:35.297Z","comments":true,"path":"2016/01/29/2016-01-29-watch-app-kai-fa-zhi-interface-elements-xiang-jie/","permalink":"https://blog.wangruofeng007.com/2016/01/29/2016-01-29-watch-app-kai-fa-zhi-interface-elements-xiang-jie/","excerpt":"","text":"iWatch 原生态支持的控件主要有以下类型,下面对每个类型一一解刨。 Labels Images Groups Pickers Tables Buttons Switches Sliders Maps Movies Date and Timer Labels Menus Labels – WKInterfaceLabel Labels 使用静态的文本来传达简短的消息，是你App中最常见的一个元素之一。它能支持多行显示也可通过代码动态更新内容。 iWatch ,设计一个标签事，首先应该把精力集中在 易读性 ,使用更亮的颜色和使用动态类型（ Dynamic Type ）来保证文本尺寸的正确，内置已经提供了最佳的易读性和自动的动态的类型支持。假如需要使用自定义的字体，应该避免使用过度格式化的。 更多信息查看：Typography Images – WKInterfaceImage 一个 Image 元素用来显示单张图片或者一系列动画图片。Images 支持在 iOS 上的的任何格式，但是跟偏向于 PNG 格式。动画系列图片可以通过代码控制启停。 38mm 和 42mm 共用一套图片资源，只要内容能够表达清晰。 Apple Watch 支持高清屏显示，所有没有必要创建一个标准的分辨率图片，在图片名应该包括 @2x 。 当图片正在加载时，应该使用占位图片来占据它的空间。 优化图片查看：Image Optimizations Groups – WKInterfaceGroup Group 这个概念是专为有限空间的 iWatch 打造的，可以帮你对其他元素进行布局。它有 postion , size , marigns 以及其他布局相关的接口，一个 Group 对象本身也是一个可见的元素，它也有背景图片，颜色，圆角半径等属性。 支持水平 horizontally 和垂直 vertically 布局，可以让放在里面的项目实现相应的布局，可以使用 spacing 属性来设置内部项目之间的间距，使用 margins 来控制 Group 和它周边的元素的距离。 Group 支持镶嵌操作，你可以通过镶嵌来指定你想要的布局样式。 你应该优化你的 Group 的背景图片来获得更好的体验，因为太大可能使你的 App 变得卡顿。优化请参考：Image Optimizations 外观大概这样: Pickers – WKInterfacePicker Pickers 能够显示一个可以使用数字表冠导航的列表。这意味着你可以使用一种更精确和迷人的方式选择。 Pickers 可以通过下面三种方式的一种来展示它们的项目： List style ,可以显示文本或者图片在一个滚动列表里面 Stack style ,栈风格以一个卡片风格的界面显示图片，当用户滚动，被选择的图片动画进入最上方，这种风格适合浏览照片。 Sequence style ,序列显示，可以显示一系列的图片。当用户转动表冠时， Picker 显示先前或下一张图片在这个序列中没有动画，这种风格适合于构建自定义的界面使用你自己的图片。 Pickers 还能被配置成显示一个 轮廓 ， 标题 ， 滚动指示器 。这些元素可以让你分辨出屏幕上的 Pickers 并且可以帮助用户导航它的内容。 使用标题来指明你选择项目的意义或者 picker 本身的作用 你可以给项目指定一个独特的标题当那些项目的意思表达不清晰的时候，可选，你也可以设置所有的项目相同的标题来标明 Picker 它本身的作用。 显示一个滚动指示器当所有的内容不是全部可见时 Tabels – WKInterfaceTable Tabels 在一列中展示多行的内容。一个表的一行是动态配置的，它的内容可以在随时改变。 Tabels 天生可滚动，支持各种交互，能够设置背景颜色或者图片。 使用注意事项： 统一使用行的风格类型，即使一个表可以包含多行，它应该呈现一个全局统一的外观，每一行使用你的主要内容开始，然后随你的需要添加更多支持的其他类型的内容，例如 headers 或者 footers ,总是用原来设计的目的来使用行类型。例如，你不应该用一行来显示 headers 或 footers 的内容。 限制行数最大 20，显示最重要的行在顶部，让用户能够浏览尽可能的多。行数越少越容易快速浏览。 **不要在 groups 里面镶嵌 tables **, Tabels 会动态改变它的尺寸基于它所包含的行的数目。它会忽略 groups 对高度的限制。 不要在 table 行内包含 ∧ 或者 ∨ 符号，行后台实现可以自然点击，你不需要包含一个 ∧ 或者 ∨ 符号或者文字来表明行是可点击的。 Buttons – WKInterfaceButton一个 button 可以执行一个 app 指定的动作， button 可以自定背景和圆角半径。它还可以充当容器使用，包含一个标签 labe; ，图片 image ，或者一个组 group 对象。 使用事项： 创建横跨屏幕的 Buttons ，全宽的 buttons 看起来更容易点击，假如有两个 buttons，必须有相同的水平间距，两者使用相同的高度使用相同的图或者简短的文本标签。 使用相同的高度对于 vertical stacks 风格布局一行和两行文本按钮，原则是，尽可能的，使用一致到高度让他们在视觉上统一。 使用标准的圆角半径，标准的圆角半径的是 6点 ，使用标准的圆角半径可以提升整个 app 的视觉的一致性并且可以增强 button 的内容。 让 butotns 足够大以便容易点击，创建让用户很容易点击的 button，buttons 应该遵循下面最小的值。 38mm (minimum) 42mm (minimum) Circular buttons 75 pixels 80 pixels Round rectangular buttons 50 pixels high 52 pixels high Switches – WKInterfaceSwitch开关控件更 iOS 类似，让用户在量个互斥的选择或者状态中选择，例如开或者关，一个靠近 switch 的标签应该指定响应的效果当，开关切换时。 效果像这样： Sliders – WKInterfaceSlider一个滑动条让用户来调整到某一个值。一个 slider 用来显示它设置的一系列的值或者是一个持续的 bar , 它可以在一个有限的范围内根据预定的数量自增或者自减。 Note：你可以像使用 slider 那样使用自定图片,系统默认显示 + 和 - 符号。 Maps – WKInterfaceMap Maps 是地理位置的静态快照。你可以放一张地图在你的界面里面在预计的时间，但是你 WatchKit extension 必须配置显示的区域在运行时。显示区域是不可交互的，但是点击一个地图将会打开你 Apple Watch 上的 Maps app。 你可以在地图上用一个高亮的点对你感兴趣或者其他相关信息进行标注。地图能显示标准的 红 ， 黄 ， 绿 大头针，它也可以显示自定义的图片，系统允许你最多添加 5个 在一张地图上。 使用注意实现： 让你地图的元素根据屏幕自动适应。用户应该能够看到整个地图元素在 Apple Watch 上而不用滚动屏幕。 配置显示的地图区域到包含兴趣点的最小范围，地图元素内容本身不能滚动，所有所有内容必须附着在一个指定的地图区域 Movies – WKInterfaceMovie一个 movie 对象会显示一张海报图片，当点击时，模态呈现一份视频或者音频对象，使用这个元素来放置简短的媒体剪切和你内容内联。媒文件的重放由系统来管理。 使用注意事项： 使用一种海报图片来呈现剪切的内容，海报图片能让用户提前做决定是否观看与这个剪切关联的媒体，不要使用没有意义的剪切图片。 不要创建海报图片像系统控件， Movies 会让视频和音频内容看起来像你节目的一部分，所以不要通过让他们看起来像其他东西的方式把他们隐藏起来。你应该使用一个 Button （而不是一个 movie ）来呈现媒体回放界面假如你喜欢的话。 保证视频或者音频剪辑得足够短，剪辑不应该超过 30 秒，首选更短的。长的剪辑会占用更多的磁盘空间并且要求用户保持他们的手腕抬起更长时间，这样可能导致疲劳。 适当的设置剪辑视频的尺寸，无论时候都应该使用推荐的尺寸来剪切，缩放视频剪辑将影响性能导致不理想的外观。更多信息关于推荐的尺寸和编码的值，参考Audio &amp; Video Date &amp; Timer Labels – WKInterfaceDate,WKInterfaceTimerDate 和 Timer 标签用来显示真实的时间在 Apple Watch 上。 一个 date label 显示了现在的日期，现在的时间或者两者的组合。它可以使用各种样式，日历和时区来配置，在你配置好后，日期标签直接跟新它的值而不需要通过你 app 的进一步输入。 一个 timer label 用来显示一个精准的倒计时和和计数定时器。它能够配置它显示的计数的值以各种形式，在你配置完成后，一个 timer label 能够计数或者倒计时不用从你的 app 的进一步输入。 Menus – WKMenuItemIcon强力触摸 Apple Watch 将调出当前屏幕的 menu （假如有点话）。一个菜单能够显示多达 4 个有关的动作对于当前屏幕，而不用从你的界面离开。 使用注意事项： 包含一个 Menu 当现在屏幕有相关的操作的时候，菜单是可选的。假如没有菜单呈现，系统将播放一段动画来响应用户的强力触摸操作。 使用一个 label 和一个 icon 来传达每个菜单动作的意图，label 和 icon 都需要，label 限制 2 行，所以文本应该尽量的短。 使用菜单来响应它们预期的目的， Menus 是一种能够修改当前界面控制器内容的方式，不要使用它们来作为主要的导航形式在你的 app 中。 避免复制你的其他 app 中菜单的视觉风格，假如你必须使用一个相似的布局，加上颜色给你的界面或者排列的项目，用一种不同于其他菜单的方式。 更多 menu icons 设计的信息，参考 Menu Icons。 参考资料： human-interface-guidelines human-interface-guidelines Visual Design Apple Watch 指南 Best-apple-watch-apps","categories":[{"name":"系统 API","slug":"系统-API","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F-API/"}],"tags":[{"name":"WatchOS2","slug":"WatchOS2","permalink":"https://blog.wangruofeng007.com/tags/WatchOS2/"}]},{"title":"MVVM 资料整理","slug":"2016-01-20-mvvmzi-liao-zheng-li","date":"2016-01-20T14:59:16.000Z","updated":"2024-11-03T05:32:35.298Z","comments":true,"path":"2016/01/20/2016-01-20-mvvmzi-liao-zheng-li/","permalink":"https://blog.wangruofeng007.com/2016/01/20/2016-01-20-mvvmzi-liao-zheng-li/","excerpt":"","text":"MVVM，作为一种新的架构设计，有别于 MVC，MVP，它有很多自己的特性和优势，例如易于调试，业务逻辑集中方便管理，统一各种通信机制，将业务和控制器解耦。这框架现在很多公司都在尝试使用，像美团等，以后可能是一种趋势，鉴于它学习成本比较高，此文意在记录和收集相关的资料，以便以后查阅。 Github 地址：ReactiveCocoa 比较不错的学习资料： ReactiveCocoa 讨论会 – 唐巧 MVVM without ReactiveCocoa – limboy ReactiveCocoa – 美团 ReactiveCocoa v2.5 源码解析之架构总览 – 雷纯峰 Functor、Applicative 和 Monad – 雷纯峰 Principles of Reactive Programming – 这里有一些视频课程，很不错 ReactiveCocoa Tutorial – The Definitive Introduction: Part 1&#x2F;2 ReactiveCocoa Tutorial – The Definitive Introduction: Part 2&#x2F;2 MVVM Tutorial with ReactiveCocoa: Part 1&#x2F;2 MVVM Tutorial with ReactiveCocoa: Part 2&#x2F;2 Functional Reactive Programming on iOS – 这本书介绍函数式编程配有例子，可以快速理解这种思想，入门级推荐 Reactive​Cocoa – NSHipster ReactiveCocoa 入坑 ing – 简书 ReactiveCocoa 学习资源收集 – 简书 ReactiveCocoa 学习资料汇总 – 简书","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.wangruofeng007.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"MVVM","slug":"MVVM","permalink":"https://blog.wangruofeng007.com/tags/MVVM/"}]},{"title":"TableView 性能优化","slug":"2016-01-18-tableviewxing-neng-you-hua","date":"2016-01-18T14:00:04.000Z","updated":"2024-11-03T05:32:35.297Z","comments":true,"path":"2016/01/18/2016-01-18-tableviewxing-neng-you-hua/","permalink":"https://blog.wangruofeng007.com/2016/01/18/2016-01-18-tableviewxing-neng-you-hua/","excerpt":"","text":"此文整理一下 TableView 优化相关的方案和思路。 TableView 为什么会卡？主要由以下原因： cellForRowAtIndexPath: 方法中处理了过多业务 tableviewCell 的 subview 层级太复杂，做了大量透明处理 cell 的 height 动态变化时计算方式不对 优化核心思想： UITableViewCell 重用机制简单的理解就是：UITableView 只会创建一屏幕（或一屏幕多一点）的 UITableViewCell，其他都是从中取出来重用的。每当 Cell 滑出屏幕时，就会放入到一个集合（或数组）中（这里就相当于一个重用池），当要显示某一位置的 Cell 时，会先去集合（或数组）中取，如果有，就直接拿来显示；如果没有，才会创建。这样做的好处可想而知，极大的减少了内存的开销。 Tips： 提前计算并缓存好高度（布局），因为 heightForRowAtIndexPath: 是调用最频繁的方法； 异步绘制,遇到复杂界面,参考 Facebook 的 AsyncDisplayKit 和YYAsyncLayer异步绘制框架； 缓存图片（ SDWebImage ），提前处理好 UIImageView 图片的尺寸按需加载而不是加载原图； 计算等耗时操作异步处理，处理完再回主线程更新 UI； 图文混排不定高度采用 CoreText 排版，缓存 Cell 高度参考YYKit； 实现 Cell 的 drawRect: 方法直接绘制，减少 UIView ， UIImageView ， UILabel 等容器的使用。 Bonus： 正确使用 reuseIdentifier 来重用 Cell； 尽量少用或不用透明图层或 View； 如果 Cell 内现实的内容来自 web，使用异步加载，缓存请求结果； 减少 subviews 的数量在 heightForRowAtIndexPath: 中尽量不使用 cellForRowAtIndexPath: ，如果你需要用到它，只用一次然后缓存结果； 尽量少用 addView 给 Cell 动态添加 View，可以初始化时就添加，然后通过 hide 来控制是否显示； 固定高度不要实现 heightForRowAtIndexPath: 方法。 可以通过实现以下方法，可以减少高度计算次数 123456@property (nonatomic) CGFloat rowHeight; // will return the default value if unset@property (nonatomic) CGFloat sectionHeaderHeight; // will return the default value if unset@property (nonatomic) CGFloat sectionFooterHeight; // will return the default value if unset@property (nonatomic) CGFloat estimatedRowHeight NS_AVAILABLE_IOS(7_0); // default is 0, which means there is no estimate@property (nonatomic) CGFloat estimatedSectionHeaderHeight NS_AVAILABLE_IOS(7_0); // default is 0, which means there is no estimate@property (nonatomic) CGFloat estimatedSectionFooterHeight NS_AVAILABLE_IOS(7_0); // default is 0, which means there is no estimate 参考资料： code-uitableviewcell-optimizations-part-1 code-uitableviewcell-optimization-part-2 Perfect smooth scrolling in UITableViews 优化 UITableViewCell 高度计算的那些事 详细整理：UITableView 优化技巧 UITableview 性能优化总结 AsyncDisplayKit 教程：达到 60 FPS 的滚动帧率 AsyncDisplayKit YYAsyncLayer","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://blog.wangruofeng007.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"TableView","slug":"TableView","permalink":"https://blog.wangruofeng007.com/tags/TableView/"}]},{"title":"iOS Animation Swift 版","slug":"2016-01-16-ios-animation-swift-ban","date":"2016-01-16T11:34:06.000Z","updated":"2024-11-03T05:32:35.299Z","comments":true,"path":"2016/01/16/2016-01-16-ios-animation-swift-ban/","permalink":"https://blog.wangruofeng007.com/2016/01/16/2016-01-16-ios-animation-swift-ban/","excerpt":"","text":"简介此文主要记录我学习 iOS 的动画相关内容用 Swift 语言，记录下来以供参考，不定时更新。 目录结构 Section I: View 动画 View animation 弹簧动画 - Springs 转场动画 - Transitions 关键帧动画 - Keyframe Section II: Auto Layout 动画 Section III: Layer 动画 Section IV: 3D 动画 Section V: 未来类型的动画 Section VI: View Controller 动画 Section VII：第三方动画库 Section VIII: Apple Watch 动画 Section I: View 动画1.View animation简介：view 的动画主要是通过 UIView 的类方法创建，动画内容一般放在 block 里面，可以镶嵌使用，构成链式动画，主要有 3 个方法,三个访法只需会参数最多的那个就行，函数名 animateWithDuration(_:delay:options:animations:completion:) ，其他的使用起来都类似。 123class func animateWithDuration(_ duration: NSTimeInterval, animations animations: () -&gt; Void)class func animateWithDuration(_ duration: NSTimeInterval, animations animations: () -&gt; Void, completion completion: ((Bool) -&gt; Void)?)class func animateWithDuration(_ duration: NSTimeInterval, delay delay: NSTimeInterval, options options: UIViewAnimationOptions, animations animations: () -&gt; Void, completion completion: ((Bool) -&gt; Void)?) 使用： 12345UIView.animateWithDuration(0.5, delay: 0, options: [], animations: &#123; //do something &#125;, completion: &#123;_ in //do something&#125;) 说明： options ，动画选项，这个运行你设置一个动画选项集合，传 [] 表示不需要选项，单个时可以省略放括号例如 .Repeat ,多个用逗号连接 [.Repeat, .CurveEaseInOut] &gt; completion 闭包需要一个参数，不需要使用参数可以用 _ 表示，不需要实现可以直接传 nil 或者像下面这样写 12345UIView.animateWithDuration(0.5, delay: 0, options: [], animations: &#123; () -&gt; Void in //do something &#125;) &#123; (_) -&gt; Void in //do something&#125; 2.弹簧动画 - Springs简介：弹簧动画是 iOS 7.0 新增的 API，函数名 animateWithDuration(_:delay:usingSpringWithDamping:initialSpringVelocity:opti ons:animations:completion:) ， 1class func animateWithDuration(_ duration: NSTimeInterval, delay delay: NSTimeInterval, usingSpringWithDamping dampingRatio: CGFloat, initialSpringVelocity velocity: CGFloat, options options: UIViewAnimationOptions, animations animations: () -&gt; Void, completion completion: ((Bool) -&gt; Void)?) 使用： 123UIView.animateWithDuration(0.5, delay: 0.5, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.0, options: [], animations: &#123;// do something&#125;, completion: nil) 说明： usingSpringWithDamping :设置弹簧的阻尼，范围（0.0-1.0），越接近 0.0 弹簧越有弹性，越接近 1.0，效果越僵硬，你可以把当成弹簧的刚度来理解，initialSpringVelocity :设置弹簧初始化的速度，设置 1.0 表示用 1 秒在动画跨度上完成整个动画距离，值越大或者越小会导致动画有相应的大的或者较小的速度，可以当成弹簧的初始动量来理解。 3.转场动画 - Transitions简介：前两种创建的动画是基于可动画的接口例如，position，alpha，frame 等等，Transitions 是专门处理添加或者移除一个 view 的动画,系统有 2 个标准函数，一个是对单个 view 的处理，一个是处理 2 个 view 替换。 12class func transitionWithView(_ view: UIView, duration duration: NSTimeInterval, options options: UIViewAnimationOptions, animations animations: (() -&gt; Void)?, completion completion: ((Bool) -&gt; Void)?)class func transitionFromView(_ fromView: UIView, toView toView: UIView, duration duration: NSTimeInterval, options options: UIViewAnimationOptions, completion completion: ((Bool) -&gt; Void)?) 使用： 1234567891011121314151617//add the new view via transitionUIView.transitionWithView(animationContainerView!, duration: 0.33,options: [.CurveEaseOut, .TransitionFlipFromBottom], animations: &#123;self.animationContainerView!.addSubview(newView) &#125;, completion: nil)//remove the view via transitionUIView.transitionWithView(animationContainerView!, duration: 0.33,options: [.CurveEaseOut, .TransitionFlipFromBottom], animations: &#123;self.newView.removeFromSuperview() &#125;, completion: nil)//hide the view via transitionUIView.transitionWithView(self.newView, duration: 0.33, options: [.CurveEaseOut, .TransitionFlipFromBottom], animations: &#123;self.newView.hidden = true &#125;, completion: nil)//replace via transitionUIView.transitionFromView(self.oldView!, toView: self.newView!, duration: 0.33, options: [.TransitionFlipFromTop],completion: nil) 4.关键帧动画 - Keyframe简介：关键帧顾名思义就是设定关键的一些帧然后系统会根据一套算法计算中间的其他帧，这样改变的可动画属性时看看起来更加流畅自然，主要有两个函数,一个创建关键帧动画，一个设置具体每帧内容 12class func animateKeyframesWithDuration(_ duration: NSTimeInterval, delay delay: NSTimeInterval, options options: UIViewKeyframeAnimationOptions, animations animations: () -&gt; Void, completion completion: ((Bool) -&gt; Void)?)+ (void)addKeyframeWithRelativeStartTime:(double)frameStartTime relativeDuration:(double)frameDuration animations:(void (^)(void))animations 例如： 1234567891011121314151617181920212223242526272829303132func planeDepart() &#123; UIView.animateKeyframesWithDuration(1.5, delay: 0.0, options: [], animations: &#123; //add keyframes UIView.addKeyframeWithRelativeStartTime(0.0, relativeDuration: 0.25, animations: &#123; self.planeImage.center.x += 100.0 self.planeImage.center.y -= 10.0 &#125;) UIView.addKeyframeWithRelativeStartTime(0.1, relativeDuration: 0.4) &#123; self.planeImage.transform = CGAffineTransformMakeRotation(CGFloat(-M_PI_4/2)) &#125; UIView.addKeyframeWithRelativeStartTime(0.25, relativeDuration: 0.25) &#123; self.planeImage.center.x += 100.0 self.planeImage.center.y -= 60.0 self.planeImage.alpha = 0.0 &#125; UIView.addKeyframeWithRelativeStartTime(0.51, relativeDuration: 0.01) &#123; self.planeImage.transform = CGAffineTransformIdentity self.planeImage.center = CGPoint(x: 0.0, y: originalCenter.y) &#125; UIView.addKeyframeWithRelativeStartTime(0.55, relativeDuration: 0.45) &#123; self.planeImage.alpha = 1.0 self.planeImage.center = originalCenter &#125; &#125;, completion: nil)&#125; 说明：这是设计一个飞机沿一条路径起飞然后再归位的一段动画， addKeyframeWithRelativeStartTime(_:relativeDuration:animations:) ,第一个参数相对开始时间，是相对于动画持续时间的百分比，例如 0.1 就是 10%，0.25 就是 25%，如果整个动画持续 2 秒，0.1 就是在 2*0.1&#x3D;0.2 秒的时候开始，后面的一个参数是相对持续时间，范围更第一参数类似也(0.0-1.0),只从相对开始时间起，往后推移的相对时间。 Section II: Auto Layout 动画12345678910111213141516// change Constraint// init layoutview.layoutIfNeeded()UIView.animateWithDuration(0.8, delay: 0.0, usingSpringWithDamping: 0.4, initialSpringVelocity: 0.0, options: [], animations: &#123; // do something change constraint // layout self.view.layoutIfNeeded() &#125;, completion: nil) 原理就是，修改约束,让添加一个动画，在动画 block 里面执行布局更新， block 里面也可以添加修改约束代码，修改约束的本质是修改相关 View 的 frame 和 bounds ，由于修改 View 的这个属性是支持动画的，所以修改约束其实是间接修改 View 的这些属性，所以也是支持动画的，这个动画的强大的之处在于，可以实现一系列 View 相互协作的动画。 Section VIII: Apple Watch 动画概述：在 Apple Watch 中有两种技术来创建动画，一个是一次性创建一系列静态可动画的图片序列或者循环动画，另一种是对标签和其他项目通过改变尺寸，对齐，颜色，透明度进行布局和外观动画。 Animated Image Sequences Animated Image Sequences 是由两个或者更多的独立图片组成的序列来随时间按序列显示。每张图片组成了动画的一个单独的帧，整个动画运行在一个循环中除了你在运行的时候修改了播放的行为。主要把它安装在你界面中的 image ， group , button 等元素中。通过 WKImageAnimatable 协议来实现动画，也就是说凡是遵循这个协议的对象都支持动画， WatchKit 中遵循这个协议的对象有： WKInterfaceGroup ， WKInterfaceImage 你可以控制 image 和 group 元素 Animated Image Sequences 的播放的速度，方向，帧率,否则界面元素将会无限循环显示一个完整的动画。 Notes: Animated Image Sequences 可以正向播放动画也可以反向执行动画在运行的时候，你不应该提供一套一样的图片以反向的方式，你应该使用这个技术来降低 App 的尺寸。 如果你是从 storyboard 创建序列图片对象，可以通过 func startAnimating() 方法开始执行动画，通过 func stopAnimating() 来停止动画的执行。 实例： 实现 WKInterfaceGroup 加载进度动画 1.在 Watch 里面的 Interface.storyboard 里面拖拽一个 WKInterfaceGroup 命名为 backgroundGroup 2.创建一个 WKInterfaceButton 按钮来触发这个动画事件,在控制器里面实现下面的代码 1234567891011121314@IBAction func checkInButtonTapped() &#123; // 1 let duration = 0.35 let delay = dispatch_time(DISPATCH_TIME_NOW, Int64((duration + 0.15) * Double(NSEC_PER_SEC))) // 2 backgroundGroup.setBackgroundImageNamed(&quot;Progress&quot;) // 3 backgroundGroup.startAnimatingWithImagesInRange(NSRange(location: 0, length: 10), duration: duration, repeatCount: 1) // 4 dispatch_after(delay, dispatch_get_main_queue()) &#123; () -&gt; Void in // 5 dosomething &#125; &#125; 参数说明： imageRange ,将要执行动画的图片范围， 0 表示第一张图片， 1 表示第二张图片，以此类推； duration ,单位秒，表示动画执行单个循环的时间， 正值 表示从第一帧到最后一帧执行， 负值 表示以相反的顺序执行动画，以第一帧结束； repeatCount ,动画的重复次数，设置 0 表示无限循环。 3.将素材文件拖入 Watch 的 Asset.xcassets 的文件里面，以 Progress 开始命名后面接一串连续的数字，效果应该像下面这样。 4.然后在模拟器上运行就 OK 了。 Layout and Appearance Animations 你可以动画改变所有界面元素的布局和外观。动画改变布局让你修改元素的尺寸或者动态的改变布局的方向。你可以移动在屏幕上的元素或者让它们的内容重新对齐。你也可以动画改变元素的外观，包括改变他们的 backgroud color 或者 opactiy 。这些类型的动画让你创建动态的界面用来响应用户的交互并且提供一个更好的反馈。 所有的 layout- and appearance-based animations 在动画开始和结束都以 easing 的曲线方式自动构建 。你不能关闭或者自定义缓动曲线。相当于 UIView 的动画选项里面的 easeInOut 。 可动画属性： Opacity Height Width Group Insets Alignment Background Color Tint Color 核心代码： 123class func animateWithDuration(_ duration: NSTimeInterval, animations animations: () -&gt; Void) 说明:这个方法在 WKInterfaceController 中，目前发现只有这一个动画 API，你可以在这个闭包里面执行相应的动画操作，实现跟 UIView 的 block 动画类似。 实例： 在界面已经出现的时候对 planeImage 进行着色动画,改变 separator 的颜色 12345678910111213141516var planeImage: WKInterfaceImage!var separator: WKInterfaceSeparator!override func didAppear() &#123; super.didAppear() // 1 animateWithDuration(0.35, animations: &#123; () -&gt; Void in // 2 let color = UIColor(red: 90/255, green: 200/255, blue: 250/255, alpha: 1) planeImage.setTintColor(color) separator.setColor(color) &#125;) &#125;&#125; 参考资料： Apple Human-interface-guidelines – Apple Apple WatchKit Programming Guide – Apple Apple Watch – SwiftGuide Swift Guide – SwiftGuide 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"动画","slug":"动画","permalink":"https://blog.wangruofeng007.com/categories/%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://blog.wangruofeng007.com/tags/Swift/"}]},{"title":"NSURLSession 教程","slug":"2016-01-15-nsurlsession","date":"2016-01-15T10:15:01.000Z","updated":"2024-11-03T05:32:35.292Z","comments":true,"path":"2016/01/15/2016-01-15-nsurlsession/","permalink":"https://blog.wangruofeng007.com/2016/01/15/2016-01-15-nsurlsession/","excerpt":"","text":"本文翻译自 http://www.raywenderlich.com/51127/nsurlsession-tutorial 原作者： Charlie Fulton 译者：@oneruofeng 注意：这是一篇来自我们作为即将发布 iOS 7 Feast的一部分iOS 7 by Tutorials的简短版本的章节。我们希望你们喜欢。 每一个新的 iOS 版本发布都会包含一些极好的新的网络 APIs，iOS7 也不例外，在 iOS7 中，Apple 引入了 NSURLSession ,这是为了取代 NSURLConnection 作为偏好的网络请求的一系列类。 在这个 NSURLSession 的教程中，你将了解到这个新类究竟是什么，为什么你要使用它以及你怎样使用它，它和以前的类库比较而言怎样，最后最重要的是：获得一个整合到一个真正的 App 的实践。 请注意：这个课程是假设你熟悉基本的网络概念。假如网络对你来说完全是新的，你仍然可以跟我一起一步一步的学习，但是可能有些你不熟悉的概念需要需要自己查询在这个过程中。 为什么使用 NSURLSession 为什么你要使用 NSURLSession ? 饿，因为它可以带给你一些好处和优势相比以前的： 后台上传和下载 ： 当你创建 NSURLSession 的时候你只需配置一个选项即可，你便可以进行所有的后台网络任务。这将有对你的电池寿命有利，它支持 UIKit 多任务并且当切换线程的时候使用相同的代理模型。 使你的网络操作可以暂停和恢复 ：你稍后将会看到，任何使用 NSURLSession API 的网络任务都可以被暂停，停止，重新开始。而没有使用 NSOperation 子类的必要。 可配置的容器：对于放进里面的请求而言每一个 NSURLSession 都是可配置的。例如，假如你需要设置一个 HTTP header 选项，你只需要设置一次然后每个在 session 中的请求就都会有相同的配置了。 可子类化和私密存储： NSURLSession 是可子类化的并且你可以配置一个 session 用来作为私密存储在某个会话中。这允许你拥有私密存储对象在全局状态下。 优化的授权处理机制：授权被完成基于某个特定的连接。当使用 NSURLConnection 的时候假如发生了一处授权改变，这个改变将返回一个随意的请求，你不能确定你具体得到的那个。使用 NSURLSession 的话，代理回来处理授权。 丰富的代理模型： NSURLConnection 有些基于 block 的同步方法，然而代理就不能使用它们了。当一个请求建立了无论它是成功还是失败，哪怕需要授权。使用 NSURLSession 就就可以混合接入，使用基于 block 的异步方法同时也可以设置代理来处理授权。 通过文件系统上传和下载：苹果鼓励把（文件内容）数据跟(URL 和一些设置)元数据分开。 NSURLSession vs NSURLConnection “哇哦， NSURLSession 听起来很复杂呀！”,你可能这么想。”我可能还是继续使用我的老朋友 NSURLConnection 。”别担心–使用 NSURLSession 使用起来其实和它的前辈 NSURLConnection 一样简单对于简单的任务来说。例如，让我来看一个在获取伦敦最新的天气的一个简单网络请求，通过它来获取 JSON 数据的例子。 假设你用这个 NSString 来构造这个 NSURL : 1NSString *londonWeatherUrl = @&quot;http://api.openweathermap.org/data/2.5/weather?q=London,uk&quot;; 这里是第一步你使用 NSURLConnection 来调用： 12345678910NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:londonWeatherUrl]];[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; // handle response&#125;]; 现在让我们来使用 NSURLSession 。注意这是使用 NSURLSession 的最简单的方式来快速构造一个请求。在后面的课程你将看到怎样配置 session 和设置其他特征比如像代理。 12345678NSURLSession *session = [NSURLSession sharedSession];[[session dataTaskWithURL:[NSURL URLWithString:londonWeatherUrl] completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123; // handle response &#125;] resume]; 注意你并不需要指定它运行在那个队列中。除了你特别指定，这个调用将会在后台线程。你可能很难注意到这两者之间有什么不同，它就是故意这样的。Apple 提到打算使用 dataTaskWithURL 来取代在 NSURLConnection 中的 sendAsynchronousRequest 。 所有从根本上来讲–对于简单的任务使用 NSURLSession 就和使用 NSURLConnection 一样简单，并且它还有一些列额外的定制功能当你需要它的时候。 NSURLSession vs AFNetworking 不提到 AFNetworking 框架就谈不上谈论网络编程。这个事在 iOS/OS X 上最流行的框架，有杰出的 Mattt Thompson 创建。 注意：想了解更多关于 AFNetworking ,请检出在https://github.com/AFNetworking/AFNetworking的 github 页面。我们也有一个关于它的课程：http://www.raywenderlich.com/30445/afnetworking-crash-course 下面是的使用 AFNetworking 1.x 版本处理相同的数据任务的代码： 1234567891011NSURLRequest *request = [NSURLRequest requestWithURL: [NSURL URLWithString:londonWeatherUrl]];AFJSONRequestOperation *operation =[AFJSONRequestOperation JSONRequestOperationWithRequest:request success:^(NSURLRequest *request, NSHTTPURLResponse *response, id JSON) &#123; // handle response&#125; failure:nil];[operation start]; 使用 AFNetworking 的一个好处是处理响应的数据的数据根据类型被归类。使用 AFJSONRequestOperation (或者诸如 XML 和 plist 相似的类),成功 block 已经被解析根据响应并且为你返回你想要的数据。使用 NSURLSession 你将收到一个 NSData 对象在 completion handler ,所有你只需要把 NSData 转换成 JOSN 或者其他形式。 注意：你能够很方便的把数据从 NSData 转换成 JSON 使用在 iOS 5 引入的 NSJSONSerialization 这个类。如果你想了解更多，请查看 23 章的 iOS 5 教程，“Working with JSON”。 你或许想知道你是应该使用 AFNetworking 还是仅仅是继续使用 NSURLSession 。 就个人而言，我认为对于简单的需求最好还是继续使用 NSURLSession –这样可以避免不必要的引入一个第三方库在你的工程中。另外，使用新的代理，配置，和基于很多添加到 AFNetworking 中的的“遗失特征”现在都被包括了的 API 的任务。 然而，假如你想使用一些在 AFNetworking 中 2.0 版本的新特性，诸如序列化和将来对 UIKit 的整合（添加到 UIIImageView 分类中），然后这样很难争辩不使用它！ 注意：在 AFNetworking 2.0 分支中，它们已经转换到使用 NSURLSession 。更多信息看这篇帖子：https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-2.0-Migration-Guide 介绍 Byte Club在这篇 NSURLSession 教程中，你将探索这个新的 API 通过构建一篇日记好图片分享 app 基于 Dropbox Core API ,因为是顶级机密组织因此姑且命名它 Byte Club 。 考虑到这个课程是你接受到 Byte Club 的官方邀请！什么是你可能会问到的关于 Byte Club 的第一条规则？没人谈论 Byte Club –除了那些足够炫酷的人将会阅读这个教程。并且那些 Android 用户完全不知道；他们被他们俩的生活劫持了。 ：] 开始构建 app 迎战下一个章节，将充当被 Byte Club 组织邀请。 主要到这个教程是假设你对基本的网络有基本的了解在先前的版本 iOS。它非常有用假如你已经使用过诸如 NSURLConnection 或者 NSURLSession 在过去。假如在 iOS 方面你是网络方面的新手，在继续这个课程之前你应该查询我们的 iOS 学徒系列作为最初的开发者。 现在开始吧 Byte Club 是iOS 开发者专有的组织，一起来加入挑战你的编程吧。由于每个成员都是远程工作，在这个挑战中有一个是跨越世界，成员通过分享他们“战场”的全景照片也能找到它的乐趣。 例如，下面是 Ray 的办公场所的全景照片： 注意：你可能想创建你自己办公室的全景照片–它很有趣，在这个课程的后续中我们将会处理。 在 iOS 7 中，你可以通过打开相机选择一个叫 Pano （全景）的标签照一张全景照片。 加入你喜欢那张，把它设置成你锁屏界面的墙纸通过打开 设置 让后选择 墙纸 \\选择墙纸 \\我的全景照片。 当然- Byte Club 有它自己的 app，我们来见证奇迹。你可以和其他成员使用 app 来完成编程挑战或者分享全景照片。在幕后，这是通过网络实现-明确的说，就是通过 Dropbox API 来分享文件。 开始的工程概述首先，下载教程开始的工程。 开始的工程包含了为你预先准备好的 UI，所以你只需把精力集中在这个教程中 app 的网络部分。开始的工程也包含一些处理 Dropbox 授权的代码,在后面你将学到更多。 在 Xcode 中打开工程让后在你设备或者模拟器上运行，你应该看到像下面这样： 然而你还并不能登录它-你不得不先配置 app，你将做一点。 下一步打开 Main.storyboard 纵览一下整个 app 的设计： 这是一个最基本的使用 2 个标签的的 TabBarController app：一个是为了挑战编程，另一个是为了放全景照片。这里也有预先让用户登录到 app 中的一步。你将要配置登录在你创建完 Dropbox 平台下的 App 后。 感到很轻松浏览一下 App 剩余的部分并且找到到目前为止相似的地方。你将会注意到除了授权组件，这里没有检索挑战编程或者全景照片的网络代码-那就是你的工作！ 创建一个新的 Dropbox 平台 App为了开始你的新的 Dropbox App,打开 Dropbox App 位于https://www.dropbox.com/developers/apps的控制台 用你的 Dropbox 账号登录，假如没有，没问题：马上创建一个免费的 Dropbox 账号。假如这是你第一次使用 Dropbox 的 API，你需要通知 Dropbox 的条款和条件。 经过这个法定的材料以后就是上路了，选择创建 App 选项。将呈现给你一系列问题-提供下面的答案 What type of app do you want to create? Choose: Dropbox API app What type of data does your app need to store on Dropbox? Choose: Files and Datastore Can your app be limited to its own, private folder? Choose: No – My App needs access to files already on Dropbox What type of files does your app need access to? Choose: All File Types 最终，为你的 App 准备一个名字，选择什么并没有关系只有它是唯一的。假如你选择了一个别人已经在使用的名字 Dropbox 将会告诉你。你的屏幕应该看起来像下面这样： 点击 Create App ，你将开始上路了！ 下一个屏幕你将看到显示到屏幕中的包含 App key 和 App secret : 先不要关闭这个屏幕，你将需要需要下一步的 App Key 和 App Secret 。 打开 Dropbox.m 文件找到下面这些行： 123#warning INSERT YOUR OWN API KEY and SECRET HEREstatic NSString *apiKey = @&quot;YOUR_KEY&quot;;static NSString *appSecret = @&quot;YOUR_SECRET&quot;; 填写你的 app key 和 secret，让后删除 #warning line，现在你可以关闭 Dropbox Web App 页面。 下面，创建一个文件夹在你 Dropbox 主文件下的根目录给它命一个你想要的名字。假如你把这个文件夹个和其他的 Dropbox 用户分享，发送他们在构建 Byte Club App 的时候，他们将能够创建笔记并且能够上传所有人都能看得见的照片。 在 Dropbox.m 中找打下面这些行： 12#warning THIS FOLDER MUST BE CREATED AT THE TOP LEVEL OF YOUR DROPBOX FOLDER, you can then share this folder with othersNSString * const appFolder = @&quot;byteclub&quot;; 改变字符串的值，设置成你创建的 Dropbox 文件夹的名字，让后删除 #warning pragma. 为了把这个 app 分发给其他用户，给他们接入 access tokens ,你将需要为你的 Dropbox 平台 App 打开 Enable additional users 设置。 去在https://www.dropbox.com/developers/appsDropbox app 的控制台。点击你 app 名称。然后点击 Enable Additional Users 按钮。将出现一个状态对话框表明你已经增加了你的用户限制。点击 Okay 关闭对话框。你的 App 页面将像下面这样显示： 注意：你可能注意到当你正在开发你的 app 的时候，你可以接入多达 100 个用户。当你准备发布 app 销售的时候，你必须申请生产状态，你可以通过点击 Apply for production 按钮来发送给 Dropbox 一些额外的信息。 Dropbox 将随后审核你的 App 来确保它遵守指南，假如所有的一切进行得顺利的话，你将打开你的 app 的 API 接入无线的用户。 Dropbox 授权: 概览假如你曾经使用过第三方 twitter 客服端 app，像 TweetBot ,你将会熟悉 OAuth 授权处理步骤从一个用户的角度。 OAuth 授权接入过程对你 app 来说是完全一样的。 构建运行你的 app，按照步骤登录。你将看到一个有 2 个标签的空白屏幕，一个是 Notes，一个是 PanoPhotos，如下图显示： OAuth 授权发生在3和高级的步骤： 获取用来处理剩下的授权一个 OAuth 请求 token。这是请求 token。 一个 web 页面被呈现到用户面前通过他们的 web 浏览器。没有这一步的用户授权，对你的应用想获取一个第三步中的接入 token 几乎不可能。 在第二步完成后，应用调用 web 服务来交换临时请求 token（从第一步中的）为了一个将存储在 app 里面的持久接入 token。 注意：为了保证这个教程的简洁，我们不打算进行更详细的讲解关于这里 Dropbox 授权工作。然而，假如你想了解更多点击整个教程的完全版本，它是iOS 7 by Tutorials.的一部分。 NSURLSession 的一系列类Apple 已经把 NSURLSession 描述成一个新类和一系列旧类的组合。这些新的工具是为了处理 上传，下载，处理授权已经处理在 HTTP 协议里面的任何事情。 一个 NSURLSession 用一个带可选代理的 NSURLSessionConfiguration 构造。在你创建会话以后，你应该能够满足你的网络需要通过创建 NSURLSessionTask 的任务。 NSURLSessionConfiguration这里有三种方式创建 NSURLSessionConfiguration : defaultSessionConfiguration - 创建一个使用全局缓存，cookie 的配置对象和凭证存储的对象。这个配置会使你的会话最像 NSURLConnection 。 ephemeralSessionConfiguration - 这个配置是用来作为‘私有的’会话并且不会持久化存储缓存，cookie，或者信用存储对象。 backgroundSessionConfiguration - 当你想要从远程推送或者当 app 被暂时挂起时进行网络业务使用这个这个配置。参考 17 章和 18 章在 iOS 7 by Tutorials, Beginning and Intermediate Multitasking ,有更详细的讲解。 一旦你创建一个 NSURLSessionConfiguration 对象，你就可以在它上面设置各种接口像这样： 1234567891011121314NSURLSessionConfiguration *sessionConfig =[NSURLSessionConfiguration defaultSessionConfiguration];// 1sessionConfig.allowsCellularAccess = NO;// 2[sessionConfig setHTTPAdditionalHeaders: @&#123;@&quot;Accept&quot;: @&quot;application/json&quot;&#125;];// 3sessionConfig.timeoutIntervalForRequest = 30.0;sessionConfig.timeoutIntervalForResource = 60.0;sessionConfig.HTTPMaximumConnectionsPerHost = 1; 你限制了网络操作只有 wifi 才能进行。 这将设置所有的请求只接受 JSON 类型的响应。 这些接口将配置资源或者请求超时时间。你也可以限制你的 app 对你的主机只能有一个网络连接。 这些仅仅是你能配置的一些东西，确保检查所有列表的文档。 NSURLSession NSURLSession 被设计成替代 NSURLConnection 的API。Sessions做了他们的工作通过他们的部下，也就是非常出名的 NSURLSessionTask 对象。使用 NSURLSession 你能够创建任务使用基于block的便利方法，设置一个代理，或者同时两者。例如，假如你想要下载一张图片（ *challenge hint *）,你就需要创建一个 NSURLSessionDownloadTask 。 第一步，你需要创建(会话)session。 这里有一个例子： 12345678910111213// 1NSString *imageUrl =@&quot;http://www.raywenderlich.com/images/store/iOS7_PDFonly_280@2x_authorTBA.png&quot;;// 2NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];// 3NSURLSession *session = [NSURLSession sessionWithConfiguration:sessionConfig delegate:self delegateQueue:nil]; Ok,这个仅仅是你目前所看到的一点点不同。让我们一步步重温。 用这个代码片段我们将一样进行下载在两个任务中。 你总是以创建 NSURLConfiguration 开始。 这里创建一个会话使用现在的类作为代理。 在你创建会话后，你可以通过创建一个带一个 completion handler 的任务下载这张图片，想下面这样: 1234567891011121314151617181920// 1NSURLSessionDownloadTask *getImageTask =[session downloadTaskWithURL:[NSURL URLWithString:imageUrl] completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) &#123; // 2 UIImage *downloadedImage = [UIImage imageWithData: [NSData dataWithContentsOfURL:location]]; //3 dispatch_async(dispatch_get_main_queue(), ^&#123; // do stuff with image _imageWithBlock.image = downloadedImage; &#125;);&#125;];// 4[getImageTask resume]; Ah ha!现在这个看起来有点像网络代码！ 任务总是被 sessions 创建。任务一旦被基于 block 的方法创建。记住你仍然可以使用 NSURLSessionDownloadDelegate 来跟踪下载进度。所以你将获得最好的两个单词！（ *hint for challenge *） -URLSession:downloadTask :didWriteData:totalBytesWritten :totalBytesExpectedToWrite: 这里你使用在 completion handler 提供的本地变量来获取一个指向图片的指针。 最终你能够，例如，更新 UIIImageView 的图片来显示新的文件。(hint hint ☺) 你总得自己启动任务！ 记住我在前面所说的，一个会话也可以创建将要发送消息给代理方法来通知你完成等的任务。 应该长成这样，使用相同的会话从上面： 12345// 1NSURLSessionDownloadTask *getImageTask = [session downloadTaskWithURL:[NSURL URLWithString:imageUrl]];[getImageTask resume]; 这当然是确定使用更少的代码☺ 然而，假如你只这样做，你将什么都看不到。你需要让你的代理实现一些 NSURLSessionDownloadDelegate 协议的方法。 首先我们需要获得通知当下载完成时： 123456-(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; // use code above from completion handler&#125; 再有你需要提供将要下载的文件存放的位置，然后你就可以使用这个来处理图片。 最后，假如你需要跟踪下载进度，对于任务创建方法，你需要像下面这样用： 123456789-(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWrittentotalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; NSLog(@&quot;%f / %f&quot;, (double)totalBytesWritten, (double)totalBytesExpectedToWrite);&#125; 正如你所见， NSURLSessionTask 是一匹通过网络来干活的真实的驮马。 NSURLSessionTask目前为止你已经知道 NSURLSessionDataTask 和 NSURLSessionDownloadTask 怎样使用了。这两个的任务是来自他们共同的基类 NSURLSessionTask ，你可以在这类看到： NSURLSessionTask 在你的会话中是任务的基类；他们只能通过一个会话创建并且它们是下面子类中的一个。 NSURLSessionDataTask这个任务发起 HTTP GET 请求来从服服务器拉取数据。数据被返回以 NSData 的形式返回。你应该在随后将其把这个数据转换成正确的数据类型比如 XML , JSON ,UIImage，plist 等等。 123456NSURLSessionDataTask *jsonData = [session dataTaskWithURL:yourNSURL completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123; // handle NSData&#125;]; NSURLSessionUploadTask使用这个类当你需要上传一些东西到 web 服务器时，使用 HTTP POST 或者 PUT 命令。任务带来也允许你监视网络状况当它正在传输的时候。 上传一张图片： 12345NSData *imageData = UIImageJPEGRepresentation(image, 0.6);NSURLSessionUploadTask *uploadTask = [upLoadSession uploadTaskWithRequest:request fromData:imageData]; 在这类任务被创建从一个会话中并且图片以 NSData 的形式上传。这里也可以通使用一个文件或者流的方法来进行上传。 NSURLSessionDownloadTask NSURLSessionDownloadTask 让通过远程服务下载文件变得超级简单，并且可以暂停和恢复下载只要你想。这个子类有别于其他两个。 这个类型的任务直接写入一个临时文件。 在下载会话中将调用 URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite: 来更新状态信息。 当任务完成时， URLSession:downloadTask:didFinishDownloadingToURL: 被调用。这就是你该保存文件从临时位置到一个永久位置的时候。 当下载失败或者取消时，你可以让数据重新开始下载。 这个特性将极其有用当你在下载一个 Byte Club 定位 全景照片给你的设备的相机胶卷。你看到的一个下载任务例子在上面下载图片片段中。 上述全部所有的上述任务被创建在一个暂停的状态；在创建一个任务时你需要调用它的继续方法像下面演示的那样： 1[uploadTask resume]; 当你一次不只管理一个任务时， taskIdentifier 接口允许你唯一标示一个在会话中的任务 这就是！既然你已经知道了 NSURLSession 系列的主要类，让我们尝试一下。 Sharing notes with NSURLSessionOK，这不是死亡诗社，这是 Byte Club !是时候开始看看一下这个的网络代码在起作用了。 你需要一个方法来给 Byte Club 的其他成员发送消息。既然你已经设置了接入 token，下一步就是实例化 NSURLSesssion 对象，让后调用你的第一个 Dropbox API。 Creating an NSURLSession添加下面的接口到 NotesViewController.m 文件，就在 NSArray *notes 行的后面： 1@property (nonatomic, strong) NSURLSession *session; 你将创造所有你的下属从上面的 session 中。 添加下面的方法到 NotesViewController.m 就在 initWithStyle 方法的上面： 123456789101112131415- (id)initWithCoder:(NSCoder *)aDecoder&#123; self = [super initWithCoder:aDecoder]; if (self) &#123; // 1 NSURLSessionConfiguration *config = [NSURLSessionConfiguration ephemeralSessionConfiguration]; // 2 [config setHTTPAdditionalHeaders:@&#123;@&quot;Authorization&quot;: [Dropbox apiAuthorizationHeader]&#125;]; // 3 _session = [NSURLSession sessionWithConfiguration:config]; &#125; return self;&#125; 下面是上面代码注释的注释的解释： 你的 app 调用 initWithCoder 当你实例化一个控制器从一个故事版中;因此这是一个完美的时刻初始化和创建 NSURLSession 。你并不想积极缓存或者持久化这里，所有你使用 ephemeralSessionConfiguration 便利方法，它返回一个没有持久化缓存，cookies，或者认证存储的会话。这是一个”私有浏览”配置。 下一步，你添加授权 HTTP 头道配置对象中。apiAuthorizationHeader 是一个我写的辅助方法，返回一个字符串，以授权制定的格式。这个字符串包含 access token，token secret 和你的 Dropbox App API 秘钥。记住这是必要的因为每个对 Dropbox API 的调用都需要被授权。 最后，你使用上面的配置创建了 NSURLSession 。 会话现在准备好创建在你 app 中你所需要的任何网络任务。 GET Notes through the Dropbox API为了模拟一条笔记被另一个用户添加，添加任何你在设置在你的 Dropbox 根目录下的文件夹中选择的文本文件。例如位于 Dropbox 文件夹下 byteclub 下面显示的 test.txt： 等待直到 Dropbox 确认它已经同步完你的文件，让后继续下面代码。 添加下面的代码到空的 notesOnDropBox 方法中在 NotesViewController.m : 1234567891011121314151617[UIApplication sharedApplication].networkActivityIndicatorVisible = YES;// 1NSURL *url = [Dropbox appRootURL];// 2NSURLSessionDataTask *dataTask =[self.session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123; if (!error) &#123; // TODO 1: More coming here! &#125; &#125;];// 3 [dataTask resume]; 这个方法的目标是检索在 app 的 Dropbox 文件下的文件列表。让我们来重温一下这是怎样工作的一步步。 在 Dropbox 中，你能看到一个文件夹的内容通过进行一个已经授权的 GET 请求到某个特别的 URL - 像 https://api.dropbox.com/1/metadata/dropbox/byteclub. 我已经创建了一个便利的方法在 Dropbox 类中来为你产生这个 URL。 NSURLSession 用便利构造方法来简单的创建各种类型的任务。这是你创建的一个数据任务为了执行一个 GET 请求到那个 URL。当请求完成时，你的 completionHandler block 被调用。一会儿你将添加一下代码到这里。 记住一个任务默认是一个 暂停 的状态,因此你需要调用恢复方法来启动运行。 那就是所有你需要做的来开始一个 GET 请求-现在让我们添加代码到解析的结果中。添加下面的这些行到”TUDO 1”注释的后面: 123456789101112131415161718// 1NSHTTPURLResponse *httpResp = (NSHTTPURLResponse *) response;if (httpResp.statusCode == 200) &#123; NSError *jsonError; // 2 NSDictionary *notesJSON = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:&amp;jsonError]; NSMutableArray *notesFound = [[NSMutableArray alloc] init]; if (!jsonError) &#123; // TODO 2: More coming here! &#125;&#125; 下面是两个主要的部分: 你知道你已经发送一个 HTTP 请求，所以响应将是一个 HTTPP 响应。因此这里你可以抛出 NSURLResponse 到一个 NSHTTPURLRequest 响应以便你能够接入到接口的状态码。假如你收到了一个 HTTP 状态码 200，然后一切正常。 HTTP 错误码举例： 400 - 输入参数错误。错误消息将表明那个和为什么错误。 401 - token 错误或者失效。这个可能发生假如用户或者 Dropbox 被撤销或者接入 token 过期。你可以通过重新授权修复这个用户。 403 - 错误的授权请求（错误的用户键，坏的随机数，时间戳过期…）。不信的是，重新授权用户在这里并没有用。 404 - 指定路径下的文件或者文件夹没找到。 405 - 未知的请求方法（通常应该是 GET 或者 POST）。 429 - 你的 app 发送太多请求超出了限制的速率，429 能够触发在每个 app 或者每个用户根部。 503 - 假如响应包括重发后的头，这就意味做你的 OAuth 1.0 app 正在被限速。否则，这个表明了一个短暂的服务器错误，并且你的 app 应该重新发送这这个请求。 507 - 用户超出 Dropbox 储存配额。 5xx - 服务器错误。 Dropbox API 返回 JSON 类型的数据。所有你收到一个 200 的响应，然后应该把数据转发成 JSON 使用 iOS 的构建 JSON 序列化的方法。了解更多关于 JSON 和 NSJSONSerialization，查看第 23 章在 iOS 5 by Tutorials ,”Working with JSON.” JSON 数据返回从 Dropbox 将看起来像下面这样： 123456789101112131415161718192021222324252627&#123; &quot;hash&quot;: &quot;6a29b68d106bda4473ffdaf2e94c4b61&quot;, &quot;revision&quot;: 73052, &quot;rev&quot;: &quot;11d5c00e1cf6c&quot;, &quot;thumb_exists&quot;: false, &quot;bytes&quot;: 0, &quot;modified&quot;: &quot;Sat, 10 Aug 2013 21:56:50 +0000&quot;, &quot;path&quot;: &quot;/byteclub&quot;, &quot;is_dir&quot;: true, &quot;icon&quot;: &quot;folder&quot;, &quot;root&quot;: &quot;dropbox&quot;, &quot;contents&quot;: [&#123; &quot;revision&quot;: 73054, &quot;rev&quot;: &quot;11d5e00e1cf6c&quot;, &quot;thumb_exists&quot;: false, &quot;bytes&quot;: 16, &quot;modified&quot;: &quot;Sat, 10 Aug 2013 23:21:03 +0000&quot;, &quot;client_mtime&quot;: &quot;Sat, 10 Aug 2013 23:21:02 +0000&quot;, &quot;path&quot;: &quot;/byteclub/test.txt&quot;, &quot;is_dir&quot;: false, &quot;icon&quot;: &quot;page_white_text&quot;, &quot;root&quot;: &quot;dropbox&quot;, &quot;mime_type&quot;: &quot;text/plain&quot;, &quot;size&quot;: &quot;16 bytes&quot; &#125;], &quot;size&quot;: &quot;0 bytes&quot;&#125; 所有最后一段添加的代码是拉取的部分你感兴趣的从 JSON 中。特别的，你想循环遍历“contents”数组来把“is_dir”设置成 false 。 这样做，添加下面的代码到“TODO 2”注释后面： 12345678910111213141516171819202122// 1NSArray *contentsOfRootDirectory = notesJSON[@&quot;contents&quot;];for (NSDictionary *data in contentsOfRootDirectory) &#123; if (![data[@&quot;is_dir&quot;] boolValue]) &#123; DBFile *note = [[DBFile alloc] initWithJSONData:data]; [notesFound addObject:note]; &#125;&#125;[notesFound sortUsingComparator: ^NSComparisonResult(id obj1, id obj2) &#123; return [obj1 compare:obj2]; &#125;];self.notes = notesFound;// 6dispatch_async(dispatch_get_main_queue(), ^&#123; [UIApplication sharedApplication].networkActivityIndicatorVisible = NO; [self.tableView reloadData];&#125;); 这里有两部分： 你拉取数组对象从“contents”键中，让后循环便利数组。每个数组入口是一个文件，所以你创建一个相应的 DBFile 文件模型为每一个文件。 DBFile 是一个我为你创建的辅助类，为了拉取信息从一个JSON字典到一个文件中 - 轻轻一瞥就能看到它是怎样工作的。 当你完成时，你添加所有的笔记到 self.notes 接口中。表视图被设置来显示数组中的任何记录。 既然你的表视图数据源已经更新了，你需要重载表的数据。无论何时你正在处理异步网络请求时，你必须保证更新 UIKit 在主线程。 机敏的读者将会注意到在上述代码中没有错误处理；假如你感觉你像一个哭丧女（大多数 Byte Club 都是！）添加一些代码在这里（在随后的代码块中你将添加），代码在错误和警告用户的时候将重试。 构建运行你的 app；你应该看你添加到你的 Dropbox 文件夹的文件是否显示在列表中，就像下面例子一样显示： 事情本来是小事，当时这证明了你正确的调用了 Dropbox API。 下一步是发布比较然后向其他俱乐部成员发起挑战，再一次使用 Dropbox API 就当你是传送机构。 POST Notes through the Dropbox API轻点右上角的 + 号，你将看到笔记 add&#x2F;edit 屏幕出现，就像下面演示的一样： 开始的 app 已经安装了 DBFile 模型对象到 NoteDetailsViewController 在 prepareForSegue:sender: 方法中： 加入你瞥一眼这个方法，你将看到 NoteViewController 被设置成 NoteDetailsViewController 的代理。这种方法， NoteDetailsViewController 能够通知 NoteViewController 当用户完成编辑一篇笔记或者取消编辑一篇笔记时。 打开 NotesViewController.m ,添加下面这行到 prepareForSegue:sender: 中，就在 showNote.delegate = self 行的后面； 1showNote.session = _session; NoteDetailsViewController 已经有一个 NSURLSession 的接口名字叫做 session ,因此你能够设置它在 prepareForSegue:sender: 载入之前。 现在 detail view controller 将获得相同的 NSURLSession ,所有 detail view controller 能够使用它来进行 DropBox 的 API 调用。 Cancel 和 Done 按钮已经呈现在你的app中；你只需要添加一些在他们背后保存或者取消在尚未完工的笔记逻辑。 在 NoteDetailsViewController.m ,找到下面这一行在 (IBAction)done:(id)sender: 方法中： 12// - UPLOAD FILE TO DROPBOX - // [self.delegate noteDetailsViewControllerDoneWithDetails:self]; …用下面的替换它： 12345678910111213141516171819202122232425262728293031// 1NSURL *url = [Dropbox uploadURLForPath: _note.path];// 2NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url];[request setHTTPMethod:@&quot;PUT&quot;];// 3NSData *noteContents = [_note.contents dataUsingEncoding:NSUTF8StringEncoding];// 4NSURLSessionUploadTask *uploadTask = [_session uploadTaskWithRequest:request fromData:noteContents completionHandler:^(NSData *data, NSURLResponse *response, NSError *error)&#123; NSHTTPURLResponse *httpResp = (NSHTTPURLResponse*) response; if (!error &amp;&amp; httpResp.statusCode == 200) &#123; [self.delegate noteDetailsViewControllerDoneWithDetails:self]; &#125; else &#123; // alert for error saving / updating note &#125;&#125;];// 5[uploadTask resume]; 这个实现了你需要保存和分享你的笔记的所有事情。假如仔细观察每一块的注释，你将发现做了下面的事： 为了上传一个文件到 Dropbox，你需要再次使用某个 API URL。就像先前你需要一个 URL 来列出在一个文件夹中的文件，我已经构造了一个辅助方法来为你产生 URL。你可以在这里调用。 下一步是你的老朋友 NSMutableURLRequest ,新的 APIs 能够同时使用普通的 URL 是和 NSURLRequest 对象，但是这里你需要可变的形式来使 Dropbox API 让它的请求变成 PUT 请求。设置 HTTP 方法作为 PUT 发信号给 Dropbox 来让它为你创建一个新的文件。 下一步是将文本从你的 UITextView 编码成 NSData 对象。 既然你已经创建好了请求和 NSData 数据，你下一步就是创建一个 NSURLSessionUploadTask 然后设置 completion handler block.一旦成功，你就调用代理方法 noteDetailsViewControllerDoneWithDetails: 来关闭呈现的内容。在生产级别的应用中你可以回传一个新的 BDFile 给代理然后同步你需要持久化的数据。为了这个应用，你只需要刷新 NotesViewController 用一个网络调用。 再次提到，所有的任务以暂停的状态被创建，所以你必须调用恢复来启动他们。 构建然后运行你的 App，点击笔记标签上的+号。在 challenge name 字段上输入你的名字，输入一些文本在 note 字段想 Ray 发布一份挑战书，和下面的例子相似： 当你清点 Done 时， NoteViewController 将返回并且给你列出新的笔记像下面显示的那样： 你已经正式的给 Ray 下发挑战书；然而，他有朋友在非常高的位置所有你最好尽力完成这场比赛。 但是这里有一条非常重要的消息遗漏了。你能告诉我是什么么？ 轻点笔记包含的挑战； NoteDetailsViewController 自己呈现，当时笔记的内容确实空白的。 Ray 并不会找到你的发的非常有威胁的挑战假如他没有读的话！ 现在，app 只是调用 Dropbox 元数据 API 来检索文件列表。你也需要添加一些代码来抓取笔记的内容。 打开 NoteDetailsViewController.m ,用下面的实现替换空白的 retreiveNoteText 的实现： 12345678910111213141516171819202122232425262728293031323334353637383940-(void)retreiveNoteText&#123; // 1 NSString *fileApi = @&quot;https://api-content.dropbox.com/1/files/dropbox&quot;; NSString *escapedPath = [ _note.path stringByAddingPercentEscapesUsingEncoding: NSUTF8StringEncoding]; NSString *urlStr = [NSString stringWithFormat: @&quot;%@/%@&quot;, fileApi,escapedPath]; NSURL *url = [NSURL URLWithString: urlStr]; [UIApplication sharedApplication].networkActivityIndicatorVisible = YES; // 2 [[ _session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123; if (!error) &#123; NSHTTPURLResponse *httpResp = (NSHTTPURLResponse*) response; if (httpResp.statusCode == 200) &#123; // 3 NSString *text = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; dispatch_async(dispatch_get_main_queue(), ^&#123; [UIApplication sharedApplication].networkActivityIndicatorVisible = NO; self.textView.text = text; &#125;); &#125; else &#123; // HANDLE BAD RESPONSE // &#125; &#125; else &#123; // ALWAYS HANDLE ERRORS :-] // &#125; // 4 &#125;] resume];&#125; 上面在笔记中的代码（没有错误检查）下面来解释： 设置请求的路径和你期望检索的文件的 URL 地址；&#x2F;文件的端点在 Dropbox API 中将会返回给你一个指定文件的内容。 用指向感兴趣的文件的 URL 创建数据任务。这个调用应该开始，只要你纵览整个 app 你会相当熟悉。 假如你响应的代码表明所有的都是好的，在主线程用你在先前的步骤中检索到的文件内容设置 textView。记住，UI 更新必须切换到主线程。 一旦这个任务被初始化，调用恢复。这里有写不一样的方法和以前的相比，当恢复被直接调用时在任务还没有指派时。 构建运行你的 App，在列表中对你的挑战轻点，内容将直接正确的显示在 view 中，像下面这样： 你可以扮演 Ray 然后通过向笔记中输入文本响应这个挑战；文件将很快更新当你轻点 Done 。 使用 NSURLSessionTask 代理发送照片你已经看到怎样使用 NSURLSession 异步便利构造方法。但是假如你想把注意力集中在文件传输上，例如上传一个大文件并且显示一个进度条怎么样？ 对于这种异步的，耗时任务类型你需要实现 NSURLSessionTaskDelegate 协议方。通过实现这个方法，你能够检索回调当一个任务接收到数据和完成接收数据时。 你可能已经注意到 PanoPhotos 标签是空的当你启动 App 的时候。然而， Byte Club 组织的创办成员已经慷慨的提供了一些他们自己的全景照片，你可以用它来填充你的 app。 下载这些 我们为你放在一起的全景照片。解压文件，拷贝到你的 app 在 Dropbox 目录下的照片目录。你文件夹的内容应该和下面一样： Dropbox 和核心 API 可以提供照片的缩略图；使用一个 UITableView cell 这听起来想一件非常完美的事。 打开 PhotosViewController.m 然后在 “GO GET THUMBNAILS 注释后面添加下面的代码到 tableView:cellForRowAtIndexPath: &#96;&#96;&#96;objc[UIApplication sharedApplication].networkActivityIndicatorVisible &#x3D; YES;NSURLSessionDataTask *dataTask &#x3D; [_session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) { if (!error) { UIImage *image &#x3D; [[UIImage alloc] initWithData:data]; photo.thumbNail &#x3D; image; dispatch_async(dispatch_get_main_queue(), ^{ [UIApplication sharedApplication].networkActivityIndicatorVisible &#x3D; NO; cell.thumbnailImage.image &#x3D; photo.thumbNail; }); } else { &#x2F;&#x2F; HANDLE ERROR &#x2F;&#x2F; }}];[dataTask resume]; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354上面的代码显示了照片的缩略图图在表视图的 cell 中...或者至少它会是，假如 `_photoThumbnails` 现在不是空的话。找到 `refreshPhotos` 用下面的实现替换：```objc- (void)refreshPhotos&#123; [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES]; NSString *photoDir = [NSString stringWithFormat:@&quot;https://api.dropbox.com/1/search/dropbox/%@/photos?query=.jpg&quot;,appFolder]; NSURL *url = [NSURL URLWithString:photoDir]; [[ _session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123; if (!error) &#123; NSHTTPURLResponse *httpResp = (NSHTTPURLResponse*) response; if (httpResp.statusCode == 200) &#123; NSError *jsonError; NSArray *filesJSON = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:&amp;jsonError]; NSMutableArray *dbFiles = [[NSMutableArray alloc] init]; if (!jsonError) &#123; for (NSDictionary *fileMetadata in filesJSON) &#123; DBFile *file = [[DBFile alloc] initWithJSONData:fileMetadata]; [dbFiles addObject:file]; &#125; [dbFiles sortUsingComparator:^NSComparisonResult(id obj1, id obj2) &#123; return [obj1 compare:obj2]; &#125;]; _photoThumbnails = dbFiles; dispatch_async(dispatch_get_main_queue(), ^&#123; [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO]; [self.tableView reloadData]; &#125;); &#125; &#125; else &#123; // HANDLE BAD RESPONSE // &#125; &#125; else &#123; // ALWAYS HANDLE ERRORS :-] // &#125; &#125;] resume];&#125; 这个和你早期载入挑战笔记时写的代码很像。这次，API 调用来查找在 photos 目录的内容，并且只会以.jpg 拓展的文件。 既然 _photoThumbnails 数组已经填充好了，缩略图将出现在表视图中并且异步更新。 构建运行你的 app，然后切换到 PanoPhotos 标签；缩略图将载入并且像下面这样出现： 照片看起来非常的棒–只是请当心 Matthijs 家撕裂代码的猫🐱！ 上传一张全景照片你的 app 能够下载相片，如果它也能上传照片并且显示上传进度的话就非常棒了。 为了跟踪上传的进度， PhotosViewController 必须成为 NSURLSessionDelegate 和 NSURLSessionTaskDelegate 协议的代理，以便你能收到进度回调。 修改在 PhotosViewController.m 中 PhotosViewController 的接口声明，添加 NSURLSessionTaskDelegate ,像下面这样： 1@ interface PhotosViewController ()UITableViewDelegate, UITableViewDataSource, UIImagePickerControllerDelegate, UINavigationControllerDelegate, NSURLSessionTaskDelegate&gt; 下一步，添加下面的私有接口： 12@property (nonatomic, strong) NSURLSessionUploadTask *uploadTask; 上面的指针引用了任务对象；通过哪种方式，你就可以接入到对象的成员中来跟踪上传任务的进度了。 当用户选择一张图片上传时， didFinishPickingMediaWithInfo 调用 uploadImage: 方法来执行文件上传。现在，那个方法空了-这是你的工作让它丰满起来。 替换 uploadImage: 用下面的代码： 12345678910111213141516171819202122232425262728- (void)uploadImage:(UIImage*)image&#123; NSData *imageData = UIImageJPEGRepresentation(image, 0.6); // 1 NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration]; config.HTTPMaximumConnectionsPerHost = 1; [config setHTTPAdditionalHeaders:@&#123;@&quot;Authorization&quot;: [Dropbox apiAuthorizationHeader]&#125;]; // 2 NSURLSession *upLoadSession = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:nil]; // for now just create a random file name, dropbox will handle it if we overwrite a file and create a new name.. NSURL *url = [Dropbox createPhotoUploadURL]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url]; [request setHTTPMethod:@&quot;PUT&quot;]; // 3 self.uploadTask = [upLoadSession uploadTaskWithRequest:request fromData:imageData]; // 4 self.uploadView.hidden = NO; [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES]; // 5 [ _uploadTask resume];&#125; 下面是上面的代码做的事： 起先，你使用设置在 initWithCoder 的会话和相关的便利方法来创建异步任务。这个时候，你使用一个 NSURLSessionConfiguration ,它只允许一个连接连接到远程主机，因为你上传进度处理一次就是一个文件。 上传和下载任务报告信息通过它们的代理返回；你将简短的实现。 这里你设置了 uploadTask 接口使用从 UIImagePicker 获得的 JPEG 图片。 下一步，你显示 UIProgressView 让它隐藏在 PhotosViewController 内部。 开始任务–额，抱歉，是恢复任务。 既然代理已经设置了，你就可以实现 NSURLSessionTaskDelegate 方法来更新进度视图。 添加下面的代码到 PhotosViewController.m 文件末尾： 1234567891011121314#pragma mark - NSURLSessionTaskDelegate methods- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [ _progress setProgress: (double)totalBytesSent / (double)totalBytesExpectedToSend animated:YES]; &#125;);&#125; 上面的代理方法将定期报告信息给调用者关于上传任务的信息。它同时会更新 UIProgressView （ _progress）的进度以便显示 totalBytesSent&#x2F;totalBytesExpectedToSend,这比显示一个完成的百分比跟有意义（也更极客）。 剩下唯一的事就是当上传任务结束时指示一下。添加下面的代码到 PhotosViewController.m 文件末尾： 123456789101112131415161718- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&#123; // 1 dispatch_async(dispatch_get_main_queue(), ^&#123; [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO]; _uploadView.hidden = YES; [ _progress setProgress:0.5]; &#125;); if (!error) &#123; // 2 dispatch_async(dispatch_get_main_queue(), ^&#123; [self refreshPhotos]; &#125;); &#125; else &#123; // Alert for error &#125;&#125; 这里没有很多代码，但是它执行了两项非常重要的任务： 打开网络指示器，然后隐藏 _uploadView 作为上传完成的一点点清理工作。 刷新 PhotosViewController 以便包含你刚刚上传的照片，由于 demo app 是不能进行任何本地储存的上传。在一个真正的 app 中，你应该把图片在本地进行储存和缓存。 构建运行你的 app，导航到 PanoPhotos 标签，点击照相图标选择一张照片。 注意：假如你说使用模拟器测试 app，很显然你不能用你的 Mac 拍照，所有仅仅是拷贝一张全景照片给模拟器然后上传。这样做，可以确保没有其他的 Xcode 工程现在连接到这个模拟器，在 Xcode 中选择 Xcode Open Developer Tool iOS Simulator。 从 Finder 中拖拽一张全景照片带模拟器中，在模拟器中图片将会在 Safari 中打开。长按图片然后保存图片到图库中。 在选择一张图片后上传，uploadView 显示在屏幕的中央，并且带有上传进度，乡下面这一样显示： 你可能注意到一张图片上传需要花一些时间由于上传任务设置了 better quality 缩放因子。对于那些 A 类性格的人，你应该提供一个取消函数假如上传花费太长的时间。 取消按钮在 uploadView 已经被封装起来在故事板中，所有你只需实现清楚逻辑来杀死下载操作就行。 用下面的代码替换 PhotosViewController.m 的 cancelUpload: ： 12345- (IBAction)cancelUpload:(id)sender &#123; if ( _uploadTask.state == NSURLSessionTaskStateRunning) &#123; [ _uploadTask cancel]; &#125;&#125; 在这类你会看到，取消一个任务相当简单就是调用一个取消方法。 现在构建运行你的 app，选择一张照片上传然后点击 Cancel 。图片上传将会停止并且 uploadView 将会被隐藏。 就这样– Byte Club 完成了！ 何去何从？这里是完成的工程在这个 NSURLSession 教程中。 假如你做到这一步，恭喜你可以享受到 Byte Club 的时光！不要告诉任何 Android 的小伙伴们！ :]你现在能够处理在你 app 需要的任何网络任务了。 假如你喜欢这个课程，你可能想要查阅我们的新书 iOS 7 by Tutorials,这是这本书的一个简略版本，这本书几乎涵盖了在 iOS 7 中最新和最多的 APIs，这些你应该清楚的知道作为一个开发者。 我几乎忘记了… &#x2F;slap have been slapped around a bit with a large trout. （不要问我为什么 hehe！😄） 假如你有任何问题或者评论关于这个教程或者 NSURLSession ,请加入到下面的论坛讨论！ 参考资料： 从 NSURLConnection 到 NSURLSession NSURLSession Tutorial 译者注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"系统 API","slug":"系统-API","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F-API/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://blog.wangruofeng007.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"NSURLSession","slug":"NSURLSession","permalink":"https://blog.wangruofeng007.com/tags/NSURLSession/"}]},{"title":"iOS 线程安全-锁","slug":"2016-01-14-iosxian-cheng-an-quan-suo","date":"2016-01-13T18:08:36.000Z","updated":"2024-11-03T05:32:35.290Z","comments":true,"path":"2016/01/14/2016-01-14-iosxian-cheng-an-quan-suo/","permalink":"https://blog.wangruofeng007.com/2016/01/14/2016-01-14-iosxian-cheng-an-quan-suo/","excerpt":"","text":"Objective－C使用 @synchronized 类实现锁1234567891011121314151617// 实例类 personPerson *person = [[Person alloc] init];// 线程 Adispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @synchronized(person) &#123; [person personA]; [NSThread sleepForTimeInterval:3]; // 线程休眠 3 秒 &#125;&#125;);// 线程 Bdispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @synchronized(person) &#123; [person personB]; &#125;&#125;); 使用 NSRecursiveLock 类实现锁 递归锁，递归或循环方法时使用此方法实现锁，可避免死锁等问题 123456789101112131415161718192021222324252627282930// 实例类 personPerson *person = [[Person alloc] init];// 创建锁对象NSRecursiveLock *theLock = [[NSRecursiveLock alloc] init];// 创建递归方法static void (^testCode)(int);testCode = ^(int value) &#123; [theLock tryLock]; if (value &gt; 0) &#123; [person personA]; [NSThread sleepForTimeInterval:1]; testCode(value - 1); &#125; [theLock unlock];&#125;;//线程 Adispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; testCode(5);&#125;);//线程 Bdispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [theLock lock]; [person personB]; [theLock unlock];&#125;); 使用 NSConditionLock（条件锁）类实现锁 使用此方法可以指定，只有满足条件的时候才可以解锁 123456789101112131415161718// 实例类 personPerson *person = [[Person alloc] init];// 创建条件锁NSConditionLock *conditionLock = [[NSConditionLock alloc] init];// 线程 Adispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [conditionLock lock]; [person personA]; [NSThread sleepForTimeInterval:5]; [conditionLock unlockWithCondition:10]; &#125;);// 线程 Bdispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [conditionLock lockWhenCondition:10]; [person personB]; [conditionLock unlock]; &#125;); NSDistributedLock（分布式锁） 在 iOS 中不需要用到，也没有这个方法，因此本文不作介绍，这里写出来只是想让大家知道有这个锁存在。如果想要学习 NSDistributedLock 的话，你可以创建 MAC OS 的项目自己演练，方法请自行 Google，谢谢 C 语言使用 pthread_mutex_t 实现锁 注意：必须在头文件导入：#import &lt;pthread.h&gt; 12345678910111213141516171819// 实例类 personPerson *person = [[Person alloc] init];// 创建锁对象__block pthread_mutex_t mutex;pthread_mutex_init(&amp;mutex, NULL);// 线程 Adispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;mutex); [person personA]; [NSThread sleepForTimeInterval:5]; pthread_mutex_unlock(&amp;mutex);&#125;);// 线程 Bdispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;mutex); [person personB]; pthread_mutex_unlock(&amp;mutex);&#125;); 使用 GCD 实现“锁”(信号量） GCD 提供一种信号的机制，使用它我们可以创建“锁” 123456789101112131415161718192021// 实例类 personPerson *person = [[Person alloc] init];// 创建并设置信量dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);// 线程 Adispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [person personA]; [NSThread sleepForTimeInterval:5]; dispatch_semaphore_signal(semaphore);&#125;);// 线程 Bdispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); [person personB]; dispatch_semaphore_signal(semaphore);&#125;); 我在这里解释一下代码。 dispatch_semaphore_wait 方法是把信号量加 1， dispatch_semaphore_signal 是把信号量减 1。 我们把信号量当作是一个计数器，当计数器是一个非负整数时，所有通过它的线程都应该把这个整数减 1。 如果计数器大于 0，那么则允许访问，并把计数器减 1。如果为 0，则访问被禁止，所有通过它的线程都处于等待的状态。 使用 POSIX（条件锁）创建锁）12345678910111213141516171819202122232425262728// 实例类 personPerson *person = [[Person alloc] init];// 创建互斥锁 __block pthread_mutex_t mutex; pthread_mutex_init(&amp;mutex, NULL); // 创建条件锁 __block pthread_cond_t cond; pthread_cond_init(&amp;cond, NULL); // 线程 A dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;mutex); pthread_cond_wait(&amp;cond, &amp;mutex); [person personA]; pthread_mutex_unlock(&amp;mutex); &#125;); // 线程 B dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;mutex); [person personB]; [NSThread sleepForTimeInterval:5]; pthread_cond_signal(&amp;cond); pthread_mutex_unlock(&amp;mutex); &#125;); 效果：程序会首先调用线程 B，在 5 秒后再调用线程 A。因为在线程 A 中创建了等待条件锁，线程 B 有激活锁，只有当线程 B 执行完后会激活线程 A。 pthread_cond_wait 方法为等待条件锁。 pthread_cond_signal 方法为激活一个相同条件的条件锁。 注意:自旋锁 OSSpinLock 已经不再线程安全 参考资料 http://www.liuhaihua.cn/archives/25316.html 不再安全的 OSSpinLock","categories":[{"name":"多线程","slug":"多线程","permalink":"https://blog.wangruofeng007.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"锁","slug":"锁","permalink":"https://blog.wangruofeng007.com/tags/%E9%94%81/"}]},{"title":"SQLite 教程(七)","slug":"2016-01-14-sqlite-jiao-cheng-qi","date":"2016-01-13T17:46:57.000Z","updated":"2024-11-03T05:32:35.295Z","comments":true,"path":"2016/01/14/2016-01-14-sqlite-jiao-cheng-qi/","permalink":"https://blog.wangruofeng007.com/2016/01/14/2016-01-14-sqlite-jiao-cheng-qi/","excerpt":"","text":"SQLite Order BySQLite 的 ORDER BY 子句是用来基于一个或多个列按升序或降序顺序排列数据。 语法 ORDER BY 子句的基本语法如下： SELECT column-list FROM table_name [WHERE condition] [ORDER BY column1, column2, .. columnN] [ASC | DESC]; 您可以在 ORDER BY 子句中使用多个列。确保您使用的排序列在列清单中。 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它会将结果按 SALARY 升序排序： sqlite&gt; SELECT * FROM COMPANY ORDER BY SALARY ASC; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 7 James 24 Houston 10000.0 2 Allen 25 Texas 15000.0 1 Paul 32 California 20000.0 3 Teddy 23 Norway 20000.0 6 Kim 22 South-Hall 45000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 下面是一个实例，它会将结果按 NAME 和 SALARY 升序排序： sqlite&gt; SELECT * FROM COMPANY ORDER BY NAME, SALARY ASC; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000.0 5 David 27 Texas 85000.0 7 James 24 Houston 10000.0 6 Kim 22 South-Hall 45000.0 4 Mark 25 Rich-Mond 65000.0 1 Paul 32 California 20000.0 3 Teddy 23 Norway 20000.0 下面是一个实例，它会将结果按 NAME 降序排序： sqlite&gt; SELECT * FROM COMPANY ORDER BY NAME DESC; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 3 Teddy 23 Norway 20000.0 1 Paul 32 California 20000.0 4 Mark 25 Rich-Mond 65000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 5 David 27 Texas 85000.0 2 Allen 25 Texas 15000.0 SQLite Group BySQLite 的 GROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。 语法 下面给出了 GROUP BY 子句的基本语法。GROUP BY 子句必须放在 WHERE 子句中的条件之后，必须放在 ORDER BY 子句之前。 SELECT column-list FROM table_name WHERE [ conditions ] GROUP BY column1, column2....columnN ORDER BY column1, column2....columnN 您可以在 GROUP BY 子句中使用多个列。确保您使用的分组列在列清单中。 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 如果您想了解每个客户的工资总额，则可使用 GROUP BY 查询，如下所示： sqlite&gt; SELECT NAME, SUM(SALARY) FROM COMPANY GROUP BY NAME; 这将产生以下结果： NAME SUM(SALARY) ---------- ----------- Allen 15000 David 85000 James 20000 Kim 45000 Mark 65000 Paul 40000 Teddy 20000 让我们把 ORDER BY 子句与 GROUP BY 子句一起使用，如下所示： sqlite&gt; SELECT NAME, SUM(SALARY) FROM COMPANY GROUP BY NAME ORDER BY NAME DESC; 这将产生以下结果： NAME SUM(SALARY) ---------- ----------- Teddy 20000 Paul 40000 Mark 65000 Kim 45000 James 20000 David 85000 Allen 15000 SQLite Having 子句HAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。 WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。 语法 下面是 HAVING 子句在 SELECT 查询中的位置： SELECT FROM WHERE GROUP BY HAVING ORDER BY 在一个查询中，HAVING 子句必须放在 GROUP BY 子句之后，必须放在 ORDER BY 子句之前。下面是包含 HAVING 子句的 SELECT 语句的语法： SELECT column1, column2 FROM table1, table2 WHERE [ conditions ] GROUP BY column1, column2 HAVING [ conditions ] ORDER BY column1, column2 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 8 Paul 24 Houston 20000.0 9 James 44 Norway 5000.0 10 James 45 Texas 5000.0 下面是一个实例，它将显示名称计数小于 2 的所有记录： sqlite &gt; SELECT * FROM COMPANY GROUP BY name HAVING count(name) &lt; 2; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000 5 David 27 Texas 85000 6 Kim 22 South-Hall 45000 4 Mark 25 Rich-Mond 65000 3 Teddy 23 Norway 20000 下面是一个实例，它将显示名称计数大于 2 的所有记录,注意其实这里只返回最后一条记录： sqlite &gt; SELECT * FROM COMPANY GROUP BY name HAVING count(name) &gt; 2; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 10 James 45 Texas 5000 SQLite Distinct 关键字SQLite 的 DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。 语法 用于消除重复记录的 DISTINCT 关键字的基本语法如下： SELECT DISTINCT column1, column2,.....columnN FROM table_name WHERE [condition] 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 8 Paul 24 Houston 20000.0 9 James 44 Norway 5000.0 10 James 45 Texas 5000.0 首先，让我们来看看下面的 SELECT 查询，它将返回重复的工资记录： sqlite&gt; SELECT name FROM COMPANY; 这将产生以下结果： NAME ---------- Paul Allen Teddy Mark David Kim James Paul James James 现在，让我们在上述的 SELECT 查询中使用 DISTINCT 关键字： sqlite&gt; SELECT DISTINCT name FROM COMPANY; 这将产生以下结果，没有任何重复的条目： NAME ---------- Paul Allen Teddy Mark David Kim James 资料整理于：RUNOOB.COM-SQLite 教程转载请注明出处。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.wangruofeng007.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQLite","slug":"SQLite","permalink":"https://blog.wangruofeng007.com/tags/SQLite/"}]},{"title":"SQLite 教程(六)","slug":"2016-01-14-sqlite-jiao-cheng-liu","date":"2016-01-13T17:41:01.000Z","updated":"2024-11-03T05:32:35.307Z","comments":true,"path":"2016/01/14/2016-01-14-sqlite-jiao-cheng-liu/","permalink":"https://blog.wangruofeng007.com/2016/01/14/2016-01-14-sqlite-jiao-cheng-liu/","excerpt":"","text":"SQLite Delete 语句SQLite 的 DELETE 查询用于删除表中已有的记录。可以使用带有 WHERE 子句的 DELETE 查询来删除选定行，否则所有的记录都会被删除。 语法 带有 WHERE 子句的 DELETE 查询的基本语法如下： DELETE FROM table_name WHERE [condition]; 您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 现在，COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 如果您想要从 COMPANY 表中删除所有记录，则不需要使用 WHERE 子句，DELETE 查询如下： sqlite&gt; DELETE FROM COMPANY; 现在，COMPANY 表中没有任何的记录，因为所有的记录已经通过 DELETE 语句删除。 SQLite Like 子句SQLite 的 LIKE 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。这里有两个通配符与 LIKE 运算符一起使用： 百分号 （%） 下划线 （_） 百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。 语法 % 和 _ 的基本语法如下： SELECT FROM table_name WHERE column LIKE &#39;XXXX%&#39; or SELECT FROM table_name WHERE column LIKE &#39;%XXXX%&#39; or SELECT FROM table_name WHERE column LIKE &#39;XXXX_&#39; or SELECT FROM table_name WHERE column LIKE &#39;_XXXX&#39; or SELECT FROM table_name WHERE column LIKE &#39;_XXXX_&#39; 您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。在这里，XXXX 可以是任何数字或字符串值。 实例 下面一些实例演示了 带有 ‘%’ 和 ‘_’ 运算符的 LIKE 子句不同的地方： 语句 描述 WHERE SALARY LIKE ‘200%’ 查找以 200 开头的任意值 WHERE SALARY LIKE ‘%200%’ 查找任意位置包含 200 的任意值 WHERE SALARY LIKE ‘_00%‘ 查找第二位和第三位为 00 的任意值 WHERE SALARY LIKE ‘2_%_%’ 查找以 2 开头，且长度至少为 3 个字符的任意值 WHERE SALARY LIKE ‘%2’ 查找以 2 结尾的任意值 WHERE SALARY LIKE ‘_2%3’ 查找第二位为 2，且以 3 结尾的任意值 WHERE SALARY LIKE ‘2___3’ 查找长度为 5 位数，且以 2 开头以 3 结尾的任意值 让我们举一个实际的例子，假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它显示 COMPANY 表中 AGE 以 2 开头的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE LIKE &#39;2%&#39;; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它显示 COMPANY 表中 ADDRESS 文本里包含一个连字符（-）的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE ADDRESS LIKE &#39;%-%&#39;; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 Mark 25 Rich-Mond 65000.0 6 Kim 22 South-Hall 45000.0 SQLite Glob 子句SQLite 的 GLOB 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。与 LIKE 运算符不同的是，GLOB 是大小写敏感的，对于下面的通配符，它遵循 UNIX 的语法。 星号 （*） 问号 （?） 星号（*）代表零个、一个或多个数字或字符。问号（?）代表一个单一的数字或字符。这些符号可以被组合使用。 语法 * 和 ? 的基本语法如下： SELECT FROM table_name WHERE column GLOB &#39;XXXX*&#39; or SELECT FROM table_name WHERE column GLOB &#39;*XXXX*&#39; or SELECT FROM table_name WHERE column GLOB &#39;XXXX?&#39; or SELECT FROM table_name WHERE column GLOB &#39;?XXXX&#39; or SELECT FROM table_name WHERE column GLOB &#39;?XXXX?&#39; or SELECT FROM table_name WHERE column GLOB &#39;????&#39; 您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。在这里，XXXX 可以是任何数字或字符串值。 实例 下面一些实例演示了 带有 ‘*’ 和 ‘?’ 运算符的 GLOB 子句不同的地方： 语句 描述 WHERE SALARY GLOB ‘200*‘ 查找以 200 开头的任意值 WHERE SALARY GLOB ‘*200*‘ 查找任意位置包含 200 的任意值 WHERE SALARY GLOB ‘?00*‘ 查找第二位和第三位为 00 的任意值 WHERE SALARY GLOB ‘2??’ 查找以 2 开头，且长度至少为 3 个字符的任意值 WHERE SALARY GLOB ‘*2’ 查找以 2 结尾的任意值 WHERE SALARY GLOB ‘?2*3’ 查找第二位为 2，且以 3 结尾的任意值 WHERE SALARY GLOB ‘2???3’ 查找长度为 5 位数，且以 2 开头以 3 结尾的任意值 让我们举一个实际的例子，假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它显示 COMPANY 表中 AGE 以 2 开头的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE GLOB &#39;2*&#39;; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它显示 COMPANY 表中 ADDRESS 文本里包含一个连字符（-）的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE ADDRESS GLOB &#39;*-*&#39;; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 Mark 25 Rich-Mond 65000.0 6 Kim 22 South-Hall 45000.0 SQLite Limit 子句SQLite 的 LIMIT 子句用于限制由 SELECT 语句返回的数据数量。 语法 带有 LIMIT 子句的 SELECT 语句的基本语法如下： SELECT column1, column2, columnN FROM table_name LIMIT [no of rows] 下面是 LIMIT 子句与 OFFSET 子句一起使用时的语法： SELECT column1, column2, columnN FROM table_name LIMIT [no of rows] OFFSET [row num] SQLite 引擎将返回从下一行开始直到给定的 OFFSET 为止的所有行，如下面的最后一个实例所示。 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它限制了您想要从表中提取的行数： sqlite&gt; SELECT * FROM COMPANY LIMIT 6; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 但是，在某些情况下，可能需要从一个特定的偏移开始提取记录( OFFSET下标从0开始 )。下面是一个实例，从第三位开始提取 3 个记录： sqlite&gt; SELECT * FROM COMPANY LIMIT 3 OFFSET 2; 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 资料整理于：RUNOOB.COM-SQLite 教程转载请注明出处。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.wangruofeng007.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQLite","slug":"SQLite","permalink":"https://blog.wangruofeng007.com/tags/SQLite/"}]},{"title":"SQLite 教程(五)","slug":"2016-01-14-sqlite-jiao-cheng-wu","date":"2016-01-13T17:35:50.000Z","updated":"2024-11-03T05:32:35.296Z","comments":true,"path":"2016/01/14/2016-01-14-sqlite-jiao-cheng-wu/","permalink":"https://blog.wangruofeng007.com/2016/01/14/2016-01-14-sqlite-jiao-cheng-wu/","excerpt":"","text":"SQL 表达式表达式是一个或多个值、运算符和计算值的 SQL 函数的组合。 SQL 表达式与公式类似，都写在查询语言中。您还可以使用特定的数据集来查询数据库。 语法 假设 SELECT 语句的基本语法如下： SELECT column1, column2, columnN FROM table_name WHERE [CONTION | EXPRESSION]; 有不同类型的 SQLite 表达式，具体讲解如下： SQLite - 布尔表达式SQLite 的布尔表达式在匹配单个值的基础上获取数据。语法如下： SELECT column1, column2, columnN FROM table_name WHERE SINGLE VALUE MATCHTING EXPRESSION; 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的实例演示了 SQLite 布尔表达式的用法： sqlite&gt; SELECT * FROM COMPANY WHERE SALARY = 10000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 James 24 Houston 10000.0 SQLite - 数值表达式这些表达式用来执行查询中的任何数学运算。语法如下： SELECT numerical_expression as OPERATION_NAME [FROM table_name WHERE CONDITION] ; 在这里，numerical_expression 用于数学表达式或任何公式。下面的实例演示了 SQLite 数值表达式的用法： sqlite&gt; SELECT (15 + 6) AS ADDITION ADDITION = 21 有几个内置的函数，比如 avg()、sum()、count()，等等，执行被称为对一个表或一个特定的表列的汇总数据计算。 sqlite&gt; SELECT COUNT(*) AS &quot;RECORDS&quot; FROM COMPANY; RECORDS = 7 SQLite - 日期表达式日期表达式返回当前系统日期和时间值，这些表达式将被用于各种数据操作。 sqlite&gt; SELECT CURRENT_TIMESTAMP; CURRENT_TIMESTAMP = 2016-01-13 16:29:56 SQLite Where 子句SQLite 的 WHERE 子句用于指定从一个表或多个表中获取数据的条件。 如果满足给定的条件，即为真（true）时，则从表中返回特定的值。您可以使用 WHERE 子句来过滤记录，只获取需要的记录。 WHERE 子句不仅可用在 SELECT 语句中，它也可用在 UPDATE、DELETE 语句中，等等，这些我们将在随后的章节中学习到。 语法 SQLite 的带有 WHERE 子句的 SELECT 语句的基本语法如下： SELECT column1, column2, columnN FROM table_name WHERE [condition] 实例 您还可以使用比较或逻辑运算符指定条件，比如 &gt;、&lt;、&#x3D;、LIKE、NOT，等等。假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的实例演示了 SQLite 逻辑运算符的用法。下面的 SELECT 语句列出了 AGE 大于等于 25 且工资大于等于 65000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 下面的 SELECT 语句列出了 AGE 大于等于 25 或工资大于等于 65000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;&#x3D; 25 OR SALARY &gt;&#x3D; 65000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 下面的 SELECT 语句列出了 AGE 不为 NULL 的所有记录，结果显示所有的记录，意味着没有一个记录的 AGE 等于 NULL： sqlite&gt; SELECT * FROM COMPANY WHERE AGE IS NOT NULL; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的 SELECT 语句列出了 NAME 以 ‘Ki’ 开始的所有记录，’Ki’ 之后的字符不做限制（不区分大小写）： sqlite&gt; SELECT * FROM COMPANY WHERE NAME LIKE &#39;Ki%&#39;; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 6 Kim 22 South-Hall 45000.0 下面的 SELECT 语句列出了 NAME 以 ‘Ki’ 开始的所有记录，’Ki’ 之后的字符不做限制（区分大小写）： sqlite&gt; SELECT * FROM COMPANY WHERE NAME GLOB &#39;Ki*&#39;; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 6 Kim 22 South-Hall 45000.0 下面的 SELECT 语句列出了 AGE 的值为 25 或 27 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE IN ( 25, 27 ); ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 SQLite AND&#x2F;OR 运算符SQLite 的 AND 和 OR 运算符用于编译多个条件来缩小在 SQLite 语句中所选的数据。这两个运算符被称为连接运算符。 这些运算符为同一个 SQLite 语句中不同的运算符之间的多个比较提供了可能。 AND 运算符AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。使用 AND 运算符时，只有当所有条件都为真（true）时，整个条件为真（true）。例如，只有当 condition1 和 condition2 都为真（true）时，[condition1] AND [condition2] 为真（true）。 语法 带有 WHERE 子句的 AND 运算符的基本语法如下： SELECT column1, column2, columnN FROM table_name WHERE [condition1] AND [condition2]...AND [conditionN]; 您可以使用 AND 运算符来结合 N 个数量的条件。SQLite 语句需要执行的动作是，无论是事务或查询，所有由 AND 分隔的条件都必须为真（TRUE）。 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的 SELECT 语句列出了 AGE 大于等于 25 且工资大于等于 65000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 OR 运算符OR 运算符也用于结合一个 SQL 语句的 WHERE 子句中的多个条件。使用 OR 运算符时，只要当条件中任何一个为真（true）时，整个条件为真（true）。例如，只要当 condition1 或 condition2 有一个为真（true）时，[condition1] OR [condition2] 为真（true） 语法 带有 WHERE 子句的 OR 运算符的基本语法如下： SELECT column1, column2, columnN FROM table_name WHERE [condition1] OR [condition2]...OR [conditionN] 您可以使用 OR 运算符来结合 N 个数量的条件。SQLite 语句需要执行的动作是，无论是事务或查询，只要任何一个由 OR 分隔的条件为真（TRUE）即可。 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的 SELECT 语句列出了 AGE 大于等于 25 或工资大于等于 65000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;= 25 OR SALARY &gt;= 65000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 SQLite Update 语句SQLite 的 **UPDATE **查询用于修改表中已有的记录。可以使用带有 WHERE 子句的 UPDATE 查询来更新选定行，否则所有的行都会被更新。 语法 带有 WHERE 子句的 UPDATE 查询的基本语法如下： UPDATE table_name SET column1 = value1, column2 = value2...., columnN = valueN WHERE [condition]; 您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它会更新 ID 为 6 的客户地址： sqlite&gt; UPDATE COMPANY SET ADDRESS = &#39;Texas&#39; WHERE ID = 6; 现在，COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 Texas 45000.0 7 James 24 Houston 10000.0 如果您想修改 COMPANY 表中 ADDRESS 和 SALARY 列的所有值，则不需要使用 WHERE 子句，UPDATE 查询如下： sqlite&gt; UPDATE COMPANY SET ADDRESS = &#39;Texas&#39;, SALARY = 20000.00; 现在，COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 Texas 20000.0 2 Allen 25 Texas 20000.0 3 Teddy 23 Texas 20000.0 4 Mark 25 Texas 20000.0 5 David 27 Texas 20000.0 6 Kim 22 Texas 20000.0 7 James 24 Texas 20000.0 资料整理于：RUNOOB.COM-SQLite 教程转载请注明出处。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.wangruofeng007.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQLite","slug":"SQLite","permalink":"https://blog.wangruofeng007.com/tags/SQLite/"}]},{"title":"SQLite 教程(四)","slug":"2016-01-13-sqlite-jiao-cheng-si","date":"2016-01-13T15:37:18.000Z","updated":"2024-11-03T05:32:35.287Z","comments":true,"path":"2016/01/13/2016-01-13-sqlite-jiao-cheng-si/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-sqlite-jiao-cheng-si/","excerpt":"","text":"SQLite 运算符SQLite 运算符是什么？ 运算符是一个保留字或字符，主要用于 SQLite 语句的 WHERE 子句中执行操作，如比较和算术运算。 运算符用于指定 SQLite 语句中的条件，并在语句中连接多个条件。 算术运算符 比较运算符 逻辑运算符 位运算符 SQLite 算术运算符假设变量 a&#x3D;10，变量 b&#x3D;20，则： 运算符 描述 实例 + 加法 - 把运算符两边的值相加 a + b 将得到 30 - 减法 - 左操作数减去右操作数 a - b 将得到 -10 * 乘法 - 把运算符两边的值相乘 a * b 将得到 200 &#x2F; 除法 - 左操作数除以右操作数 b &#x2F; a 将得到 2 % 取模 - 左操作数除以右操作数后得到的余数 b % a will give 0 实例 下面是 SQLite 算术运算符的简单实例： sqlite&gt; .mode line sqlite&gt; select 10 + 20; 10 + 20 = 30 sqlite&gt; select 10 - 20; 10 - 20 = -10 sqlite&gt; select 10 * 20; 10 * 20 = 200 sqlite&gt; select 10 / 5; 10 / 5 = 2 sqlite&gt; select 12 % 5; 12 % 5 = 2 SQLite 比较运算符假设变量 a&#x3D;10，变量 b&#x3D;20，则： 运算符 描述 实例 &#x3D;&#x3D; 检查两个操作数的值是否相等，如果相等则条件为真。 (a &#x3D;&#x3D; b) 不为真。 &#x3D; 检查两个操作数的值是否相等，如果相等则条件为真。 (a &#x3D; b) 不为真。 !&#x3D; 检查两个操作数的值是否相等，如果不相等则条件为真。 (a !&#x3D; b) 为真。 &lt;&gt; 检查两个操作数的值是否相等，如果不相等则条件为真。 (a &lt;&gt; b) 为真。 &gt; 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (a &gt; b) 不为真。 &lt; 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (a &lt; b) 为真。 &gt;&#x3D; 检查左操作数的值是否大于等于右操作数的值，如果是则条件为真。 (a &gt;&#x3D; b) 不为真。 &lt;&#x3D; 检查左操作数的值是否小于等于右操作数的值，如果是则条件为真。 (a &lt;&#x3D; b) 为真。 !&lt; 检查左操作数的值是否不小于右操作数的值，如果是则条件为真。 (a !&lt; b) 为假 !&gt; 检查左操作数的值是否不大于右操作数的值，如果是则条件为真。 (a !&gt; b) 为真 实例假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的实例演示了各种 SQLite 比较运算符的用法。 在这里，我们使用 WHERE 子句，这将会在后边单独的一个章节中讲解，但现在您需要明白，WHERE 子句是用来设置 SELECT 语句的条件语句。 下面的 SELECT 语句列出了 SALARY 大于 50,000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE SALARY &gt; 50000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 下面的 SELECT 语句列出了 SALARY 等于 20,000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE SALARY = 20000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 3 Teddy 23 Norway 20000.0 下面的 SELECT 语句列出了 SALARY 不等于 20,000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE SALARY != 20000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的 SELECT 语句列出了 SALARY 不等于 20,000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE SALARY &lt;&gt; 20000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的 SELECT 语句列出了 SALARY 大于等于 65,000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE SALARY &gt;= 65000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 SQLite 逻辑运算符下面是 SQLite 中所有的逻辑运算符列表。 运算符 描述 AND AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。 BETWEEN BETWEEN 运算符用于在给定最小值和最大值范围内的一系列值中搜索值。 EXISTS EXISTS 运算符用于在满足一定条件的指定表中搜索行的存在。 IN IN 运算符用于把某个值与一系列指定列表的值进行比较。 NOT IN IN 运算符的对立面，用于把某个值与不在一系列指定列表的值进行比较。 LIKE LIKE 运算符用于把某个值与使用通配符运算符的相似值进行比较。 GLOB GLOB 运算符用于把某个值与使用通配符运算符的相似值进行比较。GLOB 与 LIKE 不同之处在于，它是大小写敏感的。 NOT NOT 运算符是所用的逻辑运算符的对立面。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。它是否定运算符。 OR OR 运算符用于结合一个 SQL 语句的 WHERE 子句中的多个条件。 IS NULL NULL 运算符用于把某个值与 NULL 值进行比较。 IS IS 运算符与 &#x3D; 相似。 IS NOT IS NOT 运算符与 !&#x3D; 相似。 || 连接两个不同的字符串，得到一个新的字符串。 UNIQUE UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。 实例假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的实例演示了 SQLite 逻辑运算符的用法。下面的 SELECT 语句列出了 AGE 大于等于 25 且工资大于等于 65000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 下面的 SELECT 语句列出了 AGE 大于等于 25 或工资大于等于 65000.00 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt;= 25 OR SALARY &gt;= 65000; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 下面的 SELECT 语句列出了 AGE 不为 NULL 的所有记录，结果显示所有的记录，意味着没有一个记录的 AGE 等于 NULL： sqlite&gt; SELECT * FROM COMPANY WHERE AGE IS NOT NULL; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的 SELECT 语句列出了 NAME 以 ‘Ki’ 开始的所有记录，’Ki’ 之后的字符不做限制： sqlite&gt; SELECT * FROM COMPANY WHERE NAME LIKE &#39;Ki%&#39;; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 6 Kim 22 South-Hall 45000.0 下面的 SELECT 语句列出了 NAME 以 ‘Ki’ 开始的所有记录，’Ki’ 之后的字符不做限制： sqlite&gt; SELECT * FROM COMPANY WHERE NAME GLOB &#39;Ki*&#39;; ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 6 Kim 22 South-Hall 45000.0 下面的 SELECT 语句列出了 AGE 的值为 25 或 27 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE IN ( 25, 27 ); ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 2 Allen 25 Texas 15000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 下面的 SELECT 语句列出了 AGE 的值既不是 25 也不是 27 的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE NOT IN ( 25, 27 ); ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 3 Teddy 23 Norway 20000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面的 SELECT 语句使用 SQL 子查询，子查询查找 SALARY &gt; 65000 的带有 AGE 字段的所有记录，后边的 WHERE 子句与 EXISTS 运算符一起使用，列出了外查询中的 AGE 存在于子查询返回的结果中的所有记录： sqlite&gt; SELECT AGE FROM COMPANY WHERE EXISTS (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000); AGE ---------- 32 25 23 25 27 22 24 下面的 SELECT 语句使用 SQL 子查询，子查询查找 SALARY &gt; 65000 的带有 AGE 字段的所有记录，后边的 WHERE 子句与 &gt; 运算符一起使用，列出了外查询中的 AGE 大于子查询返回的结果中的年龄的所有记录： sqlite&gt; SELECT * FROM COMPANY WHERE AGE &gt; (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000); ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 SQLite 位运算符位运算符作用于位，并逐位执行操作。真值表 &amp; 和 | 如下： p q p&amp;q p|q 0 0 0 0 0 1 0 1 1 1 1 1 1 0 0 1 假设如果 A &#x3D; 60，且 B &#x3D; 13，现在以二进制格式，它们如下所示： A &#x3D; 0011 1100 B &#x3D; 0000 1101 A&amp;B &#x3D; 0000 1100 A|B &#x3D; 0011 1101 ~A &#x3D; 1100 0011 下表中列出了 SQLite 语言支持的位运算符。假设变量 A&#x3D;60，变量 B&#x3D;13，则： 运算符 描述 实例 &amp; 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 (A &amp; B) 将得到 12，即为 0000 1100 | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。 (A ~ 二进制补码运算符是一元运算符，具有”翻转”位效应。 (~A ) 将得到 -61，即为 1100 0011，2 的补码形式，带符号的二进制数。 &lt;&lt; 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。 A &lt;&lt; 2 将得到 240，即为 1111 0000 &gt;&gt; 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。 A &gt;&gt; 2 将得到 15，即为 0000 1111 实例 下面的实例演示了 SQLite 位运算符的用法： sqlite&gt; .mode line sqlite&gt; select 60 | 13; 60 | 13 = 61 sqlite&gt; select 60 &amp; 13; 60 &amp; 13 = 12 sqlite&gt; select 60 ^ 13; 10 * 20 = 200 sqlite&gt; select (~60); (~60) = -61 sqlite&gt; select (60 &lt;&lt; 2); (60 &lt;&lt; 2) = 240 sqlite&gt; select (60 &gt;&gt; 2); (60 &gt;&gt; 2) = 15 资料整理于：RUNOOB.COM-SQLite 教程转载请注明出处。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.wangruofeng007.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQLite","slug":"SQLite","permalink":"https://blog.wangruofeng007.com/tags/SQLite/"}]},{"title":"SQLite 教程(三)","slug":"2016-01-13-sqlite-jiao-cheng-san","date":"2016-01-13T15:22:37.000Z","updated":"2024-11-03T05:32:35.285Z","comments":true,"path":"2016/01/13/2016-01-13-sqlite-jiao-cheng-san/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-sqlite-jiao-cheng-san/","excerpt":"","text":"SQLite Insert 语句SQLite 的 INSERT INTO 语句用于向数据库的某个表中添加新的数据行。 语法 INSERT INTO 语句有两种基本语法，如下所示： INSERT INTO TABLE_NAME (column1, column2, column3,...columnN)] VALUES (value1, value2, value3,...valueN); 在这里，column1, column2,…columnN 是要插入数据的表中的列的名称。如果要为表中的所有列添加值，您也可以不需要在 SQLite 查询中指定列名称。但要确保值的顺序与列在表中的顺序一致。SQLite 的 INSERT INTO 语法如下： INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN); 实例 假设您已经在 testDB.db 中创建了 COMPANY 表，如下所示： sqlite&gt; CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); 现在，下面的语句将在 COMPANY 表中创建六个记录： INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (1, &#39;Paul&#39;, 32, &#39;California&#39;, 20000.00 ); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (2, &#39;Allen&#39;, 25, &#39;Texas&#39;, 15000.00 ); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (3, &#39;Teddy&#39;, 23, &#39;Norway&#39;, 20000.00 ); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (4, &#39;Mark&#39;, 25, &#39;Rich-Mond &#39;, 65000.00 ); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (5, &#39;David&#39;, 27, &#39;Texas&#39;, 85000.00 ); INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (6, &#39;Kim&#39;, 22, &#39;South-Hall&#39;, 45000.00 ); 您也可以使用第二种语法在 COMPANY 表中创建一个记录，如下所示： INSERT INTO COMPANY VALUES (7, &#39;James&#39;, 24, &#39;Houston&#39;, 10000.00 ); 上面的所有语句将在 COMPANY 表中创建下列记录。下一章会教您如何从一个表中显示所有这些记录。 ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 使用一个表来填充另一个表您可以通过在一个有一组字段的表上使用 select 语句，填充数据到另一个表中。下面是语法： INSERT INTO first_table_name [(column1, column2, ... columnN)] SELECT column1, column2, ...columnN FROM second_table_name [WHERE condition]; SQLite Select 语句SQLite 的 SELECT 语句用于从 SQLite 数据库表中获取数据，以结果表的形式返回数据。这些结果表也被称为结果集。 语法 SQLite 的 SELECT 语句的基本语法如下： SELECT column1, column2, columnN FROM table_name; 在这里，column1, column2…是表的字段，他们的值即是您要获取的。如果您想获取所有可用的字段，那么可以使用下面的语法： SELECT * FROM table_name; 实例 假设 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，使用 SELECT 语句获取并显示所有这些记录。在这里，前三个命令被用来设置正确格式化的输出。 sqlite&gt;.header on sqlite&gt;.mode column sqlite&gt; SELECT * FROM COMPANY; 最后，将得到以下的结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 如果只想获取 COMPANY 表中指定的字段，则使用下面的查询： sqlite&gt; SELECT ID, NAME, SALARY FROM COMPANY; 上面的查询会产生以下结果： ID NAME SALARY ---------- ---------- ---------- 1 Paul 20000.0 2 Allen 15000.0 3 Teddy 20000.0 4 Mark 65000.0 5 David 85000.0 6 Kim 45000.0 7 James 10000.0 设置输出列的宽度 有时，由于要显示的列的默认宽度导致 .mode column，这种情况下，输出被截断。此时，您可以使用 .width num, num…. 命令设置显示列的宽度，如下所示： sqlite&gt;.width 10, 20, 10 sqlite&gt;SELECT * FROM COMPANY; 上面的 .width 命令设置第一列的宽度为 10，第二列的宽度为 20，第三列的宽度为 10。因此上述 SELECT 语句将得到以下结果： ID NAME AGE ADDRESS SALARY ---------- -------------------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 Schema 信息因为所有的点命令只在 SQLite 提示符中可用，所以当您进行带有 SQLite 的编程时，您要使用下面的带有 sqlite_master 表的 SELECT 语句来列出所有在数据库中创建的表： sqlite&gt; SELECT tbl_name FROM sqlite_master WHERE type = &#39;table&#39;; 假设在 testDB.db 中已经存在唯一的 COMPANY 表，则将产生以下结果： tbl_name ---------- COMPANY 您可以列出关于 COMPANY 表的完整信息，如下所示： sqlite&gt; SELECT sql FROM sqlite_master WHERE type = &#39;table&#39; AND tbl_name = &#39;COMPANY&#39;; 假设在 testDB.db 中已经存在唯一的 COMPANY 表，则将产生以下结果： CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ) 资料整理于：RUNOOB.COM-SQLite 教程转载请注明出处。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.wangruofeng007.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQLite","slug":"SQLite","permalink":"https://blog.wangruofeng007.com/tags/SQLite/"}]},{"title":"SQLite 教程(二)","slug":"2016-01-13-sqlite-jiao-cheng-er","date":"2016-01-13T15:21:34.000Z","updated":"2024-11-03T05:32:35.308Z","comments":true,"path":"2016/01/13/2016-01-13-sqlite-jiao-cheng-er/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-sqlite-jiao-cheng-er/","excerpt":"","text":"SQLite 数据类型SQLite 数据类型是一个用来指定任何对象的数据类型的属性。SQLite 中的每一列，每个变量和表达式都有相关的数据类型。 您可以在创建表的同时使用这些数据类型。SQLite 使用一个更普遍的动态类型系统。在 SQLite 中，值的数据类型与值本身是相关的，而不是与它的容器相关。 SQLite 存储类每个存储在 SQLite 数据库中的值都具有以下存储类之一： 存储类 描述 NULL 值是一个 NULL 值。 INTEGER 值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中。 REAL 值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。 TEXT 值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 BLOB 值是一个 blob 数据，完全根据它的输入存储。 SQLite 的存储类稍微比数据类型更普遍。INTEGER 存储类，例如，包含 6 种不同的不同长度的整数数据类型。 SQLite Affinity 类型SQLite 支持列上的类型 affinity 概念。任何列仍然可以存储任何类型的数据，但列的首选存储类是它的 affinity。在 SQLite3 数据库中，每个表的列分配为以下类型的 affinity 之一： Affinity 描述 TEXT 该列使用存储类 NULL、TEXT 或 BLOB 存储所有数据。 NUMERIC 该列可以包含使用所有五个存储类的值。 INTEGER 与带有 NUMERIC affinity 的列相同，在 CAST 表达式中带有异常。 REAL 与带有 NUMERIC affinity 的列相似，不同的是，它会强制把整数值转换为浮点表示。 NONE 带有 affinity NONE 的列，不会优先使用哪个存储类，也不会尝试把数据从一个存储类强制转换为另一个存储类。 SQLite Affinity 及类型名称下表列出了当创建 SQLite3 表时可使用的各种数据类型名称，同时也显示了相应的应用 Affinity： 数据类型 Affinity INT INTEGERTINYINT SMALLINT MEDIUMINT BIGINT UNSIGNED BIG INT INT2 INT8 INTEGER CHARACTER(20) VARCHAR(255) VARYING CHARACTER(255) NCHAR(55) NATIVE CHARACTER(70) NVARCHAR(100) TEXT CLOB TEXT BLOB no datatype specified NONE REAL DOUBLE DOUBLE PRECISION FLOAT REAL NUMERIC DECIMAL(10,5) BOOLEAN DATE DATETIME NUMERIC Boolean 数据类型SQLite 没有单独的 Boolean 存储类。相反，布尔值被存储为整数 0（false）和 1（true）。 Date 与 Time 数据类型SQLite 没有一个单独的用于存储日期和&#x2F;或时间的存储类，但 SQLite 能够把日期和时间存储为 TEXT、REAL 或 INTEGER 值。 存储类 日期格式 TEXT 格式为 “YYYY-MM-DD HH:MM:SS.SSS” 的日期。 REAL 从公元前 4714 年 11 月 24 日格林尼治时间的正午开始算起的天数。 INTEGER 从 1970-01-01 00:00:00 UTC 算起的秒数。 您可以以任何上述格式来存储日期和时间，并且可以使用内置的日期和时间函数来自由转换不同格式。 SQLite 创建数据库SQLite 的 sqlite3 命令被用来创建新的 SQLite 数据库。您不需要任何特殊的权限即可创建一个数据。 语法 sqlite3 命令的基本语法如下： $sqlite3 DatabaseName.db 通常情况下，数据库名称在 RDBMS 内应该是唯一的。 实例 如果您想创建一个新的数据库 &lt;testDB.db&gt;，SQLITE3 语句如下所示： $sqlite3 testDB.db SQLite version 3.8.10.2 2015-05-20 18:17:19 Enter &quot;.help&quot; for usage hints. sqlite&gt; 上面的命令将在当前目录下创建一个文件 testDB.db。该文件将被 SQLite 引擎用作数据库。如果您已经注意到 sqlite3 命令在成功创建数据库文件之后，将提供一个 sqlite&gt; 提示符。一旦数据库被创建，您就可以使用 SQLite 的 .databases 命令来检查它是否在数据库列表中，如下所示： sqlite&gt;.databases seq name file ---- ---------------- -------------------------------------------- 0 main /Users/wangruofeng/Documents/SQLitePractice/testDB.db 您可以使用 SQLite .quit 命令退出 sqlite 提示符，如下所示： sqlite&gt;.quit $ .dump 命令您可以在命令提示符中使用 SQLite .dump 点命令来导出完整的数据库在一个文本文件中，如下所示： $sqlite3 testDB.db .dump &gt; testDB.sql 上面的命令将转换整个 testDB.db 数据库的内容到 SQLite 的语句中，并将其转储到 ASCII 文本文件 testDB.sql 中。您可以通过简单的方式从生成的 testDB.sql 恢复，如下所示： $sqlite3 testDB.db &lt; testDB.sql 此时的数据库是空的，一旦数据库中有表和数据，您可以尝试上述两个程序。现在，让我们继续学习下一章。 SQLite 附加数据库假设这样一种情况，当在同一时间有多个数据库可用，您想使用其中的任何一个。SQLite 的 ATTACH DTABASE 语句是用来选择一个特定的数据库，使用该命令后，所有的 SQLite 语句将在附加的数据库下执行。相当于给数据库取一个别名 语法 SQLite 的 ATTACH DATABASE 语句的基本语法如下： ATTACH DATABASE &#39;DatabaseName&#39; As &#39;Alias-Name&#39;; 如果数据库尚未被创建，上面的命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库 ‘Alias-Name’ 绑定在一起。 实例如果想附加一个现有的数据库 testDB.db，则 ATTACH DATABASE 语句将如下所示： sqlite&gt; ATTACH DATABASE &#39;testDB.db&#39; as &#39;TEST&#39;; 使用 SQLite .database 命令来显示附加的数据库。 sqlite&gt; .database seq name file --- --------------- ---------------------- 0 main /home/sqlite/testDB.db 2 test /home/sqlite/testDB.db 数据库名称 main 和 temp 被保留用于主数据库和存储临时表及其他临时数据对象的数据库。这两个数据库名称可用于每个数据库连接，且不应该被用于附加，否则将得到一个警告消息，如下所示： sqlite&gt; ATTACH DATABASE &#39;testDB.db&#39; as &#39;TEMP&#39;; Error: database TEMP is already in use sqlite&gt; ATTACH DATABASE &#39;testDB.db&#39; as &#39;main&#39;; Error: database main is already in use SQLite 分离数据库SQLite 的 DETACH DTABASE 语句是用来把命名数据库从一个数据库连接分离和游离出来，连接是之前使用 ATTACH 语句附加的。如果同一个数据库文件已经被附加上多个别名，DETACH 命令将只断开给定名称的连接，而其余的仍然有效。您无法分离 main 或 temp 数据库。 如果数据库是在内存中或者是临时数据库，则该数据库将被摧毁，且内容将会丢失。 语法 SQLite 的 DETACH DATABASE ‘Alias-Name’ 语句的基本语法如下： DETACH DATABASE &#39;Alias-Name&#39;; 在这里，’Alias-Name’ 与您之前使用 ATTACH 语句附加数据库时所用到的别名相同。 实例 假设在前面的章节中您已经创建了一个数据库，并给它附加了 ‘test’ 和 ‘currentDB’，使用 .database&#x2F;.databases 命令，我们可以看到： sqlite&gt; .databases seq name file --- --------------- ---------------------- 0 main /home/sqlite/testDB.db 2 test /home/sqlite/testDB.db 3 currentDB /home/sqlite/testDB.db 现在，让我们尝试把 ‘currentDB’ 从 testDB.db 中分离出来，如下所示： sqlite&gt; DETACH DATABASE &#39;currentDB&#39;; 现在，如果检查当前附加的数据库，您会发现，testDB.db 仍与 ‘test’ 和 ‘main’ 保持连接。 sqlite&gt; .databases seq name file --- --------------- ---------------------- 0 main /home/sqlite/testDB.db 2 test /home/sqlite/testDB.db SQLite 创建表SQLite 的 CREATE TABLE 语句用于在任何给定的数据库创建一个新表。创建基本表，涉及到命名表、定义列及每一列的数据类型。 语法 CREATE TABLE 语句的基本语法如下： CREATE TABLE database_name.table_name( column1 datatype PRIMARY KEY(one or more columns), column2 datatype, column3 datatype, ..... columnN datatype, ); CREATE TABLE 是告诉数据库系统创建一个新表的关键字。CREATE TABLE 语句后跟着表的唯一的名称或标识。您也可以选择指定带有 table_name 的 database_name。 实例 下面是一个实例，它创建了一个 COMPANY 表，ID 作为主键，NOT NULL 的约束表示在表中创建纪录时这些字段不能为 NULL： sqlite&gt; CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); 让我们再创建一个表，我们将在随后章节的练习中使用： sqlite&gt; CREATE TABLE DEPARTMENT( ID INT PRIMARY KEY NOT NULL, DEPT CHAR(50) NOT NULL, EMP_ID INT NOT NULL ); 您可以使用 SQLIte 命令中的 .tables&#x2F;.table 命令来验证表是否已成功创建，该命令用于列出附加数据库中的所有表。 sqlite&gt; .tables COMPANY DEPARTMENT TEST.COMPANY TEST.DEPARTMENT 在这里，可以看到 COMPANY 表出现两次，一个是主数据库的 COMPANY 表，一个是为 testDB.db 创建的 ‘test’ 别名的 test.COMPANY 表。您可以使用 SQLite .schema 命令得到表的完整信息，如下所示： sqlite&gt;.schema COMPANY CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL ); SQLite 删除表SQLite 的 DROP TABLE 语句用来删除表定义及其所有相关数据、索引、触发器、约束和该表的权限规范。 使用此命令时要特别注意，因为一旦一个表被删除，表中所有信息也将永远丢失。 语法 DROP TABLE 语句的基本语法如下。您可以选择指定带有表名的数据库名称，如下所示： DROP TABLE database_name.table_name; 实例 让我们先确认 COMPANY 表已经存在，然后我们将其从数据库中删除。 sqlite&gt; .tables COMPANY test.COMPANY 这意味着 COMPANY 表已存在数据库中，接下来让我们把它从数据库中删除，如下： sqlite&gt; DROP TABLE COMPANY; sqlite&gt; 现在，如果尝试 .TABLES 命令，那么将无法找到 COMPANY 表了： sqlite&gt; .tables sqlite&gt; 显示结果为空，意味着已经成功从数据库删除表。 资料整理于：RUNOOB.COM-SQLite 教程转载请注明出处。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.wangruofeng007.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQLite","slug":"SQLite","permalink":"https://blog.wangruofeng007.com/tags/SQLite/"}]},{"title":"SQLite 教程(一)","slug":"2016-01-13-sqlite-jiao-cheng-[?]","date":"2016-01-13T15:18:15.000Z","updated":"2024-11-03T05:32:35.308Z","comments":true,"path":"2016/01/13/2016-01-13-sqlite-jiao-cheng-[?]/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-sqlite-jiao-cheng-[?%5D/","excerpt":"","text":"简介：SQLite 是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite 是在世界上最广泛部署的 SQL 数据库引擎。SQLite 源代码不受版权限制。本教程将告诉您如何使用 SQLite 编程，并让你迅速上手。 什么是 SQLite？SQLite 是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。就像其他数据库，SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件 为什么要用 SQLite？ 不需要一个单独的服务器进程或操作的系统（无服务器的）。 SQLite 不需要配置，这意味着不需要安装或管理。 一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。 SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于 250KiB。 SQLite 是自给自足的，这意味着不需要任何外部的依赖。 SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。 SQLite 支持 SQL92（SQL2）标准的大多数查询语言的功能。 SQLite 使用 ANSI-C 编写的，并提供了简单和易于使用的 API。 SQLite 可在 UNIX（Linux, Mac OS-X, Android, iOS）和 Windows（Win32, WinCE, WinRT）中运行。 SQLite 命令与关系数据库进行交互的标准 SQLite 命令类似于 SQL。命令包括 CREATE、SELECT、INSERT、UPDATE、DELETE 和 DROP。这些命令基于它们的操作性质可分为以下几种： DDL - 数据定义语言 命令 描述 CREATE 创建一个新的表，一个表的视图，或者数据库中的其他对象。 ALTER 修改数据库中的某个已有的数据库对象，比如一个表。 DROP 删除整个表，或者表的视图，或者数据库中的其他对象。 DML - 数据操作语言 命令 描述 INSERT 创建一条记录。 UPDATE 修改记录。 DELETE 删除记录。 DQL - 数据查询语言 命令 描述 SELECT 从一个或多个表中检索某些记录。 在 Mac OS X 上安装 SQLite最新版本的 Mac OS X 会预安装 SQLite，但是如果没有可用的安装，只需按照如下步骤进行：请访问 SQLite 下载页面，从源代码区下载 sqlite-autoconf-*.tar.gz。步骤如下： $tar xvfz sqlite-autoconf-3071502.tar.gz $cd sqlite-autoconf-3071502 $./configure --prefix=/usr/local $make $make install 上述步骤将在 Mac OS X 机器上安装 SQLite，您可以使用下列命令进行验证： $sqlite3 SQLite version 3.7.15.2 2013-01-09 11:53:05 Enter &quot;.help&quot; for instructions Enter SQL statements terminated with a &quot;;&quot; sqlite&gt; 最后，在 SQLite 命令提示符下，使用 SQLite 命令做练习。 SQLite 语法大小写敏感性 有个重要的点值得注意，SQLite 是不区分大小写的，但也有一些命令是大小写敏感的，比如 GLOB 和 glob 在 SQLite 的语句中有不同的含义。 注释 SQLite 注释是附加的注释，可以在 SQLite 代码中添加注释以增加其可读性，他们可以出现在任何空白处，包括在表达式内和其他 SQL 语句的中间，但它们不能嵌套。SQL 注释以两个连续的 “-“ 字符（ASCII 0x2d）开始，并扩展至下一个换行符（ASCII 0x0a）或直到输入结束，以先到者为准。您也可以使用 C 风格的注释，以 “&#x2F;*“ 开始，并扩展至下一个 “*&#x2F;“ 字符对或直到输入结束，以先到者为准。SQLite 的注释可以跨越多行。 SQLite 语句所有的 SQLite 语句可以以任何关键字开始，如 SELECT、INSERT、UPDATE、DELETE、ALTER、DROP 等，所有的语句以分号（;）结束。 SQLite ANALYZE 语句： ANALYZE; or ANALYZE database_name; or ANALYZE database_name.table_name; SQLite AND&#x2F;OR 子句： SELECT column1, column2....columnN FROM table_name WHERE CONDITION-1 &#123;AND|OR&#125; CONDITION-2; SQLite ALTER TABLE 语句： ALTER TABLE table_name ADD COLUMN column_def...; SQLite ALTER TABLE 语句（Rename）： ALTER TABLE table_name RENAME TO new_table_name; SQLite ATTACH DATABASE 语句： ATTACH DATABASE &#39;DatabaseName&#39; As &#39;Alias-Name&#39;; SQLite BEGIN TRANSACTION 语句： BEGIN; or BEGIN EXCLUSIVE TRANSACTION; SQLite BETWEEN 子句： SELECT column1, column2....columnN FROM table_name WHERE column_name BETWEEN val-1 AND val-2; SQLite COMMIT 语句： COMMIT; SQLite CREATE INDEX 语句： CREATE INDEX index_name ON table_name ( column_name COLLATE NOCASE ); SQLite CREATE UNIQUE INDEX 语句： CREATE UNIQUE INDEX index_name ON table_name ( column1, column2,...columnN); SQLite CREATE TABLE 语句： CREATE TABLE table_name( column1 datatype, column2 datatype, column3 datatype, ..... columnN datatype, PRIMARY KEY( one or more columns ) ); SQLite CREATE TRIGGER 语句： CREATE TRIGGER database_name.trigger_name BEFORE INSERT ON table_name FOR EACH ROW BEGIN stmt1; stmt2; .... END; SQLite CREATE VIEW 语句： CREATE VIEW database_name.view_name AS SELECT statement....; SQLite CREATE VIRTUAL TABLE 语句： CREATE VIRTUAL TABLE database_name.table_name USING weblog( access.log ); or CREATE VIRTUAL TABLE database_name.table_name USING fts3( ); SQLite COMMIT TRANSACTION 语句： COMMIT; SQLite COUNT 子句： SELECT COUNT(column_name) FROM table_name WHERE CONDITION; SQLite DELETE 语句： DELETE FROM table_name WHERE &#123;CONDITION&#125;; SQLite DETACH DATABASE 语句： DETACH DATABASE &#39;Alias-Name&#39;; SQLite DISTINCT 子句： SELECT DISTINCT column1, column2....columnN FROM table_name; SQLite DROP INDEX 语句： DROP INDEX database_name.index_name; SQLite DROP TABLE 语句： DROP TABLE database_name.table_name; SQLite DROP VIEW 语句： DROP INDEX database_name.view_name; SQLite DROP TRIGGER 语句： DROP INDEX database_name.trigger_name; SQLite EXISTS 子句： SELECT column1, column2....columnN FROM table_name WHERE column_name EXISTS (SELECT * FROM table_name ); SQLite EXPLAIN 语句： EXPLAIN INSERT statement...; or EXPLAIN QUERY PLAN SELECT statement...; SQLite GLOB 子句： SELECT column1, column2....columnN FROM table_name WHERE column_name GLOB &#123; PATTERN &#125;; SQLite GROUP BY 子句： SELECT SUM(column_name) FROM table_name WHERE CONDITION GROUP BY column_name; SQLite HAVING 子句： SELECT SUM(column_name) FROM table_name WHERE CONDITION GROUP BY column_name HAVING (arithematic function condition); SQLite INSERT INTO 语句： INSERT INTO table_name( column1, column2....columnN) VALUES ( value1, value2....valueN); SQLite IN 子句： SELECT column1, column2....columnN FROM table_name WHERE column_name IN (val-1, val-2,...val-N); SQLite Like 子句： SELECT column1, column2....columnN FROM table_name WHERE column_name LIKE &#123; PATTERN &#125;; SQLite NOT IN 子句： SELECT column1, column2....columnN FROM table_name WHERE column_name NOT IN (val-1, val-2,...val-N); SQLite ORDER BY 子句： SELECT column1, column2....columnN FROM table_name WHERE CONDITION ORDER BY column_name &#123;ASC|DESC&#125;; SQLite PRAGMA 语句： PRAGMA pragma_name; For example: PRAGMA page_size; PRAGMA cache_size = 1024; PRAGMA table_info(table_name); SQLite RELEASE SAVEPOINT 语句： RELEASE savepoint_name; SQLite REINDEX 语句： REINDEX collation_name; REINDEX database_name.index_name; REINDEX database_name.table_name; SQLite ROLLBACK 语句： ROLLBACK; or ROLLBACK TO SAVEPOINT savepoint_name; SQLite SAVEPOINT 语句： SAVEPOINT savepoint_name; SQLite SELECT 语句： SELECT column1, column2....columnN FROM table_name; SQLite UPDATE 语句： UPDATE table_name SET column1 = value1, column2 = value2....columnN=valueN [ WHERE CONDITION ]; SQLite VACUUM 语句： VACUUM; SQLite WHERE 子句： SELECT column1, column2....columnN FROM table_name WHERE CONDITION; 资料整理于：RUNOOB.COM-SQLite 教程转载请注明出处。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.wangruofeng007.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQLite","slug":"SQLite","permalink":"https://blog.wangruofeng007.com/tags/SQLite/"}]},{"title":"CocoaPods 使用指南","slug":"2016-01-13-cocoapodsshi-yong-zhi-nan","date":"2016-01-12T21:51:18.000Z","updated":"2024-11-03T05:32:35.287Z","comments":true,"path":"2016/01/13/2016-01-13-cocoapodsshi-yong-zhi-nan/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-cocoapodsshi-yong-zhi-nan/","excerpt":"","text":"简介CocoaPods 是 iOS 最常用的第三方类库管理工具，绝大部分有名的开源类库支持 CocoaPods。 CocoaPods 是用 Ruby 实现的，要使用它首先需要有 Ruby 的环境。 安装幸亏 OS X 系统默认已经可以运行 Ruby 了，我们只需执行以下命令： 1sudo gem install cocoapods 由于某些原因，执行时会出现下面的错误提示： 1234ERROR :Could not find a valid gem `cocoapods` (&gt;= 0), here is why: Unable to download data from https://rubygems.org/ - Errno::EPIPI: Broken pipe - SSL_connect(https://rubygems.org/lastest_specs.4.8.gz) 安装成功后，接着执行命令： 1pod setup 如果 Ruby 环境不够新，可能需要更新以下： 1sudo gem update --system 至此安装就完成了，我们可以尝试搜索一个第三方类库： 1pod search AFNetworking 使用使用 CocoaPods 第一步，是在当前项目下，新建一个 Podfile 文件： 1touch Podfile 然后利用 vim 打开 Podfile 文件编辑，加入你想要的类库，格式如下： 123456platform :iospod &#x27;Reachability&#x27;, &#x27;3.1.0&#x27;platform :ios, &#x27;6.0&#x27;pod &#x27;JSONKit&#x27;, &#x27;1.4&#x27;pod &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.3.1&#x27; 如果是拷贝别人的项目，或是一个很久没打开过的项目，可能需要先执行一下： 1pod update 最后一步，执行命令： 1pod install 当终端出现类似下面的提示后，就代表成功了： 1[!] From now no use `Sample0814.xcworkspace` . 这个时候会看到项目文件夹多了一个 xxx.xcworkspace,以后要通过这个文件打开项目，老项目 xxx.xcodeproj 不再使用。 上面的每一步都可能出现问题，但大部分问题都是因为局域网的原因，用一个网速稳定的境外 VPN 可破 如果上面因为权限问题安装失败，必须每次都要删除 1rm -rf /User/loginname/Library/Caches/CocoaPods/ 因为这个缓冲中会存下你的 github 的东西，造成每次调用上次权限问题的缓存。 关于 Podfile 文件编辑时，第三方版本号的各种写法: 123456789pod &#x27;AFNetworking&#x27; # 不显式指定依赖库版本，表示每次都获取最新版本pod &#x27;AFNetworking&#x27;, &#x27;2.0&#x27; # 只使用 2.0 版本pod &#x27;AFNetworking&#x27;, &#x27;&gt;2.0&#x27; # 使用高于 2.0 的版本pod &#x27;AFNetworking&#x27;, &#x27;&gt;=2.0&#x27; # 使用大于或等于 2.0 的版本pod &#x27;AFNetworking&#x27;, &#x27;&lt;2.0&#x27; # 使用小于 2.0 的版本pod &#x27;AFNetworking&#x27;, &#x27;&lt;=2.0&#x27; # 使用小于或等于 2.0 的版本pod &#x27;AFNetworking&#x27;, &#x27;~&gt;0.1.2&#x27; # 使用大于等于 0.1.2 但小于 0.2 的版本，相当于&gt;=0.1.2 并且&lt;0.2.0pod &#x27;AFNetworking&#x27;, &#x27;~&gt;0.1&#x27; # 使用大于等于 0.1 但小于 1.0 的版本pod &#x27;AFNetworking&#x27;, &#x27;~&gt;0&#x27; # 高于 0 的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本 参考资料 语义化版本 2.0.0","categories":[{"name":"包管理","slug":"包管理","permalink":"https://blog.wangruofeng007.com/categories/%E5%8C%85%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://blog.wangruofeng007.com/tags/CocoaPods/"}]},{"title":"GET&amp;POST","slug":"2016-01-13-get-and-post","date":"2016-01-12T21:48:10.000Z","updated":"2024-11-03T05:41:38.808Z","comments":true,"path":"2016/01/13/2016-01-13-get-and-post/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-get-and-post/","excerpt":"","text":"GET 和 POST 是两种最常用的与服务器进行交互的 HTTP 方法。 GET GET 的语义是获取指定的 URL 资源, 将数据按照 variable &#x3D; value 的形式, 添加到 action 所指向的 URL 后面, 并且两者使用 ‘ ? ‘连接, 各变量之间使用 ‘ &amp; ‘连接。 对用户来说不安全, 因为在传输过程中, 数据被放在请求的 URL 中。 传输的数据量小, 这主要是因为受 URL 长度限制。 URL 长度限制 在 http 协议中，其实并没有对 url 长度作出限制，往往 url 的最大长度和用户浏览器和 Web 服务器有关，不一样的浏览器，能接受的最大长度往往是不一样的，当然，不一样的 Web 服务器能够处理的最大长度的 URL 的能力也是不一样的。 IE 浏览器对 URL 的最大限制为 2083 个字符，如果超过这个数字，提交按钮没有任何反应； Firefox 浏览器 URL 的长度限制为 65,536 个字符； Apache(Server)能够接受的最大 URL 长度为 8192 个字符； 如果浏览器的编码为 UTF8 的话，一个汉字最终编码后的字符长度为 9 个字符。 GET 请求示例 POST POST 语义是向指定 URL 的资源添加数据。 将数据放在数据体中, 按照变量和值相对应的方式, 传递到 action 所指向的 URL。 所有数据对用户来说不可见。 可以传输大量数据, 上传文件只能使用 POST。 POST 请求示例 在浏览器中判断 GET&amp;POST 请求因为 POST 请求会向服务器发送数据体, 因此刷新页面时会出现提示窗口. 而 GET 请求不会向服务器发送数据体, 因此没有提示 . 从请求本质来看, GET 请求要比 POST 更安全, 效率也会更高 .(对服务器而言) iOS 网络发送网络请求的步骤 实例化 URL( 网络资源 ) ; 根据 URL 建立 URLRequest ( 网络请求 ) ; 默认为 GET 请求; 对于 POST 请求, 需要创建请求的数据体 . 利用 URLConnection 发送网络请求(发送请求并获得结果) ; NSURLConnection 提供了两个静态方法可以直接以同步或异步的方式向服务器发送网络请求. 12345同步请求:sendSynchronousRequest : returningResponse : error :异步请求:sendAsynchronousRequest : queue : completionHandler : 在网络请求过程中, 接收数据的过程实际上是通过 NSURLConnectionDataDelegate 来实现的, 常用代理方法包括: 12345678// 服务器开始返回数据- (void)connection:didReceiveResponse:// 收到服务器返回的数据，本方法会被调用多次- (void)connection:didReceiveData:// 数据接收完毕，做数据的最后处理- (void)connectionDidFinishLoading:// 网络连接错误- (void)connection:didFailWithError: 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"网络协议","slug":"网络协议","permalink":"https://blog.wangruofeng007.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"GET、POST","slug":"GET、POST","permalink":"https://blog.wangruofeng007.com/tags/GET%E3%80%81POST/"}]},{"title":"HTTP POST and multipart forms","slug":"2016-01-13-http-post-and-multipart-forms","date":"2016-01-12T21:45:41.000Z","updated":"2024-11-03T05:32:35.286Z","comments":true,"path":"2016/01/13/2016-01-13-http-post-and-multipart-forms/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-http-post-and-multipart-forms/","excerpt":"","text":"HTTP POST 使用注意事项： http Body 中的 NSData 编码方式要用 NSASCIIStringEncoding 而不是 NSUTF8StringEncoding * 通过 NSString *postLength = [NSString stringWithFormat:@&quot;%d&quot;,[postData length]]; 计算数据的长度 POST 参数设置123456//设置 header Content-Length[request setValue:postLength forHTTPHeaderField:@&quot;Content-Length&quot;];//设置 header contentType[request setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Current-Type&quot;];//设置 body[request setHTTPBody:postData]; 备注:普通 post 的 header 的 Current-Type 为 application/x-www-form-urlencoded #### Multipart Forms POST 参数设置 123456//设置 header contentTypeNSString *contentType = [NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;, boundary];[request addValue:contentType forHTTPHeaderField:@&quot;Content-Type&quot;];//设置 body contentType[body appendData:[@&quot;Content-Type: application/octet-stream\\r\\n\\r\\n&quot; dataUsingEncoding:NSUTF8StringEncoding]]; 备注: Multipart Forms 的 header 的 Current-Type 为 multipart/form-data request body like this --YOUR_BOUNDARY_STRING Content-Disposition: form-data; name=&quot;photo&quot;; filename=&quot;calm.jpg&quot; Content-Type: image/jpeg YOUR_IMAGE_DATA_GOES_HERE --YOUR_BOUNDARY_STRING Content-Disposition: form-data; name=&quot;message&quot; My first message --YOUR_BOUNDARY_STRING Content-Disposition: form-data; name=&quot;user&quot; 1 --YOUR_BOUNDARY_STRING I’m sending over three variables: an image named photo, a string named message, and an integer named user. It’s important to note the linebreaks and the dashes before the boundary string. These must be included in order to build a good request. Now lets write some objective-c: 12345678910111213141516171819202122NSString *boundary = @&quot;YOUR_BOUNDARY_STRING&quot;;NSString *contentType = [NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;, boundary];[request addValue:contentType forHTTPHeaderField:@&quot;Content-Type&quot;];NSMutableData *body = [NSMutableData data];[body appendData:[[NSString stringWithFormat:@&quot;\\r\\n--%@\\r\\n&quot;, boundary] dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:[[NSString stringWithFormat:@&quot;Content-Disposition: form-data; name=\\&quot;photo\\&quot;; filename=\\&quot;%@.jpg\\&quot;\\r\\n&quot;, self.message.photoKey] dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:[@&quot;Content-Type: application/octet-stream\\r\\n\\r\\n&quot; dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:[NSData dataWithData:imageData]];[body appendData:[[NSString stringWithFormat:@&quot;\\r\\n--%@\\r\\n&quot;, boundary] dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:[[NSString stringWithFormat:@&quot;Content-Disposition: form-data; name=\\&quot;message\\&quot;\\r\\n\\r\\n%@&quot;, self.message.message] dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:[[NSString stringWithFormat:@&quot;\\r\\n--%@\\r\\n&quot;, boundary] dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:[[NSString stringWithFormat:@&quot;Content-Disposition: form-data; name=\\&quot;user\\&quot;\\r\\n\\r\\n%d&quot;, 1] dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:[[NSString stringWithFormat:@&quot;\\r\\n--%@\\r\\n&quot;, boundary] dataUsingEncoding:NSUTF8StringEncoding]];[request setHTTPBody:body]; Now all we need to do is make a connection to the server and send the request: [request setHTTPBody:body]; 1234NSURLResponse *response;NSError *error;[NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error]; 参考资料： Sending Multipart Forms with Objective-C POST multipart&#x2F;form-data with Objective-C Sending an HTTP POST request on iOS The Multipart Content-Type–w3 规范 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"网络协议","slug":"网络协议","permalink":"https://blog.wangruofeng007.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"Networking","slug":"Networking","permalink":"https://blog.wangruofeng007.com/tags/Networking/"}]},{"title":"工厂模式详解","slug":"2016-01-13-gong-han-mo-shi-xiang-jie","date":"2016-01-12T21:39:21.000Z","updated":"2024-11-03T05:32:35.301Z","comments":true,"path":"2016/01/13/2016-01-13-gong-han-mo-shi-xiang-jie/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-gong-han-mo-shi-xiang-jie/","excerpt":"","text":"3 种工厂模式概述：工厂模式是个系列，分为简单工厂模式， 工厂方法模式， 抽象工厂模式，这三种模式也非常常用。这些模式最最经典的就例子就是设计计算器。 Factory Method (工厂方法模式) Abstract Factory (抽象工厂模式） Simple Factory（简单工厂模式） 参考 GoF《Design Patterns》一书 GOF 是这样描述工厂模式的： “Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.” 在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。 简单工厂模式 严格的说，简单工厂模式并不是 23 种常用的设计模式之一，它只算工厂模式的一个特殊实现。简单工厂模式在实际中的应用相对于其他 2 个工厂模式用的还是相对少得多，因为它只适应很多简单的情况，最最重要的是它违背了我们在概述中说的开放-封闭原则。因为每次你要新添加一个功能，都需要在生 switch-case 语句（或者 if-else 语句）中去修改代码，添加分支条件 简单工厂模式角色分配： Creator（产品创建者）简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。 Product （ 产品抽象类）简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 Concrete Product （具体产品）是简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。 简单的工厂模式 UML 图 考虑下面一个事例： 加入你是一个商人，你做的的是手机生意。现在你生产 android 手机和 iphone 等，考虑到以后你可能还会生产其他手机例如 ubuntu 手机。假定你选择了简单工厂模式来实现。那么显然，我们需要所有产品的抽象基类（Product） 即是 Phone 类： 123456class Phone &#123; public: virtual ~Phone()&#123;&#125;;//在删除的时候防止内存泄露 virtual void call(string number) = 0; &#125;; 然后我们需要具体的产品类 Concrete Product： AndroidPhone 和 iOSPhone 1234567891011class AndroidPhone : public Phone &#123; public: void call(string number)&#123; cout&lt;&lt;&quot;AndroidPhone is calling...&quot;&lt;&lt;endl;&#125; &#125;; class IosPhone : public Phone &#123; public: void call(string number) &#123; cout&lt;&lt;&quot;IosPhone is calling...&quot;&lt;&lt;endl;&#125; &#125;; 最后我们需要 Creator 12345678910111213141516class PhoneFactory &#123; public: Phone* createPhone(string phoneName) &#123; if(phoneName == &quot;AndroidPhone&quot;) &#123; return new AndroidPhone(); &#125;else if(phoneName == &quot;IosPhone&quot;) &#123; return new IosPhone(); &#125; return NULL; &#125; &#125;; 客户端这样实现： 12345678910111213141516171819void main() &#123; PhoneFactor factory; Phone* myAndroid = factory.createPhone(&quot;AndroidPhone&quot;); Phone* myIPhone = factory.createPhone(&quot;iOSPhone&quot;); if(myAndroid) &#123; myAndroid-&gt;call(&quot;123&quot;); delete myAndroid; myAndroid = NULL; &#125; if(myIPhone) &#123; myIPhone-&gt;call(&quot;123&quot;); delete myIPhone; myIPhone = NULL; &#125; &#125; 这就是简单工厂方法，把所有的创建交给 creator,creator 通过 switch-case(或者 if-else)语句来选择具体创建的对象。简单明了。但是就如上面所说，它最致命的问题的违背了开放-封闭原则。每次你要新添加一个功能，都要修改 factor 里面的 createPhone 代码。 但是工厂方法模式可以解决这个问题。 工厂方法模式个人觉得工厂方法模式在工厂模式家族中是用的最多模式。上面说过了，如果简单工厂模式，要添加一个新功能，比如我现在要增加 WinPhone 的生产，那么我要修改 PhoneFactory 中的 createPhone 中的分支判断条件。这违背了开放-封闭原则，那为什么不能将创建方法放到子类中呢？工厂方法的定义就是：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。 工厂方法模式角色： 抽象工厂(Creator)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 具体工厂(Concrete Creator)角色：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。 抽象产品(Product)角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。 具体产品(Concrete Product)角色：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应 工厂方法模式 UML 图： 看定义看的晕乎乎的？那么我们来看代码：产品接口，以及其相应的子类。 123456789101112131415161718class Phone &#123; public: virtual ~Phone()&#123;&#125;;//在删除的时候防止内存泄露 virtual void call(string number) = 0; &#125;; class AndroidPhone : public Phone &#123; public: void call(string number)&#123; cout&lt;&lt;&quot;AndroidPhone is calling...&quot;&lt;&lt;endl;&#125; &#125;; class iOSPhone : public Phone &#123; public: void call(string number) &#123; cout&lt;&lt;&quot;iOSPhone is calling...&quot;&lt;&lt;endl;&#125; &#125;; 上面这个和简单工厂方法还是一样的。接下来不一样的来了… 123456789101112131415161718192021222324class PhoneFactory &#123; public: virtual ~PhoneFactory()&#123;&#125;; virtual Phone* createPhone() = 0; &#125;; class AndroidPhoneFactory : public PhoneFactory &#123; public: virtual Phone* createPhone() &#123; return new AndroidPhone(); &#125; &#125;; class IosPhoneFactory : public PhoneFactory &#123; public: virtual Phone* createPhone() &#123; return new IosPhone(); &#125; &#125;; 工厂方法将 PhoneFactory 抽象成了基类，PhoneFactory 的 createPhone 不在像以前那样将所有的判断塞到里面。而是改由其子类来实现创建功能，这感觉就是权力下放。客户端： 1234567891011121314151617181920212223void main() &#123; PhoneFactory* androidCreator = new AndroidPhoneFactory(); PhoneFactory* iosCreator = new IosPhoneFactory(); Phone* myAndroid = androidCreator-&gt;createPhone(); Phone* myIPhone = iosCreator-&gt;createPhone(); if(myAndroid) &#123; myAndroid-&gt;call(&quot;123&quot;); delete myAndroid; myAndroid = NULL; &#125; if(myIPhone) &#123; myIPhone-&gt;call(&quot;123&quot;); delete myIPhone; myIPhone = NULL; &#125; delete androidCreator; delete iosCreator; &#125; 在工厂方法模式中，核心工厂类不在负责产品的创建，而是将具体的创建工作交给子类去完成。也就是后所这个核心工厂仅仅只是提供创建的接口，具体实现方法交给继承它的子类去完成。当我们的系统需要增加其他新功能时，只需要继承 PhoneFactory 这个类，并且实现 createPhone 接口。 不需要对原工厂 PhoneFactory 进行任何修改，这样很好地符合了“开放-封闭“原则。 虽然工厂方法模式满足了”开放-封闭”原则，但是这个模式也仍然有缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 抽象工厂模式在工厂方法模式中，其实我们有一个潜在意识的意识。那就是我们生产的都是同一类产品，例如我们生产的都是手机！那么现在假如现在我们又要生产平板了了呢？那么就要用到抽象工厂模式。我抽象工厂模式也用的比较多在工厂模式家族中，仅次于工厂方法模式。在了解抽象工厂模式之前，还是老生常谈的理清下产品等级结构和产品簇的概念。下面的图还是老图。但是我讲讲我的理解： 产品等级结构：产品的等级结构也就是产品的继承结构。我理解就是同一类产品，比如手机是一个系列，有 android 手机，ios 手机，win 手机，那么这个抽象类手机和他的子类就构成了一个产品等级结构。那其他的平板显然不是和手机一个系列的，一个平板，一个是手机，所以他们是不同的产品等级结构。 产品族: 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。比如分为 android 产品，和 ios 产品。其中一个 ios 产品包含 ios 手机和 ios 平板。显然 ios 手机和 ios 平板不是同一个产品等级结构的，因为一个是手机，一个是平板。但他们是同一个产品簇—都是 ios 产品。希望大家通过上面的例子大家明白了这两个概念。 抽象工厂模式的 UML 图： 接着上面的话题，现在假如我要增加对平板的支持，那么我们肯定先添加两个产品等级结构，一个是手机，一个是平板： 123456789101112131415161718192021222324252627282930313233343536373839//产品等级结构--手机 class Phone &#123; public: virtual ~Phone()&#123;&#125;;//在删除的时候防止内存泄露 virtual void call(string number) = 0; &#125;; class AndroidPhone : public Phone &#123; public: void call(string number)&#123; cout&lt;&lt;&quot;AndroidPhone is calling...&quot;&lt;&lt;endl; &#125; &#125;; class IosPhone : public Phone &#123; public: void call(string number) &#123; cout&lt;&lt;&quot;IosPhone is calling...&quot;&lt;&lt;endl; &#125; &#125;; //产品等级结构--平板 class Pad &#123; public: virtual ~Pad()&#123;&#125;; virtual void playMovie() = 0; &#125;; class AndroidPad : public Pad &#123; public: virtual void playMovie()&#123; cout&lt;&lt;&quot;AndriodPad is playing movie...&quot;&lt;&lt;endl; &#125; &#125;; class IosPad : public Pad &#123; public: virtual void playMovie()&#123; cout&lt;&lt;&quot;IosPad is playing movie...&quot;&lt;&lt;endl; &#125; &#125;; 然后具体的工厂我们整个工厂是生产移动设备的所以我们取名为 MobileFactory,然后工厂可以生产平板和手机，故有了 createPhone 和 createPad 两个接口。 1234567class MobileFactory &#123; public: virtual ~MobileFactory()&#123;&#125;; virtual Phone* createPhone() = 0; virtual Pad* createPad() = 0; &#125;; 接着是 android 产品簇 的工厂类，负责生产 android 的手机和平板： 123456789101112class AndroidFactory : public MobileFactory &#123; public: Phone* createPhone() &#123; return new AndroidPhone(); &#125; Pad* createPad() &#123; return new AndroidPad(); &#125; &#125;; 接着是 ios 的产品簇的工厂类，负责生产 ios 的手机和平板： 12345678910111213class IosFactory : public MobileFactory &#123; public: Phone* createPhone() &#123; return new IosPhone(); &#125; Pad* createPad() &#123; return new IosPad(); &#125; &#125;; 最后客户端这样实现： 12345678910111213141516void main() &#123; MobileFactory* androidCreator = new AndroidFactory(); MobileFactory* iosCreator = new IosFactory(); Phone* myAndroidPhone = androidCreator-&gt;createPhone(); Pad* myAndroidPad = androidCreator-&gt;createPad(); Phone* myIosPhone = iosCreator-&gt;createPhone(); Pad* myIosPad = iosCreator-&gt;createPad(); myAndroidPhone-&gt;call(&quot;123&quot;); myAndroidPad-&gt;playMovie(); myIosPhone-&gt;call(&quot;123&quot;); myIosPad-&gt;playMovie(); //这里没有做释放和判断，请自己判断和释放 &#125; 总结：抽象工厂模式适用于那些有多种产品的产品簇，并且每次使用其中的某一产品簇的产品。缺点 ： 抽象工厂模式的添加新功能也非常麻烦，比工厂方法模式都还要复杂的多。优点： 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象 主要用途工厂方法要解决的问题是对象的创建时机，它提供了一种扩展的策略，很好地符合了开放封闭原则。工厂方法也叫做虚构造器（Virtual Constructor）。 什么时候使用工厂方法当是如下情况是，可以使用工厂方法：一个类不知道它所必须创建的对象的类时，一个类希望有它的子类决定所创建的对象时。 更多关于工厂方法的介绍，可以参考本文最后给出的参考内容。下面我们就来看看在 iOS 中工厂方法的一种实现方法。 iOS 中工厂方法的实现实例如下有一个类图，该图描述了下面即将实现的工厂方法（利用工厂方法，创建出不同的形状）。其中 BVShapeFactory 为工厂方法的基类，BVShape 为形状的基类，BVClient 通过 BVShapeFactory，利用 BVShapeFactory 的子类（BVCircleShapeFactory 和 BVSquareShapeFactory）分别创建出 BVCircleShape 和 BVSquareShape。 github 下载地址:https://github.com/BeyondVincent/ios_patterns/tree/master/FactoryMethodPattern 参考资料 iOS 设计模式——工厂方法（简单工厂模式，工厂方法模式， 抽象工厂模式） iOS 设计模式(03):工厂方法 Objective-C 类族和工厂模式 Objective C Design Patterns - Factory Class Factory Methods–Apple iOS Design Patterns–raywenderlich Abstract Factory Design Pattern Objective C The factory design pattern explained by example-php Design Patterns Series, Day 3: Factory and Singleton Patterns–safaribooksonline Automagic Factories in Objective-C–bobmccune 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.wangruofeng007.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"工厂模式","slug":"工厂模式","permalink":"https://blog.wangruofeng007.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"}]},{"title":"多线程之 NSThread","slug":"2016-01-13-duo-xian-cheng-zhi-nsthread","date":"2016-01-12T21:36:48.000Z","updated":"2024-11-03T05:40:58.061Z","comments":true,"path":"2016/01/13/2016-01-13-duo-xian-cheng-zhi-nsthread/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-duo-xian-cheng-zhi-nsthread/","excerpt":"","text":"前言每个 iOS 应用程序都有个专门用来更新显示 UI 界面、处理用户触摸事件的主线程，因此不能将其他太耗时的操作放在主线程中执行，不然会造成主线程堵塞(出现卡机现象)，带来极坏的用户体验。一般的解决方案就是将那些耗时的操作放到另外一个线程中去执行，多线程编程是防止主线程堵塞，增加运行效率的最佳方法。 iOS 中有 3 种常见的多线程编程方法 NSThread 这种方法需要管理线程的生命周期、同步、加锁问题，会导致一定的性能开销 NSOperation 和 NSOperationQueue 是基于 OC 实现的。NSOperation 以面向对象的方式封装了需要执行的操作，然后可以将这个操作放到一个 NSOperationQueue 中去异步执行。不必关心线程管理、同步等问题。 Grand Centeral Dispatch 简称 GCD，iOS4 才开始支持，是纯 C 语言的 API。自 iPad2 开始，苹果设备开始有了双核 CPU，为了充分利用这 2 个核，GCD 提供了一些新特性来支持多核并行编程 这篇文章简单介绍 NSThread 这 个类，一个 NSThread 实例就代表着一条线程 获取当前线程1NSThread *current = [NSThread currentThread]; 获取主线程12NSThread *main = [NSThread mainThread]; NSLog(@&quot;主线程:%@&quot;, main); 打印结果是： 2013-04-18 21:36:38.599 thread[7499:c07] 主线程:&lt;NSThread: 0x71434e0&gt;{name &#x3D; (null), num &#x3D; 1} num 相当于线程的 id，主线程的 num 是为 1 的 NSThread 的创建a.动态方法 (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument; 在第 2 行创建了一条新线程，然后在第 4 行调用 start 方法启动线程，线程启动后会调用 self 的 run: 方法，并且将@”mj”作为方法参数 1234// 初始化线程NSThread *thread = [[[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@&quot;mj&quot;] autorelease];// 开启线程[thread start]; 假如 run:方法是这样的： 1234- (void)run:(NSString *)string &#123; NSThread *current = [NSThread currentThread]; NSLog(@&quot;执行了 run:方法-参数：%@，当前线程：%@&quot;, string, current);&#125; 打印结果为： 2013-04-18 21:40:33.102 thread[7542:3e13] 执行了 run:方法-参数：mj，当前线程：&lt;NSThread: 0x889e8d0&gt;{name &#x3D; (null), num &#x3D; 3} 可以发现，这条线程的 num 值为 3，说明不是主线程，主线程的 num 为 1 b.静态方法1+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument; 1[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;mj&quot;]; c.隐式创建线程1[self performSelectorInBackground:@selector(run:) withObject:@&quot;mj&quot;]; 会隐式地创建一条新线程，并且在这条线程上调用 self 的 run:方法，以@”mj”为方法参数 暂停当前线程1[NSThread sleepForTimeInterval:2]; 12NSDate *date = [NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]]; [NSThread sleepUntilDate:date]; 上面两种做法都是暂停当前线程 2 秒 线程的其他操作a.在指定线程上执行操作1[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES]; 上面代码的意思是在 thread 这条线程上调用 self 的 run 方法 最后的 YES 代表：上面的代码会阻塞，等 run 方法在 thread 线程执行完毕后，上面的代码才会通过 b.在主线程上执行操作1[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES]; 在主线程调用 self 的 run 方法 c.在当前线程执行操作1[self performSelector:@selector(run) withObject:nil]; 在当前线程调用 self 的 run 方法 优缺点 优点： NSThread 比其他多线程方案较轻量级，更直观地控制线程对象 缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"多线程","slug":"多线程","permalink":"https://blog.wangruofeng007.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"NSThread","slug":"NSThread","permalink":"https://blog.wangruofeng007.com/tags/NSThread/"}]},{"title":"NSOperation and NSOperationQueue Tutorial in Swift","slug":"2016-01-13-nsoperation-and-nsoperationqueue-tutorial-in-swift","date":"2016-01-12T21:18:36.000Z","updated":"2024-11-03T06:26:13.825Z","comments":true,"path":"2016/01/13/2016-01-13-nsoperation-and-nsoperationqueue-tutorial-in-swift/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-nsoperation-and-nsoperationqueue-tutorial-in-swift/","excerpt":"","text":"译自 Written by Richard Turton — on October 7, 2014 原文链接：http://www.raywenderlich.com/76341/use-nsoperation-nsoperationqueue-swift 译者@oneruofeng Post info: Updated for Xcode 7.1 and Swift 2.1 – 1 January 2016Update note: This tutorial was updated to iOS 8, Xcode 6.1 and Swift by Richard Turton.Original post by Tutorial Team member Soheil Azarpour. 每个人都有点击一个按钮或者进入一些文本在 iOS 或者 Mac App 上的令人沮丧的经历，就是突然-WHAM，用户交互停止了响应。 在 Mac 上，你的用户开始盯着一个沙漏或者一个七彩的轮子开始旋转直到它们再次恢复 UI 交互为止。在一个 iOS app 中，用户期望 App 立即响应它们的触摸事件，无响应的 app 给人的感觉是笨重和缓慢，这样通常会导致收到差评。 保持你的 app 的可交互的状态说起来容易做起来难，一旦你的 app 需要执行不仅仅是少量的任务，事情很快就变得很复杂，我们并没有多少事件在主事件循环执行繁重的工作并且同时提供一个可以响应的 UI。 低级的开发者是怎样做的呢？解决方案就是把工作从主线程中移除通过并发。并发意味着你应用所有的操作同时执行在多个流（或者线程）中–这样的话用户界面就能保持响应的要执行的工作。 一种实现并发操作在 iOS 是通过 NSOperation 和 NSOperationQueue 这两个类。在这个教程中，你将学会怎样使用它们！你将从一个没有使用并发的 App 开始，所以它将出现的非常迟钝和无响应。然后你将重做你的应用给它们添加并发操作并且–希望–呈现一个更加响应良好的可交互界面给用户！ 我们开始吧这份样品工程的总的目标的就是展示一个滤镜处理过的图片的表视图。图片将从网络上下载，经过一个滤镜处理后，然后在表视图中显示。 下面是这个 app 模型的示意图 第一个版本尝试下载你将在这个教程中使用的第一个版本的项目 注意：所以的图片来自 stock.xchng.。一下图片在数据源故意错误命名，以便这里有些例子是图片下载失败好处理失败的情况。 构建并且运行这个工程，最终你将看到这个 app 运行起来显示一列照片。尝试滚动这个列表，很痛苦，不是吗？ 传统的相册，运行缓慢 所有的操作都发生在 ListViewController.swift 里，并且最主要的是发生在 tableView(_:cellForRowAtIndexPath:) 方法里。看一下那个方法和注释这里有两件相当集中的事情需要思考： 从网络载入图片数据 。即使网络状况良好，app 将仍然必须等待直到下载完成了才能继续。 使用Core Image给图片加滤镜。这个方法给图片应用一个深褐色的滤镜，假如你想了解更多关于 Core Image 滤镜的知识，请点击Beginning Core Image in Swift 还有，你将载入一系列图片请求从网络当它第一次被请求时: 1lazy var photos = NSDictionary(contentsOfURL:dataSourceURL) 所有的工作发生在应用的主线程。由于主线程也负责用户交互，让它一直忙于从网络下载东西和给图片加滤镜消磨掉了响应中的 app。你可以通过使用 Xcode 的仪表测量视图获得这样一个快速的概述。你可以通过显示 调试导航 (Commnad+6)接入这个仪表视图,让后选择 CPU 当 app 正在运行的时候。 Xcode 的仪表视图表明，主线程的任务非常重 你会看到那些所有的长钉在 Thread 1 ，那就是 app 的主线程。更多详细的信息你可以运行 app 的 Instruments ,但是那个在 whole other tutorial :].中 是时候考虑怎样改善一下你的用户体验了！ 任务，线程和进程在你专研这篇教程之前，这里有一下技术上的慨念需要理一下，我将定义一些专用术语： 任务 ：一个简单单个的需要完成的工作 线程 ：操作系统提供的机制允许多个用户操作同时进行在一个应用中 进程 ：一个可执行的代码块，它可以由多个线程构成 注意：在 iOS 和 OS X 中，线程的功能由 POSIX 线程 API（或者 pthreads）实现，并且它使操作系统的一部分。而这个又是相当底层的东西，你将发现它很容易犯错误；或许关于线程最糟糕的事情是那些很难被发现的错误！ Foundation 框架包含了一个叫做 NSThread 的类，这让我们处理事情更容易，但是用 NSThread 管理多个线程仍是一件令人头疼的事情。 NSOperation 和 NSOperationQueue 是为了最大化简化处理多线程的更高级的类。 在这个图解中，你会看到进程，线程和任务之间的关系： 进程，线程和任务 正如你所见，一个进程可以包涵多个执行的线程，每个线程能够同时执行多个任务。 在这个图集中, thread 2 执行文件的读的工作，同时 thread 1 执行 UI 相关的代码。这和你应该怎样在 iOS 中构建你的代码（主线程执行任何和 UI 相关的工作，第二线程应当执行慢的或者长时间运行的耗时操作例如读取文件，接入网络等等）有点相似。 NSOperation vs. Grand Central Dispatch (GCD)你应该听说过Grand Central Dispatch (GCD).。简单的来说， GCD 由语言的特征，运行时库和系统增强组成来提供一个在 iOS 和 OS X 多核硬件中支持并发系统并且综合的改良。假如你想了解更多关于 GCD 相关的知识，有可以阅读我们的Multithreading and Grand Central Dispatch on iOS for Beginners Tutorial。 NSOperation 和 NSOperationQueue 构建在GCD之上。普遍来说，苹果推荐使用最高级别抽象，当需要显示他们一些需要的测量工作时回到最底层。 下面是关于这两者的一些简单比较，将帮助你决定何时何地选择使用 GCD 或者 NSOperation ： GCD 是一个轻量级的方式来描述将要被并发执行的工作单元。你不必定制这个工作单元的时刻表；系统为你定制时刻表。在 blocks 中增加依赖是一件头疼的事情。取消或者暂停一个 block 来进行额外的工作为作为开发者的你！ :] NSOperation 和 GCD 相比增加了一些额外开支，但是你能够在各种操作之间增加依赖并且恢复，取消，暂停他们。 这个教程将使用 NSOperation ,因为你将处理一个列表为了好的表现并且由于它大量的消耗的资源你需要能够取消一个操作针对某个图片，假如用户已经将那张图片滚出屏幕。即使这些操作在后台线程，假如这里有一打事情在队列里等着它们去处理，这将表现得跟糟糕。 重构 App Model是时候重构开始的非多线程的模型了！假如你仔细观察先前的模型，你会发现这里有三个可以被改进的线程受困区域。通过切割这三个区域让后把他们放在单独的线程里，主线程的压力将得到缓解并且能够保持和用户交互。 改进后的 model 为了摆脱你应用的瓶颈，你需要一个指定一个线程来响应你的用户时间，一个线程专注于下载资源和图片，一个线程执行图片滤镜操作。在新的模型中，app 从主线程启动让后载入一个空的表视图。同时，app 启动第二个线程开始下载数据资源。 一旦数据资源下载完成，你将通知表视图重新载入。这些事情必须在主线程完成，因为它涉及到用户界面相关的操作。从这一点来说，表视图知道有多少行，并且它知道他将显示图片的 URL 地址，但是她不知道它是否真的有图片！假如你立即开始下载所有的图片在这个点上，这可能导致效率极其低下，因为你不需要一次性把所有图片下载完！ 为了让这个变得更好我们能够做什么？ 一个更好的模型就是可交互的行在屏幕范围内可见时才开始下载图片。所以你的代码开始将询问表视图有多少行可见。因此，代码应该直到这里有一个未加滤镜的图片等待处理时才开始处理图片加滤镜操作。 为了使 app 更加快速响应，代码将要让图片一旦下载完毕立即显示。让后才开始进行图片加滤镜操作，让后更新 UI 界面来显示已经经过滤镜处理后的图片。下面的图标显示了这个过程的控制流： Cotroll Flow 为了获得这些对象，你需要跟踪这张图片现在是否正在被下载，一旦完成下载，假如图片的滤镜被应用上。你需要跟跟踪每个操作的状态，它是否正在下载中或者执行滤镜操作，以便你能够取消，暂停或者恢复每个操作当用户滚动的时候。 Okey！ 现在你准备好开始码代码了！ :] 打开你下载的工程，添加一个新的Swift File到你的工程中命名为** PhotoOperations.swift**。添加下面代码： 1234567891011121314151617class PendingOperations &#123; lazy var downloadsInProgress = [NSIndexPath:NSOperation]() lazy var downloadQueue:NSOperationQueue = &#123; var queue = NSOperationQueue() queue.name = &quot;Download queue&quot; queue.maxConcurrentOperationCount = 1 return queue &#125;() lazy var filtrationsInProgress = [NSIndexPath:NSOperation]() lazy var filtrationQueue:NSOperationQueue = &#123; var queue = NSOperationQueue() queue.name = &quot;Image Filtration queue&quot; queue.maxConcurrentOperationCount = 1 return queue &#125;()&#125; 这回类包含了 2 个字典为了跟踪激活和正在进行中的下载和滤镜操作对表中的每一行，并且两个操作队列都有各自的操作类型。 所有的值被懒加载的方式创建，意味着他们不会被初始化知道他们第一次被接入。这样改善了你 app 的表现性能。 创建一个 NSOperationQueue 是非常简单的，正如你所见，给你的队列命名是非常有用的，因为名字会在仪器或者调速器中显示。 maxConcurrentOperationCount 在这里由于这个教程的缘故被设置成 1，是为了让你看到操作一个接一个完成。你可以离开这一部分允许队列决定他一次处理多少个操作–这样会进一步改善性能。 队列是怎样决定一次运行多少个操作的呢？这是一个非常好的问题！ :] 这取决于硬件。默认， NSOperationQueue 将要处理一写计算在屏幕背后，决定什么是最好的需要看代码是运行在某个具体的平台，和将载入的最大数量的线程数。 考虑到下面的例子，假设系统此时是空闲的，这里有很多资源可用，所以这个队列能够载入可能 8 条并发的线程。下一个时刻你运行程序，系统可能忙于其他不相关的正在抢夺资源的操作，这时队列就仅仅载入 2 个并发的线程。因为你已经设置了一个最大并发操作数，在这个 app 中一次只会进行一个操作。 注意：你可能想知道为什么你必须跟踪所有的激活的和正在进行中操作。队列有一个 operations 的方法，它将返回一个操作的数组，所有为什么不用它呢？在这个工程中这样做效果不是很好。你需要跟踪更表视图行数关联的操作，它可能会重复执行数组每次你需要一个的时候。把它们储存在一个字典中用 index path 来作为他的 key 方便快速和高效的查找。 是时候考虑下载和过滤操作了。添加下列代码到 PhotoOperations.swift: 文件的末尾： 1234567891011121314151617181920212223242526272829303132333435class ImageDownloader: NSOperation &#123; //1 let photoRecord: PhotoRecord //2 init(photoRecord: PhotoRecord) &#123; self.photoRecord = photoRecord &#125; //3 override func main() &#123; //4 if self.cancelled &#123; return &#125; //5 let imageData = NSData(contentsOfURL:self.photoRecord.url) //6 if self.cancelled &#123; return &#125; //7 if imageData?.length &gt; 0 &#123; self.photoRecord.image = UIImage(data:imageData!) self.photoRecord.state = .Downloaded &#125; else &#123; self.photoRecord.state = .Failed self.photoRecord.image = UIImage(named: &quot;Failed&quot;) &#125; &#125;&#125; NSOperation 是一个抽象类，为它的子类而设计。每个子类代表了一个特别的 任务 正如呈现在列表早期那样。 下面是上面代码每行注释到底发生了什么的说明： 添加一个常量引用到和操作相关的 PhotoRecord 对象 创建一个设计初始化方法允许 photo record 参数可以被传进来 main 是你在 NSOperation 子类中需要重写的方法，用来执行相关工作 在启动开始前检查是否被取消，操作应该定期检查是否已经被取消在尝试长时间或密集的工作之前 下载图片数据 再次检查是否被取消 假如这里有数据，创建一个图片对象然后把它添加到记录中，同时改变它的状态，假如这里没有数据，把这条记录标记成失败然后设置适当的图片 下一步，你将创建另一个操作来处理图片加滤镜的操作！添加下面的代码到 PhotoOperations.swift 文件末尾： 12345678910111213141516171819202122class ImageFiltration: NSOperation &#123; let photoRecord: PhotoRecord init(photoRecord: PhotoRecord) &#123; self.photoRecord = photoRecord &#125; override func main () &#123; if self.cancelled &#123; return &#125; if self.photoRecord.state != .Downloaded &#123; return &#125; if let filteredImage = self.applySepiaFilter(self.photoRecord.image!) &#123; self.photoRecord.image = filteredImage self.photoRecord.state = .Filtered &#125; &#125;&#125; 除了你对图片应用滤镜（使用一个未实现的方法，因此编译 1 错误）而不是下载它之外，这个看起来和下载操作非常相像。 添加遗失的图片滤镜处理方法到 ImageFiltration 类中: 1234567891011121314151617181920(image:UIImage) -&gt; UIImage? &#123; let inputImage = CIImage(data:UIImagePNGRepresentation(image)) if self.cancelled &#123; return nil &#125; let context = CIContext(options:nil) let filter = CIFilter(name:&quot;CISepiaTone&quot;) filter.setValue(inputImage, forKey: kCIInputImageKey) filter.setValue(0.8, forKey: &quot;inputIntensity&quot;) let outputImage = filter.outputImage if self.cancelled &#123; return nil &#125; let outImage = context.createCGImage(outputImage, fromRect: outputImage.extent()) let returnImage = UIImage(CGImage: outImage) return returnImage&#125; 图片添加滤镜操作使用先前 ListViewController 中相同的实现。已经把它移动到这里来了以至于它它能在后台的一个单独的操作中完成。再次强调，你应该非常频繁的检查取消操作；最佳实践是在进行任何耗时操作调用之前和之后。一旦加滤镜操作完成，你应该立即设置 photo record 实例的值。 很棒！现在你已经有了所有的工具和基础为了处理后台任务进程的操作。是时候回到控制器修改它以便能利用所有这些新的福利。 切换到 ListViewController.swift 文件，然后删除 lazy var photos 接口声明。添加下面声明： 12var photos = [PhotoRecord]()let pendingOperations = PendingOperations() 这些将持有一个数组的你在开始创建的 PhotoDetails 对象， PendingOperations 对象来管理操作。 添加一个下载 photos property 列表新的方法到类中： 123456789101112131415161718192021222324252627func fetchPhotoDetails() &#123; let request = NSURLRequest(URL:dataSourceURL!) UIApplication.sharedApplication().networkActivityIndicatorVisible = true NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue()) &#123;response,data,error in if data != nil &#123; let datasourceDictionary = NSPropertyListSerialization.propertyListWithData(data, options: Int(NSPropertyListMutabilityOptions.Immutable.rawValue), format: nil, error: nil) as! NSDictionary for(key : AnyObject,value : AnyObject) in datasourceDictionary &#123; let name = key as? String let url = NSURL(string:value as? String ?? &quot;&quot;) if name != nil &amp;&amp; url != nil &#123; let photoRecord = PhotoRecord(name:name!, url:url!) self.photos.append(photoRecord) &#125; &#125; self.tableView.reloadData() &#125; if error != nil &#123; let alert = UIAlertView(title:&quot;Oops!&quot;,message:error.localizedDescription, delegate:nil, cancelButtonTitle:&quot;OK&quot;) alert.show() &#125; UIApplication.sharedApplication().networkActivityIndicatorVisible = false &#125;&#125; 这个方法创建一个异步的网络请求，当完成的时候，将执行 completion block 在主线程。当下载完成 property list 的数据被萃取成一个 NSDictionary ,然后再次处理一个数组的 PhotoRecord 的对象。你不能直接使用这里的 NSOperation ,你应该在主线程中接入它使用 NSOperationQueue.mainQueue() 。 在 viewDidLoad 调用新方法 fetchPhotoDetails() 下一步找到 tableView(_:cellForRowAtIndexPath:) 然后替换它用下面的实现： 12345678910111213141516171819202122232425262728293031override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCellWithIdentifier(&quot;CellIdentifier&quot;, forIndexPath: indexPath) as! UITableViewCell //1 if cell.accessoryView == nil &#123; let indicator = UIActivityIndicatorView(activityIndicatorStyle: .Gray) cell.accessoryView = indicator &#125; let indicator = cell.accessoryView as! UIActivityIndicatorView //2 let photoDetails = photos[indexPath.row] //3 cell.textLabel?.text = photoDetails.name cell.imageView?.image = photoDetails.image //4 switch (photoDetails.state)&#123; case .Filtered: indicator.stopAnimating() case .Failed: indicator.stopAnimating() cell.textLabel?.text = &quot;Failed to load&quot; case .New, .Downloaded: indicator.startAnimating() self.startOperationsForPhotoRecord(photoDetails,indexPath:indexPath) &#125; return cell&#125; 花点时间来通读注释区域下面的解释： 为了给用户提供反馈，创建 UIActivityIndicatorView 让后把它设成 cell 的 accessory view。 数据源包含 PhotoRecord 实例。抓取正确的数据基于当前行的 indexPath 。 cell 的文本标签总是一样的，图片被正确的设置在 PhotoRecord 中当它被处理的时候，以便你能够设置他们两者，而不管记录的状态。 检查记录，正确的设置 activity indicator 和文本，然后开始操作（暂时还没实现） 你可以移除 applySepiaFilter 的实现，因为那个将不再被调用了，添加下面的方法到类中来开始操作： 12345678910func startOperationsForPhotoRecord(photoDetails: PhotoRecord, indexPath: NSIndexPath)&#123; switch (photoDetails.state) &#123; case .New: startDownloadForRecord(photoDetails, indexPath: indexPath) case .Downloaded: startFiltrationForRecord(photoDetails, indexPath: indexPath) default: NSLog(&quot;do nothing&quot;) &#125;&#125; 这里，你将传递一个 PhotoRecord 类型的实例带有它的 index path 。依据 photo record 的状态，你选开始进行下载还是加滤镜的步骤。 注意：下载图片和给图片加滤镜的方法分开实现，因为这里有可能出现当一个图片正在被下载，用户可能把它滚开了，这样你就不必对它应用滤镜操作。当下一次用户又来到相同的哪行时，你不必重新下载图片；你只需对它应用图片滤镜即可！ Efficiency rocks! :] 现在你需要实现你在上面调用的方法。记住你创建的自定义的类， PendingOperations ,保持跟踪操作；现在实际上你可以使用它了！添加下面的方法到类中： 123456789101112131415161718192021222324252627282930313233343536373839404142func startDownloadForRecord(photoDetails: PhotoRecord, indexPath: NSIndexPath)&#123; //1 if let downloadOperation = pendingOperations.downloadsInProgress[indexPath] &#123; return &#125; //2 let downloader = ImageDownloader(photoRecord: photoDetails) //3 downloader.completionBlock = &#123; if downloader.cancelled &#123; return &#125; dispatch_async(dispatch_get_main_queue(), &#123; self.pendingOperations.downloadsInProgress.removeValueForKey(indexPath) self.tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .Fade) &#125;) &#125; //4 pendingOperations.downloadsInProgress[indexPath] = downloader //5 pendingOperations.downloadQueue.addOperation(downloader)&#125;func startFiltrationForRecord(photoDetails: PhotoRecord, indexPath: NSIndexPath)&#123; if let filterOperation = pendingOperations.filtrationsInProgress[indexPath]&#123; return &#125; let filterer = ImageFiltration(photoRecord: photoDetails) filterer.completionBlock = &#123; if filterer.cancelled &#123; return &#125; dispatch_async(dispatch_get_main_queue(), &#123; self.pendingOperations.filtrationsInProgress.removeValueForKey(indexPath) self.tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .Fade) &#125;) &#125; pendingOperations.filtrationsInProgress[indexPath] = filterer pendingOperations.filtrationQueue.addOperation(filterer)&#125; Okey!下面是一个快速列表来帮助你立即上面的代码到底做了什么： 首先，检查特定的 indexPath 来看这里是否已经有一个操作在 downloadsInProgress 中。假如有，忽略它。 假如没有，通过 designated initializer 创建一个 ImageDownloader 实例 添加一个当操作完成时执行的完成 block。这是最好的地方让你其余的应用知道一个操作已经完成。注意完成 block 必须被执行即使这个操作被取消，这相当的重要，所以你需要使用 GCD 来触发重新载入表视图在主线程。 添加操作到 downloadsInProgress 中来保持跟踪一些事情。 添加操作到下载队列中。这是你实际获取这些操作开始运行的方法–队列需要注意的是一旦你添加了操作它就会执行。 过滤图片的方法遵循下面相同的类型，除了它使用 ImageFiltration 和 filtrationsInProgress 来跟踪操作。作为经验，你应该尝试不要重复这个区域的代码 :] 你做到了！你的工程完成了。构建让后运行看有什么改进在操作上！当你滚动表视图的时候，app 并没有停止，还是像它们变得可见一样继续下载图片和给图片加滤镜操作。 原来的图片，现在可以滚动了 是不是很酷？你能看到随做你的进步让你的应用更易于响应能做出的努力 –对用户来说更有趣！ 细微的调整你已经随着这个教程走过漫长的路！你的小项目现在反应灵敏表明了在原来的版本基础上有很多改进。然而，这里任然有一些遗留的细节我们需要考虑。你是想成为一名伟大的程序员，而不仅仅是一名优秀的程序员！ 你可能已经注意到了当你滚动表视图时，那些离屏的 cell 仍然在处理下载和给图片加滤镜的操作。假如你快速滚动，app 将忙于下载和给图片处理滤镜的操作，在列表中从最前面甚至到不可见的地方。理想的情况下 app 应该对离开屏幕的 cells 就是现在不可见的取消滤镜操作。 难道你没有把取消的规定放进你的代码里？ 是的，你做了–现在你应该充分利用它们！:] 回到 Xcode，让后打开 ListViewController.swift 文件。去到 tableView(_:cellForRowAtIndexPath:) 方法的实现，封装 startOperationsForPhotoRecord 调用在一个 if 条件向下面的： 123if (!tableView.dragging &amp;&amp; !tableView.decelerating) &#123; self.startOperationsForPhotoRecord(photoDetails, indexPath: indexPath)&#125; 你需要告诉表视图开始操作仅仅当表视图没有滚动的时候。这实际上是 UIScrollView 的接口，由于 UITableView 是 UIScrollView 的子类，你自动继承了这些接口。 下一步，添加到下面 UIScrollView 代理方法的实现到类中： 123456789101112131415161718override func scrollViewWillBeginDragging(scrollView: UIScrollView) &#123; //1 suspendAllOperations()&#125;override func scrollViewDidEndDragging(scrollView: UIScrollView, willDecelerate decelerate: Bool) &#123; // 2 if !decelerate &#123; loadImagesForOnscreenCells() resumeAllOperations() &#125;&#125;override func scrollViewDidEndDecelerating(scrollView: UIScrollView) &#123; // 3 loadImagesForOnscreenCells() resumeAllOperations()&#125; 快速走查上面的代码显示在下面： 当用户开始滚动，你想暂停所有的操作让后看看用户想看到什么。你将要实现 suspendAllOperations 在一会儿工夫。 假如 decelerate 的值是 false ,那就意味着停止拖拽表视图，因此你想恢复暂停的，因为 cell 离开屏幕取消的操作，启动在屏幕内 cells 的操作。你将要一起实现 loadImagesForOnscreenCells 和 resumeAllOperations 。 代理方法告诉你表视图已经停止滚动，所以你将做和#2 条相同的处理。 现在，添加下面这些遗失的方法的实现到 ListViewController.swift : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func suspendAllOperations () &#123; pendingOperations.downloadQueue.suspended = true pendingOperations.filtrationQueue.suspended = true&#125;func resumeAllOperations () &#123; pendingOperations.downloadQueue.suspended = false pendingOperations.filtrationQueue.suspended = false&#125;func loadImagesForOnscreenCells () &#123; //1 if let pathsArray = tableView.indexPathsForVisibleRows() &#123; //2 var allPendingOperations = Set(pendingOperations.downloadsInProgress.keys.array) allPendingOperations.unionInPlace(pendingOperations.filtrationsInProgress.keys.array) //3 var toBeCancelled = allPendingOperations let visiblePaths = Set(pathsArray as! [NSIndexPath]) toBeCancelled.subtractInPlace(visiblePaths) //4 var toBeStarted = visiblePaths toBeStarted.subtractInPlace(allPendingOperations) // 5 for indexPath in toBeCancelled &#123; if let pendingDownload = pendingOperations.downloadsInProgress[indexPath] &#123; pendingDownload.cancel() &#125; pendingOperations.downloadsInProgress.removeValueForKey(indexPath) if let pendingFiltration = pendingOperations.filtrationsInProgress[indexPath] &#123; pendingFiltration.cancel() &#125; pendingOperations.filtrationsInProgress.removeValueForKey(indexPath) &#125; // 6 for indexPath in toBeStarted &#123; let indexPath = indexPath as NSIndexPath let recordToProcess = self.photos[indexPath.row] startOperationsForPhotoRecord(recordToProcess, indexPath: indexPath) &#125; &#125;&#125; suspendAllOperations 和 resumeAllOperations 有一个简单的实现。 NSOperationQueues 能够被暂停，通过设置 suspended 接口为 true 。这将暂停队列里面的所有操作–你不能单独暂停一个操作。 loadImagesForOnscreenCells 有一点小复杂。这里发生了什么事？ 以一个包含了现在表视图可见的 index paths 的数组开始开始 构造一个所有进行中的操作的集合通过结合所有在下载的进度+所有在处理滤镜的进度。 构造一个 index paths 集合用来取消操作。开始所有的操作，然后移除可见行的 index paths ，这样讲留下一个离开屏幕的行正在执行的操作集合 构造一个 index paths 集合，需要操作启动，用所有可见行的 index paths 启动，让后移除它们中在进行的操作。 遍历那些被取消的操作，取消它们，然后移除它们的引用从 PendingOperations 。 遍历那些将要开始的操作，然后对他们每个调用 startOperationsForPhotoRecord 。 构建运行然后你发现一个更流畅，资源管理德更好的应用！给你自己一轮掌声！ 原来的相册，载入东西一次一个 注意到当你完成滚动表视图，在可见区域行的 cell 的图片立即开始处理。 何去何从？这里是completed version of the project。 注意：此教程写于 Update 17 April 2015: Updated for Xcode 6.3 and Swift 1.2 ,现在 Swift 最新版本 2.1 使用 Xcode7+以上编辑会报错，这里打包一个新语法修改版completed fixed version of the project。 假如你完成这个工程应该花时间来真正理解它，恭喜你！你可以认为你自己是一位更有价值 iOS 开发者了比起在教程刚开始的时候！大多数开发的公司是非常幸运的有一个或者两个人正在知道这个东西。 当时请当心 – 像多层嵌套的 blocks,不必要的使用多线程可能让一个工程变得难以理解对维护你代码的人来说。线程可能引入一些难以捉摸的 bugs，将永远不出现知道你网络非常慢，或者代码运行在一个更快（或更慢）的设备上，或一个不同数量的核的芯片上时。小心测试，尽量使用 Instruments （或者你自己的观察）来确定引入多线程真的有很大改进。 一个有用的特征使用操作时在这里没涉及到就是依赖（ dependency ）。你可以给一个操作添加一个或者更多的操作的依赖。这个操作不会开始直到它所有依赖的操作完成时。例如： 123456// MyDownloadOperation is a subclass of NSOperationlet downloadOperation = MyDownloadOperation()// MyFilterOperation is a subclass of NSOperationlet filterOperation = MyFilterOperation()filterOperation.addDependency(downloadOperation) 移除依赖： 1filterOperation.removeDependency(downloadOperation) 这个工程是否能使用依赖简化呢？把你学到的新技能用起来试一试 ：]有件非常重要的事需要注意的就是一个依赖操作将仍然启动假如它依赖的操作被取消，还有它将自然完成。你需要牢记在心。 假如你有任何评论或者问题关于这个教程或者 NSOperations ,请加Pull request。 译者注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"多线程","slug":"多线程","permalink":"https://blog.wangruofeng007.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://blog.wangruofeng007.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"NSOperation","slug":"NSOperation","permalink":"https://blog.wangruofeng007.com/tags/NSOperation/"}]},{"title":"多线程之 NSOperation","slug":"2016-01-13-duo-xian-cheng-zhi-nsoperation","date":"2016-01-12T21:14:59.000Z","updated":"2024-11-02T13:17:02.994Z","comments":true,"path":"2016/01/13/2016-01-13-duo-xian-cheng-zhi-nsoperation/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-duo-xian-cheng-zhi-nsoperation/","excerpt":"","text":"本文目录 前言 NSInvocationOperation NSBlokcOperation NSOperation的其他用法 自定义NSOperation 参考资料 前言1.虽然NSThread也可以实现多线程编程，但是需要我们去管理线程的生命周期，还要考虑线程同步、加锁问题，造成一些性能上的开销。我们也可以配合使用NSOperation和NSOperationQueue实现多线程编程，实现步骤大致是这样的 先将需要执行的操作封装到一个NSOperation对象中 然后将NSOperation对象添加到NSOperationQueue中 系统会自动将NSOperation中封装的操作放到一条新线程中执行在此过程中，我们根本不用考虑线程的生命周期、同步、加锁等问题下面列举一个应用场景，比如微博的粉丝列表： 每一行的头像肯定要从新浪服务器下载图片后才能显示的，而且是需要异步下载。这时候你就可以把每一行的图片下载操作封装到一个NSOperation对象中，上面有6行，所以要创建6个NSOperation对象，然后添加到NSOperationQueue中，分别下载不同的图片，下载完毕后，回到对应的行将图片显示出来。 2 .默认情况下，NSOperation并不具备封装操作的能力，必须使用它的子类，使用NSOperation子类的方式有3种： NSInvocationOperation NSBlockOperation 自定义子类继承NSOperation，实现内部相应的方法 这讲先介绍如何用NSOperation封装一个操作，后面再结合NSOperationQueue来使用。 NSInvocationOperation12NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run:) object:@&quot;mj&quot;];[operation start]; 第1行初始化了一个NSInvocationOperation对象，它是基于一个对象和selector来创建操作 第2行调用了start方法，紧接着会马上执行封装好的操作，也就是会调用self的run:方法，并且将@”mj”作为方法参数 这里要注意：默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作。只有将operation放到一个NSOperationQueue中，才会异步执行操作。 NSBlockOperationa.同步执行一个操作12345NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^()&#123; NSLog(@&quot;执行了一个新的操作&quot;); &#125;]; // 开始执行任务[operation start]; 第1行初始化了一个NSBlockOperation对象，它是用一个Block来封装需要执行的操作 第2行调用了start方法，紧接着会马上执行Block中的内容 这里还是在当前线程同步执行操作，并没有异步执行 b.并发执行多个操作123456789101112131415161718NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^()&#123; NSLog(@&quot;执行第1次操作，线程：%@&quot;, [NSThread currentThread]);&#125;];[operation addExecutionBlock:^() &#123; NSLog(@&quot;又执行了1个新的操作，线程：%@&quot;, [NSThread currentThread]);&#125;];[operation addExecutionBlock:^() &#123; NSLog(@&quot;又执行了1个新的操作，线程：%@&quot;, [NSThread currentThread]);&#125;];[operation addExecutionBlock:^() &#123; NSLog(@&quot;又执行了1个新的操作，线程：%@&quot;, [NSThread currentThread]);&#125;];// 开始执行任务[operation start]; 第1行初始化了一个NSBlockOperation对象 分别在第5、9、13行通过addExecutionBlock:方法添加了新的操作，包括第1行的操作，一共封装了4个操作 在第18行调用start方法后，就会并发地执行这4个操作，也就是会在不同线程中执行 1 2013-02-02 21:38:46.102 thread[4602:c07] 又执行了1个新的操作，线程：&lt;NSThread: 0x7121d50&gt;&#123;name = (null), num = 1&#125; 2 2013-02-02 21:38:46.102 thread[4602:3f03] 又执行了1个新的操作，线程：&lt;NSThread: 0x742e1d0&gt;&#123;name = (null), num = 5&#125; 3 2013-02-02 21:38:46.102 thread[4602:1b03] 执行第1次操作，线程：&lt;NSThread: 0x742de50&gt;&#123;name = (null), num = 3&#125; 4 2013-02-02 21:38:46.102 thread[4602:1303] 又执行了1个新的操作，线程：&lt;NSThread: 0x7157bf0&gt;&#123;name = (null), num = 4&#125; 可以看出，每个操作所在线程的num值都不一样，说明是不同线程 NSOperation的其他用法a.取消操作operation开始执行之后, 默认会一直执行操作直到完成，我们也可以调用cancel方法中途取消操作 [operation cancel]; b.在操作完成后做一些事情如果想在一个NSOperation执行完毕后做一些事情，就调用NSOperation的setCompletionBlock方法来设置想做的事情 operation.completionBlock = ^() &#123; NSLog(@&quot;执行完毕&quot;); &#125;; 当operation封装的操作执行完毕后，就会回调Block里面的内容 自定义NSOperation如果NSInvocationOperation和NSBlockOperation不能满足需求，我们可以直接新建子类继承NSOperation，并添加任何需要执行的操作。如果只是简单地自定义NSOperation，只需要重载-(void)main这个方法，在这个方法里面添加需要执行的操作。 下面写个子类DownloadOperation来下载图片 a.继承NSOperation，重写main方法DownloadOperation.h 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;@protocol DownloadOperationDelegate;@interface DownloadOperation : NSOperation// 图片的url路径@property (nonatomic, copy) NSString *imageUrl;// 代理@property (nonatomic, assign) id&lt;DownloadOperationDelegate&gt; delegate;- (id)initWithUrl:(NSString *)url delegate:(id&lt;DownloadOperationDelegate&gt;)delegate;@end// 图片下载的协议@protocol DownloadOperationDelegate &lt;NSObject&gt;- (void)downloadFinishWithImage:(UIImage *)image;@end DownloadOperation.m 12345678910111213141516171819202122232425262728#import &quot;DownloadOperation.h&quot;@implementation DownloadOperation@synthesize delegate = _delegate;@synthesize imageUrl = _imageUrl;// 初始化- (id)initWithUrl:(NSString *)url delegate:(id&lt;DownloadOperationDelegate&gt;)delegate &#123; if (self = [super init]) &#123; self.imageUrl = url; self.delegate = delegate; &#125; return self;&#125;// 释放内存- (void)dealloc &#123; [super dealloc]; [_imageUrl release];&#125;// 执行主任务- (void)main &#123; // 新建一个自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池 @autoreleasepool &#123; // .... &#125;&#125;@end 在第22行重载了main方法，等会就把下载图片的代码写到这个方法中 如果这个DownloadOperation是在异步线程中执行操作，也就是说main方法在异步线程调用，那么将无法访问主线程的自动释放池，所以在第24行创建了一个属于当前线程的自动释放池 b.正确响应取消事件 默认情况下，一个NSOperation开始执行之后，会一直执行任务到结束，就比如上面的DownloadOperation，默认会执行完main方法中的所有代码 NSOperation提供了一个cancel方法，可以取消当前的操作。 如果是自定义NSOperation的话，需要手动处理这个取消事件。比如，一旦调用了cancel方法，应该马上终止main方法的执行，并及时回收一些资源。 处理取消事件的具体做法是：在main方法中定期地调用isCancelled方法检测操作是否已经被取消，也就是说是否调用了cancel方法，如果返回YES，表示已取消，则立即让main方法返回。 以下地方可能需要调用isCancelled方法: 在执行任何实际的工作之前，也就是在main方法的开头。因为取消可能发生在任何时候，甚至在operation执行之前。 执行了一段耗时的操作之后也需要检测操作是否已经被取消 1234567891011121314151617181920212223242526272829- (void)main &#123; // 新建一个自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池 @autoreleasepool &#123; if (self.isCancelled) return; // 获取图片数据 NSURL *url = [NSURL URLWithString:self.imageUrl]; NSData *imageData = [NSData dataWithContentsOfURL:url]; if (self.isCancelled) &#123; url = nil; imageData = nil; return; &#125; // 初始化图片 UIImage *image = [UIImage imageWithData:imageData]; if (self.isCancelled) &#123; image = nil; return; &#125; if ([self.delegate respondsToSelector:@selector(downloadFinishWithImage:)]) &#123; // 把图片数据传回到主线程 [(NSObject *)self.delegate performSelectorOnMainThread:@selector(downloadFinishWithImage:) withObject:image waitUntilDone:NO]; &#125; &#125;&#125; 在第4行main方法的开头就先判断operation有没有被取消。如果被取消了，那就没有必要往下执行了 经过第8行下载图片后，在第10行也需要判断操作有没有被取消 总之，执行了一段比较耗时的操作之后，都需要判断操作有没有被取消 图片下载完毕后，在第26行将图片数据传递给了代理(delegate)对象 参考资料 NSHipster 的NSOperation 雷纯锋的博客的《iOS 并发编程之 Operation Queues》 objc的并发编程指南《Concurrent Programming》 StackOverflow: NSOperation vs. Grand Central Dispatch Blog: When to use NSOperation vs. GCD 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"多线程","slug":"多线程","permalink":"https://blog.wangruofeng007.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"NSOperation","slug":"NSOperation","permalink":"https://blog.wangruofeng007.com/tags/NSOperation/"}]},{"title":"iOS 中的触摸事件和手势处理","slug":"2016-01-13-ioszhong-de-hong-mo-shi-jian-he-shou-shi-chu-li","date":"2016-01-12T21:05:09.000Z","updated":"2024-11-03T05:51:32.111Z","comments":true,"path":"2016/01/13/2016-01-13-ioszhong-de-hong-mo-shi-jian-he-shou-shi-chu-li/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-ioszhong-de-hong-mo-shi-jian-he-shou-shi-chu-li/","excerpt":"","text":"iOS 触摸事件分类 触摸事件 加速事件 远程事件 谁能处理触摸事件?响应者对象 在 iOS 中不是任何对象都能处理事件,只有继承了 UIResponder 的对象才能接收并处理事件.我们称之为响应者对象. UIApplication、UIViewController、UIView 都继承自 UIResponder,因此它们都是响应者对象,都能够接收并处理事件. UIResponderUIResponder 内部提供了方法来处理事件 触摸事件 一次完成的触摸过程,会经历 3 个状态, UIView 的触摸事件处理 一根或多根手指开始触摸 view,系统会自动调用 view 下面的方法: 1- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event; //触摸开始 一根或者多根手指在 view 上移动，系统会自动调用 view 下面的方法（随着手指的移动，会持续调用该方法） 1- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event; //触摸移动 一根或者多根手指离开 view，系统会自动调用 view 下面的方法 1- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event; //触摸结束 触摸结束前，某个系统事件（例如电话呼入 ）会打断触摸过程，系统会自动调用 view 下面的方法 1- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; //触摸取消(可能会经历) 4 个触摸事件的处理方法中，都有 NSSet *touches 和 UIEvent *event 两个参数: 一次完整的触摸过程，只会产生一个事件对象，4 个触摸方法都是同一个 event 参数 如果两根手指同时触摸一个 view，那么 view 只会调用一次 touchesBegan:withEvent: 方法，touches 参数中装着两个 UITouch 对象； 如果这两根手指一前一后分开触摸同一个 view，那么 view 会分别调用两次 touchesBegan:withEvent:方法， 并且每次调用时的 touches 参数只包含一个 UITouch 对象； 根据 touches 中 UITouch 个数可以判断出使单点触摸还是多点触摸 提示：touches 中存放的都是 UITouch 对象。 加速计事件 123- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event; - (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event; - (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event; 远程控制事件 1- (void)remoteControlReceivedWithEvent:(UIEvent *)event; UITouch当用户用一根手指触摸屏幕时，会创建一个与手指相关联的 UITouch 对象；一根手指对应一个 UITouch 对象UITouch 的作用: 保存跟手指相关的信息，比如触摸的位置、时间、阶段； 当手指移动时，系统会更新同一个 UITouch 对象，使之能够一直保存该手指的触摸位置； 当手指离开屏幕时，系统会销毁相应的 UITouch 对象。 提示：iPhone 开发中，要避免使用双击事件。 UITouch 的属性:触摸产生时所处的窗口: 1@property(nonatomic,readonly,retain) UIWindow *window; 触摸产生时所处的视图 1@property(nonatomic,readonly,retain) UIView *view; 短时间内点按屏幕的次数，可以根据 tapCount 判断单击、双击或更多地点击 1@property(nonatomic,readonly) NSUInteger tapCount; 记录了触摸事件产生或变化时的时间，单位是秒 1@property(nonatomic,readonly) NSTimeInterval timestamp; 当前触摸事件所处的状态 12345678910/*UITouchPhase 是一个枚举类型，包含：UITouchPhaseBegan（触摸开始）UITouchPhaseMoved（接触点移动）UITouchPhaseStationary（接触点无移动）UITouchPhaseEnded（触摸结束）UITouchPhaseCancelled（触摸取消）*/@property(nonatomic,readonly) UITouchPhase phase; UITouch 的方法： 1- (CGPoint)locationInView:(UIView *)view; 1.返回值表示触摸在 view 上的位置；2.这里返回的位置是针对 view 坐标系的,（以 view 的左上角为原点（0，0））；3.调用时传入的 view 参数为 nil 的话，返回的是触摸点在 UIWindow 的位置。 1- (CGPoint)previousLocationInView:(UIView *)view; 该方法记录了前一个触摸点的位置； UIEvent 每产生一个事件，就会产生一个 UIEvent 对象；UIEvent:称为事件对象，记录事件产生的时刻和类型。 常见属性：1.事件类型 1234567891011121314151617181920212223@property(nonatomic,readonly) UIEventType type;@property(nonatomic,readonly) UIEventSubtype subtype;typedefNS_ENUM(NSInteger, UIEventType) &#123; UIEventTypeTouches, UIEventTypeMotion, UIEventTypeRemoteControl,&#125;;typedefNS_ENUM(NSInteger, UIEventSubtype) &#123; // available in iPhone OS 3.0 UIEventSubtypeNone = 0, // for UIEventTypeMotion, available in iPhone OS 3.0 UIEventSubtypeMotionShake = 1, // for UIEventTypeRemoteControl, available in iOS 4.0 UIEventSubtypeRemoteControlPlay = 100, UIEventSubtypeRemoteControlPause = 101, UIEventSubtypeRemoteControlStop = 102, UIEventSubtypeRemoteControlTogglePlayPause = 103, UIEventSubtypeRemoteControlNextTrack = 104, UIEventSubtypeRemoteControlPreviousTrack = 105, UIEventSubtypeRemoteControlBeginSeekingBackward = 106, UIEventSubtypeRemoteControlEndSeekingBackward = 107, UIEventSubtypeRemoteControlBeginSeekingForward = 108, UIEventSubtypeRemoteControlEndSeekingForward = 109,&#125;; 2.事件产生的时间 1@property(nonatomic,readonly) NSTimeInterval timestamp; UIEvent 还提供了相应的方法可以获得在某个 view 上面的触摸对象（UITouch）。 触摸事件的产生： 发生触摸事件后，系统会将该事件加入到一个由 UIApplication 管理的事件队列中； UIApplication 会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）； 主窗口会在视图层次结构中找到一个最合适的视图控件来处理触摸事件，这也是整个事件处理过程的第一步； 找到合适的视图控件后，就会调用视图控件的 touches 方法来做具体的事件处理。 触摸事件的传递： 触摸事件的传递是从父控件传递到子控件；如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件。 UIView 不接收触摸事件的三种情况:不接受用户交互 ： userInteractionEnable &#x3D; NO; 隐藏 ：hidden &#x3D; YES; 透明：alpha &#x3D; 0.0 ~ 0.01 提示：UIImageView 的 userInteractionEnable 默认就是 NO，因此 UIImageView 以及它的子控件默认是不能接收触摸事件的。 触摸事件处理的详细过程： 用户点击屏幕后产生的一个触摸事件，经过一些列的传递过程后，会找到最合适的视图控件来处理这个事件 找到最合适的视图控件后，就会调用控件的 touches 方法来作具体的事件处理 touchesBegan… touchesMoved… touchedEnded… 这些 touches 方法的默认做法是将事件顺着响应者链条向上传递，将事件交给上一个响应者进行处理 响应者链的事件传递过程： 如果 view 的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图； 在视图层次结构最顶级的视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给 window 对象进行处理。 如果 window 对象也不处理，则其将事件或消息传递给 UIApplication 对象； 如果 UIApplication 也不能处理该事件或消息，则将其丢弃 监听触摸事件的做法如果想监听一个 view 上面的触摸事件，之前的做法是： 自定义一个 view； 实现 view 的 touches 方法，在方法内部实现具体处理代码。 通过 touches 方法监听 view 触摸事件，有很明显的几个缺点： 必须得自定义 view； 由于是在 view 内部的 touches 方法中监听触摸事件，因此默认情况下，无法让其他外界对象监听 view 的触摸事件； 不容易区分用户的具体手势行为。 iOS 3.2 之后，苹果推出了手势识别功能（Gesture Recognizer）,在触摸事件处理方面，大大简化了开发者的开发难度。 UIGestureRescognizer为了完成手势识别，必须借助于手势识别器：UIGestureRecognizer 。利用 UIGestureRecognizer,能轻松识别用户在某个 view 上面做的一些常见手势。UIGestureRecognizer 是一个抽象类，定义了所有的手势基本行为，使用它的子类才能处理具体的手势 UITapGestureRecognizer(敲击) UIPinchGestureRecognizer(捏合，用于缩放) UIPanGestureRecognizer(拖拽) UISwipeGestureRecognizer(轻扫) UIRotationGestureRecognizer(旋转) UILongPressGestureRecognizer(长按) 每一个手势识别器的用法都差不多，比如 UITapGestureRecognizer 的使用步骤如下: 创建手势识别器对象；1UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init]; 设置手势识别器对象的具体属性；1234// 连续敲击 2 次tap.numberOfTapsRequired = 2;// 需要 2 根手指一起敲击tap.numberOfTouchesRequired = 2; 添加手势识别器到对应的 view 上1[self.iconView addGestureRecognizer:tap]; 监听手势的触发1[tap addTarget:self action:@selector(tapIconView:)]; 手势识别的状态 12345678910111213141516typedef NS_ENUM(NSInteger, UIGestureRecognizerState) &#123; // 没有触摸事件发生，所有手势识别的默认状态 UIGestureRecognizerStatePossible, // 一个手势已经开始但尚未改变或者完成时 UIGestureRecognizerStateBegan, // 手势状态改变 UIGestureRecognizerStateChanged, // 手势完成 UIGestureRecognizerStateEnded, // 手势取消，恢复至 Possible 状态 UIGestureRecognizerStateCancelled, // 手势失败，恢复至 Possible 状态 UIGestureRecognizerStateFailed, // 识别到手势识别 UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded&#125;; 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"系统原理","slug":"系统原理","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"事件处理","slug":"事件处理","permalink":"https://blog.wangruofeng007.com/tags/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"}]},{"title":"iOS 里程碑事件","slug":"2016-01-13-iosli-cheng-bei-shi-jian","date":"2016-01-12T20:46:48.000Z","updated":"2024-11-03T05:43:30.263Z","comments":true,"path":"2016/01/13/2016-01-13-iosli-cheng-bei-shi-jian/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-iosli-cheng-bei-shi-jian/","excerpt":"","text":"记录 iOS 各种重要里程碑事件 私有成员变量的实现1.0 时代，在.h 文件采用 @private 关键词 1234@interface ViewController : UIViewController &#123; @private NSInteger _value;&#125; 2.0 时代 通过在.m 文件通过 匿名Category 12345@interface ViewController ()@property (nonatomic) NSInteger value;@end 3.0 时代 2013 年的 WWDC 允许在 .m 的 @implementation 中 123@implementation ViewController &#123; NSInteger _value;&#125; ARC 推出2011 自动生成 getter 和 setter 方法的 @synthesize 2012AutoLayout 引入iOS 6.0 Swift WWDC 1.0 版本发布 – 2014.06.02 Swift 2.0 发布 – 2015.08.07 Open Source – 2015.12.04 Size ClassesiOS 8.0 BlocksMac OS X 10.6 “Snow Leopard” and iOS 4.0 Objective-C 2.0At the 2006 Worldwide Developers Conference release of Objective-C 2.0 Watch OS2015.05.21 iOS API DifferencesiOS 2.1 to iOS 2.2 API DifferencesAdded frameworks: AVFoundation iOS 2.2 to iOS 3.0 API DifferencesAdded frameworks: CoreData ExternalAccessory GameKit MapKit MessageUI MobileCoreServices StoreKit iOS 3.2 to iOS 4.0 API DifferencesAdded frameworks: Accelerate AssetsLibrary CoreMedia CoreMotion CoreTelephony CoreVideo EventKit EventKitUI iAd ImageIO QuickLook iOS 4.3 to iOS 5.0 API DifferencesAdded frameworks Accounts CoreBluetooth CoreImage GLKit GSS NewsstandKit Twitter 5.1 to iOS 6.0 API DifferencesAdded frameworks AdSupport MediaToolbox PassKit Social 6.1 to iOS 7.0 API DifferencesAdded frameworks GameController JavaScriptCore MediaAccessibility MultipeerConnectivity SafariServices SpriteKit iOS 7.1 to iOS 8.0 API DifferencesAdded frameworks Accelerate Accounts AddressBook AddressBookUI AudioToolbox AudioUnit AVFoundation AVKit (Added) CFNetwork CloudKit (Added) CoreAudio CoreAudioKit (Added) CoreAuthentication (Added) CoreBluetooth CoreData CoreFoundation CoreImage CoreLocation CoreMedia CoreMotion CoreText CoreVideo EventKit EventKitUI ExternalAccessory Foundation GameController GameKit GLKit GSS HealthKit (Added) HomeKit (Added) iAd ImageIO IOKit JavaScriptCore LocalAuthentication (Added) MapKit MediaAccessibility MediaPlayer MessageUI Metal (Added) MobileCoreServices MultipeerConnectivity NetworkExtension (Added) NewsstandKit NotificationCenter (Added) OpenGLES PassKit Photos (Added) PhotosUI (Added) PushKit (Added) QuartzCore QuickLook SceneKit (Added) Security Social SpriteKit StoreKit UIKit VideoToolbox WebKit (Added) iOS 8.3 to iOS 9.0 API DifferencesAdded frameworks Objective-C &#x2F;usr&#x2F;include Accelerate Accounts AddressBook AddressBookUI AssetsLibrary AudioToolbox AudioUnit AVFoundation AVKit CFNetwork CloudKit Contacts (Added) ContactsUI (Added) CoreAudio CoreAudioKit CoreBluetooth CoreData CoreFoundation CoreGraphics CoreImage CoreLocation CoreMedia CoreMIDI CoreMotion CoreSpotlight (Added) CoreTelephony CoreText CoreVideo EventKit EventKitUI ExternalAccessory Foundation GameController GameKit GameplayKit (Added) GLKit GSS HealthKit HomeKit iAd ImageIO JavaScriptCore LocalAuthentication MapKit MediaPlayer MediaToolbox MessageUI Metal MetalKit (Added) MetalPerformanceShaders (Added) MobileCoreServices ModelIO (Added) MultipeerConnectivity NetworkExtension NewsstandKit OpenAL PassKit Photos PushKit QuartzCore QuickLook ReplayKit (Added) SafariServices SceneKit Security SpriteKit StoreKit SystemConfiguration UIKit VideoToolbox WatchConnectivity (Added) WatchKit WebKit 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"资料收集","slug":"资料收集","permalink":"https://blog.wangruofeng007.com/categories/%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"历史事件","slug":"历史事件","permalink":"https://blog.wangruofeng007.com/tags/%E5%8E%86%E5%8F%B2%E4%BA%8B%E4%BB%B6/"}]},{"title":"优雅处理 UIImage 图片旋转","slug":"2016-01-13-you-ya-chu-li-uiimagetu-pian-xuan-zhuan","date":"2016-01-12T20:38:49.000Z","updated":"2024-11-03T06:27:49.669Z","comments":true,"path":"2016/01/13/2016-01-13-you-ya-chu-li-uiimagetu-pian-xuan-zhuan/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-you-ya-chu-li-uiimagetu-pian-xuan-zhuan/","excerpt":"","text":"UIImag 构造方式UIImag 构造方式大致有 4 种方式 从本地 bundle 中加载 imageNamed: ，传入一个 bundle 的文件名即可 从本地一个文件路径读取 imageWithContentsOfFile: ，需要传一个文件的文件路径 path 通过二进制数据 NSData 来创建 imageWithData: * 通过一个 CoreGraphics 的 CGImageRef 来创建， initWithCGImage: * 通过一个 CoreImage 的 CIImage 来创建 initWithCIImage 通过查阅 Apple 官网文档我们发现有 2 个这样的方法，今天就来一探究竟 12345+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(4_0);+ (UIImage *)imageWithCIImage:(CIImage *)ciImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(6_0);- (instancetype)initWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(4_0);- (instancetype)initWithCIImage:(CIImage *)ciImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(6_0); 2 个类方法 2 个实例方法都是类似，这里以 CGImageRef 为例 1+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(4_0); 新建的 Xcode 工程选择 single Application 在 storyboard 中拖一个 UIImageView 设置它水平垂直居中对齐，宽带高度随便设一个值不要太大就行，设置 UIImageView 的 contentMode 为 Aspect Fit 方便查看以免变形 在 UIImageView 下发放一个 UIButton 控件方便后面好对图片进行旋转操作 在 viewController 中建立一个 UIImageView 引用,拉出一个 rotate 按钮的 IBAction 现在大概界面大概这样 下面我们实现 - (IBAction)rotateImage:(id)sender &#123;&#125; 这个方法 在这里我们想通过点击按钮实现图片旋转 为了方便使用我们使用 Category 的方式实现 新建一个 UIImage 的分类取名叫 Rotate 这里需要传一张要处理的图片和一个待处理成的图片方向 12+ (UIImage *)rotateImage:(UIImage *)oldImage orientation:(UIImageOrientation)orientation; 123456789101112131415161718192021222324252627282930313233343536373839404142434445 + (UIImage *)rotateImage:(UIImage *)oldImage orientation:(UIImageOrientation)orientation&#123; UIImage *newImage = [UIImage imageWithCGImage:oldImage.CGImage scale:1 orientation:orientation]; NSString *orientationStr = nil; switch (orientation) &#123; case UIImageOrientationUp: &#123; orientationStr = @&quot;UIImageOrientationUp&quot;; break; &#125; case UIImageOrientationDown: &#123; orientationStr = @&quot;UIImageOrientationDown&quot;; break; &#125; case UIImageOrientationLeft: &#123; orientationStr = @&quot;UIImageOrientationLeft&quot;; break; &#125; case UIImageOrientationRight: &#123; orientationStr = @&quot;UIImageOrientationRight&quot;; break; &#125; case UIImageOrientationUpMirrored: &#123; orientationStr = @&quot;UIImageOrientationUpMirrored&quot;; break; &#125; case UIImageOrientationDownMirrored: &#123; orientationStr = @&quot;UIImageOrientationDownMirrored&quot;; break; &#125; case UIImageOrientationLeftMirrored: &#123; orientationStr = @&quot;UIImageOrientationLeftMirrored&quot;; break; &#125; case UIImageOrientationRightMirrored: &#123; orientationStr = @&quot;UIImageOrientationRightMirrored&quot;; break; &#125; &#125; NSLog(@&quot;current orientation: %@&quot;,orientationStr); return newImage;&#125; 在 button 点击事件触发时的这样使用 12345678- (IBAction)rotateImage:(id)sender &#123; UIImage *oldImage = self.imgView.image; UIImage *rotatedImage = [UIImage rotateImage:oldImage orientation:UIImageOrientationLeft]; self.imgView.image = rotatedImage;&#125; 点击按钮测试发现第一次没问题，但是重逢点击无效原来 + (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation 方法执行原理是执行前通过 @property(nonatomic,readonly) UIImageOrientation imageOrientation; 接口先判断当前图片的方向是否为将要旋转的方向，如果是就直接返回不做处理，如果不是再作旋转处理，也就是说这个方法并没有实际上旋转 image 的数据，只是用一个枚举标记旋转的状态 如果我们想每次旋转需要直接改变原始 image 的数据该怎么办呢？在这里我们通过 CGBitmapContext ,使用 CGContextRotateCTM 来设置旋转，再把 UIImage 通过 drawInRect 重新绘制出来，通过 UIGraphicsGetImageFromCurrentImageContext 获得处理后的图片 下面是具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475- (UIImage *)fixedRotation&#123; if (self.imageOrientation == UIImageOrientationUp) return self; CGAffineTransform transform = CGAffineTransformIdentity; switch (self.imageOrientation) &#123; case UIImageOrientationDown: case UIImageOrientationDownMirrored: transform = CGAffineTransformTranslate(transform, self.size.width, self.size.height); transform = CGAffineTransformRotate(transform, M_PI); break; case UIImageOrientationLeft: case UIImageOrientationLeftMirrored: transform = CGAffineTransformTranslate(transform, self.size.width, 0); transform = CGAffineTransformRotate(transform, M_PI_2); break; case UIImageOrientationRight: case UIImageOrientationRightMirrored: transform = CGAffineTransformTranslate(transform, 0, self.size.height); transform = CGAffineTransformRotate(transform, -M_PI_2); break; case UIImageOrientationUp: case UIImageOrientationUpMirrored: break; &#125; switch (self.imageOrientation) &#123; case UIImageOrientationUpMirrored: case UIImageOrientationDownMirrored: transform = CGAffineTransformTranslate(transform, self.size.width, 0); transform = CGAffineTransformScale(transform, -1, 1); break; case UIImageOrientationLeftMirrored: case UIImageOrientationRightMirrored: transform = CGAffineTransformTranslate(transform, self.size.height, 0); transform = CGAffineTransformScale(transform, -1, 1); break; case UIImageOrientationUp: case UIImageOrientationDown: case UIImageOrientationLeft: case UIImageOrientationRight: break; &#125; // Now we draw the underlying CGImage into a new context, applying the transform // calculated above. CGContextRef ctx = CGBitmapContextCreate(NULL, self.size.width, self.size.height, CGImageGetBitsPerComponent(self.CGImage), 0, CGImageGetColorSpace(self.CGImage), CGImageGetBitmapInfo(self.CGImage)); CGContextConcatCTM(ctx, transform); switch (self.imageOrientation) &#123; case UIImageOrientationLeft: case UIImageOrientationLeftMirrored: case UIImageOrientationRight: case UIImageOrientationRightMirrored: // Grr... CGContextDrawImage(ctx, CGRectMake(0,0,self.size.height,self.size.width), self.CGImage); break; default: CGContextDrawImage(ctx, CGRectMake(0,0,self.size.width,self.size.height), self.CGImage); break; &#125; // And now we just create a new UIImage from the drawing context CGImageRef cgimg = CGBitmapContextCreateImage(ctx); UIImage *img = [UIImage imageWithCGImage:cgimg]; CGContextRelease(ctx); CGImageRelease(cgimg); return img;&#125; 现在再优化一下原来 + (UIImage *)rotateImage:(UIImage *)oldImage orientation:(UIImageOrientation)orientation 方法,修改成这样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748+ (UIImage *)rotateImage:(UIImage *)oldImage orientation:(UIImageOrientation)orientation&#123; UIImage *newImage = [UIImage imageWithCGImage:oldImage.CGImage scale:1 orientation:orientation]; //fix original Image with gived orientation. UIImage *fixedRotationImage = [newImage fixedRotation]; NSString *orientationStr = nil; switch (orientation) &#123; case UIImageOrientationUp: &#123; orientationStr = @&quot;UIImageOrientationUp&quot;; break; &#125; case UIImageOrientationDown: &#123; orientationStr = @&quot;UIImageOrientationDown&quot;; break; &#125; case UIImageOrientationLeft: &#123; orientationStr = @&quot;UIImageOrientationLeft&quot;; break; &#125; case UIImageOrientationRight: &#123; orientationStr = @&quot;UIImageOrientationRight&quot;; break; &#125; case UIImageOrientationUpMirrored: &#123; orientationStr = @&quot;UIImageOrientationUpMirrored&quot;; break; &#125; case UIImageOrientationDownMirrored: &#123; orientationStr = @&quot;UIImageOrientationDownMirrored&quot;; break; &#125; case UIImageOrientationLeftMirrored: &#123; orientationStr = @&quot;UIImageOrientationLeftMirrored&quot;; break; &#125; case UIImageOrientationRightMirrored: &#123; orientationStr = @&quot;UIImageOrientationRightMirrored&quot;; break; &#125; &#125; NSLog(@&quot;current orientation: %@&quot;,orientationStr); return fixedRotationImage;&#125; 现在再测试一下，well，It‘s OK。 have fun!!! 参考资料 UIImageOrientation &#x2F; EXIF orientation sample images Apple-UIImage Class Reference ios-uiimageview-how-to-handle-uiimage-image-orientation 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"用 CAShapeLayer 动画绘制 CGPath","slug":"2016-01-13-dong-hua-hui-zhi-cashapelayerde-lu-jing-cgpath","date":"2016-01-12T20:35:42.000Z","updated":"2024-11-03T05:32:35.304Z","comments":true,"path":"2016/01/13/2016-01-13-dong-hua-hui-zhi-cashapelayerde-lu-jing-cgpath/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-dong-hua-hui-zhi-cashapelayerde-lu-jing-cgpath/","excerpt":"","text":"这是什么？ 此文将讲解通过形状图层 CAShaperLayer 的 strokeStart 和 strokeEnd 来实现动画绘制路径 CGPath ,此文是By Ole Begemann创建于 December 18, 2010,当时是发布 iOS SDK 4.2 时 CAShapeLayer 新增加的两个属性strokeStart和strokeEnd,这两个值是两个浮点数取值范围 0.0~1.0,用来表明形状图层所指向的路径在绘制开始和结束路径中的相对位置。 strokeStart 默认值是0.0， strokeEnd 默认值是1.0，显然这会导致形状图层的路径将一整个被绘制。假如，你想说，如果设置了layer.strokeEnd &#x3D; 0.5f,只让她绘制前半部分，那该多好。 真正有趣的事情是这些接口都是可动画的。通过动画绘制 strokeEnd 从 0.0 到 1.0 在几秒内，我们就能很容易自己绘制路径像下面这样写： 12345CABasicAnimation *pathAnimation = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];pathAnimation.duration = 10.0;pathAnimation.fromValue = [NSNumber numberWithFloat:0.0f];pathAnimation.toValue = [NSNumber numberWithFloat:1.0f];[self.pathLayer addAnimation:pathAnimation forKey:@&quot;strokeEndAnimation&quot;]; 最后，再添加第二个图层包含一个铅笔图片，使用关键帧动画 CAKeyframeAnimation 来让它随着这个路径以相同的速度绘制，就可以达到完美的错觉效果： 12345CAKeyframeAnimation *penAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];penAnimation.duration = 10.0;penAnimation.path = self.pathLayer.path;penAnimation.calculationMode = kCAAnimationPaced;[self.penLayer addAnimation:penAnimation forKey:@&quot;penAnimation&quot;]; 绘制普通路径效果视频 下载地址 这个对文本一样有效；我们只需要把字符转化成 CGPath 。 Core Text 提供了那样的功能的函数，CTFontCreatePathForGlyph( )。为了使用它，我们需要创建一个带属性的字符串用我们想要渲染的文本，先把它们分割成行在分割成一个个字符。在把所有的字符转换成路径后，我们以子路径方式把它添加到一个单个的 CGPath 路径中。更多细节可以查看Ohmu写的Low-level text rendering这篇文章。结果看以来非常的炫酷： 绘制文字路径效果视频 下载地址 从 Github 上获得iPad 版的样品工程 你将学到的知识点 使用 CAShapeLayer 的 strokeStart 和 strokeEnd 来实现路径动画,比较高级复杂的效果像 google 的下拉刷新转圈就可以从这里引申去实现。 CABasicAnimation 和 CABasicAnimation 使用 深入理解 CAShapeLayer 和 CALayer * 通过文本创建路径，核心函数 CTFontCreatePathForGlyph() 补充说明1234567891011CAShapeLayer *pathLayer = [CAShapeLayer layer];pathLayer.frame = self.animationLayer.bounds;pathLayer.bounds = pathRect;pathLayer.geometryFlipped = YES;pathLayer.path = path.CGPath;pathLayer.strokeColor = [[UIColor blackColor] CGColor];pathLayer.fillColor = nil;pathLayer.lineWidth = 10.0f;pathLayer.lineJoin = kCALineJoinBevel;[self.animationLayer addSublayer:pathLayer]; 有一点非常重要，CALayer 在 iOS 系统中相对坐标系是以屏幕左上 top-left 为坐标原点的，在 Mac OS X 上以坐下 bottom-left 为坐标原点,但是可以通过 CALayer 的接口 geometryFlipped 垂直翻转坐标系，这个值默认是 NO ，设置成 YES 就可以把坐标系转换成左下 bottom-left 了，这里作者使用的左下 bottom-left 的坐标系。 1@property(getter=isGeometryFlipped) BOOL geometryFlipped; 关于这个属性使用时需要特别注意 翻转会同时作用于它的子图层 即使这个属性设置成 YES ,图片的 orientation 仍然是不变的（也就是说当设置 flipped=YES 和 flipped=NO 时一个 CGImageRef 储存在 contents 接口中的内容将会显示一致，赋值并不会真正变换底层的图层） pathLayer 动画实现原理 先创建一个动画用的图层 animationLayer 类型 CALayer ，用来充当动画的画布。 创建真正的路径图层 pathLayer 类型为 CAShapeLayer ,让它的坐标系垂直翻转，并且让图层宽高同时向内收缩 100 个点,通过 CGRectInset(CGRect rect, CGFloat dx, CGFloat dy) 实现 把 pathLayer 添加到 animationLayer 的子图层中去 创建一个铅笔图层 penLayer 类型为 CALayer ,把它添加到 pathLayer 去 对 pathLayer 添加 CABasicAnimation 动画，动画属性为 strokeEnd 6. 对 penLayer 添加 CAKeyframeAnimation 动画，动画属性为 position #### textLayer 动画实现原理 先创建一个动画用的图层 animationLayer 类型 CALayer ，用来充当动画的画布 Create path from text,See:http://www.codeproject.com/KB/iPhone/Glyph.aspx，最终保存到一个类型为 CGMutablePathRef 的 letter 中 通过 letter 来创建文字 UIBezierPath 类型的 path 4. 通过 path 再创建 CAShapeLayer pathLayer,并且把 pathLayer 添加到 animationLayer 中去 创建一个铅笔图层 penLayer 类型为 CALayer ,把它添加到 pathLayer 去 对 pathLayer 添加 CABasicAnimation 动画，动画属性为 strokeEnd 6. 对 penLayer 添加 CAKeyframeAnimation 动画，动画属性为 position 修复一处 bug重复点击 UISegmentedControl 导致铅笔消失，这是设置了 penAnimation.delegate = self; 在代理方法里面没有判断结束直接将设置 self.penLayer.hidden = YES ，导致连续切换时铅笔不见了，要修复这个 bug 只需加一个判断if (flag) self.penLayer.hidden = YES; 即可,这样的意思是只有当动画完成时才设置 self.penLayer.hidden的值，好了现在已经非常完美了，快去动手自己试试吧！🍺 原文链接 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"动画","slug":"动画","permalink":"https://blog.wangruofeng007.com/categories/%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"CAShapeLayer","slug":"CAShapeLayer","permalink":"https://blog.wangruofeng007.com/tags/CAShapeLayer/"}]},{"title":"Blog 网站备忘录","slug":"2016-01-13-blogwang-zhan-bei-wang-lu","date":"2016-01-12T20:29:59.000Z","updated":"2024-11-03T05:32:35.300Z","comments":true,"path":"2016/01/13/2016-01-13-blogwang-zhan-bei-wang-lu/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-blogwang-zhan-bei-wang-lu/","excerpt":"","text":"简书 叶孤城___ MarkNote lp_马建成 seedante 大灰灰 iOS StrongX 国内个人 猫神 onevcat – 地球人都知道 唐巧–猿题库作者 虾神–话说你们晓得虾神年纪多大么？反正我是觉得白活了。90 后太厉害了。 sunnyxx – FDFullscreenPopGesture作者，值得关注 nixzhu–有几篇翻译的文章质量不错 破船之家–这让我想起，喝上一杯朗姆酒🍺 Limboy – 蘑菇街一位资深 iOS 程序员 MacTalk-池建强的随想录–Mac 开发大牛 雨松 MOMO–专注移动互联网，专注 Unity3D 游戏开发,国内最早开发 Unity3d 的大神之一 玉令天下的博客 – 关于 runtime 的资料整理得非常不错 Chun Tips – 对 Runtime,RunLoop,AutoLayout 讲解得非常详细 ❤️ 鹏威の博客 – 非常炫酷的博客，值得学习 mgenware – 往全栈方向发展 ing 国外个人 mikeash–白天飞行员，晚上程序员 ：] just this guy, you know? shinobicontrols–iOS 最新 API 以及新功能用法 iosdevelopertips–教程配合 Demo 让你学习成长立竿见影 iosdevweekly–很棒的个人技术博客网，已发表 230 篇文章 ios-goodies–iOS,UI,UX,Objective-c,Swift,Xcode mattt-thompson – 不用解释 subjc –Subjective-C is a study of innovative iOS interfaces. thinkandbuild–《Introduction To 3D Drawing in CoreAnimtion》作者 robb.is–《How to build a nice Hamburger transition in swift》作者 commandshift–不多说，质量极高 indieambitions–raywenderlich 常驻作者之一的 blog，非常赞。 nvie–国外一个大神的 blog，讲得比较杂，git，ios，python 都有涉猎，但是每篇都很精彩。 stuartkhall–很多关于 app 上线运营之类的 blog，值得一看。 ittybittyapps–神器 Reveal 的作者的 blog。 adoptioncurve–更新极快，当时 iOS8 还没出几个周，作者就写了篇 sizeclass 解析。非常棒 ciechanowski–各种数学上几何变化 bignerdranch cocoawithlove–2008-2011 的老文章，现在没怎么跟新了 codinghorror –Jeff Atwood 主站 g8production lucida – 我比较佩服一名程序员，想学算法找他推荐咯😁 团体 blog ibireme–最近很🔥的 YYKit 的作者 Glow 技术团队 美团点评技术团队 优质 iOS 学习资源 github–这个不用我说吧 stackoverflow–最专业的问答社区 raywenderlich–iOS 界的百科全书 nshipster–里面文章质量非常的高，最喜欢的几个网站之一AFNetworkting的作者Mattt Thompson–经常出没 nshipster 中国 objc.io–这个也不用多说了，Raywenderlich 是百科全书的话，这个就是深入深入再深入 objc 中国 realm.io–一个跨平台的移动数据库引擎 tutsplus–也是包罗万象的一个网站，有 web ios ui，不比 Raywenderlich 逊色。 maniacdev–类似 Raywenderlich，文章质量高，而且涵盖面广 Appcoda – 技术类学习网站，里面的技术更新挺及时的 中文网站 cocoachina code4app 泰然网 –游戏教程不错的网站 伯乐在线 Swift： 介紹 | 《The Swift Programming Language》中文版 Swift 必备 Tips – 猫神的杰作 Let’s Swift – Swift 站点导航 Swiftify | Objective-C to Swift Converter – 辅助将旧的* Objective-C 代码转成 Swift。 Swift.org – Apple Swift 官网 Swift - Blog – Apple Swift 官方博客 CocoaChina 小组翻译的 Swift 版本 tutorialspoint – 有一些 Swift 教程 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"资料收集","slug":"资料收集","permalink":"https://blog.wangruofeng007.com/categories/%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://blog.wangruofeng007.com/tags/%E7%BD%91%E7%AB%99/"}]},{"title":"__autoreleasing 的理解","slug":"2016-01-13-autoreleasingde-li-jie","date":"2016-01-12T20:27:10.000Z","updated":"2024-11-03T05:32:35.288Z","comments":true,"path":"2016/01/13/2016-01-13-autoreleasingde-li-jie/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-autoreleasingde-li-jie/","excerpt":"","text":"__autoreleasing 修饰符将对象赋值给附有 __autoreleasing 修饰符的变量等同于 ARC 无效时调用对象的 autorelease 方法。我们通过以下源代码来看一下 123@autoreleasepool &#123; id __autoreleasing obj = [[NSObject alloc] init];&#125; 该源代码主要将 NSObject 类对象注册到 autoreleasepool 中，可作如下变换： 123456/* 编译器的模拟代码 */id pool = objc_autoreleasePoolPush();id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj, @selector(init));objc_autorelease(obj);objc_autoreleasePoolPop(pool); 这与苹果的 autorelease 实现中的说明（参考 1.2.7 节）完全相同。虽然 ARC 有效和无效时，其在源代码上的表现有所不同，但 autorelease 的功能完全一样。 在 alloc&#x2F;new&#x2F;copy&#x2F;mutableCopy 方法群之外的方法中使用注册到 autoreleasepool 中的对象会如何呢？下面我们来看看 NSMutableArray 类的 array 类方法。 123@autoreleasepool &#123; id __autoreleasing obj = [NSMutableArray array];&#125; 这与前面的源代码有何不同呢？ 123456/* 编译器的模拟代码 */id pool = objc_autoreleasePoolPush();id obj = objc_msgSend(NSMutableArray, @selector(array));objc_retainAutoreleasedReturnValue(obj);objc_autorelease(obj);objc_autoreleasePoolPop(pool); 虽然持有对象的方法从 alloc 方法变为 objc_retainAutoreleasedReturnValue 函数， 但注册 autoreleasepool 的方法没有改变，仍是 objc_autorelease 函数。 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"系统原理","slug":"系统原理","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"autoreleasing","slug":"autoreleasing","permalink":"https://blog.wangruofeng007.com/tags/autoreleasing/"}]},{"title":"__attribute__","slug":"2016-01-13-attribute","date":"2016-01-12T20:10:33.000Z","updated":"2024-11-03T05:32:35.305Z","comments":true,"path":"2016/01/13/2016-01-13-attribute/","permalink":"https://blog.wangruofeng007.com/2016/01/13/2016-01-13-attribute/","excerpt":"","text":"译自 Written by Mattt Thompson — January 14th, 2013 原文链接：http://nshipster.com/__attribute__/ 译者 @oneruofeng 重复发布这个主题已经说明了同编译器保存健康关系的重要性,像任何草稿一样，作为一个实践者的效率取决于他们怎样对待他们的工具，你照顾好它们，它们反过来也会对你有好处。 __attribute__ 是一个编译器的指令在声明的时候指明了一些参数，这些参数允许更多的检查错误和高级的优化。 语法关键字是 __attribute__ 紧跟 2 套圆括号（双圆括号让出现的宏更容易辨认，特别是在有多个属性的时候）。在括号内部是一个以逗号分隔的属性列表， __attribute__ 指令被放在函数，变量和类型声明后面。 12345678910 // Return the square of a numberint square(int n) __attribute__((const));// Declare the availability of a particular APIvoid f(void) __attribute__((availability(macosx,introduced=10.4,deprecated=10.6)));// Send printf-like message to stderr and exitextern void die(const char *format, ...) __attribute__((noreturn, format(printf, 1, 2))); 假如这个让你想起 ISO C 语言的 #pragma ,你就不会感到孤单了。 实际上，当 __attribute__ 被第一次引入到 GCC 编译器时，它面临一些阻力，有人建议使用专用的 #pragma 因为相同的目的。 这里，然而，有 2 个非常好的理由为什么 __attribute__ 被添加进来 从一个宏中产生 #pragma 命令几乎是不能的（在 C99 _Pragma 预算符以前）。 这里没人知道相同的 #pragma 在另一个编译器中可能的意思。 引用 GCC Documentation for Function Attributes 这里有 2 个原因被应用到几乎所有的应用推荐使用 #pragma ,这犯了一个低级错误就是把 #pragma 使用到任何地方。 确实，假如你在苹果的框架中和牛逼工程师的开源项目中的头文件看一下现代的 Objective-c – __attribute__ 被大量使用。（相反， #pragma 的主要声明名声来着这些天是装饰: #pragma mark ） 所以为了以后不费力，我们还是先看一下最重要的属性： GCCformat format 属性指定了一个函数像 printf , scanf , strftime 或者 strfmo 风格的参数，这个参数应该是可以进行类型检查的一个格式化字符串。 123extern intmy_printf (void *my_object, const char *my_format, ...) __attribute__((format(printf, 2, 3))); Objective-C 程序员也可使用 __NSString__ 来格式化来做到相同的格式化规则，像在 NNString 中通过 +stringWithFormat: 和 NSLog() 格式化字符串一样。 nonnull 这个 nonnull 属性指定了某些函数的参数必须是非空的指针。 123extern void *my_memcpy (void *dest, const void *src, size_t len) __attribute__((nonnull (1, 2))); 使用 nonnull 编码期望这个值遵守一个明确的约定中，这样能帮助捕获潜伏在任何代码调用的 NULL 指针 bugs，请记住： 编译时的错误 &gt;&gt; 运行时的错误。 noreturn 一些标准库函数，例如 abort 和 exit ,是不能返回的。GCC 自动知道这些东西，这个 noreturn 属性用于指定任何其他函数永远不会返回的情况。 例如，AFNetworking 使用 noreturn 属性在它的 网络请求线程进入点的方法 里面,这个方法用在当大量产生专用的网络的线程里用来保证分离的线程持续执行在应用的整个生命周期中。 pure&#x2F;const pure 属性指定了一个函数除了返回值没有副作用，例如它的返回值仅仅依赖参数和&#x2F;或者全局变量。这样的函数可以用公共子表达式消除并且循环优化就像一个算数操作符那样。 pure 属性指定了一个函数不会检查任何值除了它们的参数，并且返回值没有副作用。注意到一个函数有一个指针参数并且需呀检查数据的指向不能声明成 const 。同样的，一个函数调用一个非 nonst 函数通常不能为 const ,一个 const 函数返回 void 并没有什么意义。 1int square(int n) __attribute__((const)); pure 和 const 是两个执行在一个函数式编程惯例中的参数为了允许有效性能优化。 const 可以被认为是严格形式的 pure 因为它不依赖全局变量或者指针。 例如，因为一个函数声明为 const 的结果并不依赖任何东西除了传进来的参数。函数的结果能够缓存那个结果并且当函数被调用时返回，这样的函数叫做相同的组合参数（也就是说，我们知道一个数字的平方是一个常量，所以我们仅仅需要只计算它一次)。 unused 这个属性，附着在一个函数后面，意味着那个函数很可能不会被使用，GCC 不会对这个函数产生警告。 用 __unused 关键词可以获得相同的效果，声明这个在方法实现中不会被使用的参数中。知道那以后一些上下文就可以允许编译器来做相应的优化。你很可能喜欢在 delegate 方法实现李勉使用 __unused ,因为协议频繁的提高更多的上下文比通常必要的情况，为了满足大量的潜在使用案例。 LLVM像 GCC 的很多特征一样，Clang 也支持 __attribute__ ,添加到它自己的小范围的扩展。为了检查某个属性的可用性，你可以直接使用 __has_attribute 属性。 availability Clang 引进了 availability 属性，这个可以被取代在声明描述的生命周期中声明相对于操作系统的版本。思考对一个简单函数 f：的函数声明 1void f(void) __attribute__((availability(macosx,introduced=10.4,deprecated=10.6,obsoleted=10.7))); availability 属性声明 f 在 OS X 老虎系统中被引入，在 OS X 雪豹系统中被弃用，在 OS X 山狮系统中被废弃。 这个信息被 Clang 用来决定什么时候使用 f：函数式安全的，例如，假如 Clang 在 OS X 美洲豹系统上编译，调用 f()函数将成功。假如 Clang 在 OS X 雪豹系统中编译，函数调用将成功但是 Clang 会发出一个警告指明这个函数被弃用了。最后，假如 Clang 被引进编译 OS X 山狮系统的代码，函数调用将失败，因为 f()函数已经不再可用了。 availability 属性是一个逗号分隔的列表以平台名开始然后引入一些定语列举出生命周期内的重要里程碑事件附加额外的信息（以任何顺序）。 introduced：声明被引入的第一个版本 deprecated：声明被弃用的第一个版本，这意味着用户应该把这个 API 移走 obsoleted： 声明被废弃的第一个版本，这意味着它将被完全移除并且不能再使用 unavailable：声明在这个平台上将永远不可用 message：额外的消息将被 Clang 提供当忽略一个警告或者一个错误在使用一个被弃用或者被废弃的声明。对引导用户替换 APIs 很有用。 在声明时可以使用多个 availability 属性，每个对应不同的平台，仅当 availability 属性对应相应的目标平台被使用的时候，任何其他才将被忽略。假如没有 availability 属性指定可用性对现在的目标平台，availability 属性将被忽略。 支持的平台 ios：苹果的 iOS 操作系统。最小的部署目标被指定通过 -mios-version-min=*version* 或者 -miphoneos-version-min=*version* 命令行参数。 macosx：苹果的 OS X 操作系统，最小的部署目标被指定通过 -mmacosx-version-min=*version* 命令行参数 overloadable Clang 提供对 C++函数在 C 中重载的支持。在 C 中函数重载被引进使用 overloadable 属性。例如，一个可能提供一个重载版本的 tgsin 函数来精确执行相关的标准函数计算 float , double , long double 的正弦值： 1234#include &lt;math.h&gt;float __attribute__((overloadable)) tgsin(float x) &#123; return sinf(x); &#125;double __attribute__((overloadable)) tgsin(double x) &#123; return sin(x); &#125;long double __attribute__((overloadable)) tgsin(long double x) &#123; return sinl(x); &#125; 请注意 overloadable 只对函数起作用。你可以重载方法声明在某种范围内通过使用通用的返回值和参数类型，想 id 或者 void * . 上下文是国王当它遇到编译器优化时。通过提供限制在怎样解析你的代码，增加你参数尽可能高效代码的可能性。遇到编译器把你打断，这将是一项奖励。 还有 __attribute__ 并不仅仅对编译器有用：下一个人看代码也将感谢这些额外的上下文。所以多走几英尺远将对你的合作中和接替者或者从现在算 2 年以后的你(那个时候你已经忘记了所以的事情关于这份代码)自己有用 你付出了多少爱,最终你会得到多少爱。 译者注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"系统原理","slug":"系统原理","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"编译器","slug":"编译器","permalink":"https://blog.wangruofeng007.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"翻译","slug":"翻译","permalink":"https://blog.wangruofeng007.com/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"RunLoop 详解","slug":"2016-01-13-runloopxiang-jie","date":"2016-01-11T20:44:06.000Z","updated":"2024-11-03T06:20:18.763Z","comments":true,"path":"2016/01/12/2016-01-13-runloopxiang-jie/","permalink":"https://blog.wangruofeng007.com/2016/01/12/2016-01-13-runloopxiang-jie/","excerpt":"","text":"NSRunLoop 是什么？在 Cocoa 中，每个线程( NSThread )对象中内部都有一个 RunLoop( NSRunLoop ) 对象用来循环处理输入事件. NSRunloop 并不真的是一个 loop，在 Apple 的文档中也提到了需要自己写 while 或者 for 语句来实现,类似下面： 123while(running)&#123; [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];&#125; 何为 RunLoop 事件源从字面翻译来看，RunLoop 就是一个运行循环，的确它就是一个处理输入时间的运行循环，为什么需要这样处理，难道没有事件发生的时候让线程空转浪费资源？很明显在有事件发生的时候唤醒线程，没有事件发生的时候让其 sleep 更好。 下面我还是拿这张百看不厌的图来说事： 处理的事件包括两类 来自 Timer sources 的同步事件 来自 Input sources 的异步事件 Time Source. Timer sources deliver synchronous events, occurring at a scheduled time or repeating interval. 苹果文档中有句话需要注意， Timer sources deliver events to their handler routines but do not cause the RunLoop to exit.* 创建 NSTimer 添加到 RunLoop 中的时候，这里需要注意的是， NSTimer 默认是处于 NSDefaultRunloopMode ，这也就可以解释为什么如果你在你的控制器中添加了一个 timer 定时刷新你的界面，而你在拖动视图的时候 timer 不回 fire，因为这个时候你的 runloop 是 NSEventTrackingRunloopMode ,在这个 mode 下 timer 不会 fire。 input source input source 主要是一些异步的事件，比如来自其它线程或者其它 app 的消息。 input source 传递异步事件到其对应的处理函数，并且使 runUntilDate(与线程相关联的 RunLoop 对象调用)返回 为了能够处理 input source， RunLoop 产生 notifications。通过注册成 RunLoop observers 可以接受到这些通知（通过 Core Foundation 来注册 observers）。 RunLoopMode 有哪些？RunLoop 在处理输入事件时会产生通知，可以通过 Core Foundation 向线程中添加 RunLoop observers 来监听特定事件,以在监听的事件发生时做附加的处理工作。 每个 RunLoop 可运行在不同的模式下，一个 RunLoop mode 是一个集合，其中包含其监听的若干输入事件源，定时器，以及在事件发生时需要通知的 RunLoop observers。运行在一种 mode 下的 RunLoop 只会处理其 RunLoop mode 中包含的输入源事件、定时器事件、以及通知 RunLoop mode 中包含的 observers。 Cocoa 中的预定义模式有: Default 模式 定义 NSDefaultRunLoopMode (Cocoa) kCFRunLoopDefaultMode (Core Foundation) 描述：默认模式中几乎包含了所有输入源(NSConnection 除外),一般情况下应使用此模式，这是最常用的 RunLoop mode。 Connection 模式 定义： NSConnectionReplyMode (Cocoa) 描述：处理 NSConnection 对象相关事件，系统内部使用，这个 mode 表明 NSConnection 对象等待 reply,用户基本不会使用。 Modal 模式 定义： NSModalPanelRunLoopMode (Cocoa) 描述：处理 modal panels 事件,需要等待处理的 input source 为 modal panel 时设置，比如 NSSavePanel 和 NSOpenPanel。 Event tracking 模式 定义： UITrackingRunLoopMode (iOS) NSEventTrackingRunLoopMode (cocoa) 描述：使用该模式来处理用户界面相关的事件,例如在拖动 loop 或其他 user interface tracking loops 时处于此种模式下，在此模式下会限制输入事件的处理。例如，当手指按住 UITableView 拖动时就会处于此模式。 Common 模式 定义： NSRunLoopCommonModes (Cocoa) kCFRunLoopCommonModes (Core Foundation) 描述：这是一个伪模式，其为一组 RunLoop mode 的集合，将输入源加入此模式意味着在 Common Modes 中包含的所有模式下都可以处理。在 Cocoa 应用程序中，默认情况下 Common Modes 包含 default modes,modal modes,event Tracking modes, 可使用 CFRunLoopAddCommonMode 方法向 Common Modes 中添加自定义 modes。 注意这个并不是一个特定的 mode，而是一个 mode 的集合，而 runloop 必须运行在一个特定的 mode 下 。 获取当前线程的 runloop mode 1NSString *runLoopMode = [[NSRunLoop currentRunLoop] currentMode]; NSTimer、NSURLConnection 与 UITrackingRunLoopModeNSTimer 与 NSURLConnection 默认运行在 default mode 下，这样当用户在拖动 UITableView 处于 UITrackingRunLoopMode 模式时，NSTimer 不能 fire,NSURLConnection 的数据也无法处理。 NSTimer 的例子: 在一个 UITableViewController 中启动一个 0.2s 的循环定时器，在定时器到期时更新一个计数器，并显示在 label 上。 123456789101112131415161718- (void)viewDidLoad &#123; label =[[UILabel alloc]initWithFrame:CGRectMake(10, 100, 100, 50)]; [self.view addSubview:label]; count = 0; NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval: 0.2 target: self selector: @selector(incrementCounter:) userInfo: nil repeats: YES];&#125;- (void)incrementCounter:(NSTimer *)theTimer&#123; count++; label.text = [NSString stringWithFormat:@&quot;%zd&quot;,count];&#125; 在正常情况下，可看到每隔 0.2s，label 上显示的数字 +1,但当你拖动或按住 tableView 时，label 上的数字不再更新，当你手指离开时，label 上的数字继续更新。当你拖动 UItableView 时，当前线程 RunLoop 处于 UIEventTrackingRunLoopMode 模式，在这种模式下，不处理定时器事件，即定时器无法 fire,label 上的数字也就无法更新。 解决方法，一种方法是在另外的线程中处理定时器事件，可把 Timer 加入到 NSOperation 中在另一个线程中调度;还有一种方法时修改 Timer 运行的 RunLoop 模式，将其加入到 UITrackingRunLoopMode 模式或 NSRunLoopCommonModes 模式中。 即 1[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode]; 或 1[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 另外一种是放到 NSThread 中 1234567891011121314151617181920- (void)viewDidLoad&#123; [super viewDidLoad]; NSLog(@&quot;主线程 %@&quot;, [NSThread currentThread]); NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil]; [thread start];&#125;- (void)newThread&#123; @autoreleasepool&#123; [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(timer_callback) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] run]; &#125;&#125;- (void)timer_callback&#123; NSLog(@&quot;Timer %@&quot;, [NSThread currentThread]);&#125; NSURLConnection 也是如此，见 SDWebImage 中的描述,以及 SDWebImageDownloader.m 代码中的实现。修改 NSURLConnection 的运行模式可使用 scheduleInRunLoop:forMode: 方法。 123456NSURL *url = [NSURL URLWithString:@&quot;https://www.baidu.com&quot;];NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:15];self.connection = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:NO];[connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];[connection start]; 参考资料： Threading Programming Guide – RunLoops NSRunLoop Class Reference NSURLConnection Class Reference NSTimer Class Reference CFRunLoop wiki SDWebImage TestButtonDown 关于 NSRunloop 的学习和理解 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"系统原理","slug":"系统原理","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"RunLoop","slug":"RunLoop","permalink":"https://blog.wangruofeng007.com/tags/RunLoop/"}]},{"title":"iOS7 tintColor 详解","slug":"2016-01-13-ios7-tintcolorxiang-jie","date":"2016-01-11T20:41:39.000Z","updated":"2024-11-03T05:42:47.456Z","comments":true,"path":"2016/01/12/2016-01-13-ios7-tintcolorxiang-jie/","permalink":"https://blog.wangruofeng007.com/2016/01/12/2016-01-13-ios7-tintcolorxiang-jie/","excerpt":"","text":"为什么需要出现 tintColor ？ 解决以前不方便统一设置视图颜色风格的通点，方便自定义系统控件外观 跟 UIAppearance 协议设计有点类似， UIAppearance 是为了方便统一 设置一类控件的外观，而 tintColor 是为方便设置某个控件的外观，或者 说某个容器内所有控件的风格。 像在 UIViewController 中，通过这段代码可以实现容器内，所有的子 view 风格统一化,这样在这个控制器中的所有子 view 都会以 tintColor 显示 1self.view.tintAdjustmentMode = UIViewTintAdjustmentModeNormal UIView的tintAdjustmentMode需要说明一下，这是一个UIViewTintAdjustmentMode枚举 UIViewTintAdjustmentModeAutomatic（着色调整模式自动） UIViewTintAdjustmentModeNormal（着色调整模式正常） UIViewTintAdjustmentModeDimmed（着色调整模式变暗，打开控风格会变成灰白模式） 先看看官方 API 说明https://developer.apple.com/documentation/uikit/uiview/1622467-tintcolor?language=objc iOS7 以后所有的 UIView 以及它的子类都新增了一个叫 tintColor 的接口，方便我们对视图进行颜色调整 注意事项 UIImageView 需要设置 renderingMode 为 UIImageRenderingModeAlwaysTemplate 才能生效。renderingMode是一个类型为UIImageRenderingMode的枚举 UIImageRenderingModeAutomatic （默认渲染模式，自动模式） UIImageRenderingModeAlwaysOriginal（总是绘制原来的图片，不把它当成临时图片来处理） UIImageRenderingModeAlwaysTemplate （总是绘制临时图片，会忽略它原本的颜色信息，也就是根据 tintColor 生产图片） UIImageView 的使用12UIImage *image = [UIImage imageNamed:@&quot;xxx.png&quot;];image = [image imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate]; tintColor 更新在子类中重写 - (void)tintColorDidChange 方法，就可以实现每次更新 tintColor 的时候调用相关配置 12345- (void)tintColorDidChange&#123;_tintColorLabel.textColor = self.tintColor;_tintColorBlock.backgroundColor = self.tintColor;&#125;","categories":[{"name":"系统 API","slug":"系统-API","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F-API/"}],"tags":[{"name":"主色调","slug":"主色调","permalink":"https://blog.wangruofeng007.com/tags/%E4%B8%BB%E8%89%B2%E8%B0%83/"}]},{"title":"MacOSX10.11 上用 Octopress 和 GitHub 搭建个人博客","slug":"2016-01-13-macosx10-dot-11shang-yong-octopresshe-githubda-jian-ge-ren-bo-ke","date":"2015-12-11T20:30:38.000Z","updated":"2024-11-03T05:46:58.267Z","comments":true,"path":"2015/12/12/2016-01-13-macosx10-dot-11shang-yong-octopresshe-githubda-jian-ge-ren-bo-ke/","permalink":"https://blog.wangruofeng007.com/2015/12/12/2016-01-13-macosx10-dot-11shang-yong-octopresshe-githubda-jian-ge-ren-bo-ke/","excerpt":"","text":"序言经过一晚上的折腾，终于从 Hexo 成功转入 Octopress ,那么本文就来细说一下如何使用 Octopress + GitHub Pages 搭建个人博客 为什么选择 Octopress &amp; Github Pages? 免费且独立。把 Octopress 博客系统搭建到 Github Pages 虽是免费，但不失独立性，即便 Github 全站关闭，你也将有一份本地全站备份，随时可以重新恢复。不必受托管商之气，而且还免费，如果你愿意，甚至可以自行插入广告挣钱。 版本控制。写文章，建网站，做软件都需要修改，但有时候改完了又会后悔，如果有时光机就好了，Git 就是你的时光机。当然如果你不想了解这些看上去很唬人的 IT 名词，只是想写博客的话，请在需要的时候再研究这条的内容。 相对其他托管到 Github 上的博客程序，Octopress 更加成熟易上手。打个比方，Jekyll 可以说是毛坯房，Hexo 和 Octopress 算是简装修，但相比 Hexo，Octopress 有更多装修范例和更多熟练的装修工人，更容易获取帮助。当然如果你只想住精装修的房子，那不得不花点钱上 WordPress 了 使用 Markdown。Markdown 是现在最为流行的轻量级标记语言，也是已故的天才 Aaron Swartz 留给世人最好的礼物，窃以为每个在互联网上发布文章的人都该掌握。 按照官方的说法，Octopress 是个 A blogging framework for hackers (「为黑客设计的博客框架」)，这很酷，你不觉得吗？ 如果你之前没有写过博客，打算开始搭建自己第一个博客的话，其实也不妨试试 Octopress，免费还能学到东西，何乐而不为？ 本文是在 OS X EI Capitan 系统上搭建一个基于 Octopress 的个人博客系统，记录搭建过程的各种坑，希望对有想搭建个人博客的朋友有所帮助。 本文是建立在你有 Shell 指令基础和 Git 操作基础之上，如果不了解的话，需要查阅相关资料。 先解释几个专业术语： Ruby Ruby 是一种编程语言。Octopress 是用 Ruby 语言 实现的。我们不需要对它有太多了解，只需要正确安装 Ruby 的环境（Ruby 版本必须不低于 1.9.3-p0，后面会详细介绍）及按步骤执行指令即可。 RubyGems RubyGems（简称 gems）是一个用于对 Ruby 组件进行打包的 Ruby 打包系统。它可以用来查找、安装、升级和卸载软件包。我们也是通过它安装 Octopress 包的 RVM RVM 是 Ruby Version Manager 的简称，是一款 Ruby 语言安装、管理的工具。我们对 Ruby 的操作是通过它的指令完成的。 Jekyll Jekyll 一个简单的博客形态的静态站点生产机器。 Jekyll 有一套模板目录，可以将 Markdown 文件（或者 Textile）转换为静态网页，并生成一个完整的可发布的静态网站。 同时，我们可以将产生的静态网站布置到 GitHub Pages 上，生成个人博客站点。 想了解更多内容可以查看中文文档。 Octopress Octopress 是基于 Jekyll 的博客框架。他们的关系就像 jQuery 与 js 的关系一样。 它为我们提供了现成的美观的主题模板，并且配置简单，使用方便，大大降低了我们建站的门槛。 Git 分布式版本控制工具，跟它有点类似的是 SVN，只是两者使用场景不一样。 GitHub GitHub 是全球最热的开源社区，程序界的 Facebook。它为我们提供代码托管服务，以及我们搭建博客所需要的 Pages 服务。 GitHub Pages GitHub Pages 是 GitHub 提供的一项服务。它用于显示托管在 GitHub 上的静态网页。所以我们可以用 Github Pages 搭建博客，当然我们也可以把项目的文档和主页放在上面。 通过以上内容，我们大概能够明白 Octopress 建站的原理：我们使用基于 Jekyll 的 Octopress 站点生成工具，生成本地的静态网站。然后将静态网站托管到 GitHub 为我们提供的 GitHub Pages 服务上。访问 username.github.io 即可显示你的个人博客站了 明白了上面这些内容，下面进行具体的搭建工作： 第一步：安装 RubyMac 自带 Ruby 环境打开终端，安装 RVM ，终端执行指令： 1$ curl -L https://get.rvm.io | bash -s stable --ruby 接下来我们要查看自己的 Ruby 环境 1$ ruby -v 如果你的 Ruby 版本不低于 1.9.3-p0 可以忽略 Ruby 的安装（或升级），直接跳到安装 RubyGems 。 否则，我们执行之后的操作，终端执行指令： 12$ rvm install 1.9.3$ rvm use 1.9.3 然后安装 RubyGems， 终端执行指令： 1$ rvm rubygems latest 到这里第一步完成。我们可以再执行一次第一条指令 ruby -v 来查看当前 Ruby 的版本了。 第二步：安装 Octopress因为 Mac 系统自动 git 环境，所以我们不需要考虑 git 的安装。直接将 Octopress 的项目 clone 到本地，在终端执行指令： 1$ git clone git://github.com/imathis/octopress.git octopress 完成后进入 octopress 的目录 1$ cd octopress 接下来，安装依赖： 12345$ gem install bundler# 这时你可能会遇到没有权限的问题，那么我们需要加上 sudo 重新执行，并输入密码。$ sudo gem install bundler# 接下来执行：$ bundle install 这时你可能还会遇到问题如下： 12345Fetching gem metadata from https://rubygems.org/...........Resolving dependencies...Gem::RemoteFetcher::FetchError: SocketError: getaddrinfo: Name or service not known (https://rubygems.org/gems/rake-10.4.2.gem)An error occurred while installing rake (10.4.2), and Bundler cannot continue. 这是因为被墙了，解决办法有两个： 一个是，可以使用自己的翻墙工具； 另一个，淘宝做了一个 gem 的镜像。我们需要在 Octopress 的文件目录下找到 Gemfile 文件，将其中的 source &#39;https://rubygems.org/&#39; 改为 source &#39;https://ruby.taobao.org/&#39; 再重新运行 bundle install 就可以了。 这段内容可以参考 bundle install 提示如下，是需要翻墙解决么。 下面就可以安装 Octopress 的默认主题了，终端执行指令： 1rake install 这样一个最基本的个人博客站就产生了。 安装 octostrap3 主题（可选）1234$ cd octopress$ git clone https://github.com/kAworu/octostrap3.git .themes/octostrap3$ rake &quot;install[octostrap3]&quot;$ rake generate 会提示以下信息 1A theme is already installed, proceeding will overwrite existing files. Are you sure? [y/n] 输入 y 继续，然后开始安装… 1234567## Copying octostrap3 theme into ./source and ./sassmkdir -p sourcecp -r .themes/octostrap3/source/. sourcemkdir -p sasscp -r .themes/octostrap3/sass/. sassmkdir -p source/_postsmkdir -p public 显示上面的内容完成后没有错误，就安装主题完成 可以看出，现在显示得都是预设值，并不是我们想要的，所以需要修改 Octopress 目录下的_config.yml 文件。 文件目录 _config.yml 描述：保存配置数据。很多配置选项都会直接从命令行中进行设置，但是如果你把那些配置写在这儿，你就不用非要去记住那些命令了。 _config.yml 文件共分为 3 个部分内容 Main Configs Jekyll &amp; Plugins 3rd Party Settings 目前，我们只需要关注第一部分 Main Configs。 # ----------------------- # # Main Configs # # ----------------------- # #网站地址 url: http://wangruofeng.github.io #网站标题 title: 王若风的技术博客 #网站副标题 subtitle: 天天向上. #网址作者，通常显示在页尾和每篇文章的尾部 author: Ace #搜索引擎 #simple_search: http://google.com/search #网站的描述，出现在 HTML 页面中的 meta 中的 description #description: 对应填入你的个人信息，其中 url 为必填的，一般填 GitHub 仓库对应的连接，其内容大致就是 username.github.io ，这个地址我们会在后面步骤中获得。 第三步：集成 GitHub Pages 注册 Github 账号 这个没什么好说的，早晚需要，去 http://github.com 注册吧。 在 GitHub 上创建一个代码参考，项目名称命名规则为 username.github.io，username 必须与用户名称一致。 域名指向（可选）如果你有自己的域名可用，可以在这时就配置好，毕竟解析起来需要一段时间，不如在我们搭建博客的时候让它开始，这样我们搭建完成后，基本上就可以直接用自有域名访问了。 我的是在万网申请的，原价一年 100 多点现在有活动便宜的几块的都有，想要个性域名的可以去注册一个。 如果你用的是顶级域名，比如 wangruofeng007.com, 请创建两个 A 记录 (A Record) 分别指向 192.30.252.153 和 192.30.252.154 . 如果你使用二级域名，比如 blog.wangruofeng007.com, 请将该域名的 CNAME 指向 [your_username].github.io, 把其中的 [your_username]换成你自己在 Github 上的用户名。 如果你暂时没有域名，这一步可以暂时不用管 Ps. 在创建过程中最好不要 添加忽略文件 和 README 文件。因为我们要把本地的 git 仓库同步到 GitHub 远程仓库中。如果再远程仓库中添加了其他文件，需要我们执行 pull 操作。除非你能非常熟练的使用 git ，否则不建议你制造不必要的麻烦。接下来将本地代码仓库同步到 GitHub 上，执行终端指令： 1$ rake setup_github_pages 它会要求你绑定远程仓库的地址，此时只需要输入即可： 1$ git@github.com:username/username.github.com.git 这样就会将 Octopress 生成的静态站点与 GitHub 进行绑定了。 之后我们创建第一篇文章： 1rake new_post[&quot;title&quot;] 然后会有一个名为 yyyy-mm-dd-Post-Title.markdown 的文件在 octopress&#x2F;source&#x2F;_posts 目录下生成，其中 yyyy-mm-dd 是你当时的日期。然后执行以下命令： 12cd source/_posts/vim yyyy-mm-dd-Post-Title.markdown 即可用 vim 编辑器编辑的刚才的文章了，好吧我知道你作为这篇文章的读者并不是一个能熟练使用 vim 的人，那么请在命令行输入 q！退出这个编辑器。如果你不想假装是个黑客的话，其实发布文章并不需要这么麻烦。 我们直接打开 octopress/source/_posts 文件夹，找到刚才生成的文件，用你喜欢的 Markdown 编辑器（免费的我推荐 Mou或者Atom）或者文本编辑器打开，对文章内容进行编辑。 打开文件后，你会发现文章开头有这么一段信息: 1234567--- layout: post title: &quot;Post Title&quot; date: yyyy-mm-dd hh:mm:ss comments: true categories: &quot;&quot;--- 这其实是这篇文章的元数据：layout 暂时不要理会；title 是这篇文章显示在最终网页上的标题；date 部分是详细的文件生成时间，如 2014-01-28 03:35:00；comment 部分表示是否允许评论，目前显示是允许，如果想关闭评论，请改为 false；categories 指这篇文章的分类目录，请在后面引号中输入,不用引号也可以，多个分类用 空格 隔开，如果没有该目录，则会自动生成。请不要删除这段信息，在这段信息下面开始你的文章内容 这件事情给我们的启发是，以后发布文章，其实并不需要使用终端命令行生成文件。可以直接将自己写好的文章放到这个文件夹下面，当然请按照 yyyy-mm-dd-Post-Title.markdown 这样的文件格式命名，同时记得在文章前面添加元数据信息。这种做法生成的文章与上面的方法无异 生成的新文章在 source&#x2F;_post&#x2F;目录下，文件名构成为时间和标题的拼音。我们可以用 Markdown 编辑器对文章进行修改。之后生成静态站点，终端执行指令： 12# 生成静态站点$ rake generate 如果你想预览本地的站点，可以执行终端指令： 12# 预览静态站点$ rake preview 此时，可以使用浏览器打开 localhost:4000 查看效果。如果没有问题可以将静态站点同步到 GitHub 远程仓库中，终端执行指令： 12# 同步内容$ rake deploy 你会发现我们的静态站点已经被 push 到 GitHub 仓库的 master 分支上。稍等几分钟，访问 username.github.io (或者 username.github.com )，就会发现你的个人博客站已创建成功了。如果你还想给自己的本地资源文件（如 Markdown 文件等内容）也同步到 GitHub 中，可以执行以下指令： 123$ git add .$ git commit -m &quot;comment&quot;$ git push origin source 这样我们的资源文件就会同步到 GitHub 的 source 分支了。 使用自己的域名（可选）如果你有自己的域名，并且想指向这个新博客的话，请首先确保执行了第三步的 域名指向（可选） 的内容。如果没有执行，可以随时执行。然后执行下面的命令，注意把 your-domain.com 换成你自己的域名。 1echo &#x27;your-domain.com&#x27; &gt;&gt; source/CNAME 这句话的意思是在 source 分支下创建一个 CNAME 的文件并且将 your-domain.com 写入文件 然后再次执行以下命令： 12rake generaterake deploy 或者二合一 1rake gen_deploy 这样你就可以使用自己的域名了。域名解析需要一段时间，如果没有马上生效，请不要着急。如果长时间没有生效，请确保完整执行了 域名指向（可选） 和 使用自己的域名（可选） 的内容。 现在我们完成了个人博客的初级搭建，足够满足我们的基本需求。 错误处理出现下面的错误： 12Pushing generated _deploy website Permission denied (publickey).fatal: Could not read from remote repository. 这个错误是因为缺少 SSH keys ，只有拥有这个 key 才有权限 push 到远程仓库，通过这种方式实现权限安全控制。解决方案:Generating SSH keys 出现下面错误： 12345678## Pushing generated _deploy websiteTo git@github.com:wangruofeng/wangruofeng.github.io.git ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to &#x27;git@github.com:wangruofeng/wangruofeng.github.io.git&#x27;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: &#x27;git pull ...&#x27;) before pushing again.hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details. 原因，是修改了远程仓库，导致本地本地版本落后于远程仓库版本。最佳解决方案： 1234cd octopress/_deploygit pull origin mastercd ..rake deploy 参考链接：rake-gen-deploy-rejected-in-octopress 参考资料： 唐巧的博客: [象写程序一样写博客：搭建基于 github 的博客]（http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/） 觅珠人: 第一篇博文：用 Octopress 搭建博客系统 破船之家: 你好！github 页面 opoo.org: Octopress 博客系统 —— a Blogging Framework for Hackers Ocotpress: Octopress Documentation Havee’s Space: 为 Octopress 添加多说评论系统 colors4.us: Octopress 博客从零开始 III 浮生猎趣:用 Octopress 在 Github 搭建博客，并绑定独立域名 Aster0id 的个人博客:制作个人博客站（一）：Mac 系统下使用 Octopress + GitHub Pages 搭建个人博客 octopress 博客搭建和个性化配置 备注：欢迎转载，但请一定注明出处！ http://blog.wangruofeng007.com","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://blog.wangruofeng007.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Octopress","slug":"Octopress","permalink":"https://blog.wangruofeng007.com/tags/Octopress/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.wangruofeng007.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://blog.wangruofeng007.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"CLI","slug":"CLI","permalink":"https://blog.wangruofeng007.com/categories/CLI/"},{"name":"网络协议","slug":"网络协议","permalink":"https://blog.wangruofeng007.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"AI","slug":"AI","permalink":"https://blog.wangruofeng007.com/categories/AI/"},{"name":"最佳实践","slug":"最佳实践","permalink":"https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"name":"资料收集","slug":"资料收集","permalink":"https://blog.wangruofeng007.com/categories/%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"},{"name":"效率","slug":"效率","permalink":"https://blog.wangruofeng007.com/categories/%E6%95%88%E7%8E%87/"},{"name":"包管理","slug":"包管理","permalink":"https://blog.wangruofeng007.com/categories/%E5%8C%85%E7%AE%A1%E7%90%86/"},{"name":"系统 API","slug":"系统-API","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F-API/"},{"name":"动画","slug":"动画","permalink":"https://blog.wangruofeng007.com/categories/%E5%8A%A8%E7%94%BB/"},{"name":"总结复盘","slug":"总结复盘","permalink":"https://blog.wangruofeng007.com/categories/%E6%80%BB%E7%BB%93%E5%A4%8D%E7%9B%98/"},{"name":"系统原理","slug":"系统原理","permalink":"https://blog.wangruofeng007.com/categories/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"},{"name":"调试","slug":"调试","permalink":"https://blog.wangruofeng007.com/categories/%E8%B0%83%E8%AF%95/"},{"name":"三方 API","slug":"三方-API","permalink":"https://blog.wangruofeng007.com/categories/%E4%B8%89%E6%96%B9-API/"},{"name":"性能优化","slug":"性能优化","permalink":"https://blog.wangruofeng007.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"多线程","slug":"多线程","permalink":"https://blog.wangruofeng007.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.wangruofeng007.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"iOS","slug":"iOS","permalink":"https://blog.wangruofeng007.com/categories/iOS/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.wangruofeng007.com/tags/Flutter/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.wangruofeng007.com/tags/Hexo/"},{"name":"SSH","slug":"SSH","permalink":"https://blog.wangruofeng007.com/tags/SSH/"},{"name":"loT","slug":"loT","permalink":"https://blog.wangruofeng007.com/tags/loT/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://blog.wangruofeng007.com/tags/ChatGPT/"},{"name":"网站","slug":"网站","permalink":"https://blog.wangruofeng007.com/tags/%E7%BD%91%E7%AB%99/"},{"name":"插件","slug":"插件","permalink":"https://blog.wangruofeng007.com/tags/%E6%8F%92%E4%BB%B6/"},{"name":"Key","slug":"Key","permalink":"https://blog.wangruofeng007.com/tags/Key/"},{"name":"特效","slug":"特效","permalink":"https://blog.wangruofeng007.com/tags/%E7%89%B9%E6%95%88/"},{"name":"Snippets","slug":"Snippets","permalink":"https://blog.wangruofeng007.com/tags/Snippets/"},{"name":"Typora","slug":"Typora","permalink":"https://blog.wangruofeng007.com/tags/Typora/"},{"name":"Runtime","slug":"Runtime","permalink":"https://blog.wangruofeng007.com/tags/Runtime/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://blog.wangruofeng007.com/tags/CocoaPods/"},{"name":"Skill","slug":"Skill","permalink":"https://blog.wangruofeng007.com/tags/Skill/"},{"name":"精度","slug":"精度","permalink":"https://blog.wangruofeng007.com/tags/%E7%B2%BE%E5%BA%A6/"},{"name":"排序","slug":"排序","permalink":"https://blog.wangruofeng007.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"Swift","slug":"Swift","permalink":"https://blog.wangruofeng007.com/tags/Swift/"},{"name":"CALayer","slug":"CALayer","permalink":"https://blog.wangruofeng007.com/tags/CALayer/"},{"name":"VFL","slug":"VFL","permalink":"https://blog.wangruofeng007.com/tags/VFL/"},{"name":"翻译","slug":"翻译","permalink":"https://blog.wangruofeng007.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"Loading","slug":"Loading","permalink":"https://blog.wangruofeng007.com/tags/Loading/"},{"name":"年终总结","slug":"年终总结","permalink":"https://blog.wangruofeng007.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"name":"音视频","slug":"音视频","permalink":"https://blog.wangruofeng007.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"UIImage","slug":"UIImage","permalink":"https://blog.wangruofeng007.com/tags/UIImage/"},{"name":"bridge","slug":"bridge","permalink":"https://blog.wangruofeng007.com/tags/bridge/"},{"name":"block","slug":"block","permalink":"https://blog.wangruofeng007.com/tags/block/"},{"name":"奔溃分析","slug":"奔溃分析","permalink":"https://blog.wangruofeng007.com/tags/%E5%A5%94%E6%BA%83%E5%88%86%E6%9E%90/"},{"name":"LLDB","slug":"LLDB","permalink":"https://blog.wangruofeng007.com/tags/LLDB/"},{"name":"chisel","slug":"chisel","permalink":"https://blog.wangruofeng007.com/tags/chisel/"},{"name":"剪切板","slug":"剪切板","permalink":"https://blog.wangruofeng007.com/tags/%E5%89%AA%E5%88%87%E6%9D%BF/"},{"name":"IB","slug":"IB","permalink":"https://blog.wangruofeng007.com/tags/IB/"},{"name":"shell","slug":"shell","permalink":"https://blog.wangruofeng007.com/tags/shell/"},{"name":"Git","slug":"Git","permalink":"https://blog.wangruofeng007.com/tags/Git/"},{"name":"序列化","slug":"序列化","permalink":"https://blog.wangruofeng007.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"WatchOS2","slug":"WatchOS2","permalink":"https://blog.wangruofeng007.com/tags/WatchOS2/"},{"name":"MVVM","slug":"MVVM","permalink":"https://blog.wangruofeng007.com/tags/MVVM/"},{"name":"TableView","slug":"TableView","permalink":"https://blog.wangruofeng007.com/tags/TableView/"},{"name":"NSURLSession","slug":"NSURLSession","permalink":"https://blog.wangruofeng007.com/tags/NSURLSession/"},{"name":"锁","slug":"锁","permalink":"https://blog.wangruofeng007.com/tags/%E9%94%81/"},{"name":"SQLite","slug":"SQLite","permalink":"https://blog.wangruofeng007.com/tags/SQLite/"},{"name":"GET、POST","slug":"GET、POST","permalink":"https://blog.wangruofeng007.com/tags/GET%E3%80%81POST/"},{"name":"Networking","slug":"Networking","permalink":"https://blog.wangruofeng007.com/tags/Networking/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://blog.wangruofeng007.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"name":"NSThread","slug":"NSThread","permalink":"https://blog.wangruofeng007.com/tags/NSThread/"},{"name":"NSOperation","slug":"NSOperation","permalink":"https://blog.wangruofeng007.com/tags/NSOperation/"},{"name":"事件处理","slug":"事件处理","permalink":"https://blog.wangruofeng007.com/tags/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"},{"name":"历史事件","slug":"历史事件","permalink":"https://blog.wangruofeng007.com/tags/%E5%8E%86%E5%8F%B2%E4%BA%8B%E4%BB%B6/"},{"name":"技巧","slug":"技巧","permalink":"https://blog.wangruofeng007.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"CAShapeLayer","slug":"CAShapeLayer","permalink":"https://blog.wangruofeng007.com/tags/CAShapeLayer/"},{"name":"autoreleasing","slug":"autoreleasing","permalink":"https://blog.wangruofeng007.com/tags/autoreleasing/"},{"name":"编译器","slug":"编译器","permalink":"https://blog.wangruofeng007.com/tags/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"RunLoop","slug":"RunLoop","permalink":"https://blog.wangruofeng007.com/tags/RunLoop/"},{"name":"主色调","slug":"主色调","permalink":"https://blog.wangruofeng007.com/tags/%E4%B8%BB%E8%89%B2%E8%B0%83/"},{"name":"Octopress","slug":"Octopress","permalink":"https://blog.wangruofeng007.com/tags/Octopress/"}]}