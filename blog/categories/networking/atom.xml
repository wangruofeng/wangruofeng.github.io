<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Networking | 王若风的技术博客]]></title>
  <link href="http://wangruofeng.github.io/blog/categories/networking/atom.xml" rel="self"/>
  <link href="http://wangruofeng.github.io/"/>
  <updated>2016-01-19T23:33:15+08:00</updated>
  <id>http://wangruofeng.github.io/</id>
  <author>
    <name><![CDATA[王若风]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NSURLSession 教程]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/15/nsurlsession/"/>
    <updated>2016-01-15T18:15:01+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/15/nsurlsession</id>
    <content type="html"><![CDATA[<p>本文翻译自 <a href="http://www.raywenderlich.com/51127/nsurlsession-tutorial">http://www.raywenderlich.com/51127/nsurlsession-tutorial</a></p>

<p>原作者： Charlie Fulton</p>

<p>译者：<a href="https://twitter.com/oneruofeng">@oneruofeng</a></p>

<p>注意：这是一篇来自我们作为即将发布<a href="http://www.raywenderlich.com/?p=49762"> iOS 7 Feast</a>的一部分<a href="http://www.raywenderlich.com/?page_id=48020">iOS 7 by Tutorials</a>的简短版本的章节。我们希望你们喜欢。</p>

<p>每一个新的iOS版本发布都会包含一些极好的新的网络APIs，iOS7也不例外，在iOS7中，Apple引入了<code>NSURLSession</code>,这是为了取代<code>NSURLConnection</code>作为偏好的网络请求的一系列类。</p>

<p>在这个<code>NSURLSession</code>的教程中，你将了解到这个新类究竟是什么，为什么你要使用它以及你怎样使用它，它和以前的类库比较而言怎样，最后最重要的是：获得一个整合到一个真正的App的实践。</p>

<p>请注意：这个课程是假设你熟悉基本的网络概念。假如网络对你来说完全是新的，你仍然可以跟我一起一步一步的学习，但是可能有些你不熟悉的概念需要需要自己查询在这个过程中。</p>

<h4>为什么使用<code>NSURLSession</code></h4>

<p>为什么你要使用<code>NSURLSession</code>? 饿，因为它可以带给你一些好处和优势相比以前的：</p>

<ul>
<li><strong>后台上传和下载</strong> ： 当你创建<code>NSURLSession</code>的时候你只需配置一个选项即可，你便可以进行所有的后台网络任务。这将有对你的电池寿命有利，它支持<code>UIKit</code>多任务并且当切换线程的时候使用相同的代理模型。</li>
<li><strong>使你的网络操作可以暂停和恢复</strong> ：你稍后将会看到，任何使用<code>NSURLSession</code>API的网络任务都可以被暂停，停止，重新开始。而没有使用<code>NSOperation</code>子类的必要。</li>
<li><strong>可配置的容器</strong>：对于放进里面的请求而言每一个<code>NSURLSession</code>都是可配置的。例如，假如你需要设置一个HTTP header选项，你只需要设置一次然后每个在session中的请求就都会有相同的配置了。</li>
<li><strong>可子类化和私密存储</strong>： <code>NSURLSession</code>是可子类化的并且你可以配置一个session用来作为私密存储在某个会话中。这允许你拥有私密存储对象在全局状态下。</li>
<li><strong>优化的授权处理机制</strong>：授权被完成基于某个特定的连接。当使用<code>NSURLConnection</code>的时候假如发生了一处授权改变，这个改变将返回一个随意的请求，你不能确定你具体得到的那个。使用<code>NSURLSession</code>的话，代理回来处理授权。</li>
<li><strong>丰富的代理模型</strong>：<code>NSURLConnection</code>有些基于block的同步方法，然而代理就不能使用它们了。当一个请求建立了无论它是成功还是失败，哪怕需要授权。使用<code>NSURLSession</code>就就可以混合接入，使用基于block的异步方法同时也可以设置代理来处理授权。</li>
<li><strong>通过文件系统上传和下载</strong>：苹果鼓励把（文件内容）数据跟(URL和一些设置)元数据分开。</li>
</ul>


<h4><code>NSURLSession</code> vs <code>NSURLConnection</code></h4>

<p>&ldquo;哇哦，<code>NSURLSession</code>听起来很复杂呀！&rdquo;,你可能这么想。"我可能还是继续使用我的老朋友<code>NSURLConnection</code>。"</p>

<p>别担心&ndash;使用<code>NSURLSession</code>使用起来其实和它的前辈<code>NSURLConnection</code>一样简单对于简单的任务来说。例如，让我来看一个在获取伦敦最新的天气的一个简单网络请求，通过它来获取JSON数据的例子。</p>

<p>假设你用这个<code>NSString</code>来构造这个<code>NSURL</code>:</p>

<pre><code class="objective-c">NSString *londonWeatherUrl = @"http://api.openweathermap.org/data/2.5/weather?q=London,uk";
</code></pre>

<p>这里是第一步你使用<code>NSURLConnection</code>来调用：</p>

<pre><code class="objective-c">NSURLRequest *request = [NSURLRequest requestWithURL:
[NSURL URLWithString:londonWeatherUrl]];

[NSURLConnection sendAsynchronousRequest:request
   queue:[NSOperationQueue mainQueue]
   completionHandler:^(NSURLResponse *response,
                       NSData *data,
                       NSError *connectionError) {
      // handle response
}];
</code></pre>

<p>现在让我们来使用<code>NSURLSession</code>。注意这是使用<code>NSURLSession</code>的最简单的方式来快速构造一个请求。在后面的课程你将看到怎样配置session和设置其他特征比如像代理。</p>

<pre><code class="objective-c">NSURLSession *session = [NSURLSession sharedSession];
[[session dataTaskWithURL:[NSURL URLWithString:londonWeatherUrl]
          completionHandler:^(NSData *data,
                              NSURLResponse *response,
                              NSError *error) {
            // handle response

  }] resume];
</code></pre>

<p>注意你并不需要指定它运行在那个队列中。除了你特别指定，这个调用将会在后台线程。你可能很难注意到这两者之间有什么不同，它就是故意这样的。Apple提到打算使用<code>dataTaskWithURL</code>来取代在<code>NSURLConnection</code>中的<code>sendAsynchronousRequest</code>。</p>

<p>所有从根本上来讲&ndash;对于简单的任务使用<code>NSURLSession</code>就和使用<code>NSURLConnection</code>一样简单，并且它还有一些列额外的定制功能当你需要它的时候。</p>

<h4><code>NSURLSession</code> vs <code>AFNetworking</code></h4>

<p>不提到<code>AFNetworking</code>框架就谈不上谈论网络编程。这个事在<code>iOS/OS X</code>上最流行的框架，有杰出的<code>Mattt Thompson</code>创建。</p>

<blockquote><p>注意：想了解更多关于<code>AFNetworking</code>,请检出在<a href="https://github.com/AFNetworking/AFNetworking">https://github.com/AFNetworking/AFNetworking</a>的github页面。我们也有一个关于它的课程：<a href="http://www.raywenderlich.com/30445/afnetworking-crash-course">http://www.raywenderlich.com/30445/afnetworking-crash-course</a></p></blockquote>

<p>下面是的使用<code>AFNetworking</code> 1.x版本处理相同的数据任务的代码：</p>

<pre><code class="objective-c">NSURLRequest *request = [NSURLRequest requestWithURL:
                         [NSURL URLWithString:londonWeatherUrl]];

AFJSONRequestOperation *operation =
[AFJSONRequestOperation JSONRequestOperationWithRequest:request
    success:^(NSURLRequest  *request,
              NSHTTPURLResponse  *response,
              id JSON) {
    // handle response
} failure:nil];
[operation start];
</code></pre>

<p>使用<code>AFNetworking</code>的一个好处是处理响应的数据的数据根据类型被归类。使用<code>AFJSONRequestOperation</code>(或者诸如<code>XML</code>和plist相似的类),成功block已经被解析根据响应并且为你返回你想要的数据。使用<code>NSURLSession</code>你将收到一个<code>NSData</code>对象在<code>completion handler</code>,所有你只需要把<code>NSData</code>转换成<code>JOSN</code>或者其他形式。</p>

<blockquote><p>注意：你能够很方便的把数据从<code>NSData</code>转换成<code>JSON</code>使用在iOS 5引入的<code>NSJSONSerialization</code>这个类。如果你想了解更多，请查看23章的iOS 5 教程，“Working with JSON”。</p></blockquote>

<p>你或许想知道你是应该使用<code>AFNetworking</code>还是仅仅是继续使用<code>NSURLSession</code>。</p>

<p>就个人而言，我认为对于简单的需求最好还是继续使用<code>NSURLSession</code>&ndash;这样可以避免不必要的引入一个第三方库在你的工程中。另外，使用新的代理，配置，和基于很多添加到<code>AFNetworking</code>中的的“遗失特征”现在都被包括了的API的任务。</p>

<p>然而，假如你想使用一些在<code>AFNetworking</code>中2.0版本的新特性，诸如序列化和将来对
<code>UIKit</code>的整合（添加到<code>UIIImageView</code>分类中），然后这样很难争辩不使用它！</p>

<blockquote><p>注意：在<code>AFNetworking</code>2.0分支中，它们已经转换到使用<code>NSURLSession</code>。更多信息看这篇帖子：<a href="https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-2.0-Migration-Guide">https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-2.0-Migration-Guide</a></p></blockquote>

<h4>介绍 Byte Club</h4>

<p>在这篇<code>NSURLSession</code>教程中，你将探索这个新的API通过构建一篇日记好图片分享app基于<code>Dropbox Core API</code>,因为是顶级机密组织因此姑且命名它<code>Byte Club</code>。</p>

<p>考虑到这个课程是你接受到<code>Byte Club</code>的官方邀请！什么是你可能会问到的关于<code>Byte Club</code>的第一条规则？没人谈论<code>Byte Club</code>&ndash;除了那些足够炫酷的人将会阅读这个教程。并且那些Android用户完全不知道；他们被他们俩的生活劫持了。 ：]</p>

<p>开始构建app迎战下一个章节，将充当被<code>Byte Club</code>组织邀请。</p>

<p>主要到这个教程是假设你对基本的网络有基本的了解在先前的版本iOS。它非常有用假如你已经使用过诸如<code>NSURLConnection</code>或者<code>NSURLSession</code>在过去。假如在iOS方面你是网络方面的新手，在继续这个课程之前你应该查询我们的iOS学徒系列作为最初的开发者。</p>

<h4>现在开始吧</h4>

<p><code>Byte Club</code>是iOS 开发者专有的组织，一起来加入挑战你的编程吧。由于每个成员都是远程工作，在这个挑战中有一个是跨越世界，成员通过分享他们“战场”的全景照片也能找到它的乐趣。</p>

<p>例如，下面是Ray的办公场所的全景照片：
<img src="http://ww4.sinaimg.cn/mw690/64124373gw1ezzf1ygxi8j20go03njs2.jpg" alt="Ray's office setup" /></p>

<blockquote><p>注意：你可能想创建你自己办公室的全景照片&ndash;它很有趣，在这个课程的后续中我们将会处理。</p>

<p>在 iOS 7中，你可以通过打开相机选择一个叫<code>Pano</code>（全景）的标签照一张全景照片。</p>

<p>加入你喜欢那张，把它设置成你锁屏界面的墙纸通过打开<code>设置</code>让后选择<code>墙纸</code>  \选择墙纸 \我的全景照片。</p></blockquote>

<p>当然-<code>Byte Club</code>有它自己的app，我们来见证奇迹。你可以和其他成员使用app来完成编程挑战或者分享全景照片。在幕后，这是通过网络实现-明确的说，就是通过<code>Dropbox API</code>来分享文件。</p>

<h4>开始的工程概述</h4>

<p>首先，下载<a href="http://cdn1.raywenderlich.com/downloads/ByteClub_Starter.zip">教程开始的工程</a>。</p>

<p>开始的工程包含了为你预先准备好的UI，所以你只需把精力集中在这个教程中app的网络部分。开始的工程也包含一些处理<code>Dropbox</code>授权的代码,在后面你将学到更多。</p>

<p>在Xcode中打开工程让后在你设备或者模拟器上运行，你应该看到像下面这样：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/64124373gw1ezzf1vk3t1j205b09edg2.jpg" alt="networking2" /></p>

<p>然而你还并不能登录它-你不得不先配置app，你将做一点。</p>

<p>下一步打开<code>Main.storyboard</code>纵览一下整个app的设计：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/64124373gw1ezzf1x56zfj20go0a9q3e.jpg" alt="networking2" /></p>

<p>这是一个最基本的使用2个标签的的TabBarController app：一个是为了挑战编程，另
一个是为了放全景照片。这里也有预先让用户登录到app中的一步。你将要配置登录在你创建完<code>Dropbox</code>平台下的App后。</p>

<p>感到很轻松浏览一下App剩余的部分并且找到到目前为止相似的地方。你将会注意到除了授权组件，这里没有检索挑战编程或者全景照片的网络代码-那就是你的工作！</p>

<h4>创建一个新的<code>Dropbox</code>平台App</h4>

<p>为了开始你的新的<code>Dropbox</code> App,打开 Dropbox App 位于<a href="https://www.dropbox.com/developers/apps">https://www.dropbox.com/developers/apps</a>的控制台</p>

<p>用你的<code>Dropbox</code>账号登录，假如没有，没问题：马上创建一个免费的Dropbox账号。假如这是你第一次使用Dropbox的API，你需要通知Dropbox的条款和条件。</p>

<p>经过这个法定的材料以后就是上路了，选择创建App选项。将呈现给你一系列问题-提供下面的答案</p>

<ul>
<li>What type of app do you want to create?

<ul>
<li>Choose: <strong>Dropbox API app</strong></li>
</ul>
</li>
<li>What type of data does your app need to store on Dropbox?

<ul>
<li>Choose: <strong>Files and Datastore</strong></li>
</ul>
</li>
<li>Can your app be limited to its own, private folder?

<ul>
<li>Choose: <strong>No – My App needs access to files already on Dropbox</strong></li>
</ul>
</li>
<li>What type of files does your app need access to?

<ul>
<li>Choose: <strong>All File Types</strong></li>
</ul>
</li>
</ul>


<p>最终，为你的App准备一个名字，选择什么并没有关系只有它是唯一的。假如你选择了一个别人已经在使用的名字<code>Dropbox</code>将会告诉你。你的屏幕应该看起来像下面这样：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/64124373gw1ezzf38fs1nj20go0epdhp.jpg" alt="networking3" /></p>

<p>点击<code>Create App</code>，你将开始上路了！</p>

<p>下一个屏幕你将看到显示到屏幕中的包含 <strong>App key</strong> 和 <strong>App secret</strong> :</p>

<p><img src="http://ww3.sinaimg.cn/mw690/64124373gw1ezzfuk4ucmj208z08rglt.jpg" alt="networking5" /></p>

<p>先不要关闭这个屏幕，你将需要需要下一步的<code>App Key</code>和<code>App Secret</code>。</p>

<p>打开<code>Dropbox.m</code>文件找到下面这些行：</p>

<pre><code class="objective-c">#warning INSERT YOUR OWN API KEY and SECRET HERE
static NSString *apiKey = @"YOUR_KEY";
static NSString *appSecret = @"YOUR_SECRET";
</code></pre>

<p>填写你的app key 和 secret，让后删除 #warning line，现在你可以关闭<code>Dropbox</code> Web App 页面。</p>

<p>下面，创建一个文件夹在你Dropbox主文件下的根目录给它命一个你想要的名字。假如你把这个文件夹个和其他的Dropbox用户分享，发送他们在构建 Byte Club App的时候，他们将能够创建笔记并且能够上传所有人都能看得见的照片。</p>

<p>在Dropbox.m中找打下面这些行：</p>

<pre><code class="objective-c">#warning THIS FOLDER MUST BE CREATED AT THE TOP LEVEL OF YOUR DROPBOX FOLDER, you can then share this folder with others
NSString * const appFolder = @"byteclub";
</code></pre>

<p>改变字符串的值，设置成你创建的Dropbox文件夹的名字，让后删除 #warning pragma.</p>

<p>为了把这个app分发给其他用户，给他们接入<code>access tokens</code>,你将需要为你的Dropbox 平台 App打开<code>Enable additional users</code>设置。</p>

<p>去在<a href="https://www.dropbox.com/developers/apps">https://www.dropbox.com/developers/apps</a>Dropbox app的控制台。点击你app 名称。然后点击<code>Enable Additional Users</code>按钮。将出现一个状态对话框表明你已经增加了你的用户限制。点击Okay关闭对话框。你的App 页面将像下面这样显示：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/64124373gw1ezzg9htvs2j20go056jrj.jpg" alt="networking5" /></p>

<blockquote><p>注意：你可能注意到当你正在开发你的app的时候，你可以接入多达100个用户。当你准备发布app销售的时候，你必须申请生产状态，你可以通过点击<code>Apply for production</code>按钮来发送给<code>Dropbox</code>一些额外的信息。</p>

<p>Dropbox 将随后审核你的App 来确保它遵守指南，假如所有的一切进行得顺利的话，你将打开你的app的 API接入无线的用户。</p></blockquote>

<h4>Dropbox 授权: 概览</h4>

<p>假如你曾经使用过第三方<code>twitter</code>客服端app，像<code>TweetBot</code>,你将会熟悉<code>OAuth</code>授权处理步骤从一个用户的角度。<code>OAuth</code>授权接入过程对你app来说是完全一样的。</p>

<p>构建运行你的app，按照步骤登录。你将看到一个有2个标签的空白屏幕，一个是Notes，一个是PanoPhotos，如下图显示：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/64124373gw1ezzglpqm1aj209f0fa0t7.jpg" alt="networking7" /></p>

<p><code>OAuth</code>授权发生在3和高级的步骤：</p>

<ol>
<li>获取用来处理剩下的授权一个OAuth请求 token。这是请求token。</li>
<li>一个web 页面被呈现到用户面前通过他们的web浏览器。没有这一步的用户授权，对你的应用想获取一个第三步中的接入token几乎不可能。</li>
<li>在第二步完成后，应用调用web服务来交换临时请求token（从第一步中的）为了一个将存储在app里面的持久接入token。</li>
</ol>


<blockquote><p>注意：为了保证这个教程的简洁，我们不打算进行更详细的讲解关于这里Dropbox授权工作。然而，假如你想了解更多点击整个教程的完全版本，它是<a href="http://www.raywenderlich.com/?page_id=48020">iOS 7 by Tutorials.</a>的一部分。</p></blockquote>

<h4>NSURLSession 的一系列类</h4>

<p>Apple已经把<code>NSURLSession</code>描述成一个新类和一系列旧类的组合。这些新的工具是为了处理 上传，下载，处理授权已经处理在HTTP协议里面的任何事情。</p>

<p><img src="http://ww3.sinaimg.cn/mw690/64124373gw1ezzgzutn43j20go0dwgn3.jpg" alt="networking12" /></p>

<p>一个<code>NSURLSession</code>用一个带可选代理的<code>NSURLSessionConfiguration</code>构造。在你创建会话以后，你应该能够满足你的网络需要通过创建<code>NSURLSessionTask</code>的任务。</p>

<h4>NSURLSessionConfiguration</h4>

<p>这里有三种方式创建<code>NSURLSessionConfiguration</code>:</p>

<ul>
<li><strong>defaultSessionConfiguration</strong> - 创建一个使用全局缓存，cookie的配置对象和凭证存储的对象。这个配置会使你的会话最像<code>NSURLConnection</code>。</li>
<li><strong>ephemeralSessionConfiguration</strong> - 这个配置是用来作为‘私有的’会话并且不会持久化存储缓存，cookie，或者信用存储对象。</li>
<li><strong>backgroundSessionConfiguration</strong> - 当你想要从远程推送或者当app被暂时挂起时进行网络业务使用这个这个配置。参考17章和18章在<a href="http://www.raywenderlich.com/?page_id=48020"> iOS 7 by Tutorials</a>,<code>Beginning and Intermediate Multitasking</code>,有更详细的讲解。</li>
</ul>


<p>一旦你创建一个<code>NSURLSessionConfiguration</code>对象，你就可以在它上面设置各种接口像这样：</p>

<pre><code class="objective-c">NSURLSessionConfiguration *sessionConfig =
[NSURLSessionConfiguration defaultSessionConfiguration];

// 1
sessionConfig.allowsCellularAccess = NO;

// 2
[sessionConfig setHTTPAdditionalHeaders:
          @{@"Accept": @"application/json"}];

// 3
sessionConfig.timeoutIntervalForRequest = 30.0;
sessionConfig.timeoutIntervalForResource = 60.0;
sessionConfig.HTTPMaximumConnectionsPerHost = 1;
</code></pre>

<ol>
<li>你限制了网络操作只有wifi才能进行。</li>
<li>这将设置所有的请求只接受 JSON类型的响应。</li>
<li>这些接口将配置资源或者请求超时时间。你也可以限制你的app对你的主机只能有一个网络连接。</li>
</ol>


<p>这些仅仅是你能配置的一些东西，确保检查所有列表的文档。</p>

<h4>NSURLSession</h4>

<p><code>NSURLSession</code>被设计成替代<code>NSURLConnection</code>的API。Sessions做了他们的工作通过他们的部下，也就是非常出名的<code>NSURLSessionTask</code>对象。使用<code>NSURLSession</code>你能够创建任务使用基于block的便利方法，设置一个代理，或者同时两者。例如，假如你想要下载一张
图片（ <em>challenge hint </em>）,你就需要创建一个<code>NSURLSessionDownloadTask</code>。</p>

<p>第一步，你需要创建(会话)session。 这里有一个例子：</p>

<pre><code class="objective-c">// 1
NSString *imageUrl =
@"http://www.raywenderlich.com/images/store/iOS7_PDFonly_280@2x_authorTBA.png";

// 2
NSURLSessionConfiguration *sessionConfig =
  [NSURLSessionConfiguration defaultSessionConfiguration];

// 3
NSURLSession *session =
  [NSURLSession sessionWithConfiguration:sessionConfig
                                delegate:self
                           delegateQueue:nil];
</code></pre>

<p>Ok,这个仅仅是你目前所看到的一点点不同。让我们一步步重温。</p>

<ol>
<li>用这个代码片段我们将一样进行下载在两个任务中。</li>
<li>你总是以创建<code>NSURLConfiguration</code>开始。</li>
<li>这里创建一个会话使用现在的类作为代理。</li>
</ol>


<p>在你创建会话后，你可以通过创建一个带一个<code>completion handler</code>的任务下载这张图片，想下面这样:</p>

<pre><code class="objective-c">// 1
NSURLSessionDownloadTask *getImageTask =
[session downloadTaskWithURL:[NSURL URLWithString:imageUrl]

    completionHandler:^(NSURL *location,
                        NSURLResponse *response,
                        NSError *error) {
        // 2
        UIImage  *downloadedImage =
          [UIImage imageWithData:
              [NSData dataWithContentsOfURL:location]];
      //3
      dispatch_async(dispatch_get_main_queue(), ^{
        // do stuff with image
         _imageWithBlock.image = downloadedImage;
      });
}];

// 4
[getImageTask resume];
</code></pre>

<p>Ah ha!现在这个看起来有点像网络代码！</p>

<ol>
<li><p>任务总是被sessions创建。任务一旦被基于block的方法创建。记住你仍然可以使用<code>NSURLSessionDownloadDelegate</code>来跟踪下载进度。所以你将获得最好的两个单词！（ <em>hint for challenge </em>）</p>

<p> -URLSession:downloadTask
 :didWriteData:totalBytesWritten
 :totalBytesExpectedToWrite:</p></li>
<li><p>这里你使用在 <code>completion handler</code>提供的本地变量来获取一个指向图片的指针。</p></li>
<li>最终你能够，例如，更新 <code>UIIImageView</code>的图片来显示新的文件。(hint hint ☺)</li>
<li>你总得自己启动任务！</li>
<li>记住我在前面所说的，一个会话也可以创建将要发送消息给代理方法来通知你完成等的任务。</li>
</ol>


<p>应该长成这样，使用相同的会话从上面：</p>

<pre><code class="objective-c">// 1
NSURLSessionDownloadTask *getImageTask =
  [session downloadTaskWithURL:[NSURL URLWithString:imageUrl]];

[getImageTask resume];
</code></pre>

<ol>
<li>这当然是确定使用更少的代码☺ 然而，假如你只这样做，你将什么都看不到。
你需要让你的代理实现一些<code>NSURLSessionDownloadDelegate</code>协议的方法。</li>
</ol>


<p>首先我们需要获得通知当下载完成时：</p>

<pre><code class="objective-c">-(void)URLSession:(NSURLSession *)session
     downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location
{
  // use code above from completion handler
}
</code></pre>

<p>再有你需要提供将要下载的文件存放的位置，然后你就可以使用这个来处理图片。</p>

<p>最后，假如你需要跟踪下载进度，对于任务创建方法，你需要像下面这样用：</p>

<pre><code class="objective-c">-(void)URLSession:(NSURLSession *)session
     downloadTask:(NSURLSessionDownloadTask *)downloadTask
     didWriteData:(int64_t)bytesWritten
totalBytesWritten:(int64_t)totalBytesWritten
totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite
{
  NSLog(@"%f / %f", (double)totalBytesWritten,
    (double)totalBytesExpectedToWrite);
}
</code></pre>

<p>正如你所见，<code>NSURLSessionTask</code>是一匹通过网络来干活的真实的驮马。</p>

<h4>NSURLSessionTask</h4>

<p>目前为止你已经知道<code>NSURLSessionDataTask</code>和<code>NSURLSessionDownloadTask</code>怎样使用了。这两个的任务是来自他们共同的基类<code>NSURLSessionTask</code>，你可以在这类看到：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/64124373gw1ezzij54674j20go0d53zc.jpg" alt="networking13" /></p>

<p><code>NSURLSessionTask</code>在你的会话中是任务的基类；他们只能通过一个会话创建并且它们是下面子类中的一个。</p>

<h4>NSURLSessionDataTask</h4>

<p>这个任务发起HTTP GET请求来从服服务器拉取数据。数据被返回以NSData的形式返回。你应该在随后将其把这个数据转换成正确的数据类型比如<code>XML</code>,<code>JSON</code>,UIImage，plist等等。</p>

<pre><code class="objective-c">NSURLSessionDataTask *jsonData = [session dataTaskWithURL:yourNSURL
      completionHandler:^(NSData  *data,
                          NSURLResponse  *response,
                          NSError  *error) {
        // handle NSData
}];
</code></pre>

<h4>NSURLSessionUploadTask</h4>

<p>使用这个类当你需要上传一些东西到web服务器时，使用HTTP <code>POST</code> 或者 <code>PUT</code> 命令。任务带来也允许你监视网络状况当它正在传输的时候。</p>

<p>上传一张图片：</p>

<pre><code class="objective-c">NSData *imageData = UIImageJPEGRepresentation(image, 0.6);

NSURLSessionUploadTask *uploadTask =
  [upLoadSession uploadTaskWithRequest:request
                              fromData:imageData];
</code></pre>

<p>在这类任务被创建从一个会话中并且图片以NSData的形式上传。这里也可以通使用一个文件或者流的方法来进行上传。</p>

<h4>NSURLSessionDownloadTask</h4>

<p><code>NSURLSessionDownloadTask</code>让通过远程服务下载文件变得超级简单，并且可以暂停和恢复下载只要你想。这个子类有别于其他两个。</p>

<ul>
<li>这个类型的任务直接写入一个临时文件。</li>
<li>在下载会话中将调用<code>URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:</code>来更新状态信息。</li>
<li>当任务完成时，<code>URLSession:downloadTask:didFinishDownloadingToURL:</code>被调用。这就是你该保存文件从临时位置到一个永久位置的时候。</li>
<li>当下载失败或者取消时，你可以让数据重新开始下载。</li>
</ul>


<p>这个特性将极其有用当你在下载一个<code>Byte Club</code>定位 全景照片给你的设备的相机胶卷。你看到的一个下载任务例子在上面下载图片片段中。</p>

<h5>上述全部</h5>

<p>所有的上述任务被创建在一个暂停的状态；在创建一个任务时你需要调用它的继续方法像下面演示的那样：</p>

<pre><code class="objective-c">[uploadTask resume];
</code></pre>

<p>当你一次不只管理一个任务时，<code>taskIdentifier</code>接口允许你唯一标示一个在会话中的任务</p>

<p>这就是！既然你已经知道了<code>NSURLSession</code>系列的主要类，让我们尝试一下。</p>

<h4>Sharing notes with NSURLSession</h4>

<p>OK，这不是死亡诗社，这是<code>Byte Club</code>!是时候开始看看一下这个的网络代码在起作用了。</p>

<p>你需要一个方法来给<code>Byte Club</code>的其他成员发送消息。既然你已经设置了接入token，下一步就是实例化<code>NSURLSesssion</code>对象，让后调用你的第一个Dropbox API。</p>

<h5>Creating an NSURLSession</h5>

<p>添加下面的接口到 <strong>NotesViewController.m</strong> 文件，就在 NSArray  *notes 行的后面：</p>

<pre><code class="objective-c">@property (nonatomic, strong) NSURLSession *session;
</code></pre>

<p>你将创造所有你的下属从上面的session中。</p>

<p>添加下面的方法到<code>NotesViewController.m</code>就在<code>initWithStyle</code>方法的上面：</p>

<pre><code class="objective-c">- (id)initWithCoder:(NSCoder *)aDecoder
{
    self = [super initWithCoder:aDecoder];
    if (self) {
        // 1
        NSURLSessionConfiguration  *config = [NSURLSessionConfiguration ephemeralSessionConfiguration];

        // 2
        [config setHTTPAdditionalHeaders:@{@"Authorization": [Dropbox apiAuthorizationHeader]}];

        // 3
         _session = [NSURLSession sessionWithConfiguration:config];
    }
    return self;
}
</code></pre>

<p>下面是上面代码注释的注释的解释：</p>

<ol>
<li>你的app调用 <code>initWithCoder</code>当你实例化一个控制器从一个故事版中;因此这是一个完美的时刻初始化和创建<code>NSURLSession</code>。你并不想积极缓存或者持久化这里，所有你使用<code>ephemeralSessionConfiguration</code>便利方法，它返回一个没有持久化缓存，cookies，或者认证存储的会话。这是一个"私有浏览"配置。</li>
<li>下一步，你添加授权HTTP头道配置对象中。apiAuthorizationHeader是一个我写的辅助方法，返回一个字符串，以授权制定的格式。这个字符串包含access token，token secret和你的 Dropbox App API 秘钥。记住这是必要的因为每个对 Dropbox API 的调用都需要被授权。</li>
<li>最后，你使用上面的配置创建了<code>NSURLSession</code>。</li>
</ol>


<p>会话现在准备好创建在你app中你所需要的任何网络任务。</p>

<h5>GET Notes through the Dropbox API</h5>

<p>为了模拟一条笔记被另一个用户添加，添加任何你在设置在你的Dropbox根目录下的文件夹中选择的文本文件。例如位于Dropbox文件夹下 <strong>byteclub</strong> 下面显示的 <strong>test.txt</strong>：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/64124373gw1ezzkkwyf6ej20go03tglw.jpg" alt="networking14" /></p>

<p>等待直到<code>Dropbox</code>确认它已经同步完你的文件，让后继续下面代码。</p>

<p>添加下面的代码到空的<code>notesOnDropBox</code>方法中在<code>NotesViewController.m</code>:</p>

<pre><code class="objective-c">[UIApplication sharedApplication].networkActivityIndicatorVisible = YES;
// 1
NSURL *url = [Dropbox appRootURL];

// 2
NSURLSessionDataTask *dataTask =
[self.session dataTaskWithURL:url
            completionHandler:^(NSData  *data,
                                NSURLResponse  *response,
                                NSError  *error) {
    if (!error) {            
        // TODO 1: More coming here!
    }                
}];

// 3  
[dataTask resume];
</code></pre>

<p>这个方法的目标是检索在app的Dropbox文件下的文件列表。让我们来重温一下这是怎样工作的一步步。</p>

<ol>
<li>在Dropbox中，你能看到一个文件夹的内容通过进行一个已经授权的<code>GET</code>请求到某个特别的URL - 像<a href="https://api.dropbox.com/1/metadata/dropbox/byteclub.">https://api.dropbox.com/1/metadata/dropbox/byteclub.</a> 我已经创建了一个便利的方法在Dropbox类中来为你产生这个URL。</li>
<li><code>NSURLSession</code>用便利构造方法来简单的创建各种类型的任务。这是你创建的一个数据任务为了执行一个GET请求到那个URL。当请求完成时，你的<code>completionHandler</code> block被调用。一会儿你将添加一下代码到这里。</li>
<li>记住一个任务默认是一个<code>暂停</code>的状态,因此你需要调用恢复方法来启动运行。</li>
</ol>


<p>那就是所有你需要做的来开始一个<code>GET</code>请求-现在让我们添加代码到解析的结果中。添加下面的这些行到"TUDO 1"注释的后面:</p>

<pre><code class="objective-c">// 1
NSHTTPURLResponse *httpResp = (NSHTTPURLResponse *) response;
if (httpResp.statusCode == 200) {

    NSError  *jsonError;

    // 2
    NSDictionary  *notesJSON =
      [NSJSONSerialization JSONObjectWithData:data                                                                        
        options:NSJSONReadingAllowFragments                                                                             
        error:&amp;jsonError];

    NSMutableArray  *notesFound = [[NSMutableArray alloc] init];

    if (!jsonError) {                    
        // TODO 2: More coming here!
    }
}
</code></pre>

<p>下面是两个主要的部分:</p>

<ol>
<li><p>你知道你已经发送一个HTTP请求，所以响应将是一个HTTPP响应。因此这里你可以抛出<code>NSURLResponse</code>到一个<code>NSHTTPURLRequest</code>响应以便你能够接入到接口的状态码。
假如你收到了一个HTTP状态码200，然后一切正常。</p>

<p>  HTTP 错误码举例：</p>

<ul>
<li>400 - 输入参数错误。错误消息将表明那个和为什么错误。</li>
<li>401 - token错误或者失效。这个可能发生假如用户或者<code>Dropbox</code>被撤销或者接入token过期。你可以通过重新授权修复这个用户。</li>
<li>403 - 错误的授权请求（错误的用户键，坏的随机数，时间戳过期&hellip;）。不信的是，重新授权用户在这里并没有用。</li>
<li>404 - 指定路径下的文件或者文件夹没找到。</li>
<li>405 - 未知的请求方法（通常应该是 GET 或者 POST）。</li>
<li>429 - 你的app发送太多请求超出了限制的速率，429能够触发在每个app或者每个用户根部。</li>
<li>503 - 假如响应包括重发后的头，这就意味做你的<code>OAuth</code> 1.0 app 正在被限速。否则，这个表明了一个短暂的服务器错误，并且你的app应该重新发送这这个请求。</li>
<li>507 - 用户超出 Dropbox 储存配额。</li>
<li>5xx - 服务器错误。</li>
</ul>
</li>
<li><p>Dropbox API返回JSON类型的数据。所有你收到一个200的响应，然后应该把数据转发成JSON使用iOS的构建JSON序列化的方法。了解更多关于JSON和NSJSONSerialization，查看第23章在 <code>iOS 5 by Tutorials</code>,&ldquo;Working with JSON.&rdquo;</p></li>
</ol>


<p>JSON 数据返回从Dropbox将看起来像下面这样：</p>

<pre><code>{
    "hash": "6a29b68d106bda4473ffdaf2e94c4b61",
    "revision": 73052,
    "rev": "11d5c00e1cf6c",
    "thumb_exists": false,
    "bytes": 0,
    "modified": "Sat, 10 Aug 2013 21:56:50 +0000",
    "path": "/byteclub",
    "is_dir": true,
    "icon": "folder",
    "root": "dropbox",
    "contents": [{
        "revision": 73054,
        "rev": "11d5e00e1cf6c",
        "thumb_exists": false,
        "bytes": 16,
        "modified": "Sat, 10 Aug 2013 23:21:03 +0000",
        "client_mtime": "Sat, 10 Aug 2013 23:21:02 +0000",
        "path": "/byteclub/test.txt",
        "is_dir": false,
        "icon": "page_white_text",
        "root": "dropbox",
        "mime_type": "text/plain",
        "size": "16 bytes"
    }],
    "size": "0 bytes"
}
</code></pre>

<p>所有最后一段添加的代码是拉取的部分你感兴趣的从JSON中。特别的，你想循环遍历“contents”数组来把“is_dir”设置成<code>false</code>。</p>

<p>这样做，添加下面的代码到“TODO 2”注释后面：</p>

<pre><code class="objective-c">// 1
NSArray *contentsOfRootDirectory = notesJSON[@"contents"];

for (NSDictionary *data in contentsOfRootDirectory) {
    if (![data[@"is_dir"] boolValue]) {
        DBFile  *note = [[DBFile alloc] initWithJSONData:data];
        [notesFound addObject:note];
    }
}

[notesFound sortUsingComparator:
  ^NSComparisonResult(id obj1, id obj2) {
    return [obj1 compare:obj2];                    
}];

self.notes = notesFound;

// 6
dispatch_async(dispatch_get_main_queue(), ^{
    [UIApplication sharedApplication].networkActivityIndicatorVisible = NO;
    [self.tableView reloadData];
});
</code></pre>

<p>这里有两部分：</p>

<ol>
<li><p>你拉取数组对象从“contents”键中，让后循环便利数组。每个数组入口是一个文件，所以你创建一个相应的<code>DBFile</code>文件模型为每一个文件。</p>

<p> <code>DBFile</code>是一个我为你创建的辅助类，为了拉取信息从一个JSON字典到一个文件中 - 轻轻一瞥就能看到它是怎样工作的。</p>

<p> 当你完成时，你添加所有的笔记到<code>self.notes</code>接口中。表视图被设置来显示数组中的任何记录。</p></li>
</ol>


<p>既然你的表视图数据源已经更新了，你需要重载表的数据。无论何时你正在处理异步网络请求时，你必须保证更新UIKit在主线程。</p>

<p>机敏的读者将会注意到在上述代码中没有错误处理；假如你感觉你像一个哭丧女（大多数Byte Club 都是！）添加一些代码在这里（在随后的代码块中你将添加），代码在错误和警告用户的时候将重试。</p>

<p>构建运行你的app；你应该看你添加到你的<code>Dropbox</code>文件夹的文件是否显示在列表中，就像下面例子一样显示：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/64124373gw1ezzmc48hezj20aa0gojs1.jpg" alt="networking16" /></p>

<p>事情本来是小事，当时这证明了你正确的调用了Dropbox API。</p>

<p>下一步是发布比较然后向其他俱乐部成员发起挑战，再一次使用Dropbox API 就当你是传送机构。</p>

<h5>POST Notes through the Dropbox API</h5>

<p>轻点右上角的 + 号，你将看到笔记add/edit屏幕出现，就像下面演示的一样：</p>

<p><img src="http://ww4.sinaimg.cn/mw690/64124373gw1ezzmc5whzij20a90gojru.jpg" alt="networking17" /></p>

<p>开始的app已经安装了DBFile 模型对象到NoteDetailsViewController在<code>prepareForSegue:sender:</code>方法中：</p>

<p>加入你瞥一眼这个方法，你将看到<code>NoteViewController</code>被设置成<code>NoteDetailsViewController</code>的代理。这种方法，<code>NoteDetailsViewController</code>能够通知<code>NoteViewController</code>当用户完成编辑一篇笔记或者取消编辑一篇笔记时。</p>

<p>打开<code>NotesViewController.m</code>,添加下面这行到<code>prepareForSegue:sender:</code>中，就在<code>showNote.delegate = self</code>行的后面；</p>

<pre><code class="objective-c">showNote.session = _session;
</code></pre>

<p><code>NoteDetailsViewController</code>已经有一个<code>NSURLSession</code>的接口名字叫做<code>session</code>,因此你能够设置它在<code>prepareForSegue:sender:</code>载入之前。</p>

<p>现在detail view controller将获得相同的<code>NSURLSession</code>,所有detail view controller能够使用它来进行DropBox 的API调用。</p>

<p><code>Cancel</code>和<code>Done</code>按钮已经呈现在你的app中；你只需要添加一些在他们背后保存或者取消在尚未完工的笔记逻辑。</p>

<p>在<code>NoteDetailsViewController.m</code>,找到下面这一行在<code>(IBAction)done:(id)sender:</code>方法中：</p>

<pre><code class="objective-c">// - UPLOAD FILE TO DROPBOX - //
    [self.delegate noteDetailsViewControllerDoneWithDetails:self];
</code></pre>

<p>&hellip;用下面的替换它：</p>

<pre><code class="objective-c">// 1
NSURL  *url = [Dropbox uploadURLForPath: _note.path];

// 2
NSMutableURLRequest *request =
  [[NSMutableURLRequest alloc] initWithURL:url];
[request setHTTPMethod:@"PUT"];

// 3
NSData *noteContents = [_note.contents dataUsingEncoding:NSUTF8StringEncoding];

// 4
NSURLSessionUploadTask *uploadTask = [_session      
  uploadTaskWithRequest:request                                                                  
  fromData:noteContents                                                        
  completionHandler:^(NSData *data,                                                                             
  NSURLResponse *response,                                                                               
  NSError *error)
{   
   NSHTTPURLResponse *httpResp = (NSHTTPURLResponse*) response;

   if (!error &amp;&amp; httpResp.statusCode == 200) {

       [self.delegate noteDetailsViewControllerDoneWithDetails:self];
   } else {
       // alert for error saving / updating note
   }
}];

// 5
[uploadTask resume];
</code></pre>

<p>这个实现了你需要保存和分享你的笔记的所有事情。假如仔细观察每一块的注释，你将发现做了下面的事：</p>

<ol>
<li>为了上传一个文件到Dropbox，你需要再次使用某个API URL。就像先前你需要一个URL来列出在一个文件夹中的文件，我已经构造了一个辅助方法来为你产生URL。你可以在这里调用。</li>
<li>下一步是你的老朋友<code>NSMutableURLRequest</code>,新的APIs能够同时使用普通的URL是和<code>NSURLRequest</code>对象，但是这里你需要可变的形式来使Dropbox API让它的请求变成PUT请求。设置HTTP方法作为PUT发信号给Dropbox来让它为你创建一个新的文件。</li>
<li>下一步是将文本从你的<code>UITextView</code>编码成NSData对象。</li>
<li>既然你已经创建好了请求和NSData数据，你下一步就是创建一个<code>NSURLSessionUploadTask</code>然后设置<code>completion handler</code> block.一旦成功，你就调用代理方法<code>noteDetailsViewControllerDoneWithDetails:</code>来关闭呈现的内容。在生产级别的应用中你可以回传一个新的BDFile给代理然后同步你需要持久化的数据。为了这个应用，你只需要刷新<code>NotesViewController</code>用一个网络调用。</li>
<li>再次提到，所有的任务以暂停的状态被创建，所以你必须调用恢复来启动他们。</li>
</ol>


<p>构建然后运行你的App，点击笔记标签上的+号。在<code>challenge name</code>字段上输入你的名字，输入一些文本在<code>note</code>字段想Ray发布一份挑战书，和下面的例子相似：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/64124373gw1f008ujjji0j20aa0godgy.jpg" alt="networking17" /></p>

<p>当你清点<code>Done</code>时，<code>NoteViewController</code>将返回并且给你列出新的笔记像下面显示的那样：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/64124373gw1f008ukjg7bj20aa0go3z4.jpg" alt="networking18" />
)</p>

<p>你已经正式的给Ray下发挑战书；然而，他有朋友在非常高的位置所有你最好尽力完成这场比赛。</p>

<p>但是这里有一条非常重要的消息遗漏了。你能告诉我是什么么？</p>

<p>轻点笔记包含的挑战；<code>NoteDetailsViewController</code>自己呈现，当时笔记的内容确实空白的。</p>

<p>Ray并不会找到你的发的非常有威胁的挑战假如他没有读的话！</p>

<p>现在，app只是调用<code>Dropbox</code>元数据API来检索文件列表。你也需要添加一些代码来抓取笔记的内容。</p>

<p>打开<code>NoteDetailsViewController.m</code>,用下面的实现替换空白的<code>retreiveNoteText</code>的实现：</p>

<pre><code class="objective-c">-(void)retreiveNoteText
{
    // 1
    NSString  *fileApi =
      @"https://api-content.dropbox.com/1/files/dropbox";
    NSString  *escapedPath = [ _note.path
      stringByAddingPercentEscapesUsingEncoding:
      NSUTF8StringEncoding];

    NSString  *urlStr = [NSString stringWithFormat: @"%@/%@",
      fileApi,escapedPath];

    NSURL  *url = [NSURL URLWithString: urlStr];

    [UIApplication sharedApplication].networkActivityIndicatorVisible = YES;

    // 2
    [[ _session dataTaskWithURL:url completionHandler:^(NSData  *data, NSURLResponse  *response, NSError  *error) {

        if (!error) {
            NSHTTPURLResponse  *httpResp = (NSHTTPURLResponse*) response;
            if (httpResp.statusCode == 200) {
                // 3
                NSString  *text =
                 [[NSString alloc]initWithData:data
                   encoding:NSUTF8StringEncoding];
                dispatch_async(dispatch_get_main_queue(), ^{
                    [UIApplication sharedApplication].networkActivityIndicatorVisible = NO;
                    self.textView.text = text;
                });

            } else {
                // HANDLE BAD RESPONSE //
            }
        } else {
            // ALWAYS HANDLE ERRORS :-] //
        }
        // 4
    }] resume];
}
</code></pre>

<p>上面在笔记中的代码（没有错误检查）下面来解释：</p>

<ol>
<li>设置请求的路径和你期望检索的文件的URL地址；/文件的端点在Dropbox API中将会返回给你一个指定文件的内容。</li>
<li>用指向感兴趣的文件的URL创建数据任务。这个调用应该开始，只要你纵览整个app你会相当熟悉。</li>
<li>假如你响应的代码表明所有的都是好的，在主线程用你在先前的步骤中检索到的文件内容设置textView。记住，UI更新必须切换到主线程。</li>
<li>一旦这个任务被初始化，调用恢复。这里有写不一样的方法和以前的相比，当恢复被直接调用时在任务还没有指派时。</li>
</ol>


<p>构建运行你的App，在列表中对你的挑战轻点，内容将直接正确的显示在view中，像下面这样：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/64124373gw1f008ulhco4j20a90got9d.jpg" alt="networking19" /></p>

<p>你可以扮演Ray然后通过向笔记中输入文本响应这个挑战；文件将很快更新当你轻点<code>Done</code>。</p>

<h4>使用<code>NSURLSessionTask</code>代理发送照片</h4>

<p>你已经看到怎样使用<code>NSURLSession</code>异步便利构造方法。但是假如你想把注意力集中在文件传输上，例如上传一个大文件并且显示一个进度条怎么样？</p>

<p>对于这种异步的，耗时任务类型你需要实现<code>NSURLSessionTaskDelegate</code>协议方。通过实现这个方法，你能够检索回调当一个任务接收到数据和完成接收数据时。</p>

<p>你可能已经注意到<code>PanoPhotos</code>标签是空的当你启动App的时候。然而，<code>Byte Club</code>组织的创办成员已经慷慨的提供了一些他们自己的全景照片，你可以用它来填充你的app。</p>

<p>下载这些 我们为你放在一起的<a href="http://cdn4.raywenderlich.com/downloads/ByteClub_photos.zip">全景照片</a>。解压文件，拷贝到你的app在Dropbox目录下的照片目录。你文件夹的内容应该和下面一样：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/64124373gw1f00a5m7rhhj20go06ddhi.jpg" alt="networking20" /></p>

<p>Dropbox和核心API可以提供照片的缩略图；使用一个 UITableView cell这听起来想一件非常完美的事。</p>

<p>打开<code>PhotosViewController.m</code>然后在<code>“GO GET THUMBNAILS</code>注释后面添加下面的代码到<code>tableView:cellForRowAtIndexPath:</code></p>

<pre><code class="objective-c">[UIApplication sharedApplication].networkActivityIndicatorVisible = YES;
NSURLSessionDataTask *dataTask = [_session dataTaskWithURL:url
  completionHandler:^(NSData  *data, NSURLResponse  *response,
  NSError  *error) {
    if (!error) {
      UIImage  *image = [[UIImage alloc] initWithData:data];
      photo.thumbNail = image;
      dispatch_async(dispatch_get_main_queue(), ^{
        [UIApplication sharedApplication].networkActivityIndicatorVisible = NO;
        cell.thumbnailImage.image = photo.thumbNail;
      });
    } else {
      // HANDLE ERROR //
    }
}];
[dataTask resume];
</code></pre>

<p>上面的代码显示了照片的缩略图图在表视图的cell中。。。或者至少它会是，假如<code>_photoThumbnails</code>现在不是空的话。</p>

<p>找到<code>refreshPhotos</code>用下面的实现替换：</p>

<pre><code class="objective-c">- (void)refreshPhotos
{
    [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES];
    NSString  *photoDir = [NSString stringWithFormat:@"https://api.dropbox.com/1/search/dropbox/%@/photos?query=.jpg",appFolder];
    NSURL  *url = [NSURL URLWithString:photoDir];

    [[ _session dataTaskWithURL:url completionHandler:^(NSData
       *data, NSURLResponse  *response, NSError  *error) {
        if (!error) {
            NSHTTPURLResponse  *httpResp =
             (NSHTTPURLResponse*) response;
            if (httpResp.statusCode == 200) {

                NSError  *jsonError;
                NSArray  *filesJSON = [NSJSONSerialization  
                  JSONObjectWithData:data                                                                     
                  options:NSJSONReadingAllowFragments                                                                           
                  error:&amp;jsonError];
                NSMutableArray  *dbFiles =
                  [[NSMutableArray alloc] init];

                if (!jsonError) {
                    for (NSDictionary  *fileMetadata in
                      filesJSON) {
                        DBFile  *file = [[DBFile alloc]
                          initWithJSONData:fileMetadata];
                        [dbFiles addObject:file];
                    }

                    [dbFiles sortUsingComparator:^NSComparisonResult(id obj1, id obj2) {
                        return [obj1 compare:obj2];
                    }];

                     _photoThumbnails = dbFiles;

                    dispatch_async(dispatch_get_main_queue(), ^{
                        [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO];
                        [self.tableView reloadData];
                    });
                }
            } else {
                // HANDLE BAD RESPONSE //
            }
        } else {
            // ALWAYS HANDLE ERRORS :-] //
        }
    }] resume];
}
</code></pre>

<p>这个和你早期载入挑战笔记时写的代码很像。这次，API调用来查找在<code>photos</code>目录的内容，并且只会以.jpg拓展的文件。</p>

<p>既然<code>_photoThumbnails</code>数组已经填充好了，缩略图将出现在表视图中并且异步更新。</p>

<p>构建运行你的app，然后切换到<code>PanoPhotos</code>标签；缩略图将载入并且像下面这样出现：</p>

<p>！<a href="http://ww2.sinaimg.cn/mw690/64124373gw1f00ahhaw20j20a90go0uz.jpg">networking21</a></p>

<p>照片看起来非常的棒&ndash;只是请当心Matthijs家撕裂代码的猫🐱！</p>

<h4>上传一张全景照片</h4>

<p>你的app能够下载相片，如果它也能上传照片并且显示上传进度的话就非常棒了。</p>

<p>为了跟踪上传的进度，<code>PhotosViewController</code>必须成为<code>NSURLSessionDelegate</code>和<code>NSURLSessionTaskDelegate</code>协议的代理，以便你能收到进度回调。</p>

<p>修改在<code>PhotosViewController.m</code>中<code>PhotosViewController</code>的接口声明，添加<code>NSURLSessionTaskDelegate</code>,像下面这样：</p>

<pre><code class="objective-c"> @ interface PhotosViewController ()UITableViewDelegate, UITableViewDataSource, UIImagePickerControllerDelegate, UINavigationControllerDelegate, NSURLSessionTaskDelegate&gt;
</code></pre>

<p>下一步，添加下面的私有接口：</p>

<pre><code class="objective-c">@property (nonatomic, strong)
  NSURLSessionUploadTask *uploadTask;
</code></pre>

<p>上面的指针引用了任务对象；通过哪种方式，你就可以接入到对象的成员中来跟踪上传任务的进度了。</p>

<p>当用户选择一张图片上传时，<code>didFinishPickingMediaWithInfo</code>调用<code>uploadImage:</code>方法来执行文件上传。
现在，那个方法空了-这是你的工作让它丰满起来。</p>

<p>替换<code>uploadImage:</code>用下面的代码：</p>

<pre><code class="objective-c">- (void)uploadImage:(UIImage*)image
{
    NSData  *imageData = UIImageJPEGRepresentation(image, 0.6);

    // 1
    NSURLSessionConfiguration  *config = [NSURLSessionConfiguration defaultSessionConfiguration];
    config.HTTPMaximumConnectionsPerHost = 1;
    [config setHTTPAdditionalHeaders:@{@"Authorization": [Dropbox apiAuthorizationHeader]}];

    // 2
    NSURLSession  *upLoadSession = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:nil];

    // for now just create a random file name, dropbox will handle it if we overwrite a file and create a new name..
    NSURL  *url = [Dropbox createPhotoUploadURL];

    NSMutableURLRequest  *request = [[NSMutableURLRequest alloc] initWithURL:url];
    [request setHTTPMethod:@"PUT"];

    // 3
    self.uploadTask = [upLoadSession uploadTaskWithRequest:request fromData:imageData];

    // 4
    self.uploadView.hidden = NO;
    [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES];

    // 5
    [ _uploadTask resume];
}
</code></pre>

<p>下面是上面的代码做的事：</p>

<ol>
<li>起先，你使用设置在<code>initWithCoder</code>的会话和相关的便利方法来创建异步任务。这个时候，你使用一个<code>NSURLSessionConfiguration</code>,它只允许一个连接连接到远程主机，因为你上传进度处理一次就是一个文件。</li>
<li>上传和下载任务报告信息通过它们的代理返回；你将简短的实现。</li>
<li>这里你设置了<code>uploadTask</code>接口使用从<code>UIImagePicker</code>获得的JPEG图片。</li>
<li>下一步，你显示<code>UIProgressView</code>让它隐藏在<code>PhotosViewController</code>内部。</li>
<li>开始任务&ndash;额，抱歉，是恢复任务。</li>
</ol>


<p>既然代理已经设置了，你就可以实现<code>NSURLSessionTaskDelegate</code>方法来更新进度视图。</p>

<p>添加下面的代码到<code>PhotosViewController.m</code>文件末尾：</p>

<pre><code class="objective-c">#pragma mark - NSURLSessionTaskDelegate methods

- (void)URLSession:(NSURLSession *)session
  task:(NSURLSessionTask *)task
  didSendBodyData:(int64_t)bytesSent
  totalBytesSent:(int64_t)totalBytesSent
  totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend
{
    dispatch_async(dispatch_get_main_queue(), ^{
        [ _progress setProgress:
          (double)totalBytesSent /
          (double)totalBytesExpectedToSend animated:YES];
    });
}
</code></pre>

<p>上面的代理方法将定期报告信息给调用者关于上传任务的信息。它同时会更新<code>UIProgressView</code>（ _progress）的进度以便显示 totalBytesSent/totalBytesExpectedToSend,这比显示一个完成的百分比跟有意义（也更极客）。</p>

<p>剩下唯一的事就是当上传任务结束时指示一下。添加下面的代码到<code>PhotosViewController.m</code>文件末尾：</p>

<pre><code class="objective-c">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error
{
    // 1
    dispatch_async(dispatch_get_main_queue(), ^{
        [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO];
         _uploadView.hidden = YES;
        [ _progress setProgress:0.5];
    });

    if (!error) {
        // 2
        dispatch_async(dispatch_get_main_queue(), ^{
            [self refreshPhotos];
        });
    } else {
        // Alert for error
    }
}
</code></pre>

<p>这里没有很多代码，但是它执行了两项非常重要的任务：</p>

<ol>
<li>打开网络指示器，然后隐藏<code>_uploadView</code>作为上传完成的一点点清理工作。</li>
<li>刷新<code>PhotosViewController</code>以便包含你刚刚上传的照片，由于demo app是不能进行任何本地储存的上传
。在一个真正的app中，你应该把图片在本地进行储存和缓存。</li>
</ol>


<p>构建运行你的app，导航到<code>PanoPhotos</code>标签，点击照相图标选择一张照片。</p>

<p><img src="http://ww4.sinaimg.cn/mw690/64124373gw1f00bn13wq4j20di09ojs2.jpg" alt="networking22" /></p>

<blockquote><p>注意：假如你说使用模拟器测试app，很显然你不能用你的Mac拍照，所有仅仅是拷贝一张全景照片
给模拟器然后上传。这样做，可以确保没有其他的Xcode工程现在连接到这个模拟器，在Xcode中选择 <strong>Xcode   Open Developer Tool   iOS Simulator</strong>。</p>

<p>从Finder中拖拽一张全景照片带模拟器中，在模拟器中图片将会在Safari中打开。长按图片然后保存图片到图库中。</p></blockquote>

<p>在选择一张图片后上传，uploadView显示在屏幕的中央，并且带有上传进度，乡下面这一样显示：</p>

<p>！<a href="http://ww1.sinaimg.cn/mw690/64124373gw1f00bn4hmqwj209e0gomzu.jpg">networking23</a></p>

<p>你可能注意到一张图片上传需要花一些时间由于上传任务设置了<code>better quality</code>缩放因子。对于那些A类性格的人，你应该提供一个取消函数假如上传花费太长的时间。</p>

<p>取消按钮在<code>uploadView</code>已经被封装起来在故事板中，所有你只需实现清楚逻辑来杀死下载操作就行。</p>

<p>用下面的代码替换<code>PhotosViewController.m</code>的<code>cancelUpload:</code>：</p>

<pre><code class="objective-c">- (IBAction)cancelUpload:(id)sender {    
    if ( _uploadTask.state == NSURLSessionTaskStateRunning) {
        [ _uploadTask cancel];
    }
}
</code></pre>

<p>在这类你会看到，取消一个任务相当简单就是调用一个取消方法。</p>

<p>现在构建运行你的app，选择一张照片上传然后点击<code>Cancel</code>。图片上传将会停止并且<code>uploadView</code>将会被隐藏。</p>

<p>就这样&ndash;<code>Byte Club</code>完成了！</p>

<h4>何去何从？</h4>

<p>这里是<a href="http://cdn5.raywenderlich.com/downloads/ByteClub_Completed.zip">完成的工程</a>在这个<code>NSURLSession</code>教程中。</p>

<p>假如你做到这一步，恭喜你可以享受到<code>Byte Club</code>的时光！不要告诉任何<code>Android</code>的小伙伴们！ :]
你现在能够处理在你app需要的任何网络任务了。</p>

<p>假如你喜欢这个课程，你可能想要查阅我们的新书<a href="http://www.raywenderlich.com/?page_id=48020"> iOS 7 by Tutorials</a>,这是这本书的一个简略版本，这本书几乎涵盖了在iOS 7中最新和最多的APIs，这些你应该清楚的知道作为一个开发者。</p>

<p>我几乎忘记了。。。</p>

<pre><code>/slap &lt;you the reader&gt; have been slapped around a bit with a large trout.
</code></pre>

<p>（不要问我为什么 hehe！😄）</p>

<p>假如你有任何问题或者评论关于这个教程或者<code>NSURLSession</code>,请加入到下面的论坛讨论！</p>

<p>参考资料：</p>

<ul>
<li><a href="http://objccn.io/issue-5-4/">从 NSURLConnection 到 NSURLSession</a></li>
<li><a href="http://www.raywenderlich.com/51127/nsurlsession-tutorial">NSURLSession Tutorial</a></li>
</ul>


<p>译者注：欢迎转载，但请一定注明出处！ <a href="http://blog.wangruofeng007.com">http://blog.wangruofeng007.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GET&amp;POST]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/get-and-post/"/>
    <updated>2016-01-13T05:48:10+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/get-and-post</id>
    <content type="html"><![CDATA[<blockquote><p>GET和POST是两种最常用的与服务器进行交互的HTTP方法 .</p></blockquote>

<h3>GET</h3>

<ul>
<li>GET的语义是获取指定的URL资源, 将数据按照 variable = value 的形式, 添加到action所指向的URL后面, 并且两者使用 &lsquo; ? '连接, 各变量之间使用 &rsquo; &amp; &lsquo;连接 .</li>
<li>对用户来说不安全, 因为在传输过程中, 数据被放在请求的URL中.</li>
<li>传输的数据量小, 这主要是因为受URL长度限制.</li>
</ul>


<h3>URL长度限制</h3>

<p> 在http协议中，其实并没有对url长度作出限制，往往url的最大长度和用户浏览器和Web服务器有关，不一样的浏览器，能接受的最大长度往往是不一样的，当然，不一样的Web服务器能够处理的最大长度的URL的能力也是不一样的。</p>

<pre><code>IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。

Firefox浏览器URL的长度限制为65,536个字符 ;

Apache(Server)能够接受的最大URL长度为8192个字符 ;

如果浏览器的编码为UTF8的话，一个汉字最终编码后的字符长度为9个字符。
</code></pre>

<p>GET请求示例</p>

<p><img src="http://static.oschina.net/uploads/space/2014/0602/164040_3SOT_1774273.png" alt="GetRequest" /></p>

<h3>POST</h3>

<ul>
<li>POST语义是向指定URL的资源添加数据.</li>
<li>将数据放在数据体中, 按照变量和值相对应的方式, 传递到action所指向的URL.</li>
<li>所有数据对用户来说不可见.</li>
<li>可以传输大量数据, 上传文件只能使用POST.</li>
</ul>


<p>POST请求示例</p>

<p><img src="http://static.oschina.net/uploads/space/2014/0602/164119_VRKY_1774273.png" alt="PostRequest" /></p>

<h3>在浏览器中判断GET&amp;POST请求</h3>

<p>因为POST请求会向服务器发送数据体, 因此刷新页面时会出现提示窗口. 而GET请求不会向服务器发送数据体, 因此没有提示 .</p>

<p>从请求本质来看, GET请求要比POST更安全, 效率也会更高 .(对服务器而言)</p>

<h3>iOS网络发送网络请求的步骤</h3>

<ol>
<li><p>实例化URL( 网络资源 ) ;</p></li>
<li><p>根据URL建立URLRequest ( 网络请求 ) ;</p>

<p> 默认为GET请求; 对于POST请求,  需要创建请求的数据体 .</p></li>
<li><p>利用 URLConnection 发送网络请求(发送请求并获得结果) ;</p></li>
</ol>


<p>NSURLConnection提供了两个静态方法可以直接以同步或异步的方式向服务器发送网络请求.</p>

<pre><code>同步请求:

sendSynchronousRequest : returningResponse : error :

异步请求:

sendAsynchronousRequest : queue : completionHandler :
</code></pre>

<p>在网络请求过程中, 接收数据的过程实际上是通过 NSURLConnectionDataDelegate来实现的, 常用代理方法包括:</p>

<pre><code class="objective-c">// 服务器开始返回数据
-(void)connection:didReceiveResponse:
// 收到服务器返回的数据，本方法会被调用多次
-(void)connection:didReceiveData:
// 数据接收完毕，做数据的最后处理
-(void)connectionDidFinishLoading:
// 网络连接错误
-(void)connection:didFailWithError:
</code></pre>

<p>备注：欢迎转载，但请一定注明出处！ <a href="http://blog.wangruofeng007.com">http://blog.wangruofeng007.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP POST and Multipart Forms]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/http-post-and-multipart-forms/"/>
    <updated>2016-01-13T05:45:41+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/http-post-and-multipart-forms</id>
    <content type="html"><![CDATA[<h4><code>HTTP POST</code>使用注意事项：</h4>

<ul>
<li>http Body 中的NSData 编码方式要用<code>NSASCIIStringEncoding</code>而不是<code>NSUTF8StringEncoding</code></li>
<li><p>通过</p>

<p>  <code>NSString *postLength = [NSString stringWithFormat:@"%d",[postData length]];</code>     <br/>
计算数据的长度</p></li>
</ul>


<h4>POST参数设置</h4>

<pre><code class="objective-c">        //设置header Content-Length
        [request setValue:postLength forHTTPHeaderField:@"Content-Length"];
        //设置header contentType
        [request setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Current-Type"];
        //设置body
        [request setHTTPBody:postData];
</code></pre>

<blockquote><p>备注:普通<code>post</code>的<code>header</code>的<code>Current-Type</code>为<code>application/x-www-form-urlencoded</code></p></blockquote>

<h4>Multipart Forms POST参数设置</h4>

<pre><code class="objective-c">        //设置header contentType
        NSString *contentType = [NSString stringWithFormat:@"multipart/form-data; boundary=%@", boundary];
        [request addValue:contentType forHTTPHeaderField:@"Content-Type"];

        //设置body contentType
        [body appendData:[@"Content-Type: application/octet-stream\r\n\r\n" dataUsingEncoding:NSUTF8StringEncoding]];
</code></pre>

<blockquote><p>备注:<code>Multipart Forms</code>的<code>header</code>的<code>Current-Type</code>为<code>multipart/form-data</code></p></blockquote>

<p>request body like this</p>

<pre><code>    --YOUR_BOUNDARY_STRING
    Content-Disposition: form-data; name="photo"; filename="calm.jpg"
    Content-Type: image/jpeg

    YOUR_IMAGE_DATA_GOES_HERE
    --YOUR_BOUNDARY_STRING
    Content-Disposition: form-data; name="message"

    My first message
    --YOUR_BOUNDARY_STRING
    Content-Disposition: form-data; name="user"

    1
    --YOUR_BOUNDARY_STRING
</code></pre>

<p>I’m sending over three variables: an image named photo, a string named message, and an integer named user. It’s important to note the linebreaks and the dashes before the boundary string. These must be included in order to build a good request. Now lets write some objective-c:</p>

<pre><code class="objective-c">
    NSString *boundary = @"YOUR_BOUNDARY_STRING";
    NSString *contentType = [NSString stringWithFormat:@"multipart/form-data; boundary=%@", boundary];
    [request addValue:contentType forHTTPHeaderField:@"Content-Type"];

    NSMutableData *body = [NSMutableData data];

    [body appendData:[[NSString stringWithFormat:@"\r\n--%@\r\n", boundary] dataUsingEncoding:NSUTF8StringEncoding]];
    [body appendData:[[NSString stringWithFormat:@"Content-Disposition: form-data; name=\"photo\"; filename=\"%@.jpg\"\r\n", self.message.photoKey] dataUsingEncoding:NSUTF8StringEncoding]];
    [body appendData:[@"Content-Type: application/octet-stream\r\n\r\n" dataUsingEncoding:NSUTF8StringEncoding]];
    [body appendData:[NSData dataWithData:imageData]];

    [body appendData:[[NSString stringWithFormat:@"\r\n--%@\r\n", boundary] dataUsingEncoding:NSUTF8StringEncoding]];
    [body appendData:[[NSString stringWithFormat:@"Content-Disposition: form-data; name=\"message\"\r\n\r\n%@", self.message.message] dataUsingEncoding:NSUTF8StringEncoding]];

    [body appendData:[[NSString stringWithFormat:@"\r\n--%@\r\n", boundary] dataUsingEncoding:NSUTF8StringEncoding]];
    [body appendData:[[NSString stringWithFormat:@"Content-Disposition: form-data; name=\"user\"\r\n\r\n%d", 1] dataUsingEncoding:NSUTF8StringEncoding]];

    [body appendData:[[NSString stringWithFormat:@"\r\n--%@\r\n", boundary] dataUsingEncoding:NSUTF8StringEncoding]];

    [request setHTTPBody:body];
</code></pre>

<p>Now all we need to do is make a connection to the server and send the request:</p>

<pre><code>[request setHTTPBody:body];
</code></pre>

<pre><code class="objective-c">    NSURLResponse *response;
    NSError *error;

    [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];
</code></pre>

<p>参考资料：</p>

<ul>
<li><a href="http://nthn.me/posts/2012/objc-multipart-forms.html">Sending Multipart Forms with Objective-C</a></li>
<li><a href="http://stackoverflow.com/questions/24250475/post-multipart-form-data-with-objective-c">POST multipart/form-data with Objective-C</a></li>
<li><a href="http://stackoverflow.com/questions/15749486/sending-an-http-post-request-on-ios">Sending an HTTP POST request on iOS</a></li>
<li><a href="http://www.w3.org/Protocols/rfc1341/7_2_Multipart.html">The Multipart Content-Type&ndash;w3规范</a></li>
</ul>


<p>备注：欢迎转载，但请一定注明出处！ <a href="http://blog.wangruofeng007.com">http://blog.wangruofeng007.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程之NSThread]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/duo-xian-cheng-zhi-nsthread/"/>
    <updated>2016-01-13T05:36:48+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/duo-xian-cheng-zhi-nsthread</id>
    <content type="html"><![CDATA[<h2>本文目录</h2>

<ul>
<li>前言</li>
<li>1.获取当前线程</li>
<li>2.获取主线程</li>
<li>3.NSThread的创建</li>
<li>4.暂停当前线程</li>
<li>5.线程的其他操作</li>
<li>6.优缺点</li>
</ul>


<h3>前言</h3>

<p>每个iOS应用程序都有个专门用来更新显示UI界面、处理用户触摸事件的主线程，因此不能将其他太耗时的操作放在主线程中执行，不然会造成主线程堵塞(出现卡机现象)，带来极坏的用户体验。一般的解决方案就是将那些耗时的操作放到另外一个线程中去执行，多线程编程是防止主线程堵塞，增加运行效率的最佳方法。</p>

<p>iOS中有3种常见的多线程编程方法
1. <code>NSThread</code>
这种方法需要管理线程的生命周期、同步、加锁问题，会导致一定的性能开销</p>

<ol>
<li><p><code>NSOperation</code>和<code>NSOperationQueue</code>
是基于OC实现的。NSOperation以面向对象的方式封装了需要执行的操作，然后可以将这个操作放到一个NSOperationQueue中去异步执行。不必关心线程管理、同步等问题。</p></li>
<li><p><code>Grand Centeral Dispatch</code>
简称GCD，iOS4才开始支持，是纯C语言的API。自iPad2开始，苹果设备开始有了双核CPU，为了充分利用这2个核，GCD提供了一些新特性来支持多核并行编程</p></li>
</ol>


<p>这篇文章简单介绍<code>NSThread这</code>个类，一个<code>NSThread</code>实例就代表着一条线程</p>

<h3>1.获取当前线程</h3>

<pre><code class="objective-c">    NSThread *current = [NSThread currentThread];
</code></pre>

<h3>2.获取主线程</h3>

<pre><code class="objective-c">    NSThread *main = [NSThread mainThread];
    NSLog(@"主线程:%@", main);    
</code></pre>

<p>打印结果是：</p>

<pre><code>2013-04-18 21:36:38.599 thread[7499:c07] 主线程:&lt;NSThread: 0x71434e0&gt;{name = (null), num = 1}
</code></pre>

<p>num相当于线程的id，主线程的num是为1的</p>

<h3>3.NSThread的创建</h3>

<h4>a.动态方法</h4>

<pre><code>- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument;
</code></pre>

<p>在第2行创建了一条新线程，然后在第4行调用<code>start</code>方法启动线程，线程启动后会调用self的<code>run:</code>方法，并且将@&ldquo;mj"作为方法参数</p>

<pre><code class="objective-c">// 初始化线程
NSThread *thread = [[[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@"mj"] autorelease];
// 开启线程
[thread start];
</code></pre>

<p>假如run:方法是这样的：</p>

<pre><code class="objective-c">- (void)run:(NSString *)string {
     NSThread *current = [NSThread currentThread];
     NSLog(@"执行了run:方法-参数：%@，当前线程：%@", string, current);
}
</code></pre>

<p>打印结果为：</p>

<pre><code>2013-04-18 21:40:33.102 thread[7542:3e13] 执行了run:方法-参数：mj，当前线程：&lt;NSThread: 0x889e8d0&gt;{name = (null), num = 3}
</code></pre>

<p>可以发现，这条线程的num值为3，说明不是主线程，主线程的num为1</p>

<h4>b.静态方法</h4>

<pre><code class="objective-c">    + (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument;
</code></pre>

<pre><code class="objective-c">[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@"mj"];
</code></pre>

<h4>c.隐式创建线程</h4>

<pre><code class="objective-c">[self performSelectorInBackground:@selector(run:) withObject:@"mj"];
</code></pre>

<p>会隐式地创建一条新线程，并且在这条线程上调用self的run:方法，以@&ldquo;mj"为方法参数</p>

<h3>4.暂停当前线程</h3>

<pre><code class="objective-c">    [NSThread sleepForTimeInterval:2];
</code></pre>

<pre><code class="objective-c">NSDate *date = [NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]];  
[NSThread sleepUntilDate:date];
</code></pre>

<p>上面两种做法都是暂停当前线程2秒</p>

<h3>5.线程的其他操作</h3>

<h4>a.在指定线程上执行操作</h4>

<pre><code class="objective-c"> [self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES];
</code></pre>

<ul>
<li>上面代码的意思是在thread这条线程上调用self的run方法</li>
<li>最后的YES代表：上面的代码会阻塞，等run方法在thread线程执行完毕后，上面的代码才会通过</li>
</ul>


<h4>b.在主线程上执行操作</h4>

<pre><code class="objective-c">[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES];  
</code></pre>

<p>在主线程调用self的run方法</p>

<h4>c.在当前线程执行操作</h4>

<pre><code class="objective-c">[self performSelector:@selector(run) withObject:nil];
</code></pre>

<p>在当前线程调用self的run方法</p>

<h3>6.优缺点</h3>

<ol>
<li>优点：<code>NSThread</code>比其他多线程方案较轻量级，更直观地控制线程对象</li>
<li>缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销</li>
</ol>


<p>备注：欢迎转载，但请一定注明出处！ <a href="http://blog.wangruofeng007.com">http://blog.wangruofeng007.com</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSOperation and NSOperationQueue Tutorial in Swift]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/nsoperation-and-nsoperationqueue-tutorial-in-swift/"/>
    <updated>2016-01-13T05:18:36+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/nsoperation-and-nsoperationqueue-tutorial-in-swift</id>
    <content type="html"><![CDATA[<ul>
<li>译自 Written by <a href="http://www.raywenderlich.com/u/jrturton"> Richard Turton</a> — on October 7, 2014</li>
<li>原文链接：<a href="http://www.raywenderlich.com/76341/use-nsoperation-nsoperationqueue-swift">http://www.raywenderlich.com/76341/use-nsoperation-nsoperationqueue-swift</a></li>
<li>译者<a href="https://twitter.com/oneruofeng">@oneruofeng</a></li>
</ul>


<p><strong>Post info</strong>: Updated for Xcode 7.1 and Swift 2.1 &ndash; 1 January 2016</p>

<p><strong>Update note</strong>: This tutorial was updated to iOS 8, Xcode 6.1 and Swift by Richard Turton.</p>

<blockquote><p><a href="http://www.raywenderlich.com/76341/use-nsoperation-nsoperationqueue-swift">Original post</a> by Tutorial Team member <a href="http://www.raywenderlich.com/u/Canopus">Soheil Azarpour</a>.</p></blockquote>

<p>每个人都有点击一个按钮或者进入一些文本在iOS或者Mac App上的令人沮丧的经历，就是突然-WHAM，用户交互停止了响应。</p>

<p>在Mac上，你的用户开始盯着一个沙漏或者一个七彩的轮子开始旋转直到它们再次恢复UI交互为止。在一个iOS app中，用户期望App立即响应它们的触摸事件，无响应的app给人的感觉是笨重和缓慢，这样通常会导致收到差评。</p>

<p>保持你的app的可交互的状态说起来容易做起来难，一旦你的app需要执行不仅仅是少量的任务，事情很快就变得很复杂，我们并没有多少事件在主事件循环执行繁重的工作并且同时提供一个可以响应的UI。</p>

<p>低级的开发者是怎样做的呢？解决方案就是把工作从主线程中移除通过并发。并发意味着你应用所有的操作同时执行在多个流（或者线程）中&ndash;这样的话用户界面就能保持响应的要执行的工作。</p>

<p>一种实现并发操作在iOS是通过<code>NSOperation</code>和<code>NSOperationQueue</code>这两个类。在这个教程中，你将学会怎样使用它们！你将从一个没有使用并发的App开始，所以它将出现的非常迟钝和无响应。然后你将重做你的应用给它们添加并发操作并且&ndash;希望&ndash;呈现一个更加响应良好的可交互界面给用户！</p>

<h3>我们开始吧</h3>

<p>这份样品工程的总的目标的就是展示一个滤镜处理过的图片的表视图。图片将从网络上下载，经过一个滤镜处理后，然后在表视图中显示。</p>

<p>下面是这个app模型的示意图</p>

<p><img src="http://ww2.sinaimg.cn/mw690/64124373gw1ezk3rh3ebyj20i20nmq4k.jpg" alt="app模型的示意图" /></p>

<!--
<img src = "http://ww2.sinaimg.cn/mw690/64124373gw1ezk3rh3ebyj20i20nmq4k.jpg" with= 300 height = 600>-->


<h3>第一个版本尝试</h3>

<p>下载你将在这个教程中使用的<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/10/ClassicPhotos-Starter63.zip">第一个版本的项目</a></p>

<blockquote><p>注意：所以的图片来自<a href="http://sxc.hu/"> stock.xchng.</a>。一下图片在数据源故意错误命名，以便这里有些例子是图片下载失败好处理失败的情况。</p></blockquote>

<p>构建并且运行这个工程，最终你将看到这个app运行起来显示一列照片。尝试滚动这个列表，很痛苦，不是吗？
<img src="http://ww3.sinaimg.cn/mw690/64124373gw1ezk45qmdigj205x08wdga.jpg" alt="list of photoes" /></p>

<p><em>传统的相册，运行缓慢</em></p>

<p>所有的操作都发生在<code>ListViewController.swift</code>里，并且最主要的是发生在<code>tableView(_:cellForRowAtIndexPath:)</code>方法里。看一下那个方法和注释这里有两件相当集中的事情需要思考：</p>

<ol>
<li><code>从网络载入图片数据</code>。即使网络状况良好，app将仍然必须等待直到下载完成了才能继续。</li>
<li>使用<em>Core Image</em>给图片加滤镜。这个方法给图片应用一个深褐色的滤镜，假如你想了解更多关于<code>Core Image</code>滤镜的知识，请点击<a href="http://www.raywenderlich.com/76285/beginning-core-image-swift">Beginning Core Image in Swift</a></li>
</ol>


<p>还有，你将载入一系列图片请求从网络当它第一次被请求时:</p>

<pre><code class="swift">  lazy var photos = NSDictionary(contentsOfURL:dataSourceURL)
</code></pre>

<p>所有的工作发生在应用的主线程。由于主线程也负责用户交互，让它一直忙于从网络下载东西和给图片加滤镜消磨掉了响应中的app。你可以通过使用Xcode的仪表测量视图获得这样一个快速的概述。你可以通过显示<code>调试导航</code>(Commnad+6)接入这个仪表视图,让后选择<code>CPU</code>当app正在运行的时候。</p>

<p><img src="http://ww4.sinaimg.cn/mw690/64124373gw1ezk4seggwgj20jg0a0ta0.jpg" alt="gauges" /></p>

<p><em>Xcode的仪表视图表明，主线程的任务非常重</em></p>

<p>你会看到那些所有的长钉在<code>Thread 1</code>，那就是app的主线程。更多详细的信息你可以运行app的<code>Instruments</code>,但是那个在<a href="http://www.raywenderlich.com/?p=23037"> whole other tutorial :].</a>中</p>

<p>是时候考虑怎样改善一下你的用户体验了！</p>

<h3>任务，线程和进程</h3>

<p>在你专研这篇教程之前，这里有一下技术上的慨念需要理一下，我将定义一些专用术语：</p>

<ul>
<li><strong>任务</strong> ：一个简单单个的需要完成的工作</li>
<li><strong>线程</strong> ：操作系统提供的机制允许多个用户操作同时进行在一个应用中</li>
<li><strong>进程</strong> ：一个可执行的代码块，它可以由多个线程构成</li>
</ul>


<blockquote><p>注意：在iOS和OS X中，线程的功能由POSIX线程API（或者 pthreads）实现，并且它使操作系统的一部分。而这个又是相当底层的东西，你将发现它很容易犯错误；或许关于线程最糟糕的事情是那些很难被发现的错误！</p>

<p><code>Foundation</code>框架包含了一个叫做<code>NSThread</code>的类，这让我们处理事情更容易，但是用<code>NSThread</code>管理多个线程仍是一件令人头疼的事情。<code>NSOperation</code>和<code>NSOperationQueue</code>是为了最大化简化处理多线程的更高级的类。</p></blockquote>

<p>在这个图解中，你会看到进程，线程和任务之间的关系：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/64124373gw1ezk5dwtbhuj20go03n0t2.jpg" alt="the relationship between a process, threads, and tasks" /></p>

<p><em>进程，线程和任务</em></p>

<p>正如你所见，一个进程可以包涵多个执行的线程，每个线程能够同时执行多个任务。</p>

<p>在这个图集中, <code>thread 2</code>执行文件的读的工作，同时<code>thread 1</code>执行UI相关的代码。这和你应该怎样在iOS中构建你的代码（主线程执行任何和UI相关的工作，第二线程应当执行慢的或者长时间运行的耗时操作例如读取文件，接入网络等等）有点相似。</p>

<h3>NSOperation vs. Grand Central Dispatch (GCD)</h3>

<p>你应该听说过<a href="http://developer.apple.com/library/ios/#documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html">Grand Central Dispatch (GCD).</a>。简单的来说，<code>GCD</code>由语言的特征，运行时库和系统增强组成来提供一个在<code>iOS</code>和<code>OS X</code>多核硬件中支持并发系统并且综合的改良。假如你想了解更多关于GCD相关的知识，有可以阅读我们的<a href="http://www.raywenderlich.com/?p=4295">Multithreading and Grand Central Dispatch on iOS for Beginners Tutorial</a>。</p>

<p><code>NSOperation</code>和<code>NSOperationQueue</code>构建在GCD之上。普遍来说，苹果推荐使用最高级别抽象，当需要显示他们一些需要的测量工作时回到最底层。</p>

<p>下面是关于这两者的一些简单比较，将帮助你决定何时何地选择使用<code>GCD</code>或者<code>NSOperation</code>：</p>

<ul>
<li><p><strong>GCD</strong> 是一个轻量级的方式来描述将要被并发执行的工作单元。你不必定制这个工作单元的时刻表；系统为你定制时刻表。在blocks中增加依赖是一件头疼的事情。取消或者暂停一个block来进行额外的工作为作为开发者的你！ :]</p></li>
<li><p><strong>NSOperation</strong> 和GCD相比增加了一些额外开支，但是你能够在各种操作之间增加依赖并且恢复，取消，暂停他们。</p></li>
</ul>


<p>这个教程将使用<code>NSOperation</code>,因为你将处理一个列表为了好的表现并且由于它大量的消耗的资源你需要能够取消一个操作针对某个图片，假如用户已经将那张图片滚出屏幕。即使这些操作在后台线程，假如这里有一打事情在队列里等着它们去处理，这将表现得跟糟糕。</p>

<h3>重构 App Model</h3>

<p>是时候重构开始的非多线程的模型了！假如你仔细观察先前的模型，你会发现这里有三个可以被改进的线程受困区域。通过切割这三个区域让后把他们放在单独的线程里，主线程的压力将得到缓解并且能够保持和用户交互。</p>

<p><img src="http://ww3.sinaimg.cn/mw690/64124373gw1ezk6m9a5xzj20i20nm416.jpg" alt="NSOperation_model_improved" /></p>

<p><em>改进后的 model</em></p>

<p>为了摆脱你应用的瓶颈，你需要一个指定一个线程来响应你的用户时间，一个线程专注于下载资源和图片，一个线程执行图片滤镜操作。在新的模型中，app从主线程启动让后载入一个空的表视图。同时，app启动第二个线程开始下载数据资源。</p>

<p>一旦数据资源下载完成，你将通知表视图重新载入。这些事情必须在主线程完成，因为它涉及到用户界面相关的操作。从这一点来说，表视图知道有多少行，并且它知道他将显示图片的URL地址，但是她不知道它是否真的有图片！假如你立即开始下载所有的图片在这个点上，这可能导致效率极其低下，因为你不需要一次性把所有图片下载完！</p>

<p>为了让这个变得更好我们能够做什么？</p>

<p>一个更好的模型就是可交互的行在屏幕范围内可见时才开始下载图片。所以你的代码开始将询问表视图有多少行可见。因此，代码应该直到这里有一个未加滤镜的图片等待处理时才开始处理图片加滤镜操作。</p>

<p>为了使app更加快速响应，代码将要让图片一旦下载完毕立即显示。让后才开始进行图片加滤镜操作，让后更新UI界面来显示已经经过滤镜处理后的图片。下面的图标显示了这个过程的控制流：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/64124373gw1ezk75nd4bdj20i206yq3q.jpg" alt="Control Flow" /></p>

<p><em>Cotroll Flow</em></p>

<p>为了获得这些对象，你需要跟踪这张图片现在是否正在被下载，一旦完成下载，假如图片的滤镜被应用上。你需要跟跟踪每个操作的状态，它是否正在下载中或者执行滤镜操作，以便你能够取消，暂停或者恢复每个操作当用户滚动的时候。</p>

<p>Okey！ 现在你准备好开始码代码了！ :]</p>

<p>打开你下载的工程，添加一个新的<strong>Swift File</strong>到你的工程中命名为<strong> PhotoOperations.swift</strong>。添加下面代码：</p>

<pre><code class="swift">class PendingOperations {
  lazy var downloadsInProgress = [NSIndexPath:NSOperation]()
  lazy var downloadQueue:NSOperationQueue = {
    var queue = NSOperationQueue()
    queue.name = "Download queue"
    queue.maxConcurrentOperationCount = 1
    return queue
    }()

  lazy var filtrationsInProgress = [NSIndexPath:NSOperation]()
  lazy var filtrationQueue:NSOperationQueue = {
    var queue = NSOperationQueue()
    queue.name = "Image Filtration queue"
    queue.maxConcurrentOperationCount = 1
    return queue
    }()
}
</code></pre>

<p>这回类包含了2个字典为了跟踪激活和正在进行中的下载和滤镜操作对表中的每一行，并且两个操作队列都有各自的操作类型。</p>

<p>所有的值被懒加载的方式创建，意味着他们不会被初始化知道他们第一次被接入。这样改善了你app的表现性能。</p>

<p>创建一个<code>NSOperationQueue</code>是非常简单的，正如你所见，给你的队列命名是非常有用的，因为名字会在仪器或者调速器中显示。<code>maxConcurrentOperationCount</code>在这里由于这个教程的缘故被设置成1，是为了让你看到操作一个接一个完成。你可以离开这一部分允许队列决定他一次处理多少个操作&ndash;这样会进一步改善性能。</p>

<p>队列是怎样决定一次运行多少个操作的呢？这是一个非常好的问题！ :] 这取决于硬件。默认，<code>NSOperationQueue</code>将要处理一写计算在屏幕背后，决定什么是最好的需要看代码是运行在某个具体的平台，和将载入的最大数量的线程数。</p>

<p>考虑到下面的例子，假设系统此时是空闲的，这里有很多资源可用，所以这个队列能够载入可能8条并发的线程。下一个时刻你运行程序，系统可能忙于其他不相关的正在抢夺资源的操作，这时队列就仅仅载入2个并发的线程。因为你已经设置了一个最大并发操作数，在这个app中一次只会进行一个操作。</p>

<blockquote><p>注意：你可能想知道为什么你必须跟踪所有的激活的和正在进行中操作。队列有一个<code>operations</code>的方法，它将返回一个操作的数组，所有为什么不用它呢？在这个工程中这样做效果不是很好。你需要跟踪更表视图行数关联的操作，它可能会重复执行数组每次你需要一个的时候。把它们储存在一个字典中用index path来作为他的key方便快速和高效的查找。</p></blockquote>

<p>是时候考虑下载和过滤操作了。添加下列代码到<code>PhotoOperations.swift:</code>文件的末尾：</p>

<pre><code class="swift">class ImageDownloader: NSOperation {
  //1
  let photoRecord: PhotoRecord

  //2
  init(photoRecord: PhotoRecord) {
    self.photoRecord = photoRecord
  }

  //3
  override func main() {
    //4
    if self.cancelled {
      return
    }
    //5
    let imageData = NSData(contentsOfURL:self.photoRecord.url)

    //6
    if self.cancelled {
      return
    }

    //7
    if imageData?.length &gt; 0 {
      self.photoRecord.image = UIImage(data:imageData!)
      self.photoRecord.state = .Downloaded
    }
    else
    {
      self.photoRecord.state = .Failed
      self.photoRecord.image = UIImage(named: "Failed")
    }
  }
}
</code></pre>

<p><code>NSOperation</code>是一个抽象类，为它的子类而设计。每个子类代表了一个特别的<code>任务</code>正如呈现在列表早期那样。</p>

<p>下面是上面代码每行注释到底发生了什么的说明：</p>

<ol>
<li>添加一个常量引用到和操作相关的<code>PhotoRecord</code>对象</li>
<li>创建一个设计初始化方法允许<code>photo record</code>参数可以被传进来</li>
<li><code>main</code>是你在<code>NSOperation</code>子类中需要重写的方法，用来执行相关工作</li>
<li>在启动开始前检查是否被取消，操作应该定期检查是否已经被取消在尝试长时间或密集的工作之前</li>
<li>下载图片数据</li>
<li>再次检查是否被取消</li>
<li>假如这里有数据，创建一个图片对象然后把它添加到记录中，同时改变它的状态，假如这里没有数据，把这条记录标记成失败然后设置适当的图片</li>
</ol>


<p>下一步，你将创建另一个操作来处理图片加滤镜的操作！添加下面的代码到<code>PhotoOperations.swift</code>文件末尾：</p>

<pre><code class="swift">class ImageFiltration: NSOperation {
  let photoRecord: PhotoRecord

  init(photoRecord: PhotoRecord) {
    self.photoRecord = photoRecord
  }

  override func main () {
    if self.cancelled {
      return
    }

    if self.photoRecord.state != .Downloaded {
      return
    }

    if let filteredImage = self.applySepiaFilter(self.photoRecord.image!) {
      self.photoRecord.image = filteredImage
      self.photoRecord.state = .Filtered
    }
  }
}
</code></pre>

<p>除了你对图片应用滤镜（使用一个未实现的方法，因此编译1错误）而不是下载它之外，这个看起来和下载操作非常相像。</p>

<p>添加遗失的图片滤镜处理方法到<code>ImageFiltration</code>类中:</p>

<pre><code class="swift">(image:UIImage) -&gt; UIImage? {
  let inputImage = CIImage(data:UIImagePNGRepresentation(image))

  if self.cancelled {
    return nil
  }
  let context = CIContext(options:nil)
  let filter = CIFilter(name:"CISepiaTone")
  filter.setValue(inputImage, forKey: kCIInputImageKey)
  filter.setValue(0.8, forKey: "inputIntensity")
  let outputImage = filter.outputImage

  if self.cancelled {
    return nil
  }

  let outImage = context.createCGImage(outputImage, fromRect: outputImage.extent())
  let returnImage = UIImage(CGImage: outImage)
  return returnImage
}
</code></pre>

<p>图片添加滤镜操作使用先前<code>ListViewController</code>中相同的实现。已经把它移动到这里来了以至于它它能在后台的一个单独的操作中完成。再次强调，你应该非常频繁的检查取消操作；最佳实践是在进行任何耗时操作调用之前和之后。一旦加滤镜操作完成，你应该立即设置photo record 实例的值。</p>

<p>很棒！现在你已经有了所有的工具和基础为了处理后台任务进程的操作。是时候回到控制器修改它以便能利用所有这些新的福利。</p>

<p>切换到<code>ListViewController.swift</code>文件，然后删除<code>lazy var photos</code>接口声明。添加下面声明：</p>

<pre><code class="swift">var photos = [PhotoRecord]()
let pendingOperations = PendingOperations()
</code></pre>

<p>这些将持有一个数组的你在开始创建的<code>PhotoDetails</code>对象，<code>PendingOperations</code>对象来管理操作。</p>

<p>添加一个下载<code>photos property</code>列表新的方法到类中：</p>

<pre><code class="swift">func fetchPhotoDetails() {
  let request = NSURLRequest(URL:dataSourceURL!)
  UIApplication.sharedApplication().networkActivityIndicatorVisible = true

  NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue()) {response,data,error in
    if data != nil {
      let datasourceDictionary = NSPropertyListSerialization.propertyListWithData(data, options: Int(NSPropertyListMutabilityOptions.Immutable.rawValue), format: nil, error: nil) as! NSDictionary

      for(key : AnyObject,value : AnyObject) in datasourceDictionary {
        let name = key as? String
        let url = NSURL(string:value as? String ?? "")
        if name != nil &amp;&amp; url != nil {
          let photoRecord = PhotoRecord(name:name!, url:url!)
          self.photos.append(photoRecord)
        }
      }

      self.tableView.reloadData()
    }

    if error != nil {
      let alert = UIAlertView(title:"Oops!",message:error.localizedDescription, delegate:nil, cancelButtonTitle:"OK")
      alert.show()
    }
    UIApplication.sharedApplication().networkActivityIndicatorVisible = false
  }
}
</code></pre>

<p>这个方法创建一个异步的网络请求，当完成的时候，将执行<code>completion block</code>在主线程。当下载完成property list的数据被萃取成一个<code>NSDictionary</code>,然后再次处理一个数组的<code>PhotoRecord</code>的对象。你不能直接使用这里的<code>NSOperation</code>,你应该在主线程中接入它使用<code>NSOperationQueue.mainQueue()</code>。</p>

<p>在<code>viewDidLoad</code>调用新方法</p>

<blockquote><p>fetchPhotoDetails()</p></blockquote>

<p>下一步找到<code>tableView(_:cellForRowAtIndexPath:)</code>然后替换它用下面的实现：</p>

<pre><code class="swift">override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
  let cell = tableView.dequeueReusableCellWithIdentifier("CellIdentifier", forIndexPath: indexPath) as! UITableViewCell

  //1
  if cell.accessoryView == nil {
    let indicator = UIActivityIndicatorView(activityIndicatorStyle: .Gray)
    cell.accessoryView = indicator
  }
  let indicator = cell.accessoryView as! UIActivityIndicatorView

  //2
  let photoDetails = photos[indexPath.row]

  //3
  cell.textLabel?.text = photoDetails.name
  cell.imageView?.image = photoDetails.image

  //4
  switch (photoDetails.state){
  case .Filtered:
    indicator.stopAnimating()
  case .Failed:
    indicator.stopAnimating()
    cell.textLabel?.text = "Failed to load"
  case .New, .Downloaded:
    indicator.startAnimating()
    self.startOperationsForPhotoRecord(photoDetails,indexPath:indexPath)
  }

  return cell
}
</code></pre>

<p>花点时间来通读注释区域下面的解释：</p>

<ol>
<li>为了给用户提供反馈，创建<code>UIActivityIndicatorView</code>让后把它设成cell的accessory view。</li>
<li>数据源包含<code>PhotoRecord</code>实例。抓取正确的数据基于当前行的<code>indexPath</code>。</li>
<li>cell的文本标签总是一样的，图片被正确的设置在<code>PhotoRecord</code>中当它被处理的时候，以便你能够设置他们两者，而不管记录的状态。</li>
<li>检查记录，正确的设置activity indicator和文本，然后开始操作（暂时还没实现）</li>
</ol>


<p>你可以移除<code>applySepiaFilter</code>的实现，因为那个将不再被调用了，添加下面的方法到类中来开始操作：</p>

<pre><code class="swift">func startOperationsForPhotoRecord(photoDetails: PhotoRecord, indexPath: NSIndexPath){
  switch (photoDetails.state) {
  case .New:
    startDownloadForRecord(photoDetails, indexPath: indexPath)
  case .Downloaded:
    startFiltrationForRecord(photoDetails, indexPath: indexPath)
  default:
    NSLog("do nothing")
  }
}
</code></pre>

<p>这里，你将传递一个<code>PhotoRecord</code>类型的实例带有它的<code>index path</code>。
依据<code>photo record</code>的状态，你选开始进行下载还是加滤镜的步骤。</p>

<blockquote><p>注意：下载图片和给图片加滤镜的方法分开实现，因为这里有可能出现当一个图片正在被下载，用户可能把它滚开了，这样你就不必对它应用滤镜操作。当下一次用户又来到相同的哪行时，你不必重新下载图片；你只需对它应用
图片滤镜即可！ Efficiency rocks! :]</p></blockquote>

<p>现在你需要实现你在上面调用的方法。记住你创建的自定义的类，<code>PendingOperations</code>,保持跟踪操作；现在实际上你可以使用它了！添加下面的方法到类中：</p>

<pre><code class="swift">func startDownloadForRecord(photoDetails: PhotoRecord, indexPath: NSIndexPath){
  //1
  if let downloadOperation = pendingOperations.downloadsInProgress[indexPath] {
    return
  }

  //2
  let downloader = ImageDownloader(photoRecord: photoDetails)
  //3
  downloader.completionBlock = {
    if downloader.cancelled {
      return
    }
    dispatch_async(dispatch_get_main_queue(), {
      self.pendingOperations.downloadsInProgress.removeValueForKey(indexPath)
      self.tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .Fade)
    })
  }
  //4
  pendingOperations.downloadsInProgress[indexPath] = downloader
  //5
  pendingOperations.downloadQueue.addOperation(downloader)
}

func startFiltrationForRecord(photoDetails: PhotoRecord, indexPath: NSIndexPath){
  if let filterOperation = pendingOperations.filtrationsInProgress[indexPath]{
    return
  }

  let filterer = ImageFiltration(photoRecord: photoDetails)
  filterer.completionBlock = {
    if filterer.cancelled {
      return
    }
    dispatch_async(dispatch_get_main_queue(), {
      self.pendingOperations.filtrationsInProgress.removeValueForKey(indexPath)
      self.tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .Fade)
      })
  }
  pendingOperations.filtrationsInProgress[indexPath] = filterer
  pendingOperations.filtrationQueue.addOperation(filterer)
}
</code></pre>

<p>Okey!下面是一个快速列表来帮助你立即上面的代码到底做了什么：</p>

<ol>
<li>首先，检查特定的<code>indexPath</code>来看这里是否已经有一个操作在<code>downloadsInProgress</code>中。假如有，忽略它。</li>
<li>假如没有，通过<code>designated initializer</code>创建一个<code>ImageDownloader</code>实例</li>
<li>添加一个当操作完成时执行的完成block。这是最好的地方让你其余的应用知道一个操作已经完成。注意完成block必须被执行即使这个操作被取消，这相当的重要，所以你需要使用GCD来触发重新载入表视图在主线程。</li>
<li>添加操作到<code>downloadsInProgress</code>中来保持跟踪一些事情。</li>
<li>添加操作到下载队列中。这是你实际获取这些操作开始运行的方法&ndash;队列需要注意的是一旦你添加了操作它就会执行。</li>
</ol>


<p>过滤图片的方法遵循下面相同的类型，除了它使用<code>ImageFiltration</code>和<code>filtrationsInProgress</code>来跟踪操作。作为经验，你应该尝试不要重复这个区域的代码 :]</p>

<p>你做到了！你的工程完成了。构建让后运行看有什么改进在操作上！当你滚动表视图的时候，app并没有停止，还是像它们变得可见一样继续下载图片和给图片加滤镜操作。</p>

<p><img src="http://ww2.sinaimg.cn/mw690/64124373gw1ezkc6fh23sj205x08wdga.jpg" alt="classicphotos-stalled-screenshot" /></p>

<p><em>原来的图片，现在可以滚动了</em></p>

<p>是不是很酷？你能看到随做你的进步让你的应用更易于响应能做出的努力 &ndash;对用户来说更有趣！</p>

<h3>细微的调整</h3>

<p>你已经随着这个教程走过漫长的路！你的小项目现在反应灵敏表明了在原来的版本基础上有很多改进。然而，这里任然有一些遗留的细节我们需要考虑。你是想成为一名伟大的程序员，而不仅仅是一名优秀的程序员！</p>

<p>你可能已经注意到了当你滚动表视图时，那些离屏的cell仍然在处理下载和给图片加滤镜的操作。假如你快速滚动，app将忙于下载和给图片处理滤镜的操作，在列表中从最前面甚至到不可见的地方。理想的情况下app应该对离开屏幕的cells就是现在不可见的取消滤镜操作。</p>

<p>难道你没有把取消的规定放进你的代码里？ 是的，你做了&ndash;现在你应该充分利用它们！:]</p>

<p>回到Xcode，让后打开<code>ListViewController.swift</code>文件。去到<code>tableView(_:cellForRowAtIndexPath:)</code>方法的实现，封装<code>startOperationsForPhotoRecord</code>调用在一个if条件向下面的：</p>

<pre><code class="swift">if (!tableView.dragging &amp;&amp; !tableView.decelerating) {
  self.startOperationsForPhotoRecord(photoDetails, indexPath: indexPath)
}
</code></pre>

<p>你需要告诉表视图开始操作仅仅当表视图没有滚动的时候。这实际上是<code>UIScrollView</code>的接口，由于<code>UITableView</code>是<code>UIScrollView</code>的子类，你自动继承了这些接口。</p>

<p>下一步，添加到下面<code>UIScrollView</code>代理方法的实现到类中：</p>

<pre><code class="swift">override func scrollViewWillBeginDragging(scrollView: UIScrollView) {
  //1
  suspendAllOperations()
}

override func scrollViewDidEndDragging(scrollView: UIScrollView, willDecelerate decelerate: Bool) {
  // 2
  if !decelerate {
    loadImagesForOnscreenCells()
    resumeAllOperations()
  }
}

override func scrollViewDidEndDecelerating(scrollView: UIScrollView) {
  // 3
  loadImagesForOnscreenCells()
  resumeAllOperations()
}
</code></pre>

<p>快速走查上面的代码显示在下面：</p>

<ol>
<li>当用户开始滚动，你想暂停所有的操作让后看看用户想看到什么。你将要实现<code>suspendAllOperations</code>在一会儿工夫。</li>
<li>假如<code>decelerate</code>的值是<code>false</code>,那就意味着停止拖拽表视图，因此你想恢复暂停的，因为cell离开屏幕取消的操作，启动在屏幕内cells的操作。你将要一起实现<code>loadImagesForOnscreenCells</code>和<code>resumeAllOperations</code>。</li>
<li>代理方法告诉你表视图已经停止滚动，所以你将做和#2条相同的处理。</li>
</ol>


<p>现在，添加下面这些遗失的方法的实现到<code>ListViewController.swift</code>:</p>

<pre><code class="swift">func suspendAllOperations () {
  pendingOperations.downloadQueue.suspended = true
  pendingOperations.filtrationQueue.suspended = true
}

func resumeAllOperations () {
  pendingOperations.downloadQueue.suspended = false
  pendingOperations.filtrationQueue.suspended = false
}

func loadImagesForOnscreenCells () {
  //1
  if let pathsArray = tableView.indexPathsForVisibleRows() {
    //2
    var allPendingOperations = Set(pendingOperations.downloadsInProgress.keys.array)
    allPendingOperations.unionInPlace(pendingOperations.filtrationsInProgress.keys.array)

    //3
    var toBeCancelled = allPendingOperations
    let visiblePaths = Set(pathsArray as! [NSIndexPath])
    toBeCancelled.subtractInPlace(visiblePaths)

    //4
    var toBeStarted = visiblePaths
    toBeStarted.subtractInPlace(allPendingOperations)

    // 5
    for indexPath in toBeCancelled {
      if let pendingDownload = pendingOperations.downloadsInProgress[indexPath] {
        pendingDownload.cancel()
      }
      pendingOperations.downloadsInProgress.removeValueForKey(indexPath)
      if let pendingFiltration = pendingOperations.filtrationsInProgress[indexPath] {
        pendingFiltration.cancel()
      }
      pendingOperations.filtrationsInProgress.removeValueForKey(indexPath)
    }

    // 6
    for indexPath in toBeStarted {
      let indexPath = indexPath as NSIndexPath
      let recordToProcess = self.photos[indexPath.row]
      startOperationsForPhotoRecord(recordToProcess, indexPath: indexPath)
    }
  }
}
</code></pre>

<p><code>suspendAllOperations</code>和<code>resumeAllOperations</code>有一个简单的实现。<code>NSOperationQueues</code>能够被暂停，通过设置<code>suspended</code>接口为<code>true</code>。这将暂停队列里面的所有操作&ndash;你不能单独暂停一个操作。</p>

<p><code>loadImagesForOnscreenCells</code>有一点小复杂。这里发生了什么事？</p>

<ol>
<li>以一个包含了现在表视图可见的<code>index paths</code>的数组开始开始</li>
<li>构造一个所有进行中的操作的集合通过结合所有在下载的进度+所有在处理滤镜的进度。</li>
<li>构造一个<code>index paths</code>集合用来取消操作。开始所有的操作，然后移除可见行的<code>index paths</code>，这样讲留下一个离开屏幕的行正在执行的操作集合</li>
<li>构造一个<code>index paths</code>集合，需要操作启动，用所有可见行的<code>index paths</code>启动，让后移除它们中在进行的操作。</li>
<li>遍历那些被取消的操作，取消它们，然后移除它们的引用从<code>PendingOperations</code>。</li>
<li>遍历那些将要开始的操作，然后对他们每个调用<code>startOperationsForPhotoRecord</code>。</li>
</ol>


<p>构建运行然后你发现一个更流畅，资源管理德更好的应用！给你自己一轮掌声！</p>

<p><img src="http://ww2.sinaimg.cn/mw690/64124373gw1ezkdl5q55nj20jg09qq4h.jpg" alt="improved app" /></p>

<p><em>原来的相册，载入东西一次一个</em></p>

<p>注意到当你完成滚动表视图，在可见区域行的cell的图片立即开始处理。</p>

<h3>何去何从？</h3>

<p>这里是<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/10/ClassicPhotos-Final63.zip">completed version of the project</a>。</p>

<blockquote><p>注意：此教程写于<code>Update 17 April 2015: Updated for Xcode 6.3 and Swift 1.2</code>,现在Swift最新版本2.1使用Xcode7+以上编辑会报错，这里打包一个新语法修改版<a href="https://github.com/wangruofeng/ClassicPhotos-Starter-fixed/archive/master.zip">completed fixed version of the project</a>。</p></blockquote>

<p>假如你完成这个工程应该花时间来真正理解它，恭喜你！你可以认为你自己是一位更有价值iOS开发者了比起在教程刚开始的时候！大多数开发的公司是非常幸运的有一个或者两个人正在知道这个东西。</p>

<p>当时请当心 &ndash; 像多层嵌套的blocks,不必要的使用多线程可能让一个工程变得难以理解对维护你代码的人来说。线程可能引入一些难以捉摸的bugs，将永远不出现知道你网络非常慢，或者代码运行在一个更快（或更慢）的设备上，或一个不同数量的核的芯片上时。小心测试，尽量使用<code>Instruments</code>（或者你自己的观察）来确定引入多线程真的有很大改进。</p>

<p>一个有用的特征使用操作时在这里没涉及到就是依赖（<code>dependency</code>）。你可以给一个操作添加一个或者更多的操作的依赖。这个操作不会开始直到它所有依赖的操作完成时。例如：</p>

<pre><code class="swift">// MyDownloadOperation is a subclass of NSOperation
let downloadOperation = MyDownloadOperation()
// MyFilterOperation  is a subclass of NSOperation
let filterOperation = MyFilterOperation()

filterOperation.addDependency(downloadOperation)
</code></pre>

<p>移除依赖：</p>

<pre><code class="swift">filterOperation.removeDependency(downloadOperation)
</code></pre>

<p>这个工程是否能使用依赖简化呢？把你学到的新技能用起来试一试 ：]
有件非常重要的事需要注意的就是一个依赖操作将仍然启动假如它依赖的操作被取消，还有它将自然完成。你需要牢记在心。</p>

<p>假如你有任何评论或者问题关于这个教程或者<code>NSOperations</code>,请加<a href="https://github.com/wangruofeng/Github_Blog/pulls">Pull request</a>。</p>

<p>译者注：欢迎转载，但请一定注明出处！ <a href="http://blog.wangruofeng007.com">http://blog.wangruofeng007.com</a></p>
]]></content>
  </entry>
  
</feed>
