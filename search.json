[{"title":"设计模式 与 Flutter","url":"/2024/11/02/设计模式-与-Flutter/","content":"\n# 写在最前\n\n比起设计模式，个人认为这3条原则更加重要：\n\n- DRY（**Don’t Repeat Yourself）**：尽量在项目中减少重复的代码行，重复的方法，重复的模块。其实许多设计原则和模式最本质的思想都是在消除重复。\n- KISS（**Keep It Simple, Stupid**）：让代码简单直接，用简单的方法解决复杂的问题，保持代码可读性和可维护性，足够简单，也就意味着很容易读懂，这就让BUG不容易隐藏且更容易修复。\n- YAGNI（**You aren’t gonna need it**）：只有当你需要的时候才去添加额外的功能，不要过度设计。我们经常会在开发当中尽可能的迎合未来可能的需求。而为了迎合某些产生概率极低的需求而设计的成本是非常高的，这种过度设计的收益非常低。可能你深思熟虑的设计花了不少时间成本，却在未来的两三年内这个设计却完全没有派上用场。一些设计是否必要，更多的应该基于当前的情况。而不是为了应对未来的各种变化，画蛇添足的设计。\n\n\n![](/images/design_pattern_flutter/design_pattern_cover.webp)\n\n\n<!-- more -->\n\n# 设计模式历史\n\n1994 年， 埃里希·伽玛、 约翰·弗利赛德斯、 拉尔夫·约翰逊、 理查德·赫尔姆这四位作者出版了 《**[设计模式： 可复用面向对象软件的基础](https://refactoringguru.cn/gof-book)**》 一书， 将设计模式的概念应用到程序开发领域中。 \n\n该书提供了 **23** 个模式来解决面向对象程序设计中的各种问题， 很快便成为了畅销书。\n\n由于书名太长， 人们将其简称为 “四人组 （Gang of Four， GoF） 的书”， 并且很快进一步简化为 “GoF 的书”。\n\n# **三大类设计模式**\n\n根据其意图或目的，可以分为三种主要的模式类别：\n\n![ ](/images/design_pattern_flutter/设计模式.png)\n\n# 六大原则（SOLID）\n\n![ ](/images/design_pattern_flutter/六大原则.png)\n\n# 创建型\n\n1. ## 单例模式 (Singleton)\n\n> **单例模式**是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/single\n\n![ ](/images/design_pattern_flutter/singleton.png)\n\n- **单例** （Sin­gle­ton） 类声明了一个名为 `get­Instance`的静态方法来返回其所属类的一个相同实例。\n- 单例的构造函数必须对客户端 （Client） 代码隐藏。 调用`get­Instance`方法必须是获取单例对象的唯一方式。\n\n```Dart\nclass Singleton {\n  Singleton._();\n\n  static late final Singleton _instance = Singleton._();\n  static Singleton get instance => _instance;\n}\n```\n\n1. ## **简单工厂模式 \\* (**Simple Factory**)**\n\n> **简单工厂模式** 不在 23 种 GoF 设计模式中，却是我们最常使用的一种编程方式。\n\n主要涉及到一个特殊的方法，专门用来提供我们想要的实例对象（对象工厂），我们可以将这个方法放到一个单独的类 `SimpleFactory` 中，如下：\n\n```Dart\nclass SimpleFactory {\n  /// 工厂方法\n  static Product createProduct(int type) {\n    switch (type) {\n      case 1:\n        return Product1();\n      case 2:\n        return Product2();\n      default:\n        return Product3();\n    }\n  }\n}\n\n// 抽象类\nabstract class Product {\n  String? name;\n  String? color;\n}\n\n// 实现类1\nclass Product1 implements Product {\n  @override\n  String? name = 'Product 1';\n  @override\n  String? color = 'red';\n}\n\n// 实现类2\nclass Product2 implements Product {\n  @override\n  String? name = 'Product 2';\n  @override\n  String? color = 'green';\n}\n\n// 实现类3\nclass Product3 implements Product {\n  @override\n  String? name = 'Product 3';\n  @override\n  String? color = 'blue';\n}\n```\n\n当我们想要在代码中获取对应的类型对象时，只需要通过这个方法传入想要的类型值即可，我们不必关心生产如何被生产以及哪个对象被选择的具体逻辑：\n\n```Dart\nfinal Product product = SimpleFactory.createProduct(1);\n```\n\n这就是 **简单工厂模式**。说到这里，就不得不提到 Dart 中特有的 **factory** 关键词了。\n\n**factory 关键词** 可以用来修饰 Dart 类的构造函数，意为 **工厂构造函数**，它能够让 **类** 的构造函数天然具有工厂的功能，使用方式如下：\n\n```Dart\nabstract class Product {\n  String? name;\n  String? color;\n\n  // 工厂构造函数\n  factory Product.createProduct(int type) {\n    switch (type) {\n      case 1:\n        return Product1();\n      case 2:\n        return Product2();\n      default:\n        return Product3();\n    }\n  }\n}\n```\n\n1. ## **工厂模式 (Factory Method)**\n\n> **工厂方法模式** 是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/factory\n\n![ ](/images/design_pattern_flutter/factory_method.png)\n\n\n- **产品** （Prod­uct） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。\n- **具体产品** （Con­crete Prod­ucts） 是产品接口的不同实现。\n- **创建者** （Cre­ator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。\n  - 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。\n  - 注意， 尽管它的名字是创建者， 但它最主要的职责并**不是**创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。\n- **具体创建者** （Con­crete Cre­ators） 将会重写基础工厂方法， 使其返回不同类型的产品。\n  - 注意， 并不一定每次调用工厂方法都会**创建**新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。\n\n**Flutter Demo 应用** \n\n在 Flutter 中，Widget 就属于 Product 抽象类，每一个具体实现的  Widget 都属于 Con­crete Prod­uct。\n\n假如我们需要区分Android 、iOS 等平台来显示不同的对话框：\n\n```Dart\nabstract class CustomDialog {\n  Widget create(BuildContext context);\n\n  Future<T?> show<T>(BuildContext context) {\n    final dialog = create(context);\n    return showDialog(context: context, builder: (context) => dialog);\n  }\n}\n\nclass AndroidAlertDialog extends CustomDialog {\n  @override\n  Widget create(BuildContext context) {\n    return const AlertDialog();\n  }\n}\n\nclass IOSAlertDialog extends CustomDialog {\n  @override\n  Widget create(BuildContext context) {\n    return const CupertinoAlertDialog();\n  }\n}\n\n// 使用\nvoid test(BuildContext context) {\n  // final dialog = AndroidAlertDialog();\n  final dialog = IOSAlertDialog();\n  dialog.show(context);\n}\n```\n\n1. ## **抽象工厂模式 (Abstract Factory)**\n\n> **抽象工厂模式**是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/factory\n\n![ ](/images/design_pattern_flutter/abstract_factory.png)\n\n\n- **抽象产品** （Abstract Prod­uct） 为构成系列产品的一组不同但相关的产品声明接口。\n- **具体产品** （Con­crete Prod­uct） 是抽象产品的多种不同类型实现。 所有变体 （苹果/小米/...） 都必须实现相应的抽象产品 （手机/平板/...）。\n- **抽象工厂** （Abstract Fac­to­ry） 接口声明了一组创建各种抽象产品的方法。\n- **具体工厂** （Con­crete Fac­to­ry） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。\n- 尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的*抽象*产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 **客户端** （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。\n\n### **与工厂模式的区别**\n\n**简单工厂** 和 **工厂方法** 这两种模式只生产一种对象，\n\n而抽象工厂**生产的是一系列对象**（对象族），而且生成的这一系列对象一定存在某种联系。比如 Apple 会生产 **手机**、**平板** 等多个产品，这些产品都属于 Apple 这个品牌。\n\n**Flutter Demo 应用** \n\n1. 定义抽象工厂，用于生产 widget：\n\n```Dart\nabstract class IWidgetsFactory {\n  Widget createButton(BuildContext context);\n\n  Widget createDialog(BuildContext context);\n\n  // ...\n}\n```\n\n1. 针对每一个平台，我们都可以实现对应的实现工厂\n\n```Dart\nDart\n// Material 风格组件工厂\nclass MaterialWidgetsFactory extends IWidgetsFactory {\n  @override\n  Widget createButton(BuildContext context) {\n    return ElevatedButton(\n      child: const Text('text'),\n      onPressed: () {},\n    );\n  }\n\n  @override\n  Widget createDialog(BuildContext context) {\n    return const AlertDialog();\n  }\n}\n\n// Cupertino 风格组件工厂\nclass CupertinoWidgetsFactory extends IWidgetsFactory {\n  @override\n  Widget createButton(BuildContext context) {\n    return CupertinoButton(\n      child: const Text('text'),\n      onPressed: () {},\n    );\n  }\n\n  @override\n  Widget createDialog(BuildContext context) {\n    return const CupertinoAlertDialog();\n  }\n}\n```\n\n1. 这样，在 Android 平台上我们使用 `MaterialWidgetsFactory`，在 iOS 平台上使用 `CupertinoWidgetsFactory`，就能使用对应平台的 widget，想要适配更多平台只需要再继承 `IWidgetsFactory` 实现对应平台的工厂类即可。\n\n至此，我们可以发现，作为创建型模式，这三类工厂模式主要工作就是以不同的方式创建对象，但他们各有特点：简单工厂模式抽象的是 **生产对象**，工厂模式抽象的是 **类方法**，抽象工厂模式抽象的则是 **生产对象的工厂**，如何使用就见仁见智了。\n\n1. ## **原型模式 (Prototype)**\n\n>  **原型模式**是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/proxy\n\n![ ](/images/design_pattern_flutter/prototype.png)\n\n\n- **原型** （Pro­to­type） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 `clone`的方法。\n- **具体原型** （Con­crete Pro­to­type） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。\n- **客户端** （Client） 可以复制实现了原型接口的任何对象。\n\n1. ## **建造者模式 (Builder)**\n\n> **建造者模式**是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/builder\n\n![ ](/images/design_pattern_flutter/builder.png)\n\n\n**Flutter 应用**\n\nDart 语言的级联语法，就已经提供了最基础的 Builder 实现，举个例子：\n\n```Dart\nDart\nclass Person {\n  String firstName = '';\n  String lastName = '';\n}\n\n// 创建方法\nfinal person = Person()\n  ..firstName = 'San'\n  ..lastName = 'Zhang';\n```\n\n# 结构型\n\n1. ## 适配器模式 Adapter\n\n> **适配器模式**是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/adapter\n\n### **对象适配器**\n\n![ ](/images/design_pattern_flutter/adapter_01.png)\n\n\n### **类适配器**\n\n![ ](/images/design_pattern_flutter/adapter_02.png)\n\n\n**Flutter Demo 应用** \n\n在 Flutter 中，最常见的适配器实现就是 **SliverToBoxAdapter** \n\n我们经常会使用到 CustomScrollView 创建拥有自定义滚动效果的组件，而 CustomScrollView 只允许包含 sliver 系列组件 (SliverAppBar、SliverList、SliverPersistentHeader 等) ，如果想包含普通的组件，必然需要使用 **SliverToBoxAdapter。**\n\n```Dart\nDart\nCustomScrollView(\n    slivers: <Widget>[\n        SliverAppBar(),\n        SliverToBoxAdapter(\n            child: Container(height: 100.0),\n        ),\n    ],\n)\n```\n\n1. ## 桥接模式 Bridge\n\n> **桥接模式**是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/bridge\n\n![ ](/images/design_pattern_flutter/bridge.png)\n\n\n1. **抽象部分** （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。\n2. **实现部分** （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。\n3. 抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。\n4. **具体实现** （Concrete Implementations） 中包括特定于平台的代码。\n5. **精确抽象** （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。\n6. 通常情况下， **客户端** （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。\n\n1. ## 组合模式 Composite\n\n> **组合模式**是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/combination\n\n![ ](/images/design_pattern_flutter/composite_01.png)\n\n![ ](/images/design_pattern_flutter/composite_02.png)\n\n\n1. **组件** （Component） 接口描述了树中简单项目和复杂项目所共有的操作。\n2. **叶节点** （Leaf） 是树的基本结构， 它不包含子项目。\n3. 一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。\n4. **容器** （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。\n5. 容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。\n6. **客户端** （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。\n\n1. ## 装饰模式 Decorator\n\n> **装饰模式**是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/decorator\n\n![ ](/images/design_pattern_flutter/decorator_01.png)\n\n![ ](/images/design_pattern_flutter/decorator_02.png)\n\n\n1. **部件** （Component） 声明封装器和被封装对象的公用接口。\n2. **具体部件** （Concrete Component） 类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。\n3. **基础装饰** （Base Decorator） 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。\n4. **具体装饰类** （Concrete Decorators） 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。\n5. **客户端** （Client） 可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。\n\n1. ## 外观模式 Facades\n\n> **外观模式**是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/facade\n\n![ ](/images/design_pattern_flutter/facades_01.png)\n\n![ ](/images/design_pattern_flutter/facades_02.png)\n\n\n1. **外观** （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。\n2. 创建**附加外观** （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。\n3. **复杂子系统** （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。\n4. 子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。\n5. **客户端** （Client） 使用外观代替对子系统对象的直接调用。\n\n1. ## 享元模式 Flyweight\n\n> **享元模式**是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/flyweight\n\n![ ](/images/design_pattern_flutter/flyweight.png)\n\n\n1. 享元模式只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。\n2. **享元** （Flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。\n3. **情景** （Context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。\n4. 通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。\n5. **客户端** （Client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。\n6. **享元工厂** （Flyweight Factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。\n\n1. ## 代理模式 Proxy\n\n> **代理模式**是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/proxy\n\n![ ](/images/design_pattern_flutter/proxy.png)\n\n\n1. **服务接口** （Service Interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。\n2. **服务** （Service） 类提供了一些实用的业务逻辑。\n3. **代理** （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。\n4. 通常情况下， 代理会对其服务对象的整个生命周期进行管理。\n5. **客户端** （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。\n\n# 行为型\n\n1. ## 责任链模式 Chain of Responsibility\n\n> **责任链模式**是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/duty\n\n![ ](/images/design_pattern_flutter/chain_of_responsibility.png)\n\n\n1. **处理者** （Handler） 声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。\n2. **基础处理者** （Base Handler） 是一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。\n3. 通常情况下， 该类中定义了一个保存对于下个处理者引用的成员变量。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为： 确定下个处理者存在后再将请求传递给它。\n4. **具体处理者** （Concrete Handlers） 包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。\n5. 处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。\n6. **客户端** （Client） 可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的任意一个处理者， 而非必须是第一个处理者。\n\n1. ## 命令模式 Command\n\n> **命令模式**是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/command\n\n![ ](/images/design_pattern_flutter/command.png)\n\n\n1. **发送者** （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。\n2. **命令** （Command） 接口通常仅声明一个执行命令的方法。\n3. **具体命令** （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。\n4. 接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。\n5. **接收者** （Receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。\n6. **客户端** （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。\n\n1. ## 迭代器模式 Iterator\n\n> **迭代器模式**是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/iterator\n\n![ ](/images/design_pattern_flutter/Iterator.png)\n\n\n1. **迭代器** （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。\n2. **具体迭代器** （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。\n3. **集合** （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。\n4. **具体集合** （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。\n5. **客户端** （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。\n\n客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。\n\n1. ## 中介者模式 Mediator\n\n> **中介者模式**是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/midd\n\n![ ](/images/design_pattern_flutter/mediator.png)\n\n\n1. **组件** （Component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。\n2. **中介者** （Mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。\n3. **具体中介者** （Concrete Mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。\n4. 组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。\n\n对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。\n\n1. ## 备忘录模式 Memento\n\n> **备忘录模式**是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/memory\n\n![ ](/images/design_pattern_flutter/memento.png)\n\n\n1. **原发器** （Originator） 类可以生成自身状态的快照， 也可以在需要时通过快照恢复自身状态。\n2. **备忘录** （Memento） 是原发器状态快照的值对象 （value object）。 通常做法是将备忘录设为不可变的， 并通过构造函数一次性传递数据。\n3. **负责人** （Caretaker） 仅知道 “何时” 和 “为何” 捕捉原发器的状态， 以及何时恢复状态。\n\n> 负责人通过保存备忘录栈来记录原发器的历史状态。 当原发器需要回溯历史状态时， 负责人将从栈中获取最顶部的备忘录， 并将其传递给原发器的恢复 （restoration） 方法。\n\n1. 在该实现方法中， 备忘录类将被嵌套在原发器中。 这样原发器就可访问备忘录的成员变量和方法， 即使这些方法被声明为私有。 另一方面， 负责人对于备忘录的成员变量和方法的访问权限非常有限： 它们只能在栈中保存备忘录， 而不能修改其状态。\n\n1. ## 观察者模式 Observer\n\n> **观察者模式**是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/observer\n\n![ ](/images/design_pattern_flutter/observer.png)\n\n\n- **发布者** （Pub­lish­er） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。\n- 当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。\n- **订阅者** （Sub­scriber） 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 `update`方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。\n- **具体订阅者** （Con­crete Sub­scribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。\n- 订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。\n- **客户端** （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。\n\n**Flutter Demo 应用** \n\n- Stream 可以被看作是 Dart 语言原生支持的观察者模式的典型模型之一\n- ChangeNotifier 大概是 Flutter 中实现观察者模式最典型的例子\n- Flutter 中每个 Navigator 对象都接受一个 NavigatorObserver 对象的数组，在实际开发过程中，我们可以通过根组件 `MaterialApp` (或 `CupertinoPageRoute`) 的 `navigatorObservers` 属性传递给根 Navigator 组件，用于观察根 Navigator 的路由行为，这一组 NavigatorObserver 对象就是一系列的路由观察者。\n\n更多参考： https://flutter.cn/community/tutorials/observer-pattern-in-flutter-n-dart\n\n1. ## 状态模式 State\n\n> **状态模式**是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。\n>\n> **Demo**: https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/state\n\n![ ](/images/design_pattern_flutter/state.png)\n\n\n1. **上下文** （Context） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。\n2. **状态** （State） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。\n3. **具体状态** （Concrete States） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。\n\n> 状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。\n\n1. 上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。\n\n1. ## 策略模式 Strategy\n\n> **策略模式**是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。\n>\n> **Demo**：https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/strategy\n\n![ ](/images/design_pattern_flutter/strategy.png)\n\n\n1. **上下文** （Context） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。\n2. **策略** （Strategy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。\n3. **具体策略** （Concrete Strategies） 实现了上下文所用算法的各种不同变体。\n4. 当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。\n5. **客户端** （Client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。\n\n1. 这个是最受争议的设计模式，因为策略模式在绝大部分现代编程语言中可以简单地使用匿名 （lamb­da） 函数来实现。\n2. 包括 Dart，允许在匿名函数中实现不同版本的算法。 因此使用这些函数的方式就和使用策略对象时完全相同， 无需借助额外的类和接口来保持代码简洁。如下：\n\n```Dart\nclass Context {\n    void doSomething({required Function() strategy}) {\n        strategy();\n    }\n}\n\n// Client\nContext().doSomething(\n    strategy: () {\n        // ...\n    }\n);\n```\n\n1. ## 模板方法模式 Template Method\n\n> **模板方法模式**是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n>\n> **Demo**：https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/template\n\n![ ](/images/design_pattern_flutter/template_method.png)\n\n\n1. **抽象类** （Abstract­Class） 会声明作为算法步骤的方法， 以及依次调用它们的实际模板方法。 算法步骤可以被声明为 `抽象`类型， 也可以提供一些默认实现。\n2. **具体类** （Concrete­Class） 可以重写所有步骤， 但不能重写模板方法自身。\n\n1. ## 访问者模式 Visitor\n\n> **访问者模式**是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。\n\n![ ](/images/design_pattern_flutter/visitor.png)\n\n\n1. **访问者** （Visitor） 接口声明了一系列以对象结构的具体元素为参数的访问者方法。 如果编程语言支持重载， 这些方法的名称可以是相同的， 但是其参数一定是不同的。\n2. **具体访问者** （Concrete Visitor） 会为不同的具体元素类实现相同行为的几个不同版本。\n3. **元素** （Element） 接口声明了一个方法来 “接收” 访问者。 该方法必须有一个参数被声明为访问者接口类型。\n4. **具体元素** （Concrete Element） 必须实现接收方法。 该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。 请注意， 即使元素基类实现了该方法， 所有子类都必须对其进行重写并调用访问者对象中的合适方法。\n5. **客户端** （Client） 通常会作为集合或其他复杂对象 （例如一个**[组合](https://refactoringguru.cn/design-patterns/composite)**树） 的代表。 客户端通常不知晓所有的具体元素类， 因为它们会通过抽象接口与集合中的对象进行交互。\n\nDemo：null\n\n1. ## 解释器模式 Interpreter\n\n> **Demo**：https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/interpreter\n\n# 参考\n\n1. https://refactoringguru.cn/design-patterns\n2. https://github.com/FlutterOpen/design_patterns\n","tags":["Flutter"],"categories":["设计模式"]},{"title":"Hexo 升级到 V7.3","url":"/2024/11/01/Hexo-升级到-V7-3/","content":"\n最近换了台 Apple M2 电脑，整个软件都进行重装，**Hexo** 年久失修，在设置的时候出现很多警告 ⚠️，看了一下日志主要原因是以前版本依赖的 node 版本太低了，还有相关依赖库因为太旧有不少安全漏洞，查了一下 Hexo 最新发布的为 [7.3 版本 ](https://hexo.io/news/2024/07/02/hexo-7-3-0-released/)，于是打算整体迁移一下。\n\n![](/images/hexo_update/hexo.webp)\n\n\n<!-- more -->\n\n\n# 安装 Hexo 7.3 \n\n首先 Hexo 的安装可以用 brew 了。使用 `brew install hexo` 安装，安装好之后 Hexo 在 `/opt/homebrew/Cellar/hexo/7.3.0` 下。\n\n使用 Hexo 的如下指令完成建站\n\n```Shell\nhexo init blog\ncd blog\nnpm install\n```\n\n当前环境配置如下：\n\n```Bash\nhexo: 7.3.0\nnode：v22.11.0\nnpm：10.9.0\nbrew：4.4.2\n```\n\n# 基本配置\n\n资源迁移：建完站之后，把之前的文章（source/_posts）和静态资源（例如图片 source/images）都迁移过去。\n\n如果博客有映射自己的域名，记得把 CNAME 文件也迁移一下\n\n配置主题：由于我定制过 Next 主题，就直接把旧项目的主题直接拷贝到新项目的 themes/next 目录即可。如果是第一次建站需要在 themes 目录下把 [Next](https://github.com/next-theme/hexo-theme-next) clone 下来：\n\n```Shell\ngit clone https://github.com/next-theme/hexo-theme-next.git next\n```\n\n配置 `_config.yml` 主题为 next：\n\n```Shell\ntheme: next\n```\n\n配置语言：在`_config.yml`中更新博客语言配置，默认为英语\n\n```YAML\nlanguage: zh-CN\n```\n\n配置链接风格：修改 `_config.yml` 的 permalink 生成格式，这里配置成短链风格，如下内容：\n\n```YAML\n# 默认风格\n# permalink: :year/:month/:day/:title/\n\n# 将文章 url 风格调整成短链风\npermalink: posts/:abbrlink/\n```\n\n# 配置分类\n\n这步配置可以参考[这个帖子](https://tohugo.com/2021/01/26/工具配置/Hexo添加分类及标签（在Next主题下）/)\n\n打开命令行，进入博客项目所在的文件夹下，执行以下命令\n\n```Bash\nhexo new page categories\n```\n\n成功会有提示\n\n```Bash\nINFO  Created: ~/path_to_blog/source/categories/index.md\n```\n\n这样我们就创建好了分类页面了。但是这个时候主题还不会识别这个页面为分类页；所以我们需要编辑这个新建的页面，让主题识别这个页面，并自动为这个页面显示分类。\n\n编辑`index.md`在文件中添加 type: \"categories\"\n\n```Bash\n---\ntitle: 分类\ndate: 2024-11-02 13:43:56\ntype: \"categories\"\n---\n```\n\n# 配置标签\n\n同理 配置 tags\n\n```Bash\nhexo new page tags\n```\n\n成功会有提示\n\n```Bash\nINFO  Created: ~/path_to_blog/source/tags/index.md\n```\n\n编辑`index.md`在文件中添加 type: \"tags\"\n\n```Bash\n---\ntitle: 标签\ndate: 2024-11-02 13:44:19\ntype: \"tags\"\n---\n```\n\n# 安装插件\n\n## 站内搜索\n\n安装 `hexo-generator-searchdb` 插件\n\n```Bash\nnpm install hexo-generator-searchdb --save\n```\n\n在 `_config.yml` 中添加配置：\n\n```YAML\n# search\nsearch:\n  path: search.json\n  field: post\n  format: html\n  limit: 1000\n```\n\n## 字数统计\n\n安装 `npm install hexo-word-counter` 插件 , [参考](https://hexo-next.readthedocs.io/zh-cn/latest/next/advanced/字数统计/)\n\n```Bash\nnpm install hexo-word-counter\nhexo clean\n```\n\n## 发布插件\n\n然后需要在 blog 根目录下安装以下插件：\n\n```Bash\nnpm install hexo-deployer-git --save\n```\n\n因为我在 `config.yml` 中配置好了 deploy 信息：\n\n```YAML\n# Deployment\ndeploy:\n  type: git\n  message: \"Site updated: {{ now('YYYY-MM-DD HH:mm') }}\"\n  repo: \n    github: git@github.com:wangruofeng/wangruofeng.github.io.git\n  branch: master\n```\n\n# 常用命令\n\n```Bash\n# 发布新文章\nhexo new \"My New Post\"\n\n# 预览\nhexo s\n\n# 生成文件到 public 目录\nhexo g\n\n# 发布到 Github Pages\nhexo d\n\n# 清除缓存\nhexo clean\n```\n\n需要注意，如果改了文件发布的话，要先 `hexo g` ，然后再 `hexo d` 。","tags":["Hexo"],"categories":["博客搭建"]},{"title":"如何通过 SSH 的方式向 Github 提交代码","url":"/2024/10/30/如何通过-ssh-方式向-Github-提交代码/","content":"\n\n\n通过 SSH 提交代码到 GitHub，可以提高安全性并避免每次提交时输入用户名和密码。\n\n![](/images/ssh/ssh.webp)\n\n<!-- more -->\n\n\n\n以下是详细步骤：\n\n### 1. 检查本地是否有 SSH 密钥\n在终端中输入以下命令，检查是否已有 SSH 密钥：\n```bash\nls ~/.ssh\n```\n如果看到 `id_rsa` 和 `id_rsa.pub` 文件，表示已有密钥；否则需要生成一个新的 SSH 密钥。\n\n### 2. 生成新的 SSH 密钥\n如果没有现有密钥，可以生成新的：\n```bash\nssh-keygen -t rsa -b 4096 -C \"你的邮箱@example.com\"\n```\n按回车接受默认路径，创建密钥时可选择设置密码以增加安全性。\n\n### 3. 启动 SSH Agent 并添加密钥\n启动 SSH Agent 并将密钥添加到它：\n```bash\neval \"$(ssh-agent -s)\"\nssh-add ~/.ssh/id_rsa\n```\n\n### 4. 将 SSH 公钥添加到 GitHub\n复制公钥到剪贴板：\n```bash\ncat ~/.ssh/id_rsa.pub | pbcopy   # macOS\ncat ~/.ssh/id_rsa.pub | clip     # Windows\ncat ~/.ssh/id_rsa.pub            # Linux，手动复制\n```\n\n登录 GitHub，导航到 **Settings > SSH and GPG keys**，点击 **New SSH key**，粘贴公钥并保存。\n\n### 5. 测试 SSH 连接\n使用以下命令测试与 GitHub 的 SSH 连接：\n```bash\nssh -T git@github.com\n```\n如果连接成功，会看到类似以下消息：\n```plaintext\nHi <你的用户名>! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n### 6. 克隆仓库或更新远程仓库 URL\n如果已经克隆了仓库，更新其远程仓库 URL：\n```bash\ngit remote set-url origin git@github.com:<用户名>/<仓库名>.git\n```\n\n### 7. 提交和推送代码\n按照正常的 Git 工作流，提交并推送代码：\n```bash\ngit add .\ngit commit -m \"提交说明\"\ngit push origin main  # 或者其他分支名\n```\n\n\n\n这时，你应该能够通过 SSH 将代码安全地推送到 GitHub。\n\n\n\n**Tips**\n\n确保你的本地 Git 配置了正确的用户名和邮箱：\n\n```bash\ngit config --global user.name \"你的用户名\"\ngit config --global user.email \"你的邮箱@example.com\"\n```\n\n这样，你就可以使用 SSH 将代码提交到 GitHub，而无需输入用户名和密码了。\n","tags":["SSH"],"categories":["CLI"]},{"title":"物联网通讯协议","url":"/2024/02/24/物联网通讯协议/","content":"\n# 物联网协议分类： 接入协议、通讯协议\n- 接入协议：一般负责子网内设备间的组网及通信。\n- 通讯协议：主要是运行在传统互联网TCP/IP协议之上的设备通讯协议，负责设备通过互联网进行数据交换及通信。\n\n![](/images/common/lot.webp)\n\n\n<!-- more -->\n\n# 一、物理层、数据链路层协议\n## 1. 远距离蜂窝通讯\n- 2G、3G、4G通讯协议\n- NB-loT (Narrow Brand Internet of Things) 窄带物联网\n- 5G\n## 2. 远距离非蜂窝通讯\n- WiFi\n- ZigBee\n- LoRa（LongRange）\n## 3. 近距离通讯\n- RFID（Radio Frequency Identification）射频识别\n- NFC\n- Bluetooth（BLE）\n- UWB （Ultra Wideband）无载波无线通讯技术\n## 4. 有线通信\n- USB（Universal Series Bus）通用串行总线\n- 串口通讯协议，RS-232、RS-422 和 RS-485\n- 以太网\n- MBus（symphonic mbus）远程抄表系统\n\n# 二、网络层、传输协议\n- IPv4\n- IPv6\n- TCP（Transmission Control Protocol）传输控制协议\n- 6LowPAN\n\n# 三、应用层协议\n- MQTT（Message Queue Telemetry Transport）遥测传输协议\n- CoAP（Constrained Application Protocol）协议\n- REST / HTTP协议\n- DDS（Data Distribution Service）分布式实时数据分发服务中间件协议\n- AMQP（Advanced Message Queuing Protocol）高级消息队列协议\n- XMPP（Extensible messaging and presence protocol 基于XML协议）可扩展通讯和表示协议\n\n# 四、部分协议比较\n## 1. NB-IoT协议和LoRa协议比较\n第一，频段。LoRa 工作在 1GHz 以下的非授权频段，在应用时不需要额外付费，NB-IoT 和蜂窝通信使用 1GHz 以下的频段是2113授权的，是需要收费的。\n\n第二，电池供电寿命。LoRa模块在处理干扰、网络5261重迭、可伸缩性等方面具有独特的特性，但却不能提供像蜂窝协议一样的服务质量4102。NB-IoT出于对服务质量的考虑，不能提供类似LoRa一样的电池寿命。\n\n第三，设备成本。对终端节点来说，LoRa协议比NB-IoT更简单，更容易开发并且1653对于微处理器的适用和兼容性更好。同时低成本、技术相对成熟的LoRa模块已经可以在市场上找到了，并且还会有升级版本陆续出来。\n\n第四，网络覆盖和部署时间表。NB-IoT标准在2016年公布，除回网络部署之外，相应的商业化和产业链的建立还需要更长的时间和努力去探索。LoRa的整个产业链相对已经较为成熟了，产品也处于“蓄势待答发”的状态，同时全球很多国家正在进行或者已经完成了全国性的网络部署。\n\n## 2. 蓝牙、WiFi、ZigBee协议比较\n目前来说，WiFi的优势是应用广泛，已经普及到千家万户；ZigBee的优势是低功耗和自组网；UWB无载波无线通信技术的优势是传输速率；蓝牙的优势组网简单。然而，这3种技术，也都有各自的不足，没有一种技术能完全满足智能家居的全部要求。\n\n蓝牙技术的出现使得短距离无线通信成为可能，但其协议较复杂、功耗高、成本高等特点不太适用于要求低成本、低功耗的工业控制和家庭网络。尤其蓝牙最大的障碍在于传输范围受限，一般有效的范围在10米左右，抗干扰能力不强、信息安全问题等问题也是制约其进一步发展和大规模应用的主要因素。\n\nWiFi也是是一种短距离无线传输技术，可以随时接入无线信号，移动性强，比较适合在办公室及家庭的环境下应用。当然WiFi也存在一个致命缺点。由于WiFi采用的是射频技术，通过空气发送和接收数据，使用无线电波传输数据信号，比较容易受到外界的干扰。\n\nZigBee则是国际通行的无线通讯技术，它的每个网络端口可以最多接入6.5万多个端口，适合家居、工业、农业等多个领域使用，而蓝牙和WiFi网端只能接入10个端口，显然不能适应家庭需要。ZigBee还具有低功耗和低成本优势。\n\n## 3. MQTT协议和CoAP协议比较\nMQTT是多对多通讯协议用于在不同客户端之间通过中间代理传送消息，解耦生产者与消费者，通过使得客户端发布，让代理决定路由并且拷贝消息。虽然MQTT支持一些持久化，最好还是作为实时数据通讯总线。\n\nCoAP主要是一个点对点协议，用于在客户端与服务器之间传输状态信息。虽然支持观察资源，CoAP最好适合状态传输模型，不是完全基于事件。\n\nMQTT客户端建立长连接TCP，这通常表示没有问题，CoAP客户端与服务器都发送与接收UDP数据包，在NAT环境中，隧道或者端口转发可以用于允许CoAP，或者像LWM2M，设备也许会先初始化前端连接。\n\nMQTT不提供支持消息打类型标记或者其他元数据帮助客户端理解，MQTT消息可用于任何目的，但是所有的客户端必须知道向上的数据格式以允许通讯，CoAP，相反地，提供内置支持内容协商与发现，允许设备相互探测以找到交换数据的方式。\n\n两种协议各有优缺点，选择合适的取决于自己的应用。\n\n# 参考\n- [【知识分享】您了解物联网通信协议5G、NB-Iot、LoRa、ZigBee、NFC…....都是啥吗？](https://mp.weixin.qq.com/s/n8PnUuubTHM7ZPmmtD5jfA)","tags":["loT"],"categories":["网络协议"]},{"title":"几分钟内本地快速搭建 ChatGPT 环境","url":"/2023/07/31/几分钟内本地快速搭建ChatGPT环境/","content":"\n# 简介\n\n使用Docker虚拟机，几步在本地快速搭建ChatGPT环境，免API，免翻墙，即可使用纯正OpenAI的全部功能，完全免费！\n\n![](/images/ChatGPT/ChatGPT_info.png)\n\n<!-- more -->\n\n# 正文\n## 下载安装Docker\n官网下载地址：https://www.docker.com/\n\n## 拉取pandora镜像\npandora源码地址：https://github.com/pengzhile/pandora\n\n安装好Docker后，打开Mac终端，输入以下命令\n\n```shell\ndocker pull pengzhile/pandora\n```\n\n## 启动pandora镜像\n等上面镜像下载完成后，输入以下命令\n\n```shell\ndocker run  -e PANDORA_CLOUD=cloud -e PANDORA_SERVER=0.0.0.0:8899 -p 8899:8899 -d pengzhile/pandora\n```\n\n成功运行效果\n![docker_run](/images/ChatGPT/docker_run.png)\n\n## 获取AccessToken\n通过登录OpenAI官方API，登录成功后，然后访问 [这里](https://chat.openai.com/api/auth/session) 即可拿到官方的Access Token（ps：这一步需要翻墙才能完成）\n\n获取成功后效果图\n![access_token](/images/ChatGPT/as.jpg)\n\n\n> 注意：Token目前看有效期是一个月，一个月后需要重新获取\n\n## 访问本地链接\nhttp://127.0.0.1:8899 \n\n使用上一步获取的Access Token登录即可\n![login_with_access_token](/images/ChatGPT/login_with_access_token.png)\n\n登录成功后，即可使用OpenAI的全部功能，完全免费！🎉🎉🎉\n![chat_gpt_demo](/images/ChatGPT/chat_gpt_demo.png)\n","tags":["ChatGPT"],"categories":["AI"]},{"title":"Flutter 最佳实践整理","url":"/2021/03/28/Flutter最佳实践整理/","content":"\n\n\n![](/images/cover_img/johannes-andersson-v5gGwubKzEA-unsplash.jpg)\n\n<!-- more -->\n\n## Text 以字符的方式截断\n\n[https://github.com/flutter/flutter/issues/52869](https://github.com/flutter/flutter/issues/52869)\n\n在flutter中，Text控件默认的溢出显示模式是`TextOverflow.fade` ,就是淡出\n\n在iOS或者Android平台默认的文件截断模式一般是...省略，flutter里面对应的截断模式为`TextOverflow.ellipsis` ,不过这里的截断是英文按照单词来的，这样的模式会导致如果最后一个单词很长时，截断显示会整理省略而不是最后超出的字符省略，导致模块可能有一大块空白。\n\nDart系统定义的截断模式\n\n```dart\n/// How overflowing text should be handled.\n///\n/// A [TextOverflow] can be passed to [Text] and [RichText] via their\n/// [Text.overflow] and [RichText.overflow] properties respectively.\nenum TextOverflow {\n  /// Clip the overflowing text to fix its container.\n  clip,\n\n  /// Fade the overflowing text to transparent.\n  fade,\n\n  /// Use an ellipsis to indicate that the text has overflowed.\n  ellipsis,\n\n  /// Render overflowing text outside of its container.\n  visible,\n}\n```\n\n如何解决英文单词被整体截断呢？\n\n将单词的每个字符切割开，插入宽度0的占位字符，打破系统默认的机制，这样就可以以字符为单位省略了\n\n> 需要注意。这种方式相当于修改了文本的内容，一般文本最大一行显示可以用，如果文本支持2行以及以上的显示的话，将会导致换行不再按照字符进行而按照单词进行\n\n下面是Example实现\n\n```objectivec\nextension TextOverflowUtil on String {\n  /// 将flutter系统默认的单词截断模式转换成字符截断模式\n  /// 通过向文本中插入宽度为0的空格实现\n  static String toCharacterBreakStr(String word) {\n    if (word == null || word.isEmpty) {\n      return word;\n    }\n    String breakWord = '';\n    word.runes.forEach((element) {\n      breakWord += String.fromCharCode(element);\n      breakWord += '\\u200B';\n    });\n    return breakWord;\n  }\n}\n```\n\n## 文本划线\n\n通过Text的decoration属性来实现划线\n\n- TextDecoration.none        没有\n- TextDecoration.underline   下划线\n- TextDecoration.overline    上划线\n- TextDecoration.lineThrough 中间的线（删除线）\n\n// 划线相关的属性设置\ndecorationColor   decoration划线的颜色\ndecorationStyle   decoration划线的样式\n- TextDecorationStyle.solid   实线\n- TextDecorationStyle.double  画两条线\n- TextDecorationStyle.dotted  点线（一个点一个点的）\n- TextDecorationStyle.dashed  虚线（一个长方形一个长方形的线）\n- TextDecorationStyle.wavy    正玄曲\n\n效果图如下\n\n![best_practise_01](/images/best_practise/best_practise_01.png)\n\n## VS Code实现保存时自动代码格式化\n\nVS Code中代码格式化默认快捷键：【Shift】+【Alt】+ F\n\n实现手动保存（Ctril + S）时自动触发代码格式化：\n\n1）Code → Perference → Settting 点击右上角（Open Setting(JSON) ）\n\n![best_practise_02](/images/best_practise/best_practise_02.png)\n\n\n2）在settings.json下的【工作区设置】中添加以下语句：\n\n```dart\n\"editor.formatOnType\": true,\n\"editor.formatOnSave\": true\n```\n\n![best_practise_03](/images/best_practise/best_practise_03.png)\n\n\n## 解决 setState() called after diapose()\n\n网络请求成功前退出了页面，该 State 被从对象树卸载掉，而这时回调了网络请求的方法，方法中带有 setState 的调用，也就导致了该问题。\n\n```dart\nif (mounted) {\n  setState(() {\n    this._books = dataModel.books;\n  });\n}\n```\n\n## Waiting for another flutter command to release the startup lock…等待另一个flutter命令释放启动锁\n\n1. 退出 VS Code。\n2. 打开 flutter 安装目录 如：…\\flutter\\flutter\\bin\\cache 删除里面的 lockfile。\n3. 重启打开VS Code。\n\n原因：当你的项目异常关闭，下次启动就会出现上面的一行话，\n此时需要打开 flutter/bin/cache/lockfile，删除就行了，\n或者直接用下面的命令：rm ./flutter/bin/cache/lockfile。\n\n## 在Stateless控件内部或者浮层内部刷新，可以使用StatefullBuilder\n\n```dart\nshowDialog<void>(\n  context: context,\n  builder: (BuildContext context) {\n    int selectedRadio = 0;\n    return AlertDialog(\n      content: StatefulBuilder(\n        builder: (BuildContext context, StateSetter setState) {\n          return Column(\n            mainAxisSize: MainAxisSize.min,\n            children: List<Widget>.generate(4, (int index) {\n              return Radio<int>(\n                value: index,\n                groupValue: selectedRadio,\n                onChanged: (int value) {\n                  setState(() => selectedRadio = value);\n                },\n              );\n            }),\n          );\n        },\n      ),\n    );\n  },\n);\n```\n\n这里通过selectedRadio变量记录Radio的是否选中的状态\n\n## 平台相关的判断\n\n只关心是否是iOS和Android的情况下不需要依赖`context`，优先使用`Platform`\n\n```json\nPlatform.isAndroid\nPlatform.isIOS\n```\n\n需要详细知道具体哪个平台才使用`TargetPlatform`\n\n这个API的缺点是需要依赖`context`这个参数\n\n```dart\nfinal platform = Theme.of(context).platform;\n\nif (platform == TargetPlatform.android) {\n\t...\n} else if (platform == TargetPlatform.iOS) {\n\t...\n}\n```\n\n## ScrollView 滑动隐藏键盘\n\n[https://stackoverflow.com/questions/55306855/hide-keyboard-on-scroll-in-flutter](https://stackoverflow.com/questions/55306855/hide-keyboard-on-scroll-in-flutter)\n\n使用ScrollView的`keyboardDismissBehavior`属性\n\n```json\nListView(\n\tkeyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag\n)\n```\n\n## 回调写法\n\n### a.无参数回调\n\nVoidCallback\n\n### b.有一个参数回调\n\nValueChanged\n\n### c.参数大于一个\n\n可以通过`typedef`自定义一个函数\n\n下面是Example用法\n\n```dart\nfinal VoidCallback onPressed;\nfinal ValueChanged<T> onSelectHandler;\ntypedef ImageSwiperOnTap = void Function(int index, List<String> imgUrls);\n```\n\n## flutter pub get is stuck\n\n可以通过切换flutter镜像到中文站点来解决\n\n使用系统shell，请编辑\n\n使用oh_my_zsh, 需要编辑`.zshrc`\n\n```bash\nexport PUB_HOSTED_URL=https://pub.flutter-io.cn\nexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn\n```\n\n保存文件后，关闭，下次重新打开终端生效\n\n再执行`flutter pub get` 查看速度是否正常","tags":["Flutter"],"categories":["最佳实践"]},{"title":"Flutter 精华资料收集","url":"/2020/10/19/flutter精华资料收集/","content":"\n![](/images/cover_img/ray-hennessy-xUUZcpQlqpM-unsplash.jpg)\n\n<!-- more -->\n\n\n## 说明\n\n此文用于记录日常flutter开发中使用到或者看到的精华文章或者资源，方便日后查阅\n\n## 文章\n\n### Flutter进阶\n\n- [让Flutter真正支持View级别的混合开发](https://mp.weixin.qq.com/s/-vyU1JQzdGLUmLGHRImIvg)\n- [Dart Souls -《Dart 之魂》](https://jarontai.github.io/dart-souls/)\n- [Flutter完整开发实战详解系列](https://guoshuyu.cn/home/wx/)\n- [深入理解Flutter Platform Channel](https://www.jianshu.com/p/39575a90e820)\n- [Flutter 布局控件完结篇](https://juejin.im/post/5bab35ff5188255c3272c228)\n- [超详解析Flutter渲染引擎|业务想创新，不了解底层原理怎么行？](https://mp.weixin.qq.com/s/xxdgoEBIC3Bg4OCOZcm-aQ) -- from 淘系技术\n- [深入理解Flutter引擎线程模式](https://mp.weixin.qq.com/s/hZ5PUvPpMlEYBAJggGnJsw)\n- [Flutter 的性能分析、工程架构与细节处理](https://mp.weixin.qq.com/s/0R5UnVFlVbLKoV__s66HnA) -- from有道云\n- [Flutter 图片控件适配之路](https://juejin.cn/post/6917081883201241101) -- from 网易云音乐\n\n### 业界动态\n\n- [Flutter 在哈啰出行 B 端创新业务的实践](https://juejin.im/post/5eb27cc9f265da7b9625e85c)\n- [Flutter在PLUS业务中的探索和实践](https://mp.weixin.qq.com/s/eJxmeAJ0ljmbPbgNVkGttQ)\n- [&quot;零&quot;学习成本：使用 Web 标准开发动态化 Flutter 应用](https://mp.weixin.qq.com/s/57CprMfvTtIeq6AdgcDdcw)\n- [京东技术中台的 Flutter 实践之路](https://www.infoq.cn/article/qSLsru9bEvuHgKpPlWMP)\n- [打破重重阻碍，Flutter 和 Web 生态如何对接？](https://www.infoq.cn/article/16dv4pmnghv6i1lct3r4)\n\n### 性能优化\n\n* [Flutter性能优化实践 —— UI篇](https://juejin.im/post/6844904153236373517)\n\n### Flutter 动态\n\n- [Dart: 健全的空安全概览](https://mp.weixin.qq.com/s/rL6FtCSyca8DsUuNVbSA_w)\n- [深入理解 Dart 空安全](https://mp.weixin.qq.com/s/MEL5kokoyb0CJcjrPpo12w)\n- [nullsafety dartpad]( https://nullsafety.dartpad.cn/)\n- [观摩！Flutter 1.22 正式发布](https://juejin.im/post/6879048672597213198)\n\n## 网站\n\n- [Flutter 官网](https://flutter.io/)\n- [Flutter 中文网](https://flutterchina.club/)\n- [Flutter 中文开发文档](https://flutter.cn/docs)\n- [Flutter教程网](http://book.flutterj.com/)\n\n\n## 视频\n\n- [Introducing Widget of the Week!](https://www.youtube.com/watch?v=b_sQ9bMltGU&list=PLjxrf2q8roU23XGwz3Km7sQZFTdB996iG&index=2&t=0s)\n- [Flutter by Google](https://www.youtube.com/watch?v=fq4N0hgOWzU&list=PLOU2XLYxmsIJ7dsVN4iRuA7BT8XHzGtCr)\n- [AliFlutter第二期直播回放](http://mudu.tv/watch/5624777mudu.tv/watch/5624777)\n- [阿里巴巴闲鱼技术团队客户端负责人一起探讨Flutter的行业现状与未来](https://www.bilibili.com/video/BV1n741117v1?from=search&seid=12211378857505011313)\n\n\n## 博客\n\n- [咸鱼技术 - Flutter](https://www.jianshu.com/u/cf5c0e4b1111)\n- [Loki的博客](http://whysodiao.com/) — 目前就职于北京腾讯，博客里面有很flutter总结的文章\n- [老孟flutter](http://laomengit.com/) — 整理了几乎所有的widget，包含使用的例子，还有部分实战项目\n- [GuruMeditation](https://www.burkharts.net/apps/blog/) — 有一些关于flutter架构方面的文章\n\n\n## 掘金博主\n\n* [Vadaski](https://juejin.im/user/1767670428477015)\n* [张风捷特烈](https://juejin.im/user/149189281194766)\n* [YYDev](https://juejin.im/user/483440843559406)\n* [老孟Flutter](https://juejin.im/user/2013961034677725)\n* [闲鱼技术](https://juejin.im/user/1257497031878408)\n\n\n## 电子书\n\n- [Flutter 实战](https://book.flutterchina.club/) — 来自duwen 是[dio](https://github.com/flutterchina/dio)、[fly](https://github.com/wendux/fly)、[dsBridge](https://github.com/wendux/DSBridge-Android)等多个知名开源项目作者\n\n\n## 工具\n\n- [flutter在线编辑工具CodePen](https://codepen.io/flutter)\n- [Dart 在线编辑工具 DartPad](https://dartpad.dev/)\n- [在线JSON To Dart 代码生成](https://javiercbk.github.io/json_to_dart/) \n- [Json to Dart built_value class converter](https://charafau.github.io/json2builtvalue/)\n- [2020年20个Flutter最漂亮的UI库和项目](https://juejin.im/post/5f14e128e51d45347c1b926a)\n\n\n## 优秀项目 &amp; App\n\n-  [GSYGithubAppFlutter](https://github.com/CarGuo/gsy_github_app_flutter) — 大型flutter项目， Star 10.8k\n- [Developer_quest](https://github.com/2d-inc/developer_quest)  — Google 官方演示游戏Demo，Star 2.6k\n- [Flutter Go](https://flutter-go.pub/website/) — Ali开发的flutter组件demo演示和新闻资讯\n- [Flutter Samples](https://github.com/flutter/samples) — Flutter 官方 Demo，Star 7.3k\n- [awesome-flutter](https://github.com/Solido/awesome-flutter) — Flutter 相关的资料集合，Star 28.3k\n- [Flutter-Notebook](https://github.com/OpenFlutter/Flutter-Notebook) — FlutterDemo合集, Star 5.7k\n- [FlutterUnit](https://github.com/toly1994328/FlutterUnit) — 组件演示项目， Star 1.8k\n- [flutter-samples](https://github.com/diegoveloper/flutter-samples) — Flutter 演示项目，很多动画效果 , Star 1.5k\n- [flutter_deer](https://github.com/simplezhli/flutter_deer)  —  Flutter 练手项目 ,功能很丰富， Star 4.1k\n- [FlutterExampleApps](https://github.com/iampawan/FlutterExampleApps)  — Flutter 示例App，包含常见流行作品（WhatsApp，Instagram等）, Star 13.8k\n\n\n\n## PPT\n\n- [AliFlutter图片解决方案与优化](https://files.alicdn.com/tpsservice/db6a840f7ac7a8e3d5bde69c401bcfd5.pdf)\n- [UC Flutter技术实践分享](https://files.alicdn.com/tpsservice/d324c2a95852b22f1bdf2e60e55670a2.pdf)\n","tags":["网站"],"categories":["资料收集"]},{"title":"Flutter 开发Tips （第二期）","url":"/2020/09/17/Flutter-开发Tips-（第二期）/","content":"\n\n\n![](/images/cover_img/ramon-salinero-vEE00Hx5d0Q-unsplash.jpg)\n\n<!-- more -->\n\n\n\n## 提高flutter attach的成功率\n\n### 方案1\n\n断开wifi，执行flutter attach，attach成功后再链接wifi\n\n### 方案2\n\n通过指定设备uuid进行attach\n\n1. 通过`flutter devices`查找已链接设备列表，获取链接设备的uuid\n2. `flutter attach -d <#uuid#>` 指定想要attach的设备进行连接，例如`flutter attach -d AE5D772C-6D56-43AD-83F2-0554257B16C4` \n\n![Xnip2020-09-17_02-35-23](/images/flutter_tips_s2/flutter_attach.jpg)\n\n### 方案3\n\n通过指定应用的app-id进行attach\n\n1. 同一wifi环境下如果有多台相同项目设备连接中，找到你需要attach的app-id进行连接\n2. 执行：`flutter attach --app-id <#app_id#> `例如：`flutter attach --app-id com.xxx.xxx`                            \n\n## 从package中加载json文件\n\n### 背景\n\n例如我这里有一个flutter的demo项目叫`flutter_demo_package_json_load`，在根目录通过命令：`flutter create --template=package json_test_package`,创建了一个名为`json_test_package`的package，在package的assets中有一个为test2.json文件，现在需要在package中加载到改文件。\n\n\n\n### 从工程加载json\n\n对于普通项目的json文件，加载方式如下：\n\n1. 在项目中添加json文件，例如项目的assets下有一个名为test1.json的文件\n\n2. 我们在yaml中添加如下依赖\n\n   ```yaml\n   # 只加载assets下的test1.json文件\n   assets:\n     - assets/test1.json\n   \n   # 或者\n   # 加载assets下的所有文件\n    assets:\n     - assets/\n   ```\n\n3. 通过rootBundle加载\n\n   ```dart\n   Future<String> _loadFromProjectAsset() async {\n     // json file in project,is ok\n     return rootBundle.loadString(\"assets/test1.json\");\n   }\n   ```\n\n但是对于package下面json文件上面的方法失效了，使用上面的方法加载将会报错，错误信息如下：\n\n![image-20200917144141986](/images/flutter_tips_s2/flutter_tips_15.png)\n\n错误原因是资源路径不对，加载不到，因为rootBundle类没有提供package name的参数，我们只能把package name信息放在资源路径里面。\n\n### 从package加载json\n\n灵感来自https://pub.dev/packages/lottie库的`Lottie.asset(\"assetsPath\",package: \"package_name\")`方法，因为lottie实现动画的原理也是加载一份json配置，不过这个方法支持指定package配置。\n\n![image-20200917145538741](/images/flutter_tips_s2/flutter_tips_16.png)\n\n这里的keyName就是我们rootBundle类里面需要用的资源路径，包含带package的情况。\n\n正确的方式如下：\n\n1. 第一步和上面一样，将json文件添加到工程中，假如这里我们package里面的json文件名为test2.json\n2. 在yaml中添加如下依赖\n```yaml\n# 只加载assets下的test2.json文件\nassets:\n - assets/test2.json\n\n# 或者\n# 加载assets下的所有文件\nassets:\n - assets/\n```\n3. 通过rootBundle加载，但是path的格式为 `packages/<#package_name#>/<#file_path#>`\n\n这里为\n\n```dart\n// json file in package,this is work\nFuture<String> _loadFromPackageAsset() async {\n  // 【importance】 packag json file need use this formate:\n  // `packages/$package/$assetName`\n  return rootBundle.loadString(\"packages/json_test_package/assets/test2.json\");\n}\n```\n\n通过`DefaultAssetBundle`也是一样可以\n\n```dart\n// This is work too.\nFuture<String> testLoadJsonFileByDefaultAssetBundle(BuildContext context) {\n  // 【importance】 packag json file need use this formate:\n  // `packages/$package/$assetName`\n  return DefaultAssetBundle.of(context)\n      .loadString('packages/json_test_package/assets/test2.json');\n}\n```\n\n> [Demo链接](https://github.com/wangruofeng/flutter_demo_package_json_load)\n\n## flutter analyse\n\n### 配置步骤\n\n  * 在项目更目录添加`analysis_options.yaml`文件可以配置lint规则和analyzer行为\n\n  * 具体支持的lint规则参考https://dart-lang.github.io/linter/lints/\n\n  * 目前有3类已经定义的常用规则\n\n      > Many lints are included in various predefined rulesets:\n\n      - [pedantic](https://github.com/dart-lang/pedantic) for rules enforced internally at Google\n      - [effective_dart](https://github.com/tenhobi/effective_dart) for rules corresponding to the [Effective Dart](https://dart.dev/guides/language/effective-dart) style guide\n      - [flutter](https://github.com/flutter/flutter/blob/master/packages/flutter/lib/analysis_options_user.yaml) for rules used in `flutter analyze`\n\n  * 推荐使用google团队内部的规则库pedantic\n\n      * 在yaml里面添加依赖 `pedantic: ^1.8.0+1`\n      \n* 在`analysis_options.yaml`里面引入使用\n\n     > `include: package:pedantic/analysis_options.1.8.0.yaml`\n\n### 使用\n\n配置好`analysis_options.yaml`文件的规则后,执行`flutter analyse`命令将对你整个项目或者package的代码进行静态分析\n\n### 修复\n\n- 根据提示修复\n\n点击提示的规则，就会跳转到需要修复位置，按照lint规则的说明和例子就可以修正了。![flutter_analyse_1](/images/flutter_tips_s2/flutter_analyse_2.png)\n\n- 利用VSCode快速修复\n\n在提示有问题的代码的地方`Ctrl +.`, 就会自动弹出快速修复，比如图中为增加`const`标识。 是不是快多了。![flutter_analyse_1](/images/flutter_tips_s2/flutter_analyse_1.png)![屏幕快照 2020-09-17 上午2.24.55](/images/flutter_tips_s2/flutter_analyse_2.png)\n\n\n\n\n### 参考配置\n\n当然你还可以根据你的需要定制自己的静态分析规则，下面是最近使用的一套配置，仅供你参考：\n\n> [analysis_options.yaml参考配置](https://gist.github.com/wangruofeng/1451c04c0149fc229a726d819b3135c2)\n\n## dartfmt 命令\n  * `dartfmt ./ -w` 静态分析代码，并尝试自动修复\n  * `dartfmt ./ -n` 静态分析代码，不会修复代码\n\n\n\n## DevTool介绍\n\nflutter提供了一个devTool系列工具，方便开发者进行调试，查看日志，网络请求，性能等信息，更多信息请参考[DevTools](https://flutter.dev/docs/development/tools/devtools/overview)\n\n### Install DevTools\n\n * [Install from command line](https://flutter.dev/docs/development/tools/devtools/cli)\n * [Install and run DevTools from Android Studio](https://flutter.dev/docs/development/tools/devtools/android-studio)\n * [Install from VS Code](https://flutter.dev/docs/development/tools/devtools/vscode)\n\n\n\n### Launch the DevTools application server\n\n启动本地web服务\n\n```\npub global run devtools   # If you have `pub` on your path.\n```\n\nor\n\n```\nflutter pub global run devtools   # If you have `flutter` on your path.\n```\n\n在命令行，你应该看到类似下面输出，表明服务启动成功\n\n```\nServing DevTools at http://127.0.0.1:9100\n```\n\n### Start an application to debug\n\n运行app\n\n```\ncd path/to/flutter/app\nflutter run\n```\n\n一旦你成功运行起来你的app，你将在终端控制台看到如下类似的信息\n\n![image-20200917151951722](/images/flutter_tips_s2/flutter_tips_01.png)\n\n用浏览器打开里面的地址，格式如下\n\n> http://127.0.0.1:59681/fVO-_3yziG8=/\n\n打开将会看到下面的调试面板，可以根据自己的需要进行调试\n\n![image-20200917152140975](/images/flutter_tips_s2/flutter_tips_02.png)\n\n这里有一个很有用的功能，【debug】\n\n打开页面可以查看断点的帧和控制台的日志。\n\n![image-20200917152456458](/images/flutter_tips_s2/flutter_tips_03.png)\n\n### Open DevTools and connect to the target app\n\n一旦工程运行起来了，在浏览器打开http://localhost:9100，打开DevTools完整版本\n\n![image-20200917152646210](/images/flutter_tips_s2/flutter_tips_04.png)\n\n输入上面的地址，点击Connect，跳转到完整devTools\n\n![image-20200917152806254](/images/flutter_tips_s2/flutter_tips_05.png)\n\n这里的功能非常强大和具体使用可以参考官方文档\n\n\n\n## flutter 调试\n\n这里以VSCode为例\n\n### 纯flutter项目\n\n纯flutter项目比较简单，VSCode支持各种devtool，使用debug模式运行app，或者直接按F5\n\n![image-20200917150502934](/images/flutter_tips_s2/flutter_tips_06.png)\n\n运行成功后会出现一下工具条\n\n![image-20200917150559335](/images/flutter_tips_s2/flutter_tips_07.png)\n\n控制台输出以下内容\n\n![image-20200917150622481](/images/flutter_tips_s2/flutter_tips_08.png)\n\n例如这里我们在这个文件107行直接下一个断点，代码执行到时会触发断点\n\n![image-20200917150821892](/images/flutter_tips_s2/flutter_tips_09.png)\n\n此时工具栏变成下面的样式\n\n![image-20200917150846708](/images/flutter_tips_s2/flutter_tips_10.png)\n\n可以通过相关的按钮进行断点调试\n\n### 混合项目(原生+flutter)\n\n1. 打开已经编译运行过的原生端App\n\n2. 通过VSCode打开壳工程，进入壳工程根目录\n\n3. 选择main.dart文件\n\n4. 执行cmd+shift+p,呼出VSCode命令面板，输入`>attach to flutter onDevice`\n\n   ![image-20200917153401365](/images/flutter_tips_s2/flutter_tips_11.png)\n\n   选择下面的对应的命令执行\n\n   > 如果attach不上请断开wifi重试\n\n5. Attach 成功的话会显示下面一条悬浮工具栏和纯flutter相比里面多了一个类似插头的按钮\n\n   ![image-20200917153656732](/images/flutter_tips_s2/flutter_tips_12.png)\n\n   Debug Console控制台也会输出下面信息\n\n   ![image-20200917153719698](/images/flutter_tips_s2/flutter_tips_13.png)\n\n5. 剩下的调试和上面DevTool介绍的流程一致\n\n6. 在这个项目里面可以直接对引用到的代码进行断点调试\n\n   ![image-20200917154306797](/images/flutter_tips_s2/flutter_tips_14.png)\n\n\n\n## 参考\n\n* [analyzer](https://pub.dev/packages/analyzer)\n\n* [dartfmt](https://dart.dev/tools/dartfmt)\n\n* [Flutter Analysis Options](https://juejin.im/post/6844904176162439182#heading-11)\n\n* [Customizing static analysis](https://dart.dev/guides/language/analysis-options)\n\n* [How to access assets in package](https://stackoverflow.com/questions/63914819/how-to-access-assets-in-package)\n\n*  [DevTools](https://flutter.dev/docs/development/tools/devtools/overview)","tags":["Flutter"],"categories":["最佳实践"]},{"title":"Flutter 开发Tips （第一期）","url":"/2020/09/07/Flutter-开发Tips-（第一期）/","content":"\n\n\n![](/images/cover_img/markus-spiske-qjnAnF0jIGk-unsplash.jpg)\n\n<!-- more -->\n\n## ...\n\n延展操作符(`...`)可以对数组或者字典进行操作\n\n```dart\n// 合并数组\ntest1() {\n  var list = [1, 2, 3];\n  var list2 = [0, ...list, 4];\n  print(list2);\n  // [0, 1, 2, 3, 4]\n}\n\n// 合并字典\ntest2() {\n  var map1 = {\n    \"key1\": \"value1\",\n    \"key2\": \"value2\",\n  };\n  var map2 = {\n    \"key3\": \"value3\",\n    \"key4\": \"value4\",\n  };\n  var map3 = {...map1, ...map2};\n  print(map3);\n  // {key1: value1, key2: value2, key3: value3, key4: value4}\n}\n```\n\n\n\n## for ()...[]\n\n合并widgets到集合中，使用`for ()...[]`范式，使用延展操作符(`...`)来合并一个数组的widgets到一个存在的集合中。例如在构造Row或者Column的children时，非常方便。下面是示例：\n\n```dart\nList<Food> foods = [\n  Food(name: 'apple', isVegetarian: true),\n  Food(name: 'nuts', isVegetarian: true),\n  Food(name: 'eggs', isVegetarian: true),\n  Food(name: 'chicken', isVegetarian: false),\n];\n\nclass Food {\n  Food({\n    this.name,\n    this.isVegetarian,\n  });\n\n  String name;\n  bool isVegetarian;\n}\n\nclass HomePage extends StatelessWidget {\n  const HomePage({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      child: Column(\n        children: [\n          Container(),\n          for (final food in foods) ...[\n            if (food.isVegetarian) ListTile(title: Text(food.name)),\n            SizedBox(height: 50.0),\n          ],\n        ],\n      ),\n    );\n  }\n```\n\n## () {} ()\n\n立即执行一个匿名函数：`() {} ()`,相当于声明一个匿名函数并且里面执行，这种范式在处理一个widget可能有多种输出时特别有用。而不是使用镶嵌的三目运算符或者通过一个函数调用，这个代码跟内联。下面是示例：\n\n```dart\nT getRandomElement<T>(List<T> list) => list[Random().nextInt(list.length)];\n\nColumn(\n          children: [\n            Container(\n              color: () {\n                switch (getRandomElement(foods).name) {\n                  case 'apple':\n                    return Colors.green;\n                  case 'nuts':\n                    return Colors.brown;\n                  case 'eggs':\n                    return Colors.yellow;\n                  default:\n                    return Colors.transparent;\n                }\n              }(),\n              child: Text('Food of the Day'),\n            ),\n          ],\n        )\n```\n\n\n\n## 代码静态分析\n\n在提交代码时为了提高代码质量，保持团队的代码风格一致，需要进行代码静态分析，一般通过下面2种方法来进行\n\n### flutter analyze\n\n使用`flutter analyze`进行代码静态分析,此命令会根据`analysis_options.yaml`定义的规则进行静态分析\n\n### dartfmt\n\n使用`dartfmt ./ -w`对当前目录以及子目录的dart代码进行代码,`-w`选项会自动重写文件使其符合规范。\n\n使用`dartfmt ./ -n`显示当前目录以及子目录的dart代码格式可以修改的文件但是不做修改，可以配合ci分析代码格式问题。\n\n更多选项请使用`dartfmt --help`查看\n\n## Push & present & Pop\n\n```dart\n// Push by route\nNavigator.pushNamed(context, '/b')\n  \n// push \nNavigator.of(context).push(MaterialPageRoute(builder: (BuildContext context) => MyPage()));\n\n// present\nNavigator.of(context).push(MaterialPageRoute(builder: (BuildContext context) => MyPage(),fullscreenDialog: true));\n\n// pop\nNavigator.pop(context)\n  \n// pop + push\nNavigator.of(context)\n\t..pop()\n\t..pop()\n\t..pushNamed('/settings');\n```\n\nAPI\n\n```dart\n// push\nFuture push(BuildContext context, Route route)\n\n// pop\nbool pop(BuildContext context, [ result ])\n  \n// 下面两种是等效的\nNavigator.push(BuildContext context, Route route)\nNavigator.of(context).push(Route route)\n```\n\n## 获取widget的位置和宽高\n\n```dart\nfinal RenderBox box = keyContext.findRenderObject();\nfinal size = box.size;\nfinal topLeftPosition = box.localToGlobal(Offset.zero);\n```\n\nSee more\n* [How to get a height of a Widget?](https://stackoverflow.com/questions/49307677/how-to-get-a-height-of-a-widget)\n\n* [Flutter : Widget Size and Position](https://medium.com/@diegoveloper/flutter-widget-size-and-position-b0a9ffed9407)\n\n## Model To JSON\n\n### json_serializable\n\n1. 引入\n\n    ```yaml\n    dependencies:\n      # Your other regular dependencies here\n      json_annotation: ^2.0.0\n    \n    dev_dependencies:\n      # Your other dev_dependencies here\n      build_runner: ^1.0.0\n      json_serializable: ^2.0.0\n    ```\n\n2. 使用\n\n   ```dart\n   import 'package:json_annotation/json_annotation.dart';\n   \n   // user.g.dart 将在我们运行生成命令后自动生成\n   part 'user.g.dart';\n   \n   ///这个标注是告诉生成器，这个类是需要生成Model类的\n   @JsonSerializable()\n   \n   class User{\n     User(this.name, this.email);\n   \n     String name;\n     String email;\n     //不同的类使用不同的mixin即可\n     factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);\n     Map<String, dynamic> toJson() => _$UserToJson(this);\n   }\n   ```\n\n   \n\n3. 单次解析：`flutter packages pub run build_runner build`\n\n4. 持续集成：`flutter packages pub run build_runner watch`\n\n5. [json_serializable 在线json转dart model工具](https://caijinglong.github.io/json2dart/index_ch.html)\n\n### Built value\n\n1. 在线json转build value 模板工具 https://charafau.github.io/json2builtvalue/\n\n2. [VSCode built value 插件 ](https://marketplace.visualstudio.com/items?itemName=GiancarloCode.built-value-snippets) \n\n3. Sample code\n\n   ```dart\n   // interface model\n   import 'package:built_value/built_value.dart';\n   \n   part 'user.g.dart';\n   \n   abstract class User implements Built<User, UserBuilder> {\n     String get name;\n     @nullable\n     String get nickname;\n     User._();\n     factory User([updates(UserBuilder b)]) = _$User;\n   }\n   \n   // init\n   var user1 = new User((b) => b\n       ..name = 'John Smith'\n       ..nickname = 'Joe');\n   \n   // update\n   var user2 = user.rebuild((b) => b\n       ..nickname = 'Jojo');\n   \n   // update\n   var updatedStructuredData = structuredData.rebuild((b) => b\n       ..user.update((b) => b\n           ..name = 'Johnathan Smith')\n       ..credentials.phone.update((b) => b\n           ..country = Country.switzerland\n           ..number = '555 01234 555'));\n   \n   \n   // nested builders\n   abstract class Node implements Built<Node, NodeBuilder> {\n     @nullable\n     String get label;\n     @nullable\n     Node get left; \n     @nullable\n     Node get right;\n     Node._();\n     factory Node([updates(NodeBuilder b)]) = _$Node;\n   }\n   \n   // new or update\n   var node = new Node((b) => b\n     ..left.left.left.right.left.right.label = 'I’m a leaf!'\n     ..left.left.right.right.label = 'I’m also a leaf!');\n   var updatedNode = node.rebuild((b) => b\n     ..left.left.right.right.label = 'I’m not a leaf any more!'\n     ..left.left.right.right.right.label = 'I’m the leaf now!');\n   ```\n   \n## 参考\n\n* [3 cool Dart patterns](https://medium.com/dartlang/3-cool-dart-patterns-6d8d9d3d8fb8)\n\n* [built_collection - pub.dev](https://pub.dev/packages/built_collection)\n\n* [Dart’s built_collection for Immutable Collections](https://medium.com/dartlang/darts-built-collection-for-immutable-collections-db662f705eff)\n\n* [dartfmt](https://dart.dev/tools/dartfmt)\n\n* [Customizing static analysis](https://dart.dev/guides/language/analysis-options)","tags":["Flutter"],"categories":["最佳实践"]},{"title":"开发 Flutter 有哪些好用的 VSCode 插件","url":"/2020/07/31/开发Flutter有哪些好用的VSCode插件/","content":"\n![](/images/cover_img/pexels-nastyasensei-335393.jpg)\n\n<!-- more -->\n\n\n\n## 简介\n\n这里整理了日常使用vscode开发flutter相关的插件，也有部分通用类型的插件\n\n## [Flutter](https://marketplace.visualstudio.com/items?itemName=Dart-Code.flutter) & [Dart](https://marketplace.visualstudio.com/items?itemName=Dart-Code.dart-code)  \n\n这2个是flutter官方插件，开发flutter装机必备，不用多说。\n\n## [Awesome Flutter Snippets](https://marketplace.visualstudio.com/items?itemName=Nash.awesome-flutter-snippets)\n\n> Awesome Flutter Snippets is a collection snippets and shortcuts for commonly used Flutter functions and classes\n\n这里面包含Flutter中非常常用的代码片段\n\n## [Bracket Pair Colorizer 2](https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer-2) \n\n> A customizable extension for colorizing matching brackets\n\n这个插件可以使成对的括号带上不同颜色，特别适合dart这种嵌套层级很深声明式语言， 这个插件可以很方便的区分括号的开始和截止位置\n\n![Bracket _Pair_Colorizer_2](/images/flutter_plugin/Bracket _Pair_Colorizer_2.jpg)\n\n## [GitLens](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens) \n\n> Supercharge the Git capabilities built into Visual Studio Code — Visualize code authorship at a glance via Git blame annotations and code lens, seamlessly navigate and explore Git repositories, gain valuable insights via powerful comparison commands, and so much more\n\n最好用的feature是在该[**行**](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens#current-line-blame-)末尾的引人注目的[**当前行责任**](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens#current-line-blame-)注释，可通过[**悬停**](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens#hovers-)获取详细的责任信息，当然还有很多其他的feature，请自行探索。\n\n![GitLens_01](/images/flutter_plugin/GitLens_01.png)\n\ngit相关的右键菜单\n\n![GitLens_02](/images/flutter_plugin/GitLens_02.png)\n\n## [Color Highlight](https://marketplace.visualstudio.com/items?itemName=naumovs.color-highlight)\n\n> Highlight web colors in your editor\n\nweb颜色高亮，直接将颜色对应的css显示出来，非常直观\n\n![color_highlight](/images/flutter_plugin/color_highlight.png)\n\n## [Image Preview](https://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-gutter-preview)\n\n> Shows image preview in the gutter and on hover\n\n单鼠标悬浮在带有图片的超链接上会显示预览图片\n\n![image_preview](/images/flutter_plugin/image_preview.png)\n\n\n\n## [pubspec assist](https://marketplace.visualstudio.com/items?itemName=jeroen-meijer.pubspec-assist)\n\n> Easily add and update dependencies to your Dart and Flutter project.\n\n下面是官方的演示效果，可以直接命令搜索flutter相关库\n\n![img](https://i.imgur.com/W2cGuPL.gif)\n\n## [Material Icon Theme](https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme)\n\n> Material Design Icons for Visual Studio Code\n\n针对不同的文件icon和文件夹icon设计了一套主题图标\n\n![file_icons](/images/flutter_plugin/file_icons.png)\n\n![folder_icons](/images/flutter_plugin/folder_icons.png)\n\n## [Error lens](https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens)\n\n> Improve highlighting of errors, warnings and other language diagnostics.\n\n增强了语言中的错误高亮效果，使错误提示在代码后面显示\n\n![error_lens](/images/flutter_plugin/error_lens.png)\n\n## [flutter-stylizer](https://marketplace.visualstudio.com/items?itemName=gmlewis-vscode.flutter-stylizer) \n\n> Flutter Stylizer organizes your Flutter classes in an opinionated and consistent manner.\n\n使flutter中的代码按照下面的方式排序，方便统一约束团队代码的结构\n\n```json\n  \"flutterStylizer.memberOrdering\": [\n      \"public-constructor\",\n      \"named-constructors\",\n      \"public-static-variables\",\n      \"public-instance-variables\",\n      \"private-static-variables\",\n      \"private-instance-variables\",\n      \"public-override-methods\",\n      \"public-other-methods\",\n      \"build-method\",\n  ],\n```\n\n当然这只是默认顺序，具体的顺序可以自行调整,插件安装完成后，通过快捷键格式化当前的文件\n\n## [RESTClient](https://marketplace.visualstudio.com/items?itemName=humao.rest-client)\n\n> REST Client for Visual Studio Code\n\n在VSCode里面直接发送请求，能自动识别`.http`和`.rest`后缀的文件\n\n点击`Send Request`开始发送请求。\n\n![RESTClient_02](/images/flutter_plugin/RESTClient_02.png)\n\n![RESTClient_01](/images/flutter_plugin/RESTClient_01.png)","tags":["插件"],"categories":["效率"]},{"title":"Flutter 中 Key 的作用","url":"/2020/07/26/Flutter中Key的作用/","content":"\n![](/images/cover_img/img_2-people-sitting-with-view-of-yellow-flowers-during-daytime.jpg)\n\n<!-- more -->\n\n## key的定义\n\nKey Class官方介绍：\n\n>  A [Key] is an identifier for [Widget]s, [Element]s and [SemanticsNode]s.\n>\n> \n>\n>  A new widget will only be used to update an existing element if its key is\n>\n>  the same as the key of the current widget associated with the element.\n>\n> \n>\n>  {@youtube 560 315 https://www.youtube.com/watch?v=kn0EOS-ZiIc}\n>\n> \n>\n>  Keys must be unique amongst the [Element]s with the same parent.\n>\n> \n>\n>  Subclasses of [Key] should either subclass [LocalKey] or [GlobalKey].\n\n翻译过来：\n\n> 一个Key是Widget，Element以及SemanticsNode的标识。\n>\n> \n>\n> 一个新widget将仅用来更新一个已存在的element假如它的key和当前widget关联的元素一致。\n>\n> \n>\n> 官方介绍视频 https://www.youtube.com/watch?v=kn0EOS-ZiIc\n>\n> \n>\n> 在有着相同父节点的element中，Key必须是唯一的。\n>\n> \n>\n> Key的子类要么是LocalKey，要么是GlobalKey。\n\n\n\nKey 官方介绍：\n\n> Controls how one widget replaces another widget in the tree.\n>\n> If the [runtimeType](https://api.flutter.dev/flutter/widgets/Widget/dart-core/Object/runtimeType.html) and [key](https://api.flutter.dev/flutter/widgets/Widget/widgets/Widget/key.html) properties of the two widgets are [operator==](https://api.flutter.dev/flutter/widgets/Widget/widgets/Widget/operator_equals.html), respectively, then the new widget replaces the old widget by updating the underlying element (i.e., by calling [Element.update](https://api.flutter.dev/flutter/widgets/Widget/widgets/Element/update.html)with the new widget). Otherwise, the old element is removed from the tree, the new widget is inflated into an element, and the new element is inserted into the tree.\n>\n> In addition, using a [GlobalKey](https://api.flutter.dev/flutter/widgets/Widget/widgets/GlobalKey-class.html) as the widget's [key](https://api.flutter.dev/flutter/widgets/Widget/widgets/Widget/key.html) allows the element to be moved around the tree (changing parent) without losing state. When a new widget is found (its key and type do not match a previous widget in the same location), but there was a widget with that same global key elsewhere in the tree in the previous frame, then that widget's element is moved to the new location.\n>\n> Generally, a widget that is the only child of another widget does not need an explicit key.\n\n翻译过来：\n\n> 控制一个小部件如何替换树中的另一个小部件。\n>\n> 如果两个widget的[runtimeType](https://api.flutter.dev/flutter/dart-core/Object/runtimeType.html)和[key](https://api.flutter.dev/flutter/widgets/Widget/key.html)属性分别是相等的([==](https://api.flutter.dev/flutter/widgets/Widget/operator_equals.html))，则新widget通过更新基础element（即，通过使用新的widget调用[Element.update](https://api.flutter.dev/flutter/widgets/Element/update.html)）来替换旧widget。否则，将从树中删除旧element，将新widget放大为一个element，然后将新element插入到树中。\n>\n> 另外，使用[GlobalKey](https://api.flutter.dev/flutter/widgets/GlobalKey-class.html)作为窗口小部件的[key](https://api.flutter.dev/flutter/widgets/Widget/key.html)允许该element在树上移动（更改父级）而不会丢失状态。当找到新的widget（其键和类型与相同位置的先前widget不匹配），但是在前一帧的树中其他位置有一个具有相同全局键的widget时，该widget的element将移至新位置。\n>\n> 通常，作为另一个widget的唯一child的widget不需要显式key。\n\n\n\n## Key的作用\n\n大多数时候并不需要使用key。\n\n当需要在一个**StatefulWidget**集合中进行添加、删除、重排序等操作时，才是key登场的时候。\n\n### 无状态组件\n\n下面这段代码在一个Row中展示了两个彩色方片（StatelessContainer），当点击按钮时，会交换两个方片的位置：\n\n![img_key_screen](/images/flutter_key/img_key_screen.png)\n\n代码如下\n\n```dart\nimport 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass StatelessContainer extends StatelessWidget {\n  final Color color = Color.fromRGBO(\n      Random().nextInt(256), Random().nextInt(256), Random().nextInt(256), 1);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      width: 100,\n      height: 100,\n      color: color,\n    );\n  }\n}\n\nclass Screen extends StatefulWidget {\n  @override\n  _ScreenState createState() => _ScreenState();\n}\n\nclass _ScreenState extends State<Screen> {\n  List<Widget> widgets = [\n    StatelessContainer(),\n    StatelessContainer(),\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: widgets,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: switchWidget,\n        child: Icon(Icons.undo),\n      ),\n    );\n  }\n\n  switchWidget() {\n    widgets.insert(0, widgets.removeAt(1));\n    setState(() {});\n  }\n}\n```\n\n### 有状态组件\n\n有状态组件的状态信息（如颜色）通常是存储在state中的，而state是存储在element树中的。\n\n那么Key到底应该用到哪呢？\n我们再来一个例子，我们把色块用Padding包装一下。运行之后会发现，色块并没有交换，而是以随机的形式在变换颜色。为什么呢？\n\n```dart\nimport 'dart:math';\nimport 'package:flutter/material.dart';\n\nclass Screen extends StatefulWidget {\n  Screen({Key key}) : super(key: key);\n\n  @override\n  _ScreenState createState() => _ScreenState();\n}\n\nclass _ScreenState extends State<Screen> {\n  List<Widget> widgets = [\n    Padding(\n      padding: const EdgeInsets.all(8.0),\n      child: StatefulContainer(key: UniqueKey()),\n    ),\n    Padding(\n      padding: const EdgeInsets.all(8.0),\n      child: StatefulContainer(key: UniqueKey()),\n    ),\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: widgets,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: switchWidget,\n        child: Icon(Icons.undo),\n      ),\n    );\n  }\n\n  switchWidget() {\n    widgets.insert(0, widgets.removeAt(1));\n    setState(() {});\n    print('${widgets[0]}, ${widgets[1]}');\n  }\n}\n\nclass StatefulContainer extends StatefulWidget {\n  StatefulContainer({Key key}) : super(key: key);\n\n  @override\n  _StatefulContainerState createState() => _StatefulContainerState();\n}\n\nclass _StatefulContainerState extends State<StatefulContainer> {\n  final Color color = Color.fromRGBO(\n      Random().nextInt(256), Random().nextInt(256), Random().nextInt(256), 1);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: color,\n      width: 100,\n      height: 100,\n    );\n  }\n}\n```\n\n结合我们上面的理论，我们分析一下这次的Widget Tree 和 Element Tree，当我们交换元素后，Flutter element-to-widget matching algorithm,(元素-组件匹配算法)，开始进行对比，算法每次只对比一层，即Padding这一层。显然，Padding并没有发生本质的变化。\n\n\n\n于是开始进行第二层对比，在对比时Flutter发现元素与组件的Key并不匹配，于是，把它设置成不可用状态，但是这里所使用的Key只是本地Key（Local Key），Flutter并不能找到另一层里面的Key（即另外一个Padding Widget中的Key）所以，Flutter就创建了一个新的Widget，而这个Widget的颜色就成了我们看到的『随机色』。\n\n\n\n通过上面的示例，我们能明显的看出，我们的Key要设置到组件树的 **顶层**，而这一层在改变时，才能复用或者更新状态。\n\n修正版本：\n\n```dart\nimport 'dart:math';\n\nimport 'package:flutter/material.dart';\n\nclass Screen extends StatefulWidget {\n  Screen({Key key}) : super(key: key);\n\n  @override\n  _ScreenState createState() => _ScreenState();\n}\n\nclass _ScreenState extends State<Screen> {\n  List<Widget> widgets = [\n    Padding(\n      key: UniqueKey(),\n      padding: const EdgeInsets.all(8.0),\n      child: StatefulContainer(),\n    ),\n    Padding(\n      key: UniqueKey(),\n      padding: const EdgeInsets.all(8.0),\n      child: StatefulContainer(),\n    ),\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: widgets,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: switchWidget,\n        child: Icon(Icons.undo),\n      ),\n    );\n  }\n\n  switchWidget() {\n    widgets.insert(0, widgets.removeAt(1));\n    setState(() {});\n    print('${widgets[0]}, ${widgets[1]}');\n  }\n}\n\nclass StatelessContainer extends StatelessWidget {\n  final Color color = Color.fromRGBO(\n      Random().nextInt(256), Random().nextInt(256), Random().nextInt(256), 1);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: color,\n      width: 100,\n      height: 100,\n    );\n  }\n}\n\nclass StatefulContainer extends StatefulWidget {\n  StatefulContainer({Key key}) : super(key: key);\n\n  @override\n  _StatefulContainerState createState() => _StatefulContainerState();\n}\n\nclass _StatefulContainerState extends State<StatefulContainer> {\n  final Color color = Color.fromRGBO(\n      Random().nextInt(256), Random().nextInt(256), Random().nextInt(256), 1);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: color,\n      width: 100,\n      height: 100,\n    );\n  }\n}\n```\n\n\n\n## Key的分类\n\n![img_key](/images/flutter_key/img_key.png)\n\n- ValueKey:以一个值为key。\n- ObjectKey:以一个对象为key。\n- UniqueKey:生成唯一的随机数作为key。\n- PageStorageKey:专用于存储页面滚动位置的key。\n- GlobalKey:见后文。\n\n## 何时使用key\n\n### ValueKey\n\n如果您有一个 Todo List 应用程序，它将会记录你需要完成的事情。我们假设每个 Todo 事情都各不相同，而你想要对每个 Todo 进行滑动删除操作。\n\n这时候就需要使用 ValueKey！\n\n```dart\nreturn TodoItem(\n    key: ValueKey(todo.task),\n    todo: todo,\n    onDismissed: (direction){\n        _removeTodo(context, todo);\n    },\n);\n```\n\n### ObjectKey\n\n如果你有一个生日应用，它可以记录某个人的生日，并用列表显示出来，同样的还是需要有一个滑动删除操作。\n\n我们知道人名可能会重复，这时候你无法保证给 Key 的值每次都会不同。但是，当人名和生日组合起来的 Object 将具有唯一性。\n\n这时候你需要使用 ObjectKey！\n\n### UniqueKey\n\n如果组合的 Object 都无法满足唯一性的时候，你想要确保每一个 Key 都具有唯一性。那么，你可以使用 UniqueKey。它将会通过该对象生成一个具有唯一性的 hash 码。\n\n不过这样做，每次 Widget 被构建时都会去重新生成一个新的 UniqueKey，失去了一致性。也就是说你的小部件还是会改变。（还不如不用😂）\n\n### PageStorageKey\n\n当你有一个滑动列表，你通过某一个 Item 跳转到了一个新的页面，当你返回之前的列表页面时，你发现滑动的距离回到了顶部。这时候，给 Sliver 一个 PageStorageKey！它将能够保持 Sliver 的滚动状态。\n\n### GlobalKey\n\n每个globalkey都是一个在整个应用内唯一的key。\n\nglobalkey相对而言是比较昂贵的，如果你并不需要globalkey的某些特性，那么可以考虑使用Key、ValueKey、ObjectKey或UniqueKey。\n\n#### 用途1\n\n允许widget在应用程序中的任何位置更改其parent而不丢失其状态。应用场景：在两个不同的屏幕上显示相同的widget，并保持状态相同。\n\n#### 用途2\n\nGlobalKey 能够跨 Widget 访问状态。 在这里我们有一个 Switcher 小部件，它可以通过 changeState 改变它的状态。\n\n```dart\nclass SwitcherScreenState extends State<SwitcherScreen> {\n  bool isActive = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Switch.adaptive(\n            value: isActive,\n            onChanged: (bool currentStatus) {\n              isActive = currentStatus;\n              setState(() {});\n            }),\n      ),\n    );\n  }\n\n  changeState() {\n    isActive = !isActive;\n    setState(() {});\n  }\n}\n```\n\n但是我们想要在外部改变该状态，这时候就需要使用 GlobalKey。\n\n```dart\nclass _ScreenState extends State<Screen> {\n  final GlobalKey<SwitcherScreenState> key = GlobalKey<SwitcherScreenState>();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: SwitcherScreen(\n        key: key,\n      ),\n      floatingActionButton: FloatingActionButton(onPressed: () {\n        key.currentState.changeState();\n      }),\n    );\n  }\n}\n```\n\n这里我们通过定义了一个 GlobalKey 并传递给 SwitcherScreen。然后我们便可以通过这个 key 拿到它所绑定的 SwitcherState 并在外部调用 changeState 改变状态了。\n\n\n\n## 参考资料\n\n* [何时使用密钥 - Flutter小部件 101 第四集](https://www.youtube.com/watch?v=kn0EOS-ZiIc&feature=youtu.be)\n\n* [widgets-intro#keys](https://flutter.dev/docs/development/ui/widgets-intro#keys)\n\n* [Flutter | 深入浅出Key](https://juejin.im/post/5ca2152f6fb9a05e1a7a9a26)\n\n* [Flutter中的Key和GlobalKey](https://blog.csdn.net/al4fun/article/details/95854045)","tags":["Key"],"categories":["最佳实践"]},{"title":"Flutter factory 使用总结","url":"/2020/07/26/Flutter-factory-使用总结/","content":"\n![](/images/cover_img/img_photography-of-airplane-during-sunrise.jpg)\n\n<!-- more -->\n\n## 0x01官方描述\n\n> Use the `factory` keyword when implementing a constructor that doesn’t always create a new instance of its class. For example, a factory constructor might return an instance from a cache, or it might return an instance of a subtype.\n>\n> 当实现并非总是创建其类的新实例的构造函数时，请使用“ factory”关键字。例如，工厂构造函数可能会从缓存返回一个实例，或者可能会返回一个子类型的实例。\n\n\n\n## 0x02使用场景\n\n1. 避免创建过多的重复实例，如果该实例已创建，则直接从缓存获取。\n\n2. 调用子类的构造函数(工厂模式 factory pattern）\n\n3. 实现单例模式(singleton pattern)\n\n## 0x03 Demo\n\n### 创建缓存实例\n\n> 引用自 https://dart.dev/guides/language/language-tour#factory-constructors\n\n```dart\nclass Logger {\n  final String name;\n  // 缓存Map\n  static final Map<String, Logger> _cache = <String, Logger>{};\n\n  factory Logger(String name) {\n    // name对应的key在_cache不存在，执行Logger._internal(name)，否则直接返回\n    return _cache.putIfAbsent(name, () => Logger._internal(name));\n  }\n\n  // 私有构造函数\n  Logger._internal(this.name) {\n    print('生成新实例:$name');\n  }\n}\n\nvoid main(List<String> args) {\n  var p1 = Logger('1');\n  var p2 = Logger('2');\n  var p3 = Logger('1');\n  print(identical(p1, p2));\n  print(identical(p1, p3));\n  // 生成新实例:1\n  // 生成新实例:2\n  // false\n  // true\n}\n```\n\n### 调用子类的构造函数\n\n```dart\nabstract class Animal extends Object {\n  String name;\n  void getNoise();\n  factory Animal(String type, String name) {\n    switch (type) {\n      case 'cat':\n        return Cat(name);\n        break;\n      case 'dog':\n        return Dog(name);\n        break;\n      default:\n        throw \"The '$type' is not an animal\";\n    }\n  }\n}\n\nclass Cat implements Animal {\n  String name;\n  Cat(this.name);\n  @override\n  void getNoise() {\n    print('${this.name}:mew~');\n  }\n}\n\nclass Dog implements Animal {\n  String name;\n  Dog(this.name);\n  @override\n  void getNoise() {\n    print('${this.name}:wang~');\n  }\n}\n\nvoid main(List<String> args) {\n  var cat = Animal('cat', 'haha');\n  var dog = Animal('dog', 'hehe');\n  cat.getNoise();\n  dog.getNoise();\n  // haha:mew~\n  // hehe:wang~\n}\n```\n\n### 实现单例模式\n\n```dart\nclass Singleton {\n  static final Singleton _singleton = Singleton._internal();\n\n  factory Singleton() {\n    return _singleton;\n  }\n\n  Singleton._internal();\n}\n\nvoid main(List<String> args) {\n  var s1 = Singleton();\n  var s2 = Singleton();\n  print(identical(s1, s2));\n  // true\n}\n```\n\n","tags":["Flutter"],"categories":["最佳实践"]},{"title":"Flutter ShapeBorder 使用手册","url":"/2020/07/12/Flutter-ShapeBorder-使用手册/","content":"\n\n## 简介\n\nShapeBorder 用于设置形状和轮廓，比如圆形，矩形，圆角矩形等。常用于 Container 中。\n\n<!-- more -->\n\n继承结构如下：\n\n- ShapeBorder【abstract】\n  - BeveledRectangleBorder\n  - BoxBorder【abstract】\n    - Border\n    - BorderDirectional\n  - CircleBorder\n  - ContinuousRectangleBorder\n  - RoundedRectangleBorder\n  - StadiumBorder\n  - InputBorder【abstract】\n    - OutlineInputBorder\n    - UnderlineInputBorder\n\n其中 ShapeBorder、BoxBorder、InputBorder 是抽象父类。InputBorder 通常用于输入框相关的。\n\n\n\n类的关系图\n\n![ShapeBorder子类继承关系图](/images/flutter_shape_border/ShapeBorder子类继承关系图.png)\n\n\n\n## BeveledRectangleBorder\n\n斜面圆角矩形\n\n继承关系:\n\n `BeveledRectangleBorder > ShapeBorder`\n\n```dart\nWidget _beveledRectangleBorder() {\n  return Center(\n    child: Container(\n      width: 240,\n      height: 120,\n      margin: EdgeInsets.all(16),\n      decoration: ShapeDecoration(\n        image: DecorationImage(\n          image: AssetImage('lib/assets/img_flutter.png'),\n          fit: BoxFit.cover,\n        ),\n        shape: BeveledRectangleBorder(\n          borderRadius: BorderRadius.circular(20),\n          side: BorderSide(\n            width: 2,\n            color: Colors.blue,\n            style: BorderStyle.solid,\n          ),\n        ),\n      ),\n    ),\n  );\n}\n```\n\n效果如下：\n\n![beveled_rectangle_border](/images/flutter_shape_border/beveled_rectangle_border.png)\n\n\n\n\n\n## BoxBorder\n\nBoxBorder主要掌管边线方面的事，自身是abstract，不能直接用\n\nBoxBorder官方说明\n\n>  Base class for box borders that can paint as rectangles, circles, or rounded rectangles.\n\n### Border\n\n继承关系:\n\n`Border > BoxBorder > ShapeBorder`\n\nBorder官方说明\n\n> A border of a box, comprised of four sides: top, right, bottom, left.\n\n```dart\nWidget _border() {\n  return Center(\n    child: Container(\n      margin: EdgeInsets.all(16),\n      padding: EdgeInsets.all(16),\n      decoration: ShapeDecoration(\n        color: Colors.orange,\n        shape: Border(\n          top: BorderSide(width: 6.0, color: Colors.black12),\n          left: BorderSide(width: 6.0, color: Colors.black12),\n          right: BorderSide(width: 6.0, color: Colors.black26),\n          bottom: BorderSide(width: 6.0, color: Colors.black26),\n        ),\n      ),\n      child: Text(\n        \"Border\",\n        style: TextStyle(color: Colors.white, fontSize: 20),\n      ),\n    ),\n  );\n}\n\n```\n\n效果图：\n\n![border](/images/flutter_shape_border/border.png)\n\n### BorderDirectional\n\n继承关系:\n\n `BorderDirectional > BoxBorder > ShapeBorder`\n\n`BorderDirectional` 通过 `top`,`bottom`,`start`,`end`分别控制上下左右的边线\n边线对象`BorderSide`\n\n```dart\nWidget _borderDirectional() {\n  return Center(\n    child: Container(\n      width: 240,\n      height: 120,\n      margin: EdgeInsets.all(16),\n      decoration: ShapeDecoration(\n        image: DecorationImage(\n          image: AssetImage('lib/assets/img_flutter.png'),\n          fit: BoxFit.cover,\n        ),\n        shape: BorderDirectional(\n          start: BorderSide(color: Colors.black, width: 15),\n          end: BorderSide(color: Colors.black, width: 15),\n          top: BorderSide(\n            color: Colors.black,\n          ),\n          bottom: BorderSide(\n            color: Colors.black,\n          ),\n        ),\n      ),\n    ),\n  );\n}\n```\n\n效果如下：\n\n![border_directional_01](/images/flutter_shape_border/border_directional_01.png)\n\n只设置左右的`BorderSide`\n\n```dart\nWidget _borderDirectional2() {\n  return Center(\n    child: Container(\n      width: 240,\n      height: 120,\n      margin: EdgeInsets.all(16),\n      decoration: ShapeDecoration(\n        image: DecorationImage(\n          image: AssetImage('lib/assets/img_flutter.png'),\n          fit: BoxFit.cover,\n        ),\n        shape: BorderDirectional(\n          start: BorderSide(color: Colors.black, width: 15),\n          end: BorderSide(color: Colors.black, width: 15),\n        ),\n      ),\n    ),\n  );\n}\n```\n\n效果如下：\n\n![border_directional_02](/images/flutter_shape_border/border_directional_02.png)\n\n\n\n\n\n## CircleBorder\n\n圆形边框。\n\n继承关系:\n\n `CircleBorder > ShapeBorder`\n\n```dart\nWidget _circleBorder1() {\n  return Center(\n    child: Container(\n      width: 120,\n      height: 120,\n      margin: EdgeInsets.all(16),\n      decoration: ShapeDecoration(\n        image: DecorationImage(\n          image: AssetImage('lib/assets/img_flutter.png'),\n          fit: BoxFit.cover,\n        ),\n        shape: CircleBorder(\n          side: BorderSide(),\n        ),\n      ),\n    ),\n  );\n}\n```\n\n效果如下：\n\n![circle_border_01](/images/flutter_shape_border/circle_border_01.jpg)\n\n上面的是使用默认参数的效果\n\n![circle_border_03](/images/flutter_shape_border/circle_border_03.png)\n\n通过设置BorderSide来设置边框颜色和宽度，以及是否显示边框\n\n```dart\nWidget _circleBorder2() {\n  return Center(\n    child: Container(\n      width: 120,\n      height: 120,\n      margin: EdgeInsets.all(16),\n      decoration: ShapeDecoration(\n        image: DecorationImage(\n          image: AssetImage('lib/assets/img_flutter.png'),\n          fit: BoxFit.cover,\n        ),\n        shape: CircleBorder(\n          side: BorderSide(\n            width: 10,\n            color: Colors.blue,\n            style: BorderStyle.solid,\n          ),\n        ),\n      ),\n    ),\n  );\n}\n\n```\n\n效果如下：\n\n![circle_border_02](/images/flutter_shape_border/circle_border_02.jpg)\n\n\n\n## ContinuousRectangleBorder\n\n平滑过渡的矩形边框\n\n继承关系:\n\n`ContinuousRectangleBorder > ShapeBorder`\n\n```dart\n\nWidget _continuousRectangleBorder() {\n  return Center(\n    child: Container(\n      width: 240,\n      height: 120,\n      margin: EdgeInsets.all(16),\n      decoration: ShapeDecoration(\n        image: DecorationImage(\n          image: AssetImage('lib/assets/img_flutter.png'),\n          fit: BoxFit.cover,\n        ),\n        shape: ContinuousRectangleBorder(\n          borderRadius: BorderRadius.circular(40),\n          side: BorderSide(\n            width: 2,\n            color: Colors.blue,\n            style: BorderStyle.solid,\n          ),\n        ),\n      ),\n    ),\n  );\n}\n```\n\n效果如下：\n\n![continuous_rectangle_border](/images/flutter_shape_border/continuous_rectangle_border.png)\n\n\n## RoundedRectangleBorder\n\n圆角矩形。\n\n继承关系:\n\n`RoundedRectangleBorder > ShapeBorder`\n\n```dart\nWidget _roundedRectangleBorder() {\n  return Center(\n    child: Container(\n      width: 240,\n      height: 120,\n      margin: EdgeInsets.all(16),\n      decoration: ShapeDecoration(\n        image: DecorationImage(\n          image: AssetImage('lib/assets/img_flutter.png'),\n          fit: BoxFit.cover,\n        ),\n        shape: RoundedRectangleBorder(\n          borderRadius: BorderRadius.circular(20),\n          side: BorderSide(\n            width: 2,\n            color: Colors.blue,\n            style: BorderStyle.solid,\n          ),\n        ),\n      ),\n    ),\n  );\n}\n```\n\n效果如下：\n\n![rounded_rectangle_border_01](/images/flutter_shape_border/rounded_rectangle_border_01.png)\n\n## StadiumBorder\n\n体育场形状。即两边是半圆。\n\n继承关系:\n\n`StadiumBorder > ShapeBorder`\n\n```dart\nWidget _stadiumBorder() {\n  return Center(\n    child: Container(\n      width: 240,\n      height: 120,\n      margin: EdgeInsets.all(16),\n      decoration: ShapeDecoration(\n        image: DecorationImage(\n          image: AssetImage('lib/assets/img_flutter.png'),\n          fit: BoxFit.cover,\n        ),\n        shape: StadiumBorder(\n          side: BorderSide(\n            width: 2,\n            color: Colors.blue,\n            style: BorderStyle.solid,\n          ),\n        ),\n      ),\n    ),\n  );\n}\n```\n\n效果如下：\n\n![stadiu_border_01](/images/flutter_shape_border/stadiu_border_01.png)\n\n## InputBorder\n\n继承关系:\n\n `InputBorder > ShapeBorder`\n\n官方说明：\n\n> Defines the appearance of an [InputDecorator]'s border.\n>\n> \n>\n> An input decorator's border is specified by [InputDecoration.border].\n>\n> \n>\n> The border is drawn relative to the input decorator's \"container\" which\n>\n> is the optionally filled area above the decorator's helper, error,and counter.\n\n常用的输入边框，有2个衍生子类`OutlineInputBorder` 和`UnderlineInputBorder`\n\n### OutlineInputBorder\n\n继承关系:\n\n `OutlineInputBorder > InputBorder > ShapeBorder`\n\n```dart\nWidget _outlineInputBorder() {\n  return Center(\n    child: Container(\n      margin: EdgeInsets.all(16),\n      padding: EdgeInsets.all(16),\n      decoration: ShapeDecoration(\n        color: Colors.orange,\n        shape: OutlineInputBorder(\n          borderSide: BorderSide(width: 2.0, color: Colors.purple),\n          borderRadius: BorderRadius.circular(20.0),\n        ),\n      ),\n      child: Text(\n        \"OutlineInputBorder\",\n        style: TextStyle(color: Colors.white, fontSize: 20),\n      ),\n    ),\n  );\n}\n```\n\n效果如下：\n\n![outlineInput_borde](/images/flutter_shape_border/outlineInput_borde.png)\n\n\n\n### UnderlineInputBorder\n\n继承关系:\n\n`UnderlineInputBorder > InputBorder > ShapeBorder`\n\n```dart\nWidget _underlineInputBorder() {\n  return Center(\n    child: Container(\n      margin: EdgeInsets.all(16),\n      padding: EdgeInsets.all(16),\n      decoration: ShapeDecoration(\n        color: Colors.orange,\n        shape: UnderlineInputBorder(\n          borderSide: BorderSide(width: 2.0, color: Colors.purple),\n          borderRadius: BorderRadius.circular(20.0),\n        ),\n      ),\n      child: Text(\n        \"UnderlineInputBorder\",\n        style: TextStyle(color: Colors.white, fontSize: 20),\n      ),\n    ),\n  );\n}\n```\n\n\n\n效果如下：\n\n![underlineInput_border](/images/flutter_shape_border/underlineInput_border.png)","tags":["特效"],"categories":["最佳实践"]},{"title":"VSCode Snippets 使用手册","url":"/2020/06/13/VSCode-Snippets-使用手册/","content":"\n# VSCode Snippets 使用手册\n\n## 前言\n\n当我们为了减少模板代码，我们第一个很可能想到使用`Code Snippets`,很多IDE和文件编辑器已经给我们提供了一个预装的代码片段，当预装的代码片段不能瞒着我们的需求，我们可能会自己定制一些自己的专有代码代码片段，下面就为大家介绍如何在VSCode定制自己的代码片段以及一些小技巧。\n\n![](/images/common/vscode_snippets.webp)\n\n\n<!-- more -->\n\n## 如何添加 \n\n### 方法一：通过控制台\n\n1. 打开VSCode,按下快捷键组合`shift+command+p`呼出控制台\n\n2. 在控制台输入： `Configure User Snippets`选择![configure_user_snippets](/images/vscode_snippets/configure_user_snippets.jpg)\n\n3. 输入`new`，找到新建代码片段命令，这里可以选择创建全局的或者为某个项目专属的代码片段,这里我们选择`New Global Snippets file...`。![new_snippets](/images/vscode_snippets/new_snippets.jpg)\n\n4. 给片段起一个易于理解的命名，回车![new_snippet_with_name](/images/vscode_snippets/new_snippet_with_name.png)\n\n5. 编辑代码片段的内容![snippets_sample](/images/vscode_snippets/snippets_sample.png)\n\n   例如我们创建一个自己名字的TODO, 类似这样的风格：`// TODO(ruofeng): some comment`\n\n   最终版本如下：![todo_snippets](/images/vscode_snippets/todo_snippets.png)\n   \n   效果图\n   \n   ![todo_snippets_auto_tip2](/images/vscode_snippets/todo_snippets_auto_tip2.png)\n\n### 方法二：通过首选项\n\n1. Code -> Preferences->User Snippets\n\n![preffer_setting_code_snippets](/images/vscode_snippets/preffer_setting_code_snippets.jpg)\n\n2. 后面的步骤和第一种的4，5一样，这里不再赘述\n\n## 使用测试\n\n新建一个`.dart`结尾的文件,这里就叫`test.dart` ,输入todo，出现了我们刚才定义的代码片段\n\n![todo_snippets_auto_tip](/images/vscode_snippets/todo_snippets_auto_tip.png)\n\n选择todo,出现我们刚才定义的代码片段\n\n![todo_snippets_auto_tip2](/images/vscode_snippets/todo_snippets_auto_tip2.png)\n\n## 常用语法\n\n1. 变量， 格式 `$+num`, 例如： \n\n   `\"console.log('$1');\"`\n\n2. 变量占位描述,格式`${num:desc}`,例如：\n\n   `\"${1:label}, ${2:another};\"`\n\n3. 缩进，`\\t`,注意缩进的对称性\n\n   ![demo_snippets](/images/vscode_snippets/demo_snippets.png)\n\n### 变量\n\n>  为了跟进环境动态定制一些片段，我们可以使用系统提供的一些环境变量，[官方介绍](https://code.visualstudio.com/docs/editor/userdefinedsnippets#_variables)\n\n![snippets_variables](/images/vscode_snippets/snippets_variables.png)\n\n示例：\n\n我们来定义一个Xcode版本的OC默认风格代码片段\n\n![snippets_copywright](/images/vscode_snippets/snippets_copywright.png)\n\n新建一个test.dart文件，在里面输入copywright，选择刚才我们的添加的代码片段，效果如下\n\n![snippets_copywright_dart](/images/vscode_snippets/snippets_copywright_dart.png)\n\n### 变量转换\n\n语法说明：\n\n```\nany         ::= tabstop | placeholder | choice | variable | text\ntabstop     ::= '$' int\n                | '${' int '}'\n                | '${' int  transform '}'\nplaceholder ::= '${' int ':' any '}'\nchoice      ::= '${' int '|' text (',' text)* '|}'\nvariable    ::= '$' var | '${' var '}'\n                | '${' var ':' any '}'\n                | '${' var transform '}'\ntransform   ::= '/' regex '/' (format | text)+ '/' options\nformat      ::= '$' int | '${' int '}'\n                | '${' int ':' '/upcase' | '/downcase' | '/capitalize' '}'\n                | '${' int ':+' if '}'\n                | '${' int ':?' if ':' else '}'\n                | '${' int ':-' else '}' | '${' int ':' else '}'\nregex       ::= JavaScript Regular Expression value (ctor-string)\noptions     ::= JavaScript Regular Expression option (ctor-options)\nvar         ::= [_a-zA-Z] [_a-zA-Z0-9]*\nint         ::= [0-9]+\ntext        ::= .*\n```\n\n下面将实现读取文件名称截取掉文件的后缀效果： `foo.text` ==> `foo`\n\n```\n${TM_FILENAME/(.*)\\\\..+$/$1/}\n  |           |         |  |\n  |           |         |  |-> no options\n  |           |         |\n  |           |         |-> references the contents of the first\n  |           |             capture group\n  |           |\n  |           |-> regex to capture everything before\n  |               the final `.suffix`\n  |\n  |-> resolves to the filename\n```\n\nTransform Example：\n\n| Example                               | Output                    | Explanation                        |\n| :------------------------------------ | :------------------------ | :--------------------------------- |\n| `\"${TM_FILENAME/[\\\\.]/_/}\"`           | `example-123_456-TEST.js` | Replace the first `.` with `_`     |\n| `\"${TM_FILENAME/[\\\\.-]/_/g}\"`         | `example_123_456_TEST_js` | Replace each `.` or `-` with `_`   |\n| `\"${TM_FILENAME/(.*)/${1:/upcase}/}\"` | `EXAMPLE-123.456-TEST.JS` | Change to all uppercase            |\n| `\"${TM_FILENAME/[^0-9^a-z]//gi}\"`     | `example123456TESTjs`     | Remove non-alphanumeric characters |\n\n### Build value 代码片段插件`bvtf` 的实现\n\n`bvtf`，是上面变量和变量转换的综合应用，实现了下面功能\n\n1. 自动识别文件名称\n2. 将文件名称去掉后缀，转换为大写驼峰法（pascalcase）\n\n\n\n源码获取步骤：\n\n1. 去github官网下载它的源码，[built-value-snippets](https://github.com/GiancarloCode/built-value-snippets)\n\n2. 在vscode->snippets->snippets.json 找到对应的源码，如下\n\n   ```json\n   {\n   \"Built Value Type File\": {\n           \"prefix\": \"bvtf\",\n           \"body\": [\n               \"import 'package:built_collection/built_collection.dart';\",\n               \"import 'package:built_value/built_value.dart';\",\n               \"\",\n               \"part '$TM_FILENAME_BASE.g.dart';\",\n               \"\",\n               \"abstract class ${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/} implements Built<${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}, ${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}Builder> {\",\n               \"  ${2}\",\n               \"\",\n               \"  ${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}._();\",\n               \"  factory ${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}([void Function(${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}Builder) updates]) = _$${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/};\",\n               \"}\"\n           ],\n           \"description\": \"Built Value Type File whose name corresponds to the file name\"\n       }\n   }\n   ```\n\n   \n\n   核心的变量如下：\n\n   ```json\n   // file name: home_page.dart => HomePage\n   \"${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}\"\n   ```\n\n   通过上面的学习我们几乎可能编写我们的日常需要各种代码片段\n\n   \n\n## 引用\n\n* [built-value-snippets](https://github.com/GiancarloCode/built-value-snippets)\n\n* [Built Value Snippets VSCode 插件](https://marketplace.visualstudio.com/items?itemName=GiancarloCode.built-value-snippets)\n\n* [Snippets in Visual Studio Code](https://code.visualstudio.com/docs/editor/userdefinedsnippets#_variables)","tags":["Snippets"],"categories":["效率"]},{"title":"用 Typora 的 MarkDown 绘制Diagrams(图解)","url":"/2019/11/29/用Typora的MarkDown绘制Diagrams-图解/","content":"\n\n## 简介\n\n最近在研究软件设计领域常用各种图解，发现[Typora](https://typora.io)d对MarkDown渲染diagrams的支持特别好，于是整理了一下，方便以后查阅使用，目前(测试版本`0.9.9.18.1(1088)`)支持以下几大类图解:\n\n* Sequence\n* Flowchart \n* Mermaid \n  * sequence  (时序图)\n  * flowchart   (流程图)\n  * gantt          (甘特图)\n\n<!-- more -->\n\n\n>Sequence由[js-sequence](https://bramp.github.io/js-sequence-diagrams/)驱动\n>\n>Flowchart由[flowchart.js](http://flowchart.js.org/)驱动\n>\n>Mermaid由[mermaid](https://mermaid-js.github.io/mermaid/#/)驱动，支持sequence，flowchart，gantt\n\n## Sequence -- 时序图\n\n### UML时序图(sequence)\n\n```sequence\n对象A->对象B: 对象B你好吗?（请求）\nNote right of 对象B: 对象B的描述\nNote left of  对象A: 对象A的描述(提示)\n对象B-->对象A: 我很好(响应)\n对象A->对象B: 你真的好吗？\n```\n\n![UML_sequence_01](/images/Diagrams/UML_sequence_01.png)\n\n### UML时序图复杂(sequence)\n\n```sequence\nTitle: 标题：复杂使用\n对象A->对象B: 对象B你好吗?（请求）\nNote right of 对象B: 对象B的描述\nNote left of 对象A: 对象A的描述(提示)\n对象B-->对象A: 我很好(响应)\n对象B->小三: 你好吗\n小三-->>对象A: 对象B找我了\n对象A->对象B: 你真的好吗？\nNote over 小三,对象B: 我们是朋友\nparticipant C\nNote right of C: 没人陪我玩\n```\n\n![UML_sequence_02](/images/Diagrams/UML_sequence_02.png)\n\n### UML标准时序图(mermaid)\n\n```mermaid\n%% 时序图例子,-> 直线，-->虚线，->>实线箭头\nsequenceDiagram\nparticipant 张三\nparticipant 李四\n张三->王五: 王五你好吗？\nloop 健康检查\n王五->王五: 与疾病战斗\nend\nNote right of 王五: 合理 食物 <br/>看医生...\n李四-->>张三: 很好!\n王五->李四: 你怎么样?\n李四-->王五: 很好!\n```\n\n语法说明：\n```\nTitle: Here is a title\nA->B: Normal line\nB-->C: Dashed line\nC->>D: Open arrow\nD-->>A: Dashed open arrow\n```\n\n\n![UML_mermaid](/images/Diagrams/UML_mermaid.png)\n\n## flowchart -- 流程图\n\n### 横向流程图(mermaid)\n\n```mermaid\ngraph LR\nA[方形] -->B(圆角)\nB --> C{条件a}\nC -->|a=1| D[结果1]\nC -->|a=2| E[结果2]\nF[横向流程图]\n```\n\n![flowchart_mermaid_01](/images/Diagrams/flowchart_mermaid_01.png)\n\n### 竖向流程图(mermaid)\n\n```mermaid\ngraph TB\nA[方形] -->B(圆角)\nB --> C{条件a}\nC -->|a=1| D[结果1]\nC -->|a=2| E[结果2]\nF[竖向流程图]\n```\n\n![flowchart_mermaid_02](/images/Diagrams/flowchart_mermaid_02.png)\n\n### 标准流程图(flow)\n\n```flow\nst=>start: 开始框\nop=>operation: 处理框\ncond=>condition: 判断框(是或否?)\nsub1=>subroutine: 子流程\nio=>inputoutput: 输入输出框\ne=>end: 结束框\nst->op->cond\ncond(yes)->io->e\ncond(no)->sub1(right)->op\n```\n\n![flowchart_flow_01](/images/Diagrams/flowchart_flow_01.png)\n\n### 标准流程图-横向(flow)\n\n```flow\n\nst=>start: 开始框\nop=>operation: 处理框\ncond=>condition: 判断框(是或否?)\nsub1=>subroutine: 子流程\nio=>inputoutput: 输入输出框\ne=>end: 结束框\nst(right)->op(right)->cond\ncond(yes)->io(bottom)->e\ncond(no)->sub1(right)->op\n```\n\n![flowchart_flow_02](/images/Diagrams/flowchart_flow_02.png)\n\n## 甘特图样例 (gantt)\n\n```mermaid\n%% 语法示例\ngantt\ndateFormat  YYYY-MM-DD\ntitle 软件开发甘特图\n\nsection 设计\n需求:done,    des1, 2014-01-06,2014-01-08\n原型:active,  des2, 2014-01-09, 3d\nUI设计: des3, after des2, 5d\n未来任务: des4, after des3, 5d\n\nsection 开发\n学习准备理解需求 :crit, done, 2014-01-06,24h\n设计框架 :crit, done, after des2, 2d\n开发 :crit, active, 3d\n未来任务 :crit, 5d\n耍 :2d\n\nsection 测试\n功能测试 :active, a1, after des3, 3d\n压力测试 :after a1  , 20h\n测试报告 : 48h\n```\n\n![Gantt](/images/Diagrams/Gantt.png)\n\n\n## 不错的画图工具网站\n* https://www.processon.com\n* https://www.draw.io\n\n## 参考资料\n\n* [Draw Diagrams With Markdown](http://support.typora.io/Draw-Diagrams-With-Markdown/)\n* [Typora画流程图、时序图(顺序图)、甘特图（转）](https://www.jianshu.com/p/7ddbb7dc8fec)\n* [mermaid](http://mermaid-js.github.io/mermaid/#/)\n* [mermaid-live-editor](https://github.com/mermaidjs/mermaid-live-editor)\n","tags":["Typora"],"categories":["效率"]},{"title":"[转]Objective-C Runtime 大佬系列文章整理","url":"/2019/11/18/转-Objective-C-Runtime-大佬系列文章整理/","content":"\n## 简介\n此文转自[kangzubin 收集的runtime大佬系列文章](https://kangzubin.com/objc-runtime-articles/)，特别鸣谢，方便后续查阅。\n\n<!-- more -->\n\n## kangzubin\n\n最近重新温习了下 Objective-C Runtime 相关的知识，自己整理了两篇水文：\n\n- [Objective-C 1.0 中类与对象的定义](https://kangzubin.com/objc1.0-class-object/)\n- [Objective-C 2.0 中类与对象的定义](https://kangzubin.com/objc2.0-class-object/)\n\n然后在网上搜罗了一圈，发现很多大佬之前都写了一系列关于 Runtime 的文章，深入浅出，真是让人难以望其项背，收集如下，方便日后学习，欢迎补充。\n\n\n\n## [Greg Parker](http://www.sealiesoftware.com/blog/)\n\n- [Classes and metaclasses](http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html)\n\n## [Matt Gallagher](https://www.cocoawithlove.com/)\n\n- [What is a meta-class in Objective-C?](https://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html)\n\n## [南峰子](https://southpeak.github.io/)\n\n- [Objective-C Runtime 运行时之一：类与对象](http://southpeak.github.io/2014/10/25/objective-c-runtime-1/)\n- [Objective-C Runtime 运行时之二：成员变量与属性](http://southpeak.github.io/2014/10/30/objective-c-runtime-2/)\n- [Objective-C Runtime 运行时之三：方法与消息](http://southpeak.github.io/2014/11/03/objective-c-runtime-3/)\n- [Objective-C Runtime 运行时之四：Method Swizzling](http://southpeak.github.io/2014/11/06/objective-c-runtime-4/)\n- [Objective-C Runtime 运行时之五：协议与分类](http://southpeak.github.io/2014/11/08/objective-c-runtime-5/)\n- [Objective-C Runtime 运行时之六：拾遗](http://southpeak.github.io/2014/11/09/objective-c-runtime-6/)\n\n## [halfrost](https://halfrost.com/)\n\n- [神经病院 Objective-C Runtime 入院第一天 —— isa 和 Class](http://halfrost.com/objc_runtime_isa_class/)\n- [神经病院 Objective-C Runtime 住院第二天 —— 消息发送与转发](http://halfrost.com/objc_runtime_objc_msgsend/)\n- [神经病院 Objective-C Runtime 出院第三天 —— 如何正确使用 Runtime](http://halfrost.com/how_to_use_runtime/)\n- [Objc 对象的今生今世](http://halfrost.com/objc_life/)\n\n## [杨萧玉](http://yulingtianxia.com/)\n\n- [Objective-C Runtime](http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/)\n- [Objective-C 引用计数原理](http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/)\n- [Objective-C 消息发送与转发机制原理](http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/)\n\n## [雷纯锋](http://blog.leichunfeng.com/)\n\n- [Objective-C 对象模型](http://blog.leichunfeng.com/blog/2015/04/25/objective-c-object-model/)\n- [Objective-C +load vs +initialize](http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/)\n- [Objective-C Category 的实现原理](http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/)\n- [Objective-C Autorelease Pool 的实现原理](http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/)\n- [Objective-C Method Swizzling 的最佳实践](http://blog.leichunfeng.com/blog/2015/06/14/objective-c-method-swizzling-best-practice/)\n- [Objective-C Associated Objects 的实现原理](http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/)\n\n## [draveness/analyze](https://github.com/draveness/analyze)\n\n- [从 NSObject 的初始化了解 isa](https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md)\n- [深入解析 ObjC 中方法的结构](https://github.com/draveness/analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md)\n- [从源代码看 ObjC 中消息的发送](https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9C%8B%20ObjC%20%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81.md)\n- [你真的了解 load 方法么？](https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%20load%20%E6%96%B9%E6%B3%95%E4%B9%88%EF%BC%9F.md)\n- [自动释放池的前世今生](https://github.com/draveness/analyze/blob/master/contents/objc/%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.md)\n- [黑箱中的 retain 和 release](https://github.com/draveness/analyze/blob/master/contents/objc/%E9%BB%91%E7%AE%B1%E4%B8%AD%E7%9A%84%20retain%20%E5%92%8C%20release.md)\n- [关联对象 AssociatedObject 完全解析](https://github.com/draveness/analyze/blob/master/contents/objc/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%20AssociatedObject%20%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90.md)\n- [懒惰的 initialize 方法](https://github.com/draveness/analyze/blob/master/contents/objc/%E6%87%92%E6%83%B0%E7%9A%84%20initialize%20%E6%96%B9%E6%B3%95.md)\n- [对象是如何初始化的（iOS）](https://github.com/draveness/analyze/blob/master/contents/objc/%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%EF%BC%88iOS%EF%BC%89.md)\n\n## [CornBallast](https://www.jianshu.com/u/a9008a597529)\n\n- [Runtime 深度解析以及实用技巧](https://www.jianshu.com/p/88d11bb12ba1)\n- [Runtime 奇技淫巧__带你深入理解 Runtime 特有概念](https://www.jianshu.com/p/37e1b71ad03a)\n- [Runtime 奇技淫巧__不受限制的消息发送](https://www.jianshu.com/p/38bbde2c5632)\n- [Runtime 奇技淫巧__获取类的实例变量以及属性并强势 与KVC、msgSend 混用](https://www.jianshu.com/p/cb55dbb72c84)\n- [Runtime 奇技淫巧__方法交换](https://www.jianshu.com/p/13ab44c46904)\n- [Runtime 奇技淫巧__动态链接对象以及给分类添加属性](https://www.jianshu.com/p/48220940118f)\n- [Runtime 奇技淫巧__动态添加方法，消息转发改善异常](https://www.jianshu.com/p/c5bdd6f7a68c)\n\n## [唐巧](https://blog.devtang.com/)\n\n- [Objective-C对象模型及应用](https://blog.devtang.com/2013/10/15/objective-c-object-model/)\n\n## [ibireme](https://blog.ibireme.com/2013/11/25/objc-object/)\n\n- [Objective-C 中的类和对象](https://blog.ibireme.com/2013/11/25/objc-object/)\n\n## [sunnyxx](http://blog.sunnyxx.com/)\n\n- [objc 与鸭子对象（上）](http://blog.sunnyxx.com/2014/08/24/objc-duck/)\n- [objc 与鸭子对象（下）](http://blog.sunnyxx.com/2014/08/26/objc-duck-advanced/)\n- [神经病院 objc runtime 入院考试](http://blog.sunnyxx.com/2014/11/06/runtime-nuts/)\n- [重识 Objective-C Runtime - Smalltalk 与 C 的融合](http://blog.sunnyxx.com/2016/08/13/reunderstanding-runtime-0/)\n- [重识 Objective-C Runtime - 看透 Type 与 Value](http://blog.sunnyxx.com/2016/08/13/reunderstanding-runtime-1/)\n\n## 其他\n\n此外，在简书、掘金等技术博客平台，以及 Google 上搜索 `Objective-C Runtime` 关键词，也能找出成千上万相关的文章。\n","tags":["Runtime"]},{"title":"从零开始创建 cocoaPods 公有库","url":"/2019/11/17/从零开始创建cocoaPods公有库/","content":"\n## 简介\n这篇文章记录了一个公共Pod库 [RFSegmentView](https://github.com/wangruofeng/RFSegmentView)的创建过程\n\n<!-- more -->\n\n## 注册CocoaPods账号\n\n想要创建一个开源pod库, 首先我们需要注册CocoaPods, 这里使用trunk方式,  那么只需要在终端执行（这里默认你已经安装好CocoaPods环境）:\n\n```ruby\npod trunk register 邮箱地址 '用户名' --verbose\n```\n\n这里我们一般使用github邮箱和用户名, 然后在你的邮箱中会收到确认邮件,下面是确认邮件的内容：\n\n![img](/images/cocoapod_trunk_register.png)\n\n 在浏览器中点击链接确认即注册成功, 成功之后可以终端执行:\n\n```ruby\npod trunk me\n```\n\n通过上面的命令查看注册信息，里面会展示该账号下的所有的Pod库，可以用此方式查看自己发布过的Pods\n\n```shell\n➜  myBlog git:(master) ✗ pod trunk me\n  - Name:     wangruofeng\n  - Email:    wangruofeng007@gmail.com\n  - Since:    November 16th, 12:17\n  - Pods:\n    - RFSegmentView\n  - Sessions:\n    - November 16th, 12:17 - March 24th, 2020 04:54. IP: 119.123.133.39\n```\n\n\n\n## 创建共享库文件并上传到公有仓库\n\n共享库需要三个必不可少的部分:\n\n1. `共享文件夹`(文件夹存放着你要共享的内容, 也就是其他人通过pod安装得到的文件, .podspec文件中的source_files需要指定此文件路径及文件类型);\n2. `LICENSE文件`(默认一般选择MIT);\n3. `库名.podspec`(本库的各项信息描述, 需要提交给CocoaPods, pod通过这个文件查找到你共享的库).\n\n\n\n如果没有 `podspec` 文件可以用下面的命令，初始化\n\n```\npod lib create 库名\n```\n\n\n\n## 编辑.podspec文件\n\n以 `RFSegmentView.podspec` 为例：\n\n```ruby\nPod::Spec.new do |spec|\n\n  spec.name         = \"RFSegmentView\"\n  spec.version      = \"1.3.0\"\n  spec.summary      = \"Imitate iOS7 style segmented controls, simple, practical！\"\n  spec.homepage     = \"https://github.com/wangruofeng/RFSegmentView\"\n  spec.license      = { :type => \"MIT\", :file => \"LICENSE.md\" }\n  spec.author       = { \"wangruofeng\" =>\"wangruofeng007@gmail.com\" }\n  spec.platform     = :ios, \"8.0\"\n  spec.source       = { :git => 'https://github.com/wangruofeng/RFSegmentView.git', :tag => spec.version.to_s}\n  spec.source_files  = \"RFSegmentView/RFSegmentView.{h,m}\"\n  # spec.exclude_files = \"Classes/Exclude\"\n  # spec.public_header_files = \"Classes/**/*.h\"\n\n  spec.frameworks = 'UIKit', 'CoreGraphics', 'Foundation'\n  spec.requires_arc = true\n\n  # spec.dependency \"JSONKit\", \"~> 1.4\" 添加依赖库\n\nend\n```\n\n编写完成后, 我们需要验证.podspec文件的合法性, 这里需要终端cd到.podspec文件所在文件夹, 执行:\n\n```shell\npod lib lint RFSegmentView.podspec\n```\n\n如有警告或者错误请重新检查你的编写正确性, 如果没有问题会出现\n\n```shell\n-> RFSegmentView (1.3.0)\n    \nRFSegmentView passed validation.\n```\n\n\n\n## 打tag，发布新版本\n\n一切准备就绪后, 我们需要在你的git仓库里面存在一个与.podspec文件中一致的版本, 这里你可以在你的git仓库中的准备一个版本, 也可以在当前文件夹下使用终端命令:\n\n```\ngit tag -m 'first release' '1.3.0'\ngit push --tag #推送tag到远端仓库\n```\n\n成功之后即可在你分支里面看到这个tag的版本.\n\n\n\n## 发布库描述文件\n\n下面我们需要发布自己的库描述文件podspec给cocoapods\n同样在这个文件夹下, 终端执行:\n\n```shell\npod trunk push RFSegmentView.podspec\n```\n\n将你的库文件.podspec文件提交到公有的specs上面, 这一步做的操作是验证你的podspec文件是否合法+提交到specs中+将上传的podspec文件转成json格式文件,如果重复提交会出现下面的信息:\n\n```\n[!] Unable to accept duplicate entry for: RFSegmentView (1.3.0)\n```\n\n为了测试将RFSegmentView.podspec里面的spec.version修改成1.3.1,成功后会出现Congrats信息:\n\n```\n➜  RFSegmentView git:(master) pod trunk push RFSegmentView.podspec\nUpdating spec repo `trunk`\nValidating podspec\n -> RFSegmentView (1.3.1)\n    - NOTE  | xcodebuild:  note: Using new build system\n    - NOTE  | [iOS] xcodebuild:  note: Planning build\n    - NOTE  | [iOS] xcodebuild:  note: Constructing build description\n    - NOTE  | [iOS] xcodebuild:  warning: Skipping code signing because the target does not have an Info.plist file and one is not being generated automatically. (in target 'App' from project 'App')\n\nUpdating spec repo `trunk`\n\n--------------------------------------------------------------------------------\n 🎉  Congrats\n\n 🚀  RFSegmentView (1.3.1) successfully published\n 📅  November 17th, 07:08\n 🌎  https://cocoapods.org/pods/RFSegmentView\n 👍  Tell your friends!\n--------------------------------------------------------------------------------\n```\n\n## 查找和使用新创建的库\n\n成功后需要等待的时间不定, 目前一般比较快, 一般使用pod setup和pod search查看是否已经可以使用, 如果\n\n`pod search RFSegmentView` 一直搜索不到，尝试删除`pod setup`成功后生成的`~/Library/Caches/CocoaPods/search_index.json`文件, 该文是用来查找的索引文件, \n\n终端输入:\n\n```shell\nrm ~/Library/Caches/CocoaPods/search_index.json\n```\n\n删除成功后再执行:`pod search 库名`, 等待输出：`Creating search index for spec repo 'master'.. Done!`稍等片刻就会出现你想要的结果,如果还是没有结果需要等待pod同步，过一段时间再来尝试。\n\n## 更新维护podspec\n\n如果有错误或者需要迭代版本,修改工程文件后推送到远端仓库后, 需要修改podspec中的版本号, 并重新打tag上传, 再进行新一轮的验证和发布。\n\n\n## 参考资料\n\n* [[CocoaPods创建公有和私有Pod库方法总结](https://segmentfault.com/a/1190000007947371)](https://segmentfault.com/a/1190000007947371)\n* [Podspecs](https://github.com/CocoaPods/Specs/)\n* [Podspec attributes](https://guides.cocoapods.org/syntax/podspec.html)\n","tags":["CocoaPods"],"categories":["包管理"]},{"title":"Pod 常用命令","url":"/2019/11/14/Pod常用命令/","content":"\n\n# 简介\n介绍Pod常用的几种命令\n\n<!-- more -->\n\n## pod init\n\n第一次调用会初始化项目，如果已经初始化后调用会抛出以下错误。\n\n\n> [!] Existing Podfile found in directory\n\n\n## pod install\n\n根据podfile.lock文件中指定的pod依赖库的版更新项目的pod依赖库。在首次执行pod install命令时，如果不存在podfile.lock文件会生成该文件，并且同时生成`xcworkspace`文件和pods文件夹。 \n\n> pod install执行后，后续的项目需要使用`xxx.xcworkspace`打开\n\n\n\n参数：--no-repo-update\n\n不更新pod仓库，使用此命令可以加快pod install的更新速度。\n\neg: `pod install --no-repo-update`\n\n\n\n## pod update\n\n这个命令会检查podfile.lock文件中的pod依赖库的版本，并更新，会重新生成一个新podfile.lock文件。\n\n\n\n选项：--exclude-pods=xxx\n\n只更新xxx之外的仓库。\n\neg: `pod update --exclude-pods=AFNetworking`\n\n\n\n选项：xxx --no-repo-update\n\n只更新`xxx`依赖不更新除它之外的其他依赖。\n\neg: `pod update AFNetworking --no-repo-update`\n\n\n\n> 一般没有特别必要时不建议使用pod update命令,尽量使用pod install，如果实在不行再使用带上面选项的od update，如果更新失败才使用pod update命名，这样能明显加快更新流程，节约更新依赖的时间。\n\n\n\n## pod search \n\n后面更新依赖库的名称，搜索指定依赖库\n\neg: pod search AFNetworking\n\n```ruby\n-> AFNetworking (3.2.1)\n   A delightful iOS and OS X networking framework.\n   pod 'AFNetworking', '~> 3.2.1'\n   - Homepage: https://github.com/AFNetworking/AFNetworking\n   - Source:   https://github.com/AFNetworking/AFNetworking.git\n   - Versions: 3.2.1, 3.2.0, 3.1.0, 3.0.4, 3.0.3, 3.0.2, 3.0.1, 3.0.0,\n   3.0.0-beta.3, 3.0.0-beta.2, 3.0.0-beta.1, 2.7.0, 2.6.3, 2.6.2, 2.6.1, 2.6.0,\n   2.5.4, 2.5.3, 2.5.2, 2.5.1, 2.5.0, 2.4.1, 2.4.0, 2.3.1, 2.3.0, 2.2.4, 2.2.3,\n   2.2.2, 2.2.1, 2.2.0, 2.1.0, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 2.0.0-RC3, 2.0.0-RC2,\n   2.0.0-RC1, 1.3.4, 1.3.3, 1.3.2, 1.3.1, 1.3.0, 1.2.1, 1.2.0, 1.1.0, 1.0.1,\n   1.0, 1.0RC3, 1.0RC2, 1.0RC1, 0.10.1, 0.10.0, 0.9.2, 0.9.1, 0.9.0, 0.7.0,\n   0.5.1 [master repo]\n   - Subspecs:\n     - AFNetworking/Serialization (3.2.1)\n     - AFNetworking/Security (3.2.1)\n     - AFNetworking/Reachability (3.2.1)\n     - AFNetworking/NSURLSession (3.2.1)\n     - AFNetworking/UIKit (3.2.1)\n```\n\n\n\n## pod repo\n\n查看所有pod 仓库的源\n\n```ruby\nmaster\n- Type: git (master)\n- URL:  https://github.com/CocoaPods/Specs.git\n- Path: /Users/wangruofeng/.cocoapods/repos/master\n```\n\n\n\n选项：remove xxx\n\neg: pod repo remove xxx\n\n移除xxx repo源\n\n\n\n## pod try\n\n非常棒，却很少有人知道，使您可以在将库添加到项目之前对其进行测试驱动。\n\n选项：try xxx\n\n```ruby\npod try AFNetworking\n```\n\n\n\n## pod outdated\n\n显示当前 Podfile.lock文件中过期的pods，仅仅是来自spec repos，不包含来自本地和外部的资源。\n\n![pod_outdated](/images/pod_outdated.png)\n\n ## gem source 操作\n\n当前gem源查看\n\n>  gem source -l\n\n```ruby\n*** CURRENT SOURCES ***\n\nhttps://gems.ruby-china.com/\n```\n\n移除指定的gem源\n\n> gem source  - - remove <https://rubygems.org/>\n\n添加指定的gem源\n\n> gem source - a https://gems.ruby-china.com/\n\n更新cocoapod\n\n> sudo gem install cocoapods\n\n","tags":["CocoaPods","Skill"]},{"title":"从 Octopress 迁移博客到 hexo","url":"/2019/11/10/从Octopress迁移博客到hexo/","content":"\n![hexo](/images/baner_hexo.jpg)\n<!-- more -->\n\n## 简介\n\n最近准备更新博客（以前的基于Octopress），去写的时候突然发现以前的博客跑不起来了。。。倒腾了一下，在执行博客更新时`rake generate`，一直报错，错误出现在高亮解析模块 `Pygments`，尝试升级`jekyll`但是和它相关的依赖模块还是有问题。\n\n```shell\n➜  Octopress git:(source) ✗ rake generate\n## Generating Site with Jekyll\nConfiguration file: /Users/wangruofeng/Documents/Git Repositories/Octopress/_config.yml\n            Source: source\n       Destination: public\n      Generating... \njekyll 2.5.3 | Error:  Pygments can't parse unknown language: objective-c.\n```\n\n\n\n后面去[Octopress](http://octopress.org)官网查了了，发现上次更新还是[2015.01.15](http://octopress.org/2015/01/15/octopress-3.0-is-coming/)的事了，后续也没有更新，于是觉得这个不太靠谱，准备换一个，调研了一下，发现使用hexo的挺多，于是开始捣腾起来。。。\n\n\n\n## 准备环境\n\n\b准备 node 和 git 环境， 首先，安装 [NodeJS](https://nodejs.org/en/)，因为 [Hexo](https://hexo.io/zh-cn/) 是基于 Node.js 驱动的一款博客框架。\n\n\n\n在命令行中输入相应命令验证是否成功，如果成功会有相应的版本号。\n\n```shell\n➜  myBlog git:(master) ✗ git version\ngit version 2.24.0\n➜  myBlog git:(master) ✗ node -v\nv12.13.0\n➜  myBlog git:(master) ✗ npm -v\n6.12.0\n```\n\n\n\n## 安装Hexo\n\n如果以上环境准备好了就可以使用 npm 开始安装 Hexo 了。也可查看 [Hexo](https://hexo.io/zh-cn/) 的详细文档。 在命令行输入执行以下\b命令：\n\n```bash\nnpm install -g hexo-cli\n```\n\n没有权限的话可能会出现下面的错误信息:\n\n```shell\nnpm ERR! code EACCES\nnpm ERR! syscall mkdir\nnpm ERR! path /Users/wangruofeng/.npm/_cacache/content-v2/sha512/0b/8a\nnpm ERR! errno -13\nnpm ERR! \nnpm ERR! Your cache folder contains root-owned files, due to a bug in\nnpm ERR! previous versions of npm which has since been addressed.\nnpm ERR! \nnpm ERR! To permanently fix this problem, please run:\nnpm ERR!   sudo chown -R 501:20 \"/Users/wangruofeng/.npm\"\n\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /Users/wangruofeng/.npm/_logs/2019-11-10T07_21_42_135Z-debug.log\n```\n\n报错的话加上 sudo重试一次或者执行**sudo chown -R 501:20 \"/Users/wangruofeng/.npm\"**\n\n```shell\n➜  Git Repositories sudo npm install -g hexo-cli\n/usr/local/Cellar/node/5.7.0/bin/hexo -> /usr/local/Cellar/node/5.7.0/lib/node_modules/hexo-cli/bin/hexo\n+ hexo-cli@3.1.0\nadded 67 packages from 317 contributors in 27.347s\n```\n\n\n\n安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\n\n```sh\nhexo init myBlog\ncd myBlog\nnpm install\n```\n\n\n\n新建完成后，指定文件夹的目录如下：\n\n```\n.\n├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 \n├── package.json\n├── scaffolds # 模版文件夹\n├── source  # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹\n|   ├── _drafts # 草稿文件\n|   └── _posts # 文章Markdowm文件 \n└── themes  # 主题文件夹\n```\n\n\n\n好了，如果上面的\b命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的\b缩写，在浏览器中输入 [http://localhost:4000](http://localhost:4000/) 回车就可以预览效果了。\n\n```shell\nhexo s\n```\n\n至此，你本地的博客就已经搭建成功，接下来就是部署到 Github Page 了。\n\n\n\n## 部署到GitHub\n\n此时，本地和Github的工作做得差不了，是时候把它们两个连接起来了。你\b也可以查看官网的[部署](https://hexo.io/zh-cn/docs/deployment)教程。 先不着急，部署之前还需要修改配置和安装部署插件。 第一：打开项目根目录下的 _config.yml 配置文件\b配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）：\n\n```yaml\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo:\n    github: https://github.com/wangruofeng/wangruofeng.github.io.git\n  branch: master\n```\n\n\n\n第二：要安装一个部署\b插件 [hexo-deployer-git](https://github.com/hexojs/hexo-deployer-git)。\n\n```shell\nnpm install hexo-deployer-git --save\n```\n\n最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写\n\n```shell\nhexo g -d\n```\n\n稍等一会，在浏览器访问网址： [https://你的用户名.github.io](https://你的用户名.github.io]) 就会看到你的博客啦！！\n\n\n\n## 开始写作\n\n博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档可以看 [hexo](https://hexo.io/zh-cn/) 官网。 新建文章，输入以下命令即可\n\n```\nhexo new '文章标题'\n```\n\n执行完成后可以在 /source/_posts 下看到一个“[文章标题.md](http://xn--7dvp9ct91as61a.md/)”的文章文件啦。.md 就是 Markdown 格式的文件，具体用法可以在网上找一下，语法还是比较简单的。\n\n在 Markdown 文章里面输入你的文章内容\n\n再执行一下以下命令\n\n```shell\nhexo g # 生成相关文件\nhexo s # 部署到本地\n```\n\n\n\n最后，只要部署到你的 Github 上就可以了！\n\n```shell\nhexo clean\nhexo g -d\n```\n\n部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n\n\n\n另外，如果你的文章暂时不发布可以先保存在草稿里面。生成草稿的方法和文章差不多 hexo new draft \"文章标题\"，生成后会在 /source/_drafts 里看到你的草稿文章。当你想发布时只要执行 publish 命令即可发布到博客。\n\n```\nhexo publish [layout] <filename>\n```\n\n\n\n## 遇到的坑 \n\n### 1. Hexo: TypeError: Cannot set property ‘lastIndex’ of undefined\n\n解决方案是 将你工程下的 _config.yml (这个不是主题的_config.yml) 文件里面的 `auto_detect` 设置为 false。\n\n```yaml\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n```\n\n\n\n### 2.修改完 hexo 目录下的 _config.yml 文件 重新 generate 文件不生效\n\n使用 hexo 的命令 `hexo clean`,清除一下。\n\n\n\n## 参考链接\n\n* [运行 hexo g 出错 #1913](https://github.com/hexojs/hexo/issues/1913)\n* [有哪些好看的 Hexo 主题？](https://www.zhihu.com/question/24422335)\n* [超详细Hexo+Github Page搭建技术博客教程【持续更新】](https://juejin.im/post/5c4730c9f265da61616efeec)\n","tags":["Hexo"],"categories":["博客搭建"]},{"title":"NSNumber 转 NSString 丢精问题","url":"/2017/10/14/2017-10-14-nsnumberzhuan-nsstringdiu-jing-wen-ti/","content":"\n\n### 问题引出\n\n在开发中，涉及价格金额处理，后台会返回Number类型的数据，打印或者经过Json转Model后的NSString可能出现精度丢失的问题，如果涉及到金额的加减乘除运算问题将暴露得更为明显。这里就iOS数据精度处理做一个总结。\n\n<!-- more -->\n\n\n### 问题复现\n\n#### NSNumber转NSSting\n\n```objc\n    NSArray *numbers = @[\n                         @99.00,\n                         @99.09,\n                         @99.19,\n                         @99.29,\n                         @99.39,\n                         @99.49,\n                         @99.59,\n                         @99.69,\n                         @99.79,\n                         @99.89,\n                         @99.99,\n                         ];\n    \n    for (int i = 0; i < numbers.count; i++) {\n        NSNumber *number = numbers[i];\n        NSString *strValue = [number stringValue];\n        \n        NSLog(@\"strValue:%@\",strValue);\n    }\n    \n    /*\n     oldVlue:99.00 strValue:99\n     oldVlue:99.09 strValue:99.09\n     oldVlue:99.19 strValue:99.19\n     oldVlue:99.29 strValue:99.29000000000001\n     oldVlue:99.39 strValue:99.39\n     oldVlue:99.48 strValue:99.48999999999999\n     oldVlue:99.59 strValue:99.59\n     oldVlue:99.69 strValue:99.69\n     oldVlue:99.79 strValue:99.79000000000001\n     oldVlue:99.89 strValue:99.89\n     oldVlue:99.99 strValue:99.98999999999999\n     */\n```\n\n在这里我们发现将NSNumber转换成NSSting的过程中可能会出现精度丢失。\n\n#### Json到Model\n\n```objc\n    //出现BUG的条件必须是两位数，且带两位小数，类型还必须是float\n    //两位数：十位必须是7、8、9；个位数随意\n    //两位小数：个位数随意；十位数必须是0\n    NSString *jsonStr = @\"{\\\"71.40\\\":71.40, \\\"97.40\\\":97.40, \\\"80.40\\\":80.40, \\\"188.40\\\":188.40}\";\n    NSLog(@\"json:%@\", jsonStr);\n    \n    NSData *jsonData = [jsonStr dataUsingEncoding:NSUTF8StringEncoding];\n    NSError *jsonParsingError = nil;\n    NSDictionary *dic = [NSMutableDictionary dictionaryWithDictionary:[NSJSONSerialization JSONObjectWithData:jsonData options:0 error:&jsonParsingError]];\n    \n    NSLog(@\"dic:%@\", dic);\n    /*\n    2017-10-14 18:29:19.434 FloatTransferDemo[62722:3093992] dic:{\n        \"188.40\" = \"188.4\";\n        \"71.40\" = \"71.40000000000001\";\n        \"80.40\" = \"80.40000000000001\";\n        \"97.40\" = \"97.40000000000001\";\n    }\n    */\n```\n\n在这里我们发现将Json解析成Model的过程中可能会出现精度丢失。\n\n### 问题分析\n\n因为浮点数在计算机中是采用IEEE规定的标准浮点格式，即二进制科学表示法。\n在这种表示法中，一个数 `S = M * 2 ^ N`。\n\n其中N表示阶码，M表示位数(有效数字位)。\n例如一个float类型的浮点，在32bit位上，占4个字节，字节表示为\n\n\t【31】N:【30 ~ 23】 M:【22~0】\n\n* 31位表示符号位: 0正，1负\n* 中间8位是阶码位: 表示范围【-128 ~ 127】,对于float类型数据规定其偏移量为127\n* 后面23位是有效数字位: 因为科学计数法，整数位定死了是1，所以这里记录的是小数点后面的二进制为\n\n指数N决定它的范围，因为M总是一个以1开头的小数，以float来说即是：-2 ^ 128 ~ 2 ^ 128,即float能表示的数的大小的范围。\n\n而它的精度是由位数(也就是有效的数据位)来决定的， 2 ^ 23 = 8388608，总共7位，表示最多能用7位有效数字，最多能表示到.8388708即小数点后7位，由于不能完全表示全部的7位数，所以它的精度范围是6位~7位。\n\n同理可得double的精度是2 ^ 52 = 4503599627370496， 共16位，所以精度为15 ~ 16位。\n\n#### 总结：float/double类型的范围和精度的计算方式\n\n\t不同机器字节序的规定\n\t公式： S = M * 2 ^ N\n\t二进制在内存中是以补码形式存储，负数要对其二进制绝对值按位取反再加一，正数的补码与原码形式相同\n\t\n也就是说float和doublel类型数据在计算机中存储可能是不精确的。\n当我们需要转换成浮点类型是数据时，最好用double，因为double的精度更高，出现丢精度的概率相对是较小的。\n\n在iOS中提供一个专用的类来处理浮点数据相关的运算：`NSDecimalNumber`\n\n### 解决方案\n\n使用`NSDecimalNumber`来进行浮点数处理。\n我们给NSString添加一个分类来处理浮点运算问题\n\n```objc\n///.h\n@interface NSString (DecimalNumber)\n\n+ (NSString *)decimalNumberWithNSNumber:(NSNumber * )number;\n+ (NSString *)decimalNumberWithDouble:(double)conversionValue;\n\n@end\n\n///.m\n#import \"NSString+DecimalNumber.h\"\n\n@implementation NSString (DecimalNumber)\n\n+ (NSString *)decimalNumberWithNSNumber:(NSNumber * )number\n{\n    double conversionValue = [number doubleValue];\n    NSString *doubleString        = [NSString stringWithFormat:@\"%lf\", conversionValue];\n    NSDecimalNumber *decNumber    = [NSDecimalNumber decimalNumberWithString:doubleString];\n    return [decNumber stringValue];\n}\n\n+ (NSString *)decimalNumberWithDouble:(double)conversionValue\n{\n    NSString *doubleString        = [NSString stringWithFormat:@\"%lf\", conversionValue];\n    NSDecimalNumber *decNumber    = [NSDecimalNumber decimalNumberWithString:doubleString];\n    return [decNumber stringValue];\n}\n\n@end\n```\n\n### 如何使用\n\n```objc\n    NSArray *numbers = @[\n                         @99.00,\n                         @99.09,\n                         @99.19,\n                         @99.29,\n                         @99.39,\n                         @99.49,\n                         @99.59,\n                         @99.69,\n                         @99.79,\n                         @99.89,\n                         @99.99,\n                         ];\n    \n    for (int i = 0; i < numbers.count; i++) {\n        NSNumber *number = numbers[i];\n        NSString *strValue = [NSString decimalNumberWithNSNumber:number];\n        \n        NSLog(@\"strValue:%@\",strValue);\n    }\n    \n    /*\n     oldVlue:99.00 strValue:99\n     oldVlue:99.09 strValue:99.09\n     oldVlue:99.19 strValue:99.19\n     oldVlue:99.29 strValue:99.29\n     oldVlue:99.39 strValue:99.39\n     oldVlue:99.48 strValue:99.49\n     oldVlue:99.59 strValue:99.59\n     oldVlue:99.69 strValue:99.69\n     oldVlue:99.79 strValue:99.79\n     oldVlue:99.89 strValue:99.89\n     oldVlue:99.99 strValue:99.99\n     */\n```\n\n问题得以解决。☕️\n\n参考资料：\n\n* https://developer.apple.com/documentation/foundation/nsdecimalnumber\n* http://www.jianshu.com/p/4703d704c953\n* https://eezytutorials.com/ios/nsdecimalnumber-by-example.php\n* http://www.skyfox.org/ios-nsdecimalnumber-use.html\n* https://stackoverflow.com/questions/421463/should-i-use-nsdecimalnumber-to-deal-with-money\n","tags":["精度"],"categories":["最佳实践"]},{"title":"NSSortDescriptor 正确的打开方式","url":"/2017/06/07/2017-06-07-nssortdescriptorzheng-que-de-da-kai-fang-shi/","content":"\n\n排序是应用常见需求之一，如何正确优雅的实现一个排序，`NSSortDescriptor`或许是一个非常好的选择。\n\n`NSSortDescriptor`由3个参数组成：\n\n* **key**(键):对于一个给定的集合，将对集合种的每个对象按照该键来进行排序\n* **ascending**(升序):指定集合按照升序(YES)还是降序(NO)进行排序\n* **selector**(方法子):排序时的比较函数，当对字符串进行排序时，应当加入`localizedStandardCompare:`选择器，它将根据语言规则进行排序(例如大小写，变音符号等等的顺序)\n\n<!-- more -->\n\n\n### 如何使用\n\n`NSSortDescriptor`主要针对各种集合排序,`NSArray`,`NSMutableArray`,`NSSet`,`NSOrderedSet`,`NSMutableOrderedSet`\n\n如果集合是可变的，则对集合本身排序例如\n\n* `NSMutableOrderedSet`的`sortUsingDescriptors:`\n* `NSMutableArray`的`sortUsingDescriptors:`\n\n如果集合是可变的，则返回一个排好序的新集合例如\n\n* `NSArray`的`sortedArrayUsingDescriptors:`\n* `NSSet`的`sortedArrayUsingDescriptors:`\n* `NSOrderedSet`的`sortedArrayUsingDescriptors:`\n\n注意排序描述是一个数组，也就是排序可以支持按照多个描述综合排序。如果存在多个规则先满足前面的规则再满足后面的规则。例如两个元素按照第一天规则顺序一致，那么如果还存在第二天规则，它们将按照第二条规则继续排序，如果前面的规则已经区分出顺序后面的规则将失效。\n\n### 实例说明\n\n为了更好的描述，假如我们有一个`Person`对象，它有**NSString * **类型的姓和名属性，以及一个`NSNumber`类型的年龄属性。\n\n```objc\n@interface Person : NSObject\n\n@property (nonatomic, copy  ) NSString *firstName;\n@property (nonatomic, copy  ) NSString *lastName;\n@property (nonatomic, strong) NSNumber *age;\n\n@end\n```\n\n给定以下数据集：\n\n| index        | 0     | 1    |   2    |    3   |   4    |\n| ------------ |:-----:| -----| ------ | -------| ------ |\n| firstName    | Alice | Bod  | Charlie| Quentin|        |\n| lastName     | Smith | Jones| Smith  |        | Alberts|\n| age          | 24    |    27| 33     | 31     | 19     |\n\n\n使用不同的`NSSortDescriptor`的不同组合来将它们排序：\n\n```objc\nNSArray *firstNames = @[@\"Alice\", @\"Bod\", @\"Charlie\", @\"Quentin\", @\"\"];\nNSArray *lastNames = @[@\"Smith\", @\"Jones\", @\"Smith\", @\"\", @\"Alberts\"];\nNSArray *ages = @[@24, @27, @33, @31, @12];\n\nNSMutableArray *people = [NSMutableArray array];\n[firstNames enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n    Person *person = [[Person alloc] init];\n    person.firstName = [firstNames objectAtIndex:idx];\n    person.lastName = [lastNames objectAtIndex:idx];\n    person.age = [ages objectAtIndex:idx];\n    \n    [people addObject:person];\n}];\n\nNSSortDescriptor *firstNameSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@\"firstName\" ascending:YES selector:@selector(localizedStandardCompare:)];\nNSSortDescriptor *lastNameSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@\"lastName\" ascending:YES selector:@selector(localizedStandardCompare:)];\nNSSortDescriptor *ageSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@\"age\" ascending:NO];\n\nNSLog(@\"By age: %@\",[people sortedArrayUsingDescriptors:@[ageSortDescriptor]]);\n/*\n 2017-06-06 23:15:02.101 NSSort​Descriptor_Demo[9103:1255482] By age: (\n \"Charlie Smith 33\",\n \"Quentin  31\",\n \"Bod Jones 27\",\n \"Alice Smith 24\",\n \" Alberts 12\"\n )\n */\n\nNSLog(@\"By first name: %@\",[people sortedArrayUsingDescriptors:@[firstNameSortDescriptor]]);\n/*\n 2017-06-06 23:15:02.102 NSSort​Descriptor_Demo[9103:1255482] By first name: (\n \" Alberts 12\",\n \"Alice Smith 24\",\n \"Bod Jones 27\",\n \"Charlie Smith 33\",\n \"Quentin  31\"\n )\n*/\n \nNSLog(@\"By last name, first name: %@\",[people sortedArrayUsingDescriptors:@[lastNameSortDescriptor ,firstNameSortDescriptor]]);\n/*\n 2017-06-06 23:15:02.102 NSSort​Descriptor_Demo[9103:1255482] By last name, first name: (\n \"Quentin  31\",\n \" Alberts 12\",\n \"Bod Jones 27\",\n \"Alice Smith 24\",\n \"Charlie Smith 33\"\n )\n */\n \n```\n\n### 注意事项\n\n* 空字符是排在普通字符之前的\n* 基本数据类型需要包装成`NSNumber`对象来排序\n* 字符串类型排序需要加入`localizedStandardCompare:`选择器\n\n\n参考链接\n\n* [NSSort​Descriptor -- NSHipster](http://nshipster.cn/nssortdescriptor/)\n","tags":["排序"],"categories":["系统 API"]},{"title":"从 OC 到 Swift 你要知道的事","url":"/2017/03/10/2017-03-10-cong-ocdao-swiftni-yao-zhi-dao-de-shi/","content":"\n\n# 枚举\n\n## 概述\n\nSwift中枚举和结构体也上升到对象的位置，但是却不具备完整的对象特征，比如说他们不能继承。\n\n在OC中枚举本质其实是整数类型，只是给他们取了一些意义直观的名称而已，而Swift完全摆脱以前的思想的束缚编的更自由，拥有了以下特征。\n\n* 类型更广，不限于整形，可以是`Character`，`String`，`Float`，`Double`等，这些叫做原始值\n* 可以拥有自己的静态成员变量来储存一些常量\n* 可以拥有自己的方法和变量\n* `case`条件匹配可以定义参数，可以使用`where`来过滤\n* 通过`rawValue`可以拿到枚举的原始值\n\n<!-- more -->\n\n\n##  原始值\n\n如果提供了原始值，就可以在case声明成员时提供默认值，这样跟OC的枚举在结构上一些类似\n\n```objc\nenum WeekDays : Int {\n    case Monday    = 0\n    case Tuesday   = 1\n    case Wednesday = 2\n    case Thursday  = 3\n    case Friday    = 4\n}\n```\n\n1.声明一个枚举值\n\n```swift\nlet monday = WeekDays.Monday\n```\n\n2.获取原始值\n\n```swift\nlet rawVlaue = WeekDays.Tuesday.rawValue\n```\n\n3.通过原始值构造某个枚举变量\n\n```swift\nlet wednesday = WeekDays.init(rawValue: 2)\n```\n\n##  相关值\n\n和C的联合体有点类似\n\n1.声明\n\n```objc\nenum Figure {\n    case Rectangle(Int, Int)\n    case Circle(Int)\n}\n```\n\n2.使用\n\n```swift\nfunc printFigure(figure: Figure) {\n    switch figure {\n    case .Rectangle(let width, let height):\n        print(\"width:\\(width), height:\\(height)\")\n    case .Circle(let radius):\n        print(\"the circle's radius is:\\(radius)\")\n    }\n}\n\n\nvar figure = Figure.Rectangle(1024, 768)\nprintFigure(figure)\n\nfigure = .Circle(600)\nprintFigure(figure)\n```\n\n# OC与Swift中Options枚举的不同定义\n\n## OC版本NS_OPTIONS\n\n```objc\ntypedef NS_OPTIONS(NSUInteger, NSVolumeEnumerationOptions) {\n    /* The mounted volume enumeration will skip hidden volumes.\n     */\n    NSVolumeEnumerationSkipHiddenVolumes = 1UL << 1,\n    \n    /* The mounted volume enumeration will produce file reference URLs rather than path-based URLs.\n     */\n    NSVolumeEnumerationProduceFileReferenceURLs = 1UL << 2\n}\n```\n## Swift版本OPTIONS\n\n```swift\nstruct NSVolumeEnumerationOptions : OptionSetType {\n    init(rawValue rawValue: UInt)\n    static var SkipHiddenVolumes: NSVolumeEnumerationOptions { get }\n    static var ProduceFileReferenceURLs: NSVolumeEnumerationOptions { get }\n}\n```\n**使用**\n\n```swift\nUIView.animateWithDuration(0.3,\n                           delay: 0.0,\n                           options: [.CurveEaseIn, .AllowUserInteraction],\n                           animations: {},\n                           completion: nil)\n```\n\n## 结构体\n\nSwift中加强了结构体的能力，可以定义和使用属性，方法，下标，构造器等，但是不能被继承，没有强制类型抓换，使用析构器和引用计数等能力\n\n通常使用结构体来充当数据模型，常量可以使用静态关键词`static`标示\n\n# 循环引用\n\n## Swift中解决循环强引用的方式\n\n* 弱引用 -- `weak`\n* 无主引用 -- `unowned`\n\n## 解决闭包中循环引用\n\n[unowned 捕获对象]或者\n[weak 捕获对象]\n\n\n使用实例\n\n```objc\n\tclass Person {\n\t    let name: String\n\t    \n\t    // 写法1\n\t//    lazy var printName: () ->() = {\n\t//        [weak self] in if let strongSelf = self {\n\t//            print(\"The name is \\(strongSelf.name)\")\n\t//        }\n\t//    }\n\t    \n\t    // 写法2\n\t    lazy var printName: () ->() = {\n\t        [unowned self] in print(\"The name is \\(self.name)\")\n\t    }\n\t    \n\t    init(personName: String) {\n\t        name = personName\n\t    }\n\t    \n\t    deinit {\n\t        print(\"Person deinit \\(self.name)\")\n\t    }\n\t}\n\t\n\tvar xiaoMing: Person? = Person(personName: \"xiaoMing\")\n\txiaoMing!.printName\n\txiaoMing = nil\n```\n\n**二者的区别**\n\n如果我们可以确定在整个过程中 self 不会被释放的话，我们可以将上面的 weak 改为 unowned，这样就不再需要 strongSelf 的判断。但是如果在过程中 self 被释放了而 printName 这个闭包没有被释放的话 (比如 生成 Person 后，某个外部变量持有了 printName，随后这个 Persone 对象被释放了，但是 printName 已然存在并可能被调用)，使用 unowned 将造成崩溃。在这里我们需要根据实际的需求来决定是使用 weak 还是 unowned。\n\n\n# OC和Swift中常用数据类型\n\n## 字符串\n\n* OC： NSString， NSMutableString\n* Swift： String\n\nNSString和String的关系：在Swift中，使用字符串可以使用Foundatio中的NSString和Swift中的String。\n\nSwift在底层能够将String与NSString无缝地桥接起来，String可以调用NSString的全部API。\n\n## 数组类\n\n* OC： NSArray, NSMutableArray\n* Swift： Array [AnyObject]\n\nNSArray和Array的关系：Swift能在底层将他们自动桥接起来，一个NSArray对象桥接后的结果是[AnyObject]。\n\n## 字典\n\n* OC： NSDictionary， NSMutableDictionary\n* Swift： Dictionary [Object: AnyObject]\n\nNSDictionary和Dictionary的关系： 底层自动桥接，一个NSDictionary对象桥接后的结果是[Object: AnyObject]。\n\n# 类型转换\n\n类的转换使用 `as`\n数据类型加括号 `Int()`\n\nOC使用 `（新的类型）原来的变量`\n# 类型判断\n\n`is`关键词\n\n相当于OC的`isKindofClass:`\n\n# 辅助命令\n\n* \\#file --> \\__FILE__\n* \\#line --> \\__LINE__\n* \\#function --> \\__func__  或者 \\__FUNCTION__\n\n# 退出程序\n* C: exit（0）\n* Swift: fatalError() 或者 fatalError(message: String)\n\n# 断言\n\n* OC: `NSAssert`\n* Swift: `assert()`\n","tags":["Swift"],"categories":["系统 API"]},{"title":"Layer Animations Tips","url":"/2017/03/10/2017-03-10-layer-animations-tips/","content":"\n### beginTime的妙用\n创建一个动画，添加到不同的图层上，可以实现复用，通过调节`beginTime`可以调节动画开始执行的时间。\n\n例如，我们创建一个水平位移动画，添加到不同的图层对象上，并且让他们轮流执行。\n\n<!-- more -->\n\n\n```swift\nlet flyRight = CABasicAnimation(keyPath: \"position.x\")\nflyRight.fromValue = 0\nflyRight.toValue = 100\nflyRight.duration = 0.5\nflyRight.fillMode = kCAFillModeBoth\n\nfirstView.layer.addAnimation(flyRight, forKey: nil)\n\n// make secondView perform animation on delay 0.3 seconds.\nflyRight.beginTime = CACurrentMediaTime() + 0.3\nsecondView.layer.addAnimation(flyRight, forKey: nil)\nsecondView.layer.position.x = 100\n\n// make thirdView perform animation on delay 0.4 seconds.\nflyRight.beginTime = CACurrentMediaTime() + 0.4\nthirdView.layer.addAnimation(flyRight, forKey: nil)\nthirdView.layer.position.x = 100\n```\n\n动画的`beginTime`属性可以设置将要执行的动画的绝对开始时间，通过`CACurrentMediaTime()`函数获取当前时间再加上你想要延迟执行的时间的，单位秒。\n\n\n### 动画代理\n\n动画代理可以监听动画的进行状态，在动画开始和结束的时候回通知代理.\n也就是会调用以下两个函数：\n\n```swift\nfunc animationDidStart(anim: CAAnimation)\nfunc animationDidStop(anim: CAAnimation, finished flag: Bool)\n```\n\n### CAAnimation\n\n`CAAnimation`和它的子类遵循KVO，也就意味着你可以把它们当成字典一样使用来添加新的接口在运行时。\n\n例如你可以使用这种机制来给某个动画指定一个名字，以便你能够把它和其它动画区分开。\n\n```swift\nflyRight.setValue(\"somename\", forKey: \"name\")\n```\n\n### CASpringAnimation\n\n|Property        | Default Value|\n|----------------|--------------|\n|damping         |10.0          |\n|mass            |1.0           |\n|stiffness       |100.0         |\n|initialVelocity |0.0           |\n\n参数说明：\n\n* `damping` - 应用给系统的阻尼\n* `mass` - 在系统中重物的质量\n* `stiffness` - 附加在重物上的弹簧的硬度\n* `initialVelocity` - 附加在重物上的初始速度\n\n\n使用实例：\n\n```swift\nlet jump = CASpringAnimation(keyPath: \"position.y\")\njump.initialVelocity = 100.0\njump.mass = 10.0\njump.stiffness = 1500.0\njump.damping = 50.0\n\njump.fromValue = textField.layer.position.y + 1.0\njump.toValue = textField.layer.position.y\njump.duration = jump.settlingDuration\ntextField.layer.addAnimation(jump, forKey: nil)\n```\n\n备注：\n此动画的`duration`参数可以通过前面几个参数自动计算得出\n\n\tjump.duration = jump.settlingDuration\n\n### 使用CAGradientLayer的locations实现滑动解锁\n\n对`CAGradientLayer`的`locations`属性做动画轻松的实现iPhone自带的滑动解锁效果\n\n a.创建一个渐变图层\n\n```swift\nlet gradientLayer: CAGradientLayer = {\n    let gradientLayer = CAGradientLayer()\n    \n    // Configure the gradient here\n    \n    gradientLayer.startPoint = CGPoint(x: 0.0, y: 0.5)\n    gradientLayer.endPoint = CGPoint(x: 1.0, y: 0.5)\n    \n    let colors = [\n        UIColor.blackColor().CGColor,\n        UIColor.whiteColor().CGColor,\n        UIColor.blackColor().CGColor\n    ]\n    gradientLayer.colors = colors\n    \n    let locations = [\n        0.25,\n        0.5,\n        0.75\n    ]\n    gradientLayer.locations = locations\n    \n    return gradientLayer\n}()\n```\n\n\nb.创建一个文本样式字典\n\n```swift\nlet textAttributes : [String: AnyObject] = {\n    let style = NSMutableParagraphStyle()\n    style.alignment = .Center\n    \n    return [\n        NSFontAttributeName:UIFont(name: \"HelveticaNeue-Thin\", size: 28.0)!,\n        NSParagraphStyleAttributeName:style\n    ]\n}()\n```\n\nc.当设置文本时绘制内容，添加`@IBInspectable`方便看实时效果\n\n```swift\n@IBInspectable var text: String! {\ndidSet {\n    setNeedsDisplay()\n    \n    UIGraphicsBeginImageContextWithOptions(frame.size, false, 0)\n    text.drawInRect(bounds, withAttributes: textAttributes)\n    let image = UIGraphicsGetImageFromCurrentImageContext()\n    UIGraphicsEndImageContext()\n    \n    let maskLayer = CALayer()\n    maskLayer.backgroundColor = UIColor.clearColor().CGColor\n    maskLayer.frame = CGRectOffset(bounds, bounds.size.width, 0)\n    maskLayer.contents = image.CGImage\n    \n    gradientLayer.mask = maskLayer\n    }\n}\n```\n\nd.重新布局`gradientLayer`\n\n```swift\noverride func layoutSubviews() {\n    gradientLayer.frame = CGRect(\n        x: -bounds.size.width,\n        y: bounds.origin.y,\n        width: 3 * bounds.size.width,\n        height: bounds.size.height)\n}\n```\n\ne.添加到window时向渐变层添加动画\n\n```swift\noverride func didMoveToWindow() {\n    super.didMoveToWindow()\n    \n    layer.addSublayer(gradientLayer)\n    \n    let gradientAnimation = CABasicAnimation(keyPath: \"locations\")\n    gradientAnimation.fromValue = [0.0, 0.0, 0.25]\n    gradientAnimation.toValue = [0.75, 1.0, 1.0]\n    gradientAnimation.duration = 3.0\n    gradientAnimation.repeatCount = Float.infinity\n    \n    gradientLayer.addAnimation(gradientAnimation, forKey: nil)\n}\n```\n","tags":["CALayer"],"categories":["动画"]},{"title":"VFL 深入浅出","url":"/2017/03/02/2017-03-02-vflshen-ru-qian-chu/","content":"\n\n### 使用场景\n\n给视图对象快速创建约束，可以使用比较冷门的VFL(Visual Format Language),本质是是基于自动布局(AutoLayout)。\n\n<!-- more -->\n\n\n### 解决的问题\n\n以一种直观的方式，为视图创建约束\n\n### 怎样解决\n\n核心方法：\n\n```objc\n+ (NSArray<__kindof NSLayoutConstraint *> *)constraintsWithVisualFormat:(NSString *)format\n                                                                options:(NSLayoutFormatOptions)opts\n                                                                metrics:(nullable NSDictionary<NSString *,id> *)metrics\n                                                                  views:(NSDictionary<NSString *, id> *)views;\n```\n\nExample:\n\n```objc\n[NSLayoutConstraint constraintsWithVisualFormat:@\"|-[button1]-[button2]-[textField(>=20)]-|\"\n                                        options:0\n                                        metrics:metrics\n                                          views:views]\n```\n\n参数：\n\n* format:指定约束的格式。更多信息，在[Auto Layout Guide](file:///Users/wangruofeng/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853)查看[Visual Format Language](file:///Users/wangruofeng/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH3)。\n* opts:描述在视觉格式化字符串中的布局属性和方向\n* metrics:将出现在视觉格式化字符串的常量字典。字典的Keys必须是在出现在视觉格式化字符串的字符串类型，对应的values必须是NSNumber对象。\n* views:出现的视觉格式化字符串的字典view，所有的Keys必须是使用在视觉格式化字符串的字符串类型，对应的values必须是view对象。\n\n返回值：\n\n一个约束组合的数组，像视觉格式化字符串描述的一样表述了在提供的视图和它们的父视图之间的关系。所有的约束以在视觉格式化字符串被指定的约束顺序一致。\n\n\n### 效率和可维护性\n\n需要对VFL理解比较全面和深入，有一定的学习成本，维护起来比较困难，但是如果理解的比较深刻，对于简单的布局效率非常高，比直接创建约束要直观。\n\n\n### 最佳实践\n\n* 每条约束格式字符串分水平(`H`，可省略)和垂直方向(`V`)。\n* `|` 代表父视图。\n* `-` 代表标准间距，两个子视图直接的值是8，与父视图之间的值是16。\n* `[view]` 每个视图必须用[]包裹起来，否则语法错误。\n* `[view(>=44)]` 可以为每个视图设置一些属性或者关系，写一个紧跟view后的括号集合，支持宽高，优先级，和其它视图之间的关系。\n* `[view@20]` 可以设置视图的约束的优先级，以@开头，取值范围(0 1000]。\n* `[view1]-20-[view2]` 可以指定view之间的水平或者垂直间距，写在一对 `-` 即可。\n* `[view1][view2]` 如果 `-` 省略则他们之间的距离为0。\n* `[flexibleButton(>=70,<=100)]` 多个条件之间用`,`连接并且之间不能有空格。\n\n### 其它方案\n\n1. 使用`NSLayoutConstraint`的类方法创建(iOS96.0及以上可用)\n\n```objc\n+ (instancetype)constraintWithItem:(id)view1\n                        attribute:(NSLayoutAttribute)attr1\n                        relatedBy:(NSLayoutRelation)relation\n                           toItem:(nullable id)view2\n                        attribute:(NSLayoutAttribute)attr2\n                       multiplier:(CGFloat)multiplier\n                         constant:(CGFloat)c;\n```\n2. 使用`NSLayoutAnchor`的工厂方法创建(iOS9.0及以上可用)\n\n```objc\n- (NSLayoutConstraint *)constraintEqualToAnchor:(NSLayoutAnchor<AnchorType> *)anchor;\n- (NSLayoutConstraint *)constraintGreaterThanOrEqualToAnchor:(NSLayoutAnchor<AnchorType> *)anchor;\n- (NSLayoutConstraint *)constraintLessThanOrEqualToAnchor:(NSLayoutAnchor<AnchorType> *)anchor;\n\n- (NSLayoutConstraint *)constraintEqualToAnchor:(NSLayoutAnchor<AnchorType> *)anchor constant:(CGFloat)c;\n- (NSLayoutConstraint *)constraintGreaterThanOrEqualToAnchor:(NSLayoutAnchor<AnchorType> *)anchor constant:(CGFloat)c;\n- (NSLayoutConstraint *)constraintLessThanOrEqualToAnchor:(NSLayoutAnchor<AnchorType> *)anchor constant:(CGFloat)c;\n```\n\n### 使用注意事项\n\n* 使用时，必须把view的`translatesAutoresizingMaskIntoConstraints`属性设置为`NO`，否则约束可能更预期不一致。这是一个历史遗留的问题，由于在`AutoLayout`诞生以前一直使用`Autoresizing`来控制布局.\n\n* 重写`updateConstraints()`方法，在里面计算约束，然后调用`setNeedsUpdateConstraints()`触发更新约束。\n\n* 系统计算布局顺序: \n\t* updateConstraints()\n\t* layoutSubviews()\n\t* drawRect(_:)\n\n系统计算布局顺序参考\n\n![LayoutCycle](https://koenig-media.raywenderlich.com/uploads/2016/05/LayoutCycle-1.png)\n\n具体使用示例，查看下面的Demo，样品工程\n\n----\nDemo地址：[VFLDemo](https://github.com/wangruofeng/VFLDemo)\n\n参考链接\n\n* [coding-auto-layout](https://www.raywenderlich.com/125718/coding-auto-layout)\n* [Visual Format Language](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1)\n","tags":["VFL"],"categories":["系统 API"]},{"title":"UIActivity​View​Controller 详解","url":"/2017/02/23/2017-02-23-uiactivityviewcontroller-xiang-jie/","content":"\n\n> 翻译自NSHipster的[UIActivity​View​Controller](http://nshipster.com/uiactivityviewcontroller/)\n\n<!-- more -->\n\n一直非常好奇代码和数据之间的联系。\n\n某些编程语言，例如[Lisp](http://en.wikipedia.org/wiki/Lisp_programming_language)，[Io](http://en.wikipedia.org/wiki/Io_%28programming_language%29)和[Mathematica](http://en.wikipedia.org/wiki/Mathematica)他们是[同型性](http://en.wikipedia.org/wiki/Homoiconicity)(代码即数据)，那就意味着它们的代码是原始数据的呈现形式，它们本身在代码中也能够被维护。然而大多数其它语言，包括Objective-C，然而，在这两者之间有严格的边界，避免eval()和其它有动态引导加载的潜在危险方法。\n\n当数据出现太大和呈现一些东西过于笨重除了使用二进制流的问题时代码和数据之间的不安被推向到了一个全新的高度。自从第一个操作系统出现开始，怎样编码，解码，解释二进制代表的图片，文档，和媒体一直是一个问题。\n\n在OS X上的核心服务框架和iOS上提供标识功能和通过文件拓展和[MIMIE type](http://en.wikipedia.org/wiki/Internet_media_type)--根据[通用数据标示](http://en.wikipedia.org/wiki/Uniform_Type_Identifier)，给数据类型的分类核心服务框架。UTIs提供了一种可拓展，阶梯分层系统，这给开发者在处理大量不同的文件类型提供了巨大的灵活性。例如，一个Ruby的源文件(.rb)被归类为：Ruby Source Code > Source Code > Text > Content > Data；一个QuickTime电影文件(.mov)被归类为 Video > Movie > Audiovisual Content > Content > Data。\n\nUTIs表现得非常好在桌面的抽象文件系统中。然而，在一个移动范例中这就崩溃得很快，因为文件和目录是对用户隐藏的。还有，随着云服务和社交媒体扮演着越来越重要的角色在远程实体通过本地文件。因此，UTIs和URLs之间很紧张。\n\n我们非常清楚我们需要一些别的东西。`UIActivityViewController`能否成为我们正在急切寻找的解决方案呢?\n\n----\n\n`UIActivityViewController`，在iOS6中被引入，提供了一套分享和在应用内执行数据操作的统一服务界面。\n\n考虑到可操作的数据集合，一个`UIActivityViewController`实例通过如下方式创建：\n\n```objc\nNSString *string = ...;\nNSURL *URL = ...;\n\nUIActivityViewController *activityViewController = [[UIActivityViewController alloc] initWithActivityItems:@[string, URL]\n                                    applicationActivities:nil];\n[navigationController presentViewController:activityViewController\n                                   animated:YES\n                                 completion:^{\n  // ...\n}];\n```\n\n这将在屏幕底部呈现如下界面：\n\n![activity sharing img](http://nshipster.s3.amazonaws.com/uiactivityviewcontroller.png)\n\n默认情况下，`UIActivityViewController`将会显示所有支持的可用服务类型，但是某些活动类型也可以排除：\n\n```objc\nactivityViewController.excludedActivityTypes = @[UIActivityTypePostToFacebook];\n```\n\n活动类型被划分“动作”(action)和“分享”(share)类型：\n\n### UIActivityCategoryAction\n\n* UIActivityTypePrint\n* UIActivityTypeCopyToPasteboard\n* UIActivityTypeAssignToContact\n* UIActivityTypeSaveToCameraRoll\n* UIActivityTypeAddToReadingList\n* UIActivityTypeAirDrop\n\n### UIActivityCategoryShare\n\n* UIActivityTypeMessage\n* UIActivityTypeMail\n* UIActivityTypePostToFacebook\n* UIActivityTypePostToTwitter\n* UIActivityTypePostToFlickr\n* UIActivityTypePostToVimeo\n* UIActivityTypePostToTencentWeibo\n* UIActivityTypePostToWeibo\n\n每种活动类型，支持一系列不同的数据类型。例如，一个`Tweet`可能由一个`NSString`并附带一个`image`和或者`URL`。\n\n\n不同活动类型支持的数据类型\n\n| Activity Type         | String        | Attributed String | URL  | Data | Image | Asset | Other |\n| --------------------- |:-------------:| ----------------- | ---- | ---- | ----  | ----- | ----- |\n| Post To Facebook      | ✓             | ✓                 |✓     |      |✓      |       |       |\n| Post To Twitter       | ✓             | ✓                 |✓     |      |✓      |       |       |\n| Post To Weibo         | ✓             | ✓                 |✓     |      |✓      |✓      |       |\n| Message               | ✓             | ✓                 |✓*    |✓*    |       |✓      | sms:// NSURL|\n| Mail                  | ✓+            | ✓+                |✓+    |      |       |       |       |\n| Print                 |               |                   |      |✓+    |✓+     |       |UIPrintPageRenderer, UIPrintFormatter, & UIPrintInfo|\n| Copy To Pasteboard    | ✓             |                   |✓     |      |✓      |       |UIColor, NSDictionary |\n| Assign To Contact     |               |                   |      |      |✓      |       |       |\n| Save To Camera Roll   |               |                   |✓     |      |✓      |       |       |\n| Add To Reading List   |               |                   |✓     |      |       |       |       |\n| Post To Flickr        |               |                   |✓     |✓     |✓      |✓      |       |\n| Post To Vimeo         | ✓             | ✓                 |✓     |✓     |       |✓      |       |\n| Post To Tencent Weibo | ✓             | ✓                 |✓     |      |✓      |✓      |       |\n| AirDrop               | ✓             | ✓                 |✓     |      |✓      |✓      |       |\n\n\n### UIActivityItemSource & UIActivityItemProvider\n\n当必要时和一个粘贴板项目能用来提供的数据类似，为了避免过度的内测开销或处理时间，活动类型可以是一种自定义类型。\n\n任何遵循`<UIActivityItemSource>`协议的对象，包括内构`UIActivityItemProvider`类，可以用来动态提供不同类型的数据根据活动的类型。\n\n#### UIActivityItemSource\n\n获取数据项目：\n\n* activityViewControllerPlaceholderItem:\n* activityViewController:itemForActivityType:\n\n提供数据项目信息：\n\n* activityViewController:subjectForActivityType:\n* activityViewController:dataTypeIdentifierForActivityType:\n* activityViewController:thumbnailImageForActivityType:suggestedSize:\n\n\n下面是一个例子，根据是否分享到FaceBook或者Twitter来展示自定义一条消息是怎样使用的:\n\n```objc\n- (id)activityViewController:(UIActivityViewController *)activityViewController\n         itemForActivityType:(NSString *)activityType\n{\n    if ([activityType isEqualToString:UIActivityTypePostToFacebook]) {\n        return NSLocalizedString(@\"Like this!\");\n    } else if ([activityType isEqualToString:UIActivityTypePostToTwitter]) {\n        return NSLocalizedString(@\"Retweet this!\");\n    } else {\n        return nil;\n    }\n}\n```\n\n### 创建一个自定义UIActivity\n\n除了上述的系统提供的活动，你也可以创建你自己的活动。\n\n例如，让我们创建一个自定义活动类型，它能使一个URL中的图片添加上胡须通过使用[mustache.me](http://mustache.me/)。\n\nBefore:\n\n![Before](http://nshipster.s3.amazonaws.com/jony-ive-unstache.png)\n\nAfter:\n\n![After](http://nshipster.s3.amazonaws.com/jony-ive-mustache.png)\n\n首先，我们定义一个[反向域名解析的标识符](http://en.wikipedia.org/wiki/Reverse_domain_name_notation)给活动类型：\n\n```objc\nstatic NSString * const HIPMustachifyActivityType = @\"com.nshipster.activity.Mustachify\";\n```\n\n然后指定它的分类为`UIActivityCategoryAction`并且提供一个本地化标题和iOS版本相应的图片：\n\n```objc\n#pragma mark - UIActivity\n\n+ (UIActivityCategory)activityCategory {\n    return UIActivityCategoryAction;\n}\n\n- (NSString *)activityType {\n    return HIPMustachifyActivityType;\n}\n\n- (NSString *)activityTitle {\n    return NSLocalizedString(@\"Mustachify\", nil);\n}\n\n- (UIImage *)activityImage {\n    if (NSFoundationVersionNumber > NSFoundationVersionNumber_iOS_6_1) {\n        return [UIImage imageNamed:@\"MustachifyUIActivity7\"];\n    } else {\n        return [UIImage imageNamed:@\"MustachifyUIActivity\"];\n    }\n}\n```\n\n下一步，我们创建一个辅助函数，`HIPMatchingURLsInActivityItems`，通过它返回一个支持类型的图片URL的数组。\n\n```objc\nstatic NSArray * HIPMatchingURLsInActivityItems(NSArray *activityItems) {\n    return [activityItems filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:\n    ^BOOL(id item, __unused NSDictionary *bindings) {\n        if ([item isKindOfClass:[NSURL class]] &&\n            ![(NSURL *)item isFileURL]) {\n            return [[(NSURL *)item pathExtension] caseInsensitiveCompare:@\"jpg\"] == NSOrderedSame ||\n            [[(NSURL *)item pathExtension] caseInsensitiveCompare:@\"png\"] == NSOrderedSame;\n        }\n\n        return NO;\n    }]];\n}\n```\n\n这个函数让后被用在`-canPerformWithActivityItems:`和`prepareWithActivityItems:`来获取小胡子的第一张PNG或JPEG图片的URL，假如有的话。\n\n```objc\n- (BOOL)canPerformWithActivityItems:(NSArray *)activityItems {\n    return [HIPMatchingURLsInActivityItems(activityItems) count] > 0;\n}\n\n- (void)prepareWithActivityItems:(NSArray *)activityItems {\n    static NSString * const HIPMustachifyMeURLFormatString = @\"http://mustachify.me/%d?src=%@\";\n\n    self.imageURL = [NSURL URLWithString:[NSString stringWithFormat:HIPMustachifyMeURLFormatString, self.mustacheType, [HIPMatchingURLsInActivityItems(activityItems) firstObject]]];\n}\n```\n\n我们的网站服务提供了各种胡须选项，它被定义在一个枚举中：\n\n```objc\ntypedef NS_ENUM(NSInteger, HIPMustacheType) {\n    HIPMustacheTypeEnglish,\n    HIPMustacheTypeHorseshoe,\n    HIPMustacheTypeImperial,\n    HIPMustacheTypeChevron,\n    HIPMustacheTypeNatural,\n    HIPMustacheTypeHandlebar,\n};\n```\n\n最终，我们提供了一个`UIViewController`来显示图片。在这个例子中，一个简单的`UIWebView`控制器就够用了。\n\n```objc\n@interface HIPMustachifyWebViewController : UIViewController <UIWebViewDelegate>\n@property (readonly, nonatomic, strong) UIWebView *webView;\n@end\n\n- (UIViewController *)activityViewController {\n    HIPMustachifyWebViewController *webViewController = [[HIPMustachifyWebViewController alloc] init];\n\n    NSURLRequest *request = [NSURLRequest requestWithURL:self.imageURL];\n    [webViewController.webView loadRequest:request];\n\n    return webViewController;\n}\n```\n\n为了使用我们加了新胡须的活动，我们简单把它传递到`UIActivityViewController`构造器中：\n\n```objc\nHIPMustachifyActivity *mustacheActivity = [[HIPMustachifyActivity alloc] init];\nUIActivityViewController *activityViewController =\n  [[UIActivityViewController alloc] initWithActivityItems:@[imageURL]\n                                    applicationActivities:@[mustacheActivity]];\n```\n\n### 手动执行动作\n\n现在是一个提醒的好时机，当`UIActivityViewController`允许用户执行他们选择的动作，分享也能通过手动执行，当场景出现时。\n\n所有为了完整性，下面是怎样手动执行这些动作示例：\n\n#### Open URL\n\n```objc\nNSURL *URL = [NSURL URLWithString:@\"http://nshipster.com\"];\n[[UIApplication sharedApplication] openURL:URL];\n```\n系统支持的URL协议包括：`mailto:`，` tel:`，`sms:`和`maps:`。\n\n#### 添加到Safari阅读列表\n\n```objc\n@import SafariServices;\n\nNSURL *URL = [NSURL URLWithString:@\"http://nshipster.com/uiactivityviewcontroller\"];\n[[SSReadingList defaultReadingList] addReadingListItemWithURL:URL\n                                                        title:@\"NSHipster\"\n                                                  previewText:@\"...\"\n                                                        error:nil];\n```\n\n#### 保存到相册\n\n```objc\nUIImage *image = ...;\nid completionTarget = self;\nSEL completionSelector = @selector(didWriteToSavedPhotosAlbum);\nvoid *contextInfo = NULL;\nUIImageWriteToSavedPhotosAlbum(image, completionTarget, completionSelector, contextInfo);\n```\n\n#### 发送 SMS\n\n```objc\n@import MessageUI;\n\nMFMessageComposeViewController *messageComposeViewController = [[MFMessageComposeViewController alloc] init];\nmessageComposeViewController.messageComposeDelegate = self;\nmessageComposeViewController.recipients = @[@\"mattt@nshipster•com\"];\nmessageComposeViewController.body = @\"Lorem ipsum dolor sit amet\";\n[navigationController presentViewController:messageComposeViewController animated:YES completion:^{\n    // ...\n}];\n```\n\n#### 发送 Email\n\n```objc\n@import MessageUI;\n\nMFMailComposeViewController *mailComposeViewController = [[MFMailComposeViewController alloc] init];\nmailComposeViewController.mailComposeDelegate = self;\n[mailComposeViewController setToRecipients:@[@\"mattt@nshipster•com\"]];\n[mailComposeViewController setSubject:@\"Hello\"];\n[mailComposeViewController setMessageBody:@\"Lorem ipsum dolor sit amet\" isHTML:NO];\n[navigationController presentViewController:mailComposeViewController animated:YES completion:^{\n    // ...\n}];\n```\n\n#### 发送 Tweet\n\n```objc\n@import Social;\n\nSLComposeViewController *tweetComposeViewController = [SLComposeViewController composeViewControllerForServiceType:SLServiceTypeTwitter];\n[tweetComposeViewController setInitialText:@\"Lorem ipsum dolor sit amet.\"];\n[self.navigationController presentViewController:tweetComposeViewController\n                                        animated:YES\n                                      completion:^{\n                                          // ...\n                                      }];\n```\n\n\n### IntentKit\n\n\n当所有的这些都是印象深刻和非常有用，它在iOS中的活动范例特别缺乏，当和在Android中的丰富的[Intents Model](http://developer.android.com/guide/components/intents-filters.html)相比。\n\n\n在Android中，apps能够注册不同的intents，来指示它们能够用在Maps，或者充当一个浏览器，能够被涉及到相关活动的默认app选中，比如指引方向，或者一个书签的URL。\n\n然而iOS缺乏来支持这些的可拓展的基础架构，有一个叫[IntentKit](https://github.com/intentkit/IntentKit)第三方库，作者[@lazerwalker](https://github.com/lazerwalker)(因[f*ingblocksyntax.com](http://goshdarnblocksyntax.com/)成名)，这是一个有趣的例子关于我们怎样缩小这方面的差距。\n\n\n![IntentKit demo](https://raw.github.com/intentkit/IntentKit/master/example.gif)\n\n通常，一个开发者可能已经做了很多第一步的工作，来决定是否某个app是否安装，然后怎样构造一个URL来支持某个特殊的活动。\n\nIntentKit加强了连结到大多数流行的Web，Maps,Mail,Twitter,Facebook,和Google+客户的的逻辑，以和`UIActivityViewController`相似的UI。\n\n任何寻找提升他们的分享体验到下一个级别的人都应该仔细看看这个。\n\n--\n\n在iOS长期生存能力作为一个平台取决于像`UIActivityViewController`类型的分享机制存上在很大的争论。正如俗语所言：“资讯应该免费”。任何阻碍方式统一的东西，最终都会失去一些没有的东西。\n\n将来的景象是公共的远程视图控制器APIs带给我希望，对于将来在iOS平台上的分享功能。然而现在我们做的和UIActivityViewController相比糟糕得多。\n","tags":["翻译","Loading"],"categories":["系统 API"]},{"title":"2016 个人年度总结","url":"/2017/01/09/2017-01-10-2016ge-ren-nian-du-zong-jie/","content":"\n### 前言\n\n2016对于我来说的意义，就像10年前的今天，`iPhone`之余乔布斯，`iPhone`发布后10年后的今天，小程序之余张小龙。它跨越了一道深深的鸿沟，并向自己理想的方向坚定前行。\n\n一直相信努力就会有回报，付出就会有收获，是金子总会发光。\n\n* 2016是我加入[客路](www.klook.com)一周年的时间，认识了很多有趣的朋友和同事的一\n* 2016是我迈出自我，走出中国探索未知的世界的一年。\n* 2016是旅行，工作，生活，学习，社交一样都没落下的一年。\n\n曾经的铁哥们也即将回归东莞，这样我们的距离又进了一步，以后有更多的时间聊理想谈人生，想想突然好激动。\n\n<!-- more -->\n\n\n### 业绩\n\n2016-2017年间一共发布17个版本，多次被`Apple`推荐，崩溃率小于0.2%，这就是给自己和公司交出最满意的答卷。\n\n下面是Klook App上Apple的推荐页截图：\n\n<img src=\"/images/2016_year_end_review/klook Apple App recommend.PNG\" alt=\"klook Apple App recommend\" width=\"50%\" />\n\n下面是Klook iMessage App上Apple的推荐页截图：\n\n<img src=\"/images/2016_year_end_review/klook Apple iMessage App recommend.JPG\" alt=\"klook Apple iMessage App recommend\" width=\"50%\" />\n\n有时发现互联网真的很奇妙，他能让很多人迅速积累大量的财富成名走上人生的巅峰，过上自己想要的生活，只要你一个好的idea和一个强大的执行力。\n\n这一年来个人技术博客一共写了 **46** 遍文章，也算一点小积蓄，希望来年继续坚持，能够影响和帮助更多的人，因为技术这条道路上坑实在是太多。\n\n`Github`上**405**次commit还算中规中矩，希望来年分享更多的有价值的东西给有需要的小伙伴，也留给自己方便以后查阅。\n\n![github 2016 commit record](/images/2016_year_end_review/github_2016_commit_record.png)\n\n当然现在`Github`上的内容Fork和博客居多，原创开源项目还比较少，希望来年多输出一点东西。\n\n### 未来\n\n愿望这东西还真神奇，许一个试试吧，或许它真的实现了呢，就非常有趣了。\n给自己定下的旅行清单，学习清单，阅读清单，电影清单基本都完成，这是一件非常棒的事情，为自己点个赞。单反已经从风光转人像，希望来年多出点片，新年即将来临，希望自己坚持一周2次的锻炼，保持精力充沛以便好投入到感情，生活中以及学习中，毕竟互联网是一门终生学习的职业，也是容易产生奇迹的职业，说不定一下个就是你呢。\n\n来年希望和自己喜欢的人旅拍，多尝试一些没尝试过的事情，交更多有趣的朋友。干巴爹😁😁😁\n\n","tags":["年终总结"],"categories":["总结复盘"]},{"title":"视频播放 Tips","url":"/2016/12/08/2016-12-08-shi-pin-bo-fang-tips/","content":"\n主要涉及到Tips：\n1. 获取设备音量\n2. 静音模式失效\n3. 监听音量改变\n4. 设置设备音量 \n5. 监听静音按钮\n6. 监听耳机拔插\n\n## 获取设备音量\n\n播放音频可以通过：\n\n```objc\nMPMusicPlayerController *iPod = [MPMusicPlayerController systemMusicPlayer];\nfloat volumeLevel = iPod.volume;\n```\n\n播放视频可以通过：\n\n```objc\nfloat outputVolume = [[AVAudioSession sharedInstance] outputVolume];\n```\n\n> 推荐下面的方法，上面的在某些版本可能有问题，下面的方法兼容**iOS6及以上**。\n\n## 静音模式失效\n\n通过设置音频会话的category实现：\n\n```objc\nNSError *setCategoryError = nil;\nBOOL success = [[AVAudioSession sharedInstance] setCategory: AVAudioSessionCategoryPlayback\n\t                                                  error: &setCategoryError];\n    \nif (!success) { /* handle the error in setCategoryError */ }\n```\n\n> 这样App就不会随着手机静音键打开而静音，可在手机静音下播放声音😁\n\n## 监听音量改变\n\n监听音频改变私有通知：\n\n```objc\n[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(volumeChanged:) name:@\"AVSystemController_SystemVolumeDidChangeNotification\" object:nil];\n```\n\n实现通过回调：\n\n```objc\n- (void)volumeChanged:(NSNotification *)notification\n{\n    float volume = [[[notification userInfo] objectForKey:@\"AVSystemController_AudioVolumeNotificationParameter\"]\n     floatValue];\n     \n     // do something\n}\n```\n\n## 设置设备音量 \n\n使用`MPVolumeView`类，便利它的子views找到类为`MPVolumeSlider`的滑竿。\n\n```objc\nMPVolumeView *volumeView = [[MPVolumeView alloc] init];\nUISlider *volumeViewSlider = nil;\n\tfor (UIView *view in [volumeView subviews]){\n\t    if ([view.class.description isEqualToString:@\"MPVolumeSlider\"])\t{\n\t        volumeViewSlider = (UISlider *)view;\n\t        break;\n\t    }\n\t}\n```\n\n然后再通过设置`volumeViewSlider`的`value`即可。\n\n```objc\n_volumeViewSlider.value = someVolume;\n```\n\n## 监听静音按钮\n\n参考[Sound Switch - Sharkfood](http://sharkfood.com/content/Developers/content/Sound%20Switch/)的实现。\n\n使用很简单，判断是否为静音模式：\n\n```objc\nif ([SharkfoodMuteSwitchDetector shared].isMute) {\n    // do something\n}\n```\n动态监听，通过block回调：\n\n```objc\n[SharkfoodMuteSwitchDetector shared].silentNotify = ^(BOOL silent){\n      // do something\n};\n```\n\n## 监听耳机拔插\n\n监听`AVAudioSessionRouteChangeNotification`通知：\n\n```objc\n[[NSNotificationCenter defaultCenter] addObserver:self\n\t\t\t\t\t\t\t\t\t      selector:@selector(audioRouteChangeListenerCallback:) \t\t\t\t\t\t\t\t\t\t      name:AVAudioSessionRouteChangeNotification \n\t\t\t\t\t\t\t\t\t        object:nil];\n```\n\n实现回调：\n\n```objc\n- (void)audioRouteChangeListenerCallback:(NSNotification*)notification\n{\n    NSDictionary *interuptionDict = notification.userInfo;\n    \n    NSInteger routeChangeReason = [[interuptionDict valueForKey:AVAudioSessionRouteChangeReasonKey] integerValue];\n    switch (routeChangeReason) {\n        case AVAudioSessionRouteChangeReasonNewDeviceAvailable:\n            // 耳机插入\n            break;\n            \n        case AVAudioSessionRouteChangeReasonOldDeviceUnavailable:\n            // 耳机拔掉\n            break;\n            \n        case AVAudioSessionRouteChangeReasonCategoryChange:\n            // called at start - also when other audio wants to play\n            NSLog(@\"AVAudioSessionRouteChangeReasonCategoryChange\");\n            break;\n    }\n}\n```\n","tags":["音视频"],"categories":["最佳实践"]},{"title":"动画切换 Image 最佳实践","url":"/2016/11/26/2016-11-26-dong-hua-qie-huan-imagezui-jia-shi-jian/","content":"\n### 前言\n\n`UIImageView`应该是iOS中使用最频换的控件，就如日常吃饭一样，天天都在重复，有时或许应该反思一下，怎么使用这个控件，达到低能耗，最佳用户体验。\n\n针对单张图片来说，常见的处理是在图片准备显示时增加一个淡出动画，能使图片显示闲的很平滑。\n\n多张图片也一样，在第一张图片的基础上淡出原来的图片，淡入新的图片。也可以说是溶解效果。\n\n很多人喜欢对图片的`alpha`做淡出动画，使`alpha`从0到1动画改变。这种动画有一点不好的是，在动画结束后，图片会明显的出现一闪，这样使动画看起来有点突兀。比较好的做法时，在将要显示时给图片做一个转场动画。\n\n### 淡出动画实现\n\n下面是其中一种简单的实现：\n\n```objc\n@implementation UIImageView (RFWebImage)\n\n- (void)animatedChangeToImage:(UIImage *)img\n{\n    [UIView transitionWithView:self\n                      duration:0.3f\n                       options:UIViewAnimationOptionTransitionCrossDissolve\n                    animations:^{\n                        self.image = img;\n                    } completion:NULL];\n}\n\n@end\n```\n\n思路：在ImageView将要显示是使用转场动画函数来实现淡出动画效果，体验应该是是各种动画中最好的了，而且使用起来很简单。\n\n\n在淡出显示的动画基础上，我们引出今天的主角，动画切换Image。\n\n思路：单张图片淡出我们已经实现，现在做的就是在切换一张新的图片时同时再加入淡出或者说溶解效果即可。\n\n### 动画切换Image\n\n比较常见的有下面3种实现：\n\n* `CATransition`类实现\n* `UIView`动画转场API实现\n* `CABasicAnimation`类实现\n\n#### CATransition实现\n\n`CATransition`类是iOS中很好用的控制转场动画的类，通过简单的配置可以实现常见而炫酷的动画效果，变换类型通过`type`字段控制，`subtype`可以很细化控制动画的方向（比如动画开始的上下左右方向）。`CATransition`继承至`CAAnimation`可以对动画设置动画曲线（timingFunction），可以通过代理获取动画状态（是已经开始，还是已经停止，已经是否完成）。\n\n`type`支持四种类型：\n\n* kCATransitionFade    // 淡入淡出\n* kCATransitionMoveIn  // 从某个方向向终点平移知道覆盖在上方\n* kCATransitionPush    // 把原来的推出去，自己推出去\n* kCATransitionReveal  // 把原来的从正上方解开，自己在下面\n\n*下面是样板代码：*\n\n```objc\n- (void)animatedSwichImageMethodOne {\n\n    UIImage *toImage = [self getRadomImage];\n    \n    CATransition *transition = [CATransition animation];\n    transition.duration = 0.3f;\n    transition.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];\n    transition.type = kCATransitionFade;\n    transition.subtype = kCATransitionFromTop;\n    \n    [self.imageViewOne.layer addAnimation:transition forKey:nil];\n    [self.imageViewOne setImage:toImage];\n}\n```\n\n#### UIView动画转场\n\n```objc\n+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0);\n```\n\n通过上面的函数实现，其实是对第一种的高级封装。通过设置`options`为`UIViewAnimationOptionTransitionCrossDissolve`即可。\n\n*下面是样板代码：*\n\n```objc\n- (void)animatedSwichImageMethodTwo {\n    \n    UIImage *toImage = [self getRadomImage];\n    \n    [UIView transitionWithView:self.imageViewTwo\n                      duration:0.3f\n                       options:UIViewAnimationOptionTransitionCrossDissolve | UIViewAnimationOptionCurveEaseInOut\n                    animations:^{\n                        self.imageViewTwo.image = toImage;\n                    } completion:nil];\n}\n```\n\n#### CABasicAnimation实现\n\n`CABasicAnimation`是核心动画一个重要的类，继承至`CAPropertyAnimation`，可以对所有的可动画属性做动画，可以通过`fromValue`，`toValue`，`byValue`字段控制动画的进度。\n在这里我们是对`CALayer`的`contents`属性做动画，在改变图片时，创建一个`CABasicAnimation`对象添加到ImageView的图层上即可。\n\n*下面是样板代码：*\n\n```objc\n- (void)animatedSwichImageMethodThree {\n    \n    UIImage *toImage = [self getRadomImage];\n    \n    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"contents\"];\n    animation.toValue = toImage;\n    animation.duration = 0.3f;\n    \n    [self.imageViewThree.layer addAnimation:animation forKey:@\"contentsAnimationKey\"];\n    [self.imageViewThree setImage:toImage];\n}\n```\n\n> 更多内容请下载[Demo](https://github.com/wangruofeng/AnimatedSwitchImageDemo)查看（**🤔Bonus： Flip效果🤔**）\n","tags":["UIImage"],"categories":["动画"]},{"title":"iOS 无缝桥接【翻译 Apple 官方文档】","url":"/2016/11/17/2016-11-17-ioswu-feng-qiao-jie/","content":"\n### Toll-Free Bridged Types\n\n在`Core Foundation`框架和`Foundation `框架中有很多数据类型可以交替转换。能够被交替转换的数据类型也被叫做`Toll-Free Bridged`数据类型。这意味着你能像参数一样使用相同的数据结构对一个`Core Foundation`的函数进行调用，或者像`Objective-C`的消息接受模式一样执行。例如，`NSLocale`（查看[NSLocale Class Reference](https://developer.apple.com/reference/foundation/nslocale)）可以与在`Core Foundation`中对应的`CFLocale `（查看[CFLocale Reference](https://developer.apple.com/reference/corefoundation/1666963-cflocale)）之间互相转换。\n\n\n不是所有数据类型都是`Toll-Free Bridged`,即使它们的名字可能让你认为它们是。例如，`NSRunLoop`是没有对应的桥接类型`CFRunLoop`,`NSBundle`也没有对应的桥接类型`CFBundle`，`NSDateFormatter`同样没有对应的桥接类型`CFDateFormatter`。\n\n文章末尾表1提供了一份支持无缝桥接的数据类型的列表。\n\n> **注意**：假如你使用一个自定义回调在一个`Core Foundation`框架的集合中，包含一个`NULL`回调，当使用`Objective-C`的方式接入它，它的内存管理方式是未定义的。\n\n### 类型转换和对象语义周期声明\n\n通过无缝桥接技术，在一个你以`NSLocale *`做为一个参数的方法的例子中，你能传递一个`CFLocaleRef`结构体，并且当你看到有一个`CFLocaleRef `参数的函数中，你能够传递一个`NSLocale`实例对象。当然你也必须提供给编译器相关的一些其它信息:第一，你必须转换一种类型成其它；第二，你可能必须指明对象的语义生命周期。\n\n编译器理解`Objective-C`的方法并且返回`Core Foundation`数据类型，下面是`Cocoa`命名转换的历史（查看[Advanced Memory Management Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i)）。例如，编译器知道，在`iOS`中，通过`UIColor `的`CGColor`方法返回的`CGColor`并不应该被持有。你必须使用恰当的类型转换，像下面例子演示的那样：\n\n```objc\nNSMutableArray *colors = [NSMutableArray arrayWithObject:(id)[[UIColor darkGrayColor] CGColor]];\n[colors addObject:(id)[[UIColor lightGrayColor] CGColor]];\n```\n\n编译器并不会自动管理`Core Foundation`对象的生命周期。你必须告诉编译器对象的语义所属关系通过使用一种转换（定义在**objc/runtime.h**）或者`Core Foundation`风格的宏（定义在 **NSObject.h**）：\n\n* `__bridge`关键字表示转换指针在`Objective-C`和`Core Foundation`之间而不会转换所属关系。\n* `__bridge_retained `关键字或者`CFBridgingRetain `表示转换指针在`Objective-C`和`Core Foundation`之间并且把所属权交给你。你负责调用`CFRelease`或者相关的函数来交出对象的所属权。\n* `__bridge_transfer`关键字或者`CFBridgingRelease`表示转换一个非`Objective-C`的指针到`Objective-C`并且转换所属权给**ARC**。**ARC**负责交出对象的所属权。\n\n\n下面是一些例子：\n\n```objc\nNSLocale *gbNSLocale = [[NSLocale alloc] initWithLocaleIdentifier:@\"en_GB\"];\nCFLocaleRef gbCFLocale = (__bridge CFLocaleRef)gbNSLocale;\nCFStringRef cfIdentifier = CFLocaleGetIdentifier(gbCFLocale);\nNSLog(@\"cfIdentifier: %@\", (__bridge NSString *)cfIdentifier);\n// Logs: \"cfIdentifier: en_GB\"\n \nCFLocaleRef myCFLocale = CFLocaleCopyCurrent();\nNSLocale *myNSLocale = (NSLocale *)CFBridgingRelease(myCFLocale);\nNSString *nsIdentifier = [myNSLocale localeIdentifier];\nCFShow((CFStringRef)[@\"nsIdentifier: \" stringByAppendingString:nsIdentifier]);\n// Logs identifier for current locale\n```\n\n下面的例子显示了使用口述的`Core Foundation`内存管理规则来管理`Core Foundation`内存：\n\n```objc\n- (void)drawRect:(CGRect)rect {\n    CGContextRef ctx = UIGraphicsGetCurrentContext();\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();\n    CGFloat locations[2] = {0.0, 1.0};\n    NSMutableArray *colors = [NSMutableArray arrayWithObject:(id)[[UIColor darkGrayColor] CGColor]];\n    [colors addObject:(id)[[UIColor lightGrayColor] CGColor]];\n    CGGradientRef gradient = CGGradientCreateWithColors(colorSpace, (__bridge CFArrayRef)colors, locations);\n    CGColorSpaceRelease(colorSpace);  // Release owned Core Foundation object.\n \n    CGPoint startPoint = CGPointMake(0.0, 0.0);\n    CGPoint endPoint = CGPointMake(CGRectGetMaxX(self.bounds), CGRectGetMaxY(self.bounds));\n    CGContextDrawLinearGradient(ctx, gradient, startPoint, endPoint,\n                                kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation);\n    CGGradientRelease(gradient);  // Release owned Core Foundation object.\n}\n```\n### 无缝桥接类型\n\n表1提供了一个在`Core Foundation`和`Foundation`中可以交替转换数据类型列表。对每一对桥接类型，表也列举出了这些无缝桥接类型在`OS X`中的可用版本。\n\n| Core Foundation 类型         | Foundation 类型           | 可用性     |\n| :----------------------------|:--------------------------| :---------:|\n| CFArrayRef                  | NSArray                   | OS X v10.0|\n| CFAttributedStringRef       | NSAttributedString        | OS X v10.4|\n| CFCalendarRef               | NSCalendar                | OS X v10.0|\n| CFCharacterSetRef           | NSCharacterSet            | OS X v10.4|\n| CFDataRef                   | NSData                    | OS X v10.0|\n| CFDateRef                   | NSDate                    | OS X v10.4 |\n| CFDictionaryRef             | NSDictionary              | OS X v10.0|\n| CFErrorRef                  | NSError                   | OS X v10.4|\n| CFLocaleRef                 | NSLocale                  | OS X v10.0|\n| CFMutableArrayRef           | NSMutableArray            | OS X v10.4|\n| CFMutableAttributedStringRef| NSMutableAttributedString | OS X v10.0|\n| CFMutableCharacterSetRef    | NSMutableCharacterSet     | OS X v10.4|\n| CFMutableDataRef            | NSMutableData             | OS X v10.0|\n| CFMutableDictionaryRef      | NSMutableDict             | OS X v10.4|\n| CFMutableSetRef             | NSMutableSet              | OS X v10.0|\n| CFMutableStringRef          | NSMutableString           | OS X v10.4|\n| CFNumberRef                 | NSNumber                  | OS X v10.0|\n| CFReadStreamRef             | NSInputStream             | OS X v10.4|\n| CFRunLoopTimerRef           | NSTimer                   | OS X v10.0|\n| CFSetRef                    | NSSet                     | OS X v10.4|\n| CFStringRef                 | NSString                  | OS X v10.0|\n| CFTimeZoneRef               | NSTimeZone                | OS X v10.4|\n| CFURLRef                    | NSURL                     | OS X v10.0|\n| CFWriteStreamRef            | NSOutputStream            | OS X v10.4|\n\n表1\n\n###  参考资料\n* [Toll-Free Bridged Types](https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html)\n","tags":["翻译","bridge"],"categories":["系统原理"]},{"title":"block 备忘录","url":"/2016/11/17/2016-11-17-blockbei-wang-lu/","content":"\n### 前言\n\n随著`block`在**iOS4.0**和**OS X 10.6**的引入，给事件传递一种新的方式实现，在开发中用得最多的场景莫过于事件回调。使用`block`相对与`delegate`的优势在于，业务集中，可读性强，代码内联，不像代理需要实现很多函数，在适当的场景选择这种方式实现事件传递或者传参效果非常好，现在很多开源项目都实现了两种方法的事件回调。\n\n`block`用起来虽然很爽，但也有它的不足，存在循环引用，轻者内存泄露，甚至导致App崩溃，不易调试追溯，因此使用它使一定要小心。鉴于实践中的踩过各种坑，总结下来，方便自己和他人以后查阅，这就是**block备忘录**写作的初衷。\n\n### block的本质\n\n`block`实际上是指向结构体的指针，编译时，`block`的内部代码生产对应的函数。\n\n具体结构如下：\n\n![block结构图](/images/block_structure.jpg)\n\n### 与C语言的函数指针的区别\n\n* `block`的代码是内联的，效率高于函数调用\n* `block`对于外部变量默认是只读属性\n* `block`被`Objective-C`看成是对象处理\n\n### block声明\n* 作为`property`\n\n\t> @property (nonatomic, copy) returnType \t(^blockName)(parameterTypes);\n\t\n* 作为方法参数\n\n\t> \\- (void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName;\n\t\n* 作为一个方法调用参数\n\n\t> [someObject someMethodThatTakesABlock:^returnType \t(parameters) {...}];\n\t\n* 作为一个`typedef`\n\n\t> typedef returnType (^TypeName)(parameterTypes);\n\t\n\t> TypeName blockName = ^returnType(parameters) {...};\n\n* 作为函数参数\n\n\t> int (^sumOfNumbers)(int a, int b) = ^(int a, int \tb) \t{\n\t    return a + b;\n\t};\n\n### `SDWebImage`中使用的`block`示例：\n\n```objc\ntypedef void(^SDWebImageCompletionBlock)(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL);\n\ntypedef void(^SDWebImageCompletionWithFinishedBlock)(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL);\n\ntypedef NSString *(^SDWebImageCacheKeyFilterBlock)(NSURL *url);\n```\n\n### block调用\n\n跟C函数类似使用`（）`，括号里面还可以带一个或者多个参数\n\n```objc\n// block声明\n（void）(^loggerBlock)(void); \n\n// block定义\nloggerBlock = ^{ \n     NSLog(\"hello world\")\n};\n\n// block调用\nloggerBlock(); \n```\n\n\n### block内存管理\n\n默认情况下，`block`是在栈内存中，它不会对所引用的对象进行任何操作；如果对`block`进行一次`copy`操作，`block`就会在堆内存中，并且它会它所有的引用的对象做一次`retain`操作\n\n1. 对于block外的变量引用，block 默认是将其复制到其数据结构中来实现访问的\n2. 对于用 `__block` 修饰的外部变量引用，block 是复制其引用地址来实现访问的\n3. 而block会捕获代码外的局部变量，并且仅限于只读操作\n4. 在block中希望修改的外界局部对象，必须加上`__block`关键词\n\nARC\n\n\t如果对象使用`__unsafe_unretained`或`__weak`修饰，就不会对其做`retain`操作\n\nMRC\n\n\t如果对象使用了`__block`修饰, 就不会对其做`retain`操作\n\n为了防止`block`中的循环引用，可以用`__weak`关键词把相应的对象声明为弱引用,在`block`快内部需要多次访问，防止该对象被释放，可以用`__strong`关键词将声明为强引用：\n\n```objc\n__weak __typeof__(self) weakSelf = self;\n\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n\n    __strong __typeof(self) strongSelf = weakSelf;\n    \n    [strongSelf doSomething];\n    [strongSelf doOtherThing];\n});\n```\n\n### 参考链接\n\n* [谈Objective-C block的实现](http://blog.devtang.com/2013/07/28/a-look-inside-blocks/)\n* [A look inside blocks: Episode 1](http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-1/)\n* [A look inside blocks: Episode 2](http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-2/)\n* [A look inside blocks: Episode 3](http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/)\n* [对 Objective-C 中 Block 的追探](http://www.cnblogs.com/biosli/archive/2013/05/29/iOS_Objective-C_Block.html)\n* [LLVM 中 block 实现源码](https://llvm.org/svn/llvm-project/compiler-rt/trunk/BlocksRuntime/Block_private.h)\n* [objective-c-blocks-quiz](http://blog.parse.com/2013/02/05/objective-c-blocks-quiz/)\n* [Blocks](http://rypress.com/tutorials/objective-c/blocks.html)\n* [iOS开发-由浅至深学习block](http://www.jianshu.com/p/29d70274374b)\n","tags":["block"],"categories":["系统原理"]},{"title":"App 常见崩溃问题分析","url":"/2016/10/23/2016-10-23-appchang-jian-beng-kui-wen-ti-fen-xi/","content":"\n### 前言\n此文是基于这些年工作中项目里面常见崩溃的一些总结，整理出来方便查阅，希望对大家都有所帮助。\n\n### App常见崩溃\n\n1. 数组下标越界\n2. 字典构造与修改\n3. `NSAttributedString`相关\n4. 呈现一个空控制器\n5. unrecognized selector\n6. 操作`tableView`数据\n7. Push到同一个控制器多次\n\n\n#### 1.数组下标越界\n\n**示例代码**：\n\n```objc\n- (void)testArrayOutOfBounds\n{\n    NSArray *testArray = @[@1,@2,@3];\n    NSNumber *num = testArray[3];\n}\n```\n\n**异常现象**：\n\n*Terminating app due to uncaught exception 'NSRangeException', reason: '\\*** -[__NSArrayI objectAtIndex:]: index 3 beyond bounds [0 .. 2]'*\n\n**预防方案**：\n\n在数组中取值时需要先进组下标索引边界检查，如果没有越界方可取值。\n\n\n\n#### 2.字典构造造与修改\n\n**示例代码**：\n\n```\n- (void)testDicSetNilValueCrash\n{\n    // 构造不可变字典时 key和value都不能为空\n    NSString *nilValue = nil;\n    NSString *nilKey = nil;\n    NSDictionary *dic1 = @{@\"key\" : nilValue};\n    NSDictionary *dic2 = @{nilKey : @\"value\"};\n}\n```\n\n**异常现象**：\n\n*Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '\\*** -[__NSPlaceholderDictionary initWithObjects:forKeys:count:]: attempt to insert nil object from objects[0]'*\n\n**预防方案**：\n\n在我们使用字面量快速创建一个字典的时候需要特别小心，因为很可能字典的键和值不能保证同时不为空。有潜在崩溃的风险，这种崩溃非常容易出现，需要特别小心，但是当你留心的话也非常好避免，就是设置字典的键或者值的时候判断是否非空，可变字典设置某个键的值是可以为空，相当于删除字典中的某个键值。为了使App保持健壮推荐使用`KVO`或者字面量的方式来设置字典的值\n\n```objc\n- (void)testMutableDicSetNilValueCrash\n{\n    NSString *value = nil;\n    NSMutableDictionary *mDic = [NSMutableDictionary dictionary];\n\n    // via Dic set, leading crash\n    [mDic setObject:value forKey:@\"key\"];\n\n    // via KVO set, it's safe\n    [mDic setValue:value forKey:@\"key\"];\n\n    // or via literal set, it's safe\n    mDic[@\"key\"] = value;\n}\n```\n\n\n#### 3.NSAttributedString相关\n\n**示例代码**：\n\n```objc\n- (void)testAttributedStringInitCrash\n{\n    NSString *nilStr = nil;\n    NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:nilStr];\n}\n\n- (void)testAttributedStringAddAttributeCrash\n{\n    NSString *nonnullStr = @\"str\";\n    NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:nonnullStr];\n\n    NSString *nilValue = nil;\n    [attributedStr addAttribute:NSAttachmentAttributeName value:nilValue range:NSMakeRange(0, 1)];\n}\n```\n\n**异常现象**：\n\n*Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'NSConcreteMutableAttributedString initWithString:: nil value'*\n\n**预防方案**：\n\n在构造`NSMutableAttributedString`或者`NSAttributedString`需要留意，设置的属性的值是否有可能存在`nil`的情况。这个很容易被人忽视，值得注意。\n\n\n\n#### 4.呈现一个空控制器\n\n**示例代码**：\n\n```objc\n- (void)testPresentNilControllerCrash\n{\n    UIViewController *someVC = [UIViewController new];\n    UIViewController *presentVC = nil;\n\n    [someVC presentViewController:presentVC animated:YES completion:nil];\n}\n```\n\n**异常现象**：\n\npresent一个空的控制器导致App crash\n\n**预防方案**：\n\npresent一个新控制器时，判断是否存在，存在才执行，否则直接返回\n\n```objc\n- (void)testPresentNilControllerCrashFixed\n{\n    UIViewController *someVC = [UIViewController new];\n    UIViewController *presentVC = [UIViewController new];\n    \n    if (presentVC) {\n        [someVC presentViewController:presentVC animated:YES completion:nil];\n    }\n}\n```\n\n#### 5.unrecognized selector \n\n**示例代码**：\n\n```objc\n- (void)testUnrecogernizedSelectorCash\n{\n    [self performSelector:@selector(testSel) withObject:nil afterDelay:0];\n}\n```\n\n**异常现象**：\n\n*Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[ViewController testSel]: unrecognized selector sent to instance 0x7ffd41609d10'*\n\n**预防方案**：\n\n此类崩溃经常出现，特别是当服务器数据放回异常时，比如本来应该返回一个`NSString`类型字符串，结果返回`NULL`,当你调用字符串的`length`方式时，导致App崩溃。预防方法，重要的地方对类型进行判断再调用该类的相关方法，或者写一个分类统一处理此类逻辑。\n\n\n\n\n#### 6.操作tableView数据\n\n**示例代码**：\n\n```objc\n- (void)testTableViewUpdateCrash\n{\n    NSIndexPath *insertIndexPath = [NSIndexPath indexPathForRow:0 inSection:0];\n    NSIndexPath *deleteIndexPath = [NSIndexPath indexPathForRow:1 inSection:0];\n    NSIndexPath *reloadIndexPath = [NSIndexPath indexPathForRow:2 inSection:0];\n    NSIndexPath *moved1IndexPath = [NSIndexPath indexPathForRow:3 inSection:0];\n    NSIndexPath *moved2IndexPath = [NSIndexPath indexPathForRow:4 inSection:0];\n    [self.tableView beginUpdates];\n\n    [self.tableView insertRowsAtIndexPaths:@[insertIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic];\n    [self.tableView deleteRowsAtIndexPaths:@[deleteIndexPath]withRowAnimation:UITableViewRowAnimationAutomatic];\n    [self.tableView reloadRowsAtIndexPaths:@[reloadIndexPath] withRowAnimation:UITableViewRowAnimationAutomatic];\n    [self.tableView moveRowAtIndexPath:moved1IndexPath toIndexPath:moved2IndexPath];\n\n    [self.tableView endUpdates];\n}\n```\n\n**异常现象**：\n\n*Fatal Exception: NSInternalInconsistencyException*\n\n*Invalid update: invalid number of sections. The number of sections contained in the table view after the update (1) must be equal to the number of sections contained in the table view before the update (1), plus or minus the number of sections inserted or deleted (1 inserted, 0 deleted).*\n\n**预防方案**：\n\n当需要动态更新`tableView`的数据时，计算好模型的数据使模型的数据和更新`tableView`的后的数据保持同步。\n\n\n\n\n#### 7.Push到同一个控制器多次\n\n**异常现象**：\n\nFatal Exception: NSInvalidArgumentException\n\nPushing the same view controller instance more than once is not supported (<PPSelectPayMethodViewControllerIOS7: 0x10d7e7f10>)\n\n**参考链接**：\n\n* [防止点击 Cell 时 ViewController 被重复 Push](https://github.com/nixzhu/dev-blog/blob/master/2016-01-04-duplicate-push.md)\n\n\n以上就是工作中常见的异常崩溃以及处理方案，下面的异常分类内容来自`Apple`的官方文档，有兴趣的可以查阅。☕️\n\n\n### Apple官方常见异常类型(Exception types)\n\n1. 访问一块坏内存`[EXC_BAD_ACCESS] // SIGSEGV // SIGBUS]`\n2. 异常退出`[EXC_CRASH // SIGABRT]`\n3. 追踪受限`[EXC_BREAKPOINT // SIGTRAP]`\n4. 非法指令`[EXC_BAD_INSTRUCTION // SIGILL]`\n5. 被保护的资源遭到侵害`[EXC_GUARD]`\n6. 资源限制`[EXC_RESOURCE]`\n7. 其他异常类型\n\n#### 1.访问一块坏内存(Bad Memory Access)\n\n当程序试图接入无效内容或者尝试以不被允许的方式接入由于内存的保护等级(例如，尝试写入只读的内存)。`Exception Subtype`字段包含一个**kern_return_t**结构体用来描述错误和不正确接入的内存地址。\n\n下面是一些调试坏内存接入导致崩溃的建议：\n\n* 假如**objc_msgSend**或者**objc_release**在崩溃线程回溯(**Backtraces**)的顶部附近,这个线程可能尝试给一个释放的对象发消息。你应该profile应用使用**Zombies instrument**来更好的理解这个崩溃发生的条件。\n* 假如**gpus_ReturnNotPermittedKillClient**在崩溃线程回溯(**Backtraces**)的顶部附近，线程被终结因为它尝试用**OpenGL ES**或者**Metal**执行渲染当程序处于后台时。查看[QA1766: How to fix OpenGL ES application crashes when moving to the background](https://developer.apple.com/library/ios/qa/qa1766/_index.html)\n* 打开`Address Sanitizer`运行你的应用。Address Sanitizer添加了额外的说明在内容接入当你编译代码的时候。随着你应用的运行，Xcode将⚠️你假如内存以一种可能导致崩溃的方式接入。\n\n#### 2.异常退出（Abnormal Exit）\n\n程序异常退出，是最常见导致这类异常崩溃的原因是捕获到`Objective-C/C++`异常和调用了`abort()`函数。\n\n**App Extensions**将被终结发生这种类型的异常，假如他们初始化花费太多的时间(*watchdog*终结)。假如一个**extension**由于载入时间太长被终结，产生崩溃报告的**Exception Subtype**将是*LAUNCH_HANG*。因为**extensions**并没有一个`main`函数，任何花销在初始化的时间都发生在**static constructors**和呈现在你的**extensions**和依赖库的`+load`方法。你应该尽可能的延迟做这些工作。\n\n#### 3.追踪受限（Trace Trap）\n\n和异常退出类似，这种异常的目的是给一个追加的调试器，让它有机会来打断在一个当它执行时候指定的点的进程。你可以使用`__builtin_trap()`函数在你的代码中来触发这个异常。假如没有调试器追加的话，线程将被终结并且产生一个崩溃报告。\n\n低等级的库（例如**libdispatch**）将受限这个进程一旦遇到一个重大的错误。关于错误的额外信息可以在[Additional Diagnostic Information](https://developer.apple.com/library/content/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-APPINFO)章节中的崩溃报告找到，或者在设备的控制台。\n\n假如在`runtime`遇到诸如下面的一个意外的条件，`Swift`代码将终结出现这种类型的异常：\n\n* 非可选类型带有一个`nil`值\n* 错误的强制类型转换\n\n查看[Backtraces](https://developer.apple.com/library/content/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-STACKTRACE)来决发生定异常条件的位置。额外的信息可能已经在设备的控制台打印出来了。你应该修改崩溃处的代码来优雅的处理`runtime`错误。例如，使用[Optional Binding](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html)而不是强制解包一个可选变量。\n\n#### 4.非法指令（Illegal Instruction）\n\n进程尝试执行一个非法或者未定义的指令。进程可能已经尝试跳进到一个无效的地址通过一个配置错误的函数指针。在`Intel`处理器中，`ud2`操作码导致一个**EXC_BAD_INSTRUCTION**异常，但是它通常被用来困住进程达到调试的目的。`Swift`代码在`Intel`处理器中将以这种异常终结，假如在`runtime`位置条件发生。更多详情查看**Trace Trap**。\n\n#### 5.被保护的资源遭到侵害（Guarded Resource Violation）\n\n进程侵犯一个被保护的资源。系统库可能某个文件的描述器成`guarded`，在那以后，所有不正常的操作在这些描述器上都将触发一个**EXC_GUARD**异常（当它想操作在这些文件描述器上，系统可以使用特殊的`guarded`标记的私有APIs）。这可以帮你向下快速追踪问题，例如关闭一个已经被系库打开的文件描述器。例如，假如一个app关闭文件秒杀器通过使用截图`SQLite`文件到一个`Core Data`存储，`Core Data`将会在随后诡异的崩溃。**guard exception**将让这些问题尽早引起你的注意，这样也让他们变得更容易调试。\n\n崩溃报告来自新版的`iOS`包含了人类可读的详细信息关于引起`EXC_GUARD`异常的操作在`Exception Subtype`和`Exception Message`字段中。在来自`macOS`或者老版本的`iOS`的崩溃报告中，这些信息被编码到第一个` Exception Code`就像一个分解成如下的位段：\n\n* **[63:61] - Guard Type**：被保护的资源类型。`0x2`代表一个文件描述器资源。\n* **[60:32] - Flavor**：侵害被处罚时的条件\n\t* 假如第一个`(1 << 0)`位被设置，进程尝试执行`close()`函数在一个受保护的文件描述器。\n\t* 假如第二个`(1 << 1)`位被设置，进程尝试执行`dup()`，`dup2()`，或者`fcntl()`带`F_DUPFD`或者`F_DUPFD_CLOEXEC`命令在一个受保护的文件描述器。\n\t* 假如第三个`(1 << 2)`位被设置，进程尝试通过一个`socket`发送给一个受保护的文件描述器。\n\t* 假如第三个`(1 << 3)`位被设置，进程尝试写入到一个受保护的文件描述器。\n* **[31:0] - File Descriptor**：进程尝试修改的受保护的文件描述器。\n\n#### 6.资源限制（Resource Limit）\n\n进程超出了一个资源消耗的限制。这是一个来自操作系统通知，告诉进程正在使用的资源过多。精确的资源列在`Exception Subtype`字段中。假如`Exception Note`字段包含`NON-FATAL CONDITION`，进程不会被终结即使产生了一个崩溃报告。\n\n* 异常子类型`MEMORY`表明进程已经越过系统应用的内存限制。这可能是一个终结的先兆由于超额的使用内存。\n* 异常子类型`WAKEUPS`表明在进程中的线程每秒被唤醒太多次，这强制`CPU`非常频繁的唤醒消耗电池寿命。\n\n\t典型的，这个通过由线程与线程的通信产生（通常是使用`peformSelector:onThread:`或`dispatch_async`）,那样无意的发生了远远超出它正常应该的切换频率。因为通信的协调发生得非常频繁而出发此类的异常，这个通常和多个后台线程有着相似`Backtraces` -- 表明那些地方发生过通信。\n\t\n#### 7.其他异常类型（Other Exception Types）\n\n一些崩溃报告可能含有一个未命名的`Exception Type`，将以一个16进制的值（例如，00000020）的形式打印。假如你的设备收到了一个这样的崩溃报告，直接查看`Exception Codes`字段寻找更多的信息。\n\n* 异常代码`0xbaaaaaad`表明记录是整个系统的`stackshot`，不是一个崩溃报告。为了获得一个`stackshot`，按`Home`键和任意音量键。这些记录经常被用户偶然创建，并不表明是一个错误。\n* 异常代码`0xbad22222`表明一个`VoIP`应用已经被`iOS`终结，因为它启动得太频繁。\n* 异常代码`0x8badf00d`表明应用已经被`iOS`终结因为发生`watchdog`超时。应用花费太长时间启动，终结，或者响应系统事件。通常导致这歌问题是做了[在主线程执行了同步的网络请求](http://developer.apple.com/library/ios/qa/qa1693/)。无论什么操作在`Thread 0`都需要移动到后台线程，或者异步处理，以免它阻塞主线程。\n* 异常代码`0xc00010ff`表明引用被操作系统终结为了响应一个发热事件。这个可能由于一个发生崩溃的特定的设备的问题或者环境被操作导致。为了使你的应用更高效运行的建议，查看**WWDC session**[ iOS Performance and Power Optimization with Instruments](https://developer.apple.com/videos/wwdc/2011/?id=312)。\n* 异常代码`0xdead10cc`表明应用被`iOS`终结，由于当在后台运行时它持有了一个系统的资源（像通信录数据库）。\n* 异常代码`0xdeadfa11`表明应用被用户强制退出。强制退出发生在当用户第一次按下开关机按钮直到\"滑动来关机\"出现，然后在按下Home键。这是合理的假如用户这样做了，因为应用已经变得不可响应，但是这并不能保证 - 强制退出任何正在运行的任务。\n\n\t> 注意：终结一个挂起的app通过从多任务关系面板中移除并不会产生一个崩溃报告。一旦一个app被挂起，**iOS**它有资格在任何时候终结它，所有没有崩溃报告产生。\n\n### 参考资料\n\n* [Understanding and Analyzing Application Crash Reports](https://developer.apple.com/library/content/technotes/tn2151/_index.html)\n* [Analyzing Crash Reports](https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/AnalyzingCrashReports/AnalyzingCrashReports.html)\n\n","tags":["奔溃分析"],"categories":["最佳实践"]},{"title":"快速封装 Airbnb 风格 Loadingview","url":"/2016/09/10/2016-09-10-kuai-su-feng-zhuang-airbnbfeng-ge-loadingview/","content":"\n### 前言\n\n一直在观察各种App的`LoadingView`，比较有代表性的是`MBProgressVHUD`，`SVProgressHUD`，这两个使用得非常广泛，大到QQ，支付宝，小到各种不知道名的App，长时间的迭代让它们的逻辑非常完善，同时也导致了有些累赘，如果把它们当一个产品来分析，可以看出，它们在不断地增加需求和使用场景，有没有一个非常简洁的HUD没有我们不需要的那些多余的逻辑只是负责显示指示和隐藏呢？\n\n好像没有，所有今天动手准备自己封装一个`LoadingView`，灵感来自Airbnb，用过Airbnb的同学都知道，它的`LoadingView`很有风格,Airbnb是几张图片循环翻转切换，当然我不准备复制他们的idea，我准备做一个循环左右上下切换的`LoadingView`。\n\n<img src=\"/images/loading_img/loading_img_01.jpg\" width=\"375\" height=\"667\">\n\n废话不多说，先来看一下，最终效果的原型图\n\n![RFLoadingView](/images/loading_img/loading_img_02.jpg)\n\n### 思路\n分析一下思路：\n\n * 四条虚线交叉形成的区域就是我们能够看到的图片\n * 首先准备两张图片，位置 中+上\n * 开始第一段动画，向下切换，位置 变成 中+下\n * 第一段动画结束，将下面的图片移动到右边，准备开始第二段动画\n * 第二动画跟第一段类似，只是方向是从右向左，动画结束后 位置变成 中+左\n * 将左边的图片移动到上方位置，完成一个循环\n\n 为了使动画更流畅不至于生硬，我们使用iOS7推出的带弹簧效果的API\n\n```objc\n \n+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);\n \n```\n\n###  API接口\n\n在API接口设计上，我希望尽量简单实用，封装了两个方法，一个用来显示，一个用来隐藏，可以指定显示到某个view，以及指定显示和隐藏时是否使用动画。\n\n```objc\n \n+ (void)showViewAddedTo:(UIView *)view animated:(BOOL)animated;\n+ (void)hideViewForView:(UIView *)view animated:(BOOL)animated;\n\n```\n\n###  API实现\n\n根据刚才的分析，核心的动画实现已经有了思路，现在就是怎么设计内部代码实现，为了方便显示蒙版阻止加载的时候用户交互，我把view的背景颜色设置了一个淡灰色，view的中间有三个子view，一个是位于中间的容器`centralView`,负责显示我们所看到的区域，方便实现圆角和动画效果，里面加入两个子view，`firstView`和`secondView`用于显示动画切换的图片。\n\n内部接口大概这样\n\n```objc\n\n@property (nonatomic, strong) UIView      *centralView;\n@property (nonatomic, strong) UIImageView *firstView;\n@property (nonatomic, strong) UIImageView *secondView;\n\n```\n\n为了防止多次添加`LoadingView`，在每次添加前，我们会查找该view是否存在，如果不存在，创建一个新的对象，如果存在直接跳过添加操作。反向遍历，快速查找。\n\n```objc\n\n+ (RFLoadingView *)loadingViewForView:(UIView *)view\n{\n    NSEnumerator *subviewsEnum = [view.subviews reverseObjectEnumerator];\n    for (UIView *subview in subviewsEnum) {\n        if ([subview isKindOfClass:self]) {\n            return (RFLoadingView *)subview;\n        }\n    }\n    \n    return nil;\n}\n\n```\n\n动画核心实现,两端动画，封装成两个方法\n\n* `- (void)animatedImageFromTopToBottom`\n* `- (void)animatedImageFromTopToBottom`\n\n具体实现如下\n\n```objc\n\n- (void)animatedImageFromTopToBottom\n{\n    [UIView animateWithDuration:0.3 delay:0.5 usingSpringWithDamping:0.7 initialSpringVelocity:0 options:UIViewAnimationOptionCurveEaseInOut animations:^{\n        _firstView.centerY  += kCenterViewSize;\n        _secondView.centerY += kCenterViewSize;\n    } completion:^(BOOL finished) {\n        _firstView.centerX += kCenterViewSize;\n        _firstView.centerY -= kCenterViewSize;\n        \n        [self changeFirstImage];\n        [self animatedImageFromRightToLeft];\n    }];\n}\n\n- (void)animatedImageFromRightToLeft\n{\n    \n    [UIView animateWithDuration:0.3 delay:0.5 usingSpringWithDamping:0.7 initialSpringVelocity:0 options:UIViewAnimationOptionCurveEaseInOut animations:^{\n        _firstView.centerX  -= kCenterViewSize;\n        _secondView.centerX -= kCenterViewSize;\n    } completion:^(BOOL finished) {\n        _secondView.centerX += kCenterViewSize;\n        _secondView.centerY -= kCenterViewSize;\n        \n        if (self.alpha && self) {\n            [self changeSecondImage];\n            [self animatedImageFromTopToBottom];\n        }\n        \n    }];\n}\n\n```\n\n> 需要非常注意的是，一定要写上终止动画的条件，不然会无限循环，影响性能\n\n### show和hide\n\n```\n- (void)showAnimated:(BOOL)animated\n{\n    RFMainThreadAssert();\n    \n    self.alpha = 1;\n    \n    [UIView animateWithDuration:animated ? 0.3 : 0 animations:^{\n        _centralView.alpha = 1;\n    } completion:^(BOOL finished) {\n        [self animatedImageFromTopToBottom];\n    }];\n}\n\n- (void)hideAnimated:(BOOL)animated\n{\n    RFMainThreadAssert();\n    \n    [UIView animateWithDuration:animated ? 0.3 : 0 animations:^{\n        self.alpha = 0;\n    } completion:^(BOOL finished) {\n        [self removeFromSuperview];\n    }];\n}\n\n```\n\n### 最终效果\n\n<img src=\"/images/loading_img/loading_img_03.jpg\" width=\"375\" height=\"667\">\n\n* Github Demo地址:\n[RFLoadingViewDemo](https://github.com/wangruofeng/RFLoadingView)\n\n \n\n\n\n\n\n\n","tags":["Loading"],"categories":["动画"]},{"title":"iOS 第三方库汇总","url":"/2016/04/15/2016-04-15-iosdi-san-fang-ku-hui-zong/","content":"\n### 简介\n\n此文用于总结，本人使用过或者收藏过的`Github`第三方类库，以便日后查阅，也便他人借鉴。\n\n资料整理中不定期更新。。。\n\n### 开源项目\n\n* [CodeHub](https://github.com/thedillonb/CodeHub)\n\t>  browse and maintain your GitHub repositories on any iOS device!\n* [Open-Source iOS Apps](https://github.com/dkhamsing/open-source-ios-apps)\n\t> 开源iOS apps列表\n\n### APP相关\n\n* [iVersion](https://github.com/nicklockwood/iVersion)\n\t> 提示版本更新\n* [BonMot](https://github.com/Raizlabs/BonMot)\n\t> 字体相关的库，设置字体样式\n* [FontAwesomeKit](https://github.com/PrideChung/FontAwesomeKit)\n\t> FontAwesomeKit 提供一些简单的助手类用来帮助在iOS上使用[FontAwesome](https://github.com/FortAwesome/Font-Awesome)\n* [Font-Awesome](https://github.com/FortAwesome/Font-Awesome)\n\t> The iconic font and CSS toolkit\t\n* [JMHoledView](https://github.com/leverdeterre/JMHoledView)\n\t> 首次启动APP的新手指引\n\t\n### 自动布局\n* [Masonry](https://github.com/cloudkite/Masonry)\n\t> 最优雅的自动布局解决方案，支持链式编程\n* [PureLayout](https://github.com/PureLayout/PureLayout)\n\t> 又一强大的自动布局解决方案\n\t\n### 网络请求\n* [AFNetworking](https://github.com/AFNetworking/AFNetworking)\n\t> 地球人都在用\n* [CocoaAsyncSocket](https://github.com/robbiehanson/CocoaAsyncSocket)\n\t> 封装最完善的Socket类库\n* [RxAlamofire](https://github.com/RxSwiftCommunity/RxAlamofire)\n\t> 封装Alamofire\n\t\n### 基础工具类以及Category\n* [sstoolkit](https://github.com/soffes/sstoolkit)\n\t> 一个不错的工具包，提供各种比如编码、加密、字符串处理等等东西\n* [BFKit Swift版本](https://github.com/FabrizioBrancati/BFKit-Swift)\n\t> 国外的一个大神写的很好用的分类，比较齐全\n* [YYKit](https://github.com/ibireme/YYKit)\n\t> **ibireme**用心之作\n* [BlocksKit](https://zwaldowski.github.io/BlocksKit)\n\t> 为基础类提供Block支持，很好用\n* [DateTools](https://github.com/MatthewYork/DateTools)\n\t> 非常强大的日期处理工具\n* [FlatUIKit](https://github.com/Grouper/FlatUIKit)\n\t> 扩展Foundation基本UI主件，扁平化风格\n* [iOS-Categories](https://github.com/shaojiankui/iOS-Categories)\n\t> iOS Objective-C Category, a collection of useful Objective-C Categories extending iOS Frameworks such as Foundation,UIKit,CoreData,QuartzCore,CoreLocation,MapKit Etc.\n* [PinYin4Objc](https://github.com/kimziv/PinYin4Objc)\n\t> 拼音解析\n* [ZipArchive](https://github.com/mattconnolly/ZipArchive)\n\t> 解压缩\n* [Chameleon](https://github.com/ViccAlexander/Chameleon)\n\t> 扁平颜色框架，可以创建非常漂亮的颜色\n* [CYLTabBarController](https://github.com/ChenYilong/CYLTabBarController)\n\t> 低耦合集成TabBarController\n* [RKNotificationHub](https://github.com/cwRichardKim/RKNotificationHub)\n\t> 在右上方显示通知小角标\n* [Material-Controls-For-iOS](https://github.com/fpt-software/Material-Controls-For-iOS)\n\t> Google风格的控件\n* [YYKit](https://github.com/wangruofeng/YYKit)\n\t> A collection of iOS components.\n\t\n### 弹框\n\n* [TYAlertController](https://github.com/12207480/TYAlertController)\n\t> 各种风格的弹框，满足你的各种需求\n* [JKPopMenuView](https://github.com/UncleJoke/JKPopMenuView)\n\t> 简单的弹出菜单\n* [MMPopupView](https://github.com/adad184/MMPopupView)\n\t> 精简的弹框，非常漂亮，和喜欢\n* [MJPopupViewController](https://github.com/martinjuhasz/MJPopupViewController)\n\t> A UIViewController Category to display a ViewController as a popup with different transition effects.\n* [QBPopupMenu](https://github.com/questbeat/QBPopupMenu.git)\n\t> 自定义popup menu，外观和iOS7上的`UIMenuController`类似\n* [CWStatusBarNotification](https://github.com/cezarywojcik/CWStatusBarNotification)\n\t> 状态栏通知\n* [DOPDropDownMenu](https://github.com/12207480/DOPDropDownMenu-Enhanced)\n    > 下拉列表菜单\n* [KLCPopup](https://github.com/jmascia/KLCPopup)\n\t> 非常漂亮的弹出控件\n  \n### 动画\n\n* [JHChainableAnimations](https://github.com/jhurray/JHChainableAnimations)\n\t> 链式动画编程，有点Masonry的味道\n* [Canvas](http://canvaspod.io/)\n\t> 非常强大的动画框架\n* [VCTransitionsLibrary](https://github.com/ColinEberhardt/VCTransitionsLibrary)\n\t> 转场动画库\n* [iCarousel](https://github.com/nicklockwood/iCarousel)\n\t> 各种3D变换的动画，以前用过，炫酷得没朋友\n* [tapkulibrary](https://github.com/devinross/tapkulibrary)\n\t> Tapku remain home to the things like the calendar UIs, coverflow, and any legacy classes, ect.\n* [TBIconTransitionKit](https://github.com/AlexeyBelezeko/TBIconTransitionKit)\n\t> 点击按钮过渡动画 + --> x   - --> + \n* [Spring](https://github.com/MengTo/Spring)\n\t> A library to simplify iOS animations in `Swift`\n* [awesome-iOS-animation](https://github.com/sxyx2008/awesome-ios-animation)\n\t> iOS动画库整理收集\n* [FeSpinner](https://github.com/NghiaTranUIT/FeSpinner)\n\t> Rocket Loader Collection for iOS app,有一些非常有趣的loading动画\n* [SDECollectionViewAlbumTransition](https://github.com/seedante/SDECollectionViewAlbumTransition)\n\t> CollectionView相册自定义转场\n* [RZTransitions](https://github.com/Raizlabs/RZTransitions)  \n\t> A library of custom iOS View Controller Animations and Interactions.\n* [AnimatedTransitionGallery](https://github.com/shu223/AnimatedTransitionGallery)\n\t> 各种自定义转场动画收集，非常值得学习\n* [StarWars.iOS](https://github.com/Yalantis/StarWars.iOS)\n    > 非常炫酷的`CAShapeLayer`动画，非常炫酷😘\n* [Animations](https://github.com/YouXianMing/Animations)\n    > 来自极客学院的`YouXianMing`的一些动画收集\n* [ZFDragableModalTransition](https://github.com/zoonooz/ZFDragableModalTransition)\n\t> Custom animation transition for present modal view controller\n\t\n### Gif引擎\n\n* [FLAnimatedImage](https://github.com/Flipboard/FLAnimatedImage)\n\t> [Flipboard](https://github.com/Flipboard)开源的`Gif`引擎\n\n###  缓存\n\n* [RENCache](https://github.com/REN-LEI/RENCache)\n\t> 简单的缓存解决方案\n* [RNCachingURLProtocol](https://github.com/rnapier/RNCachingURLProtocol)\n\t> webView离线缓存库\n* [HanekeSwift](https://github.com/Haneke/HanekeSwift)\n    > Swift语言书写的轻量级图片缓存框架\n* [FastImageCache](https://github.com/path/FastImageCache)\n    > [Path](https://github.com/path)官方开源的图片缓存框架\n* [Kingfisher](https://github.com/onevcat/Kingfisher)\n\t> 猫神用Swift实现图片下载缓存框架\n\t\n### 文本相关\n\n* [TTTAttributedLabel](https://github.com/TTTAttributedLabel/TTTAttributedLabel)\n\t> 非常强大的Label，支持属性，数据诊断和链接\n* [SlackTextViewController](https://github.com/slackhq/SlackTextViewController.git)\n\t> `Slack`开源的drop-in UIViewController subclass with a growing text input view and other useful messaging features\n* [RTLabel](https://github.com/honcheng/RTLabel)\n\t> 可以展示Html的Label\n* [TYAttributedLabel](https://github.com/12207480/TYAttributedLabel)\n\t> 强大的属性文本控件(无需了解`CoreText`)，支持图文混排显示，支持添加链接，image和UIView控件，支持自定义排版显示\n* [CSGrowingTextView](https://github.com/cloverstudio/CSGrowingTextView)\n\t> 文本框会随着输入字数改变高度\n* [LTMorphingLabel](https://github.com/lexrus/LTMorphingLabel)\n\t> 效果非常炫的文本框\n* [TextFieldEffects](https://github.com/raulriera/TextFieldEffects)\n\t> 动效非常不错的文本输入框\n* [DDRichText](https://github.com/daiweilai/DDRichText)\n\t> 图文混排\n* [BMLine](https://github.com/AirSars/BMLine)\n\t> 为你的View增加线条\n* [UITextView-Placeholder](https://github.com/devxoul/UITextView-Placeholder)\n\t> A missing placeholder for UITextView.\n\t\t\n### 加载进度\n\n* [DACircularProgress](https://github.com/danielamitay/DACircularProgress)\n\t> 各种圆形和圆环型进度指示\n* [NJKWebViewProgress](https://github.com/ninjinkun/NJKWebViewProgress)\n\t> UIWebView progress interface\n* [MBProgressHUD](https://github.com/jdg/MBProgressHUD)\n\t> 这个不用讲，基本上都会用\n* [SVProgressHUD](https://github.com/SVProgressHUD/SVProgressHUD)\n\t> 又一个进度指示\n* [Toast](https://github.com/scalessec/Toast)\n\t> 和MBProgressHUD差不多\n* [LCProgressHUD](https://github.com/LeoiOS/LCProgressHUD)\n\t> 对MBProgressHUD的简单封装，非常实用\n* [TSMessages](https://github.com/KrauseFx/TSMessages/)\n\t> 消息通知提醒框，非常好用\n* [PINRemoteImage](https://github.com/pinterest/PINRemoteImage)\n\t> `Pinterest`抓取远程图片类\n* [SDWebImage](https://github.com/rs/SDWebImage)\n\t> 最广泛使用的图片缓存框架\n* [AlamofireImage](https://github.com/Alamofire/AlamofireImage)\n\t> Swift版本的`SDWebImage`\n\n### 键盘类\n\n* [DAKeyboardControl](https://github.com/danielamitay/DAKeyboardControl)\n\t> 一个键盘管理框架\n* [IQKeyboardManager](https://github.com/hackiftekhar/IQKeyboardManager)\n\t> 全局键盘管理\n* [TPKeyboardAvoiding](https://github.com/michaeltyson/TPKeyboardAvoiding)\n\t> 使用时设置scrollView的类为`TPKeyboardAvoidingScrollView`即可支持`xib`\n* [RDRStickyKeyboardView](https://github.com/datwelk/RDRStickyKeyboardView)\n\t> 作者已经停止维护。。。\n\t\n### 抽屉\n\n* [ViewDeck](https://github.com/ViewDeck/ViewDeck)\n\t> 功能强大的抽屉效果\n* [MMDrawerController](https://github.com/mutualmobile/MMDrawerController)\n\t> 又一个抽屉\n* [SWRevealViewController](https://github.com/John-Lluch/SWRevealViewController)\n\t> A UIViewController subclass for revealing a rear (left and/or right) view controller behind a front controller, inspired by the Facebook app, done right!\n* [MSDynamicsDrawerViewController](https://github.com/erichoracek/MSDynamicsDrawerViewController)\n\t> Container view controller that leverages UIKit Dynamics to provide a realistic drawer navigation paradigm.\n*  [PKRevealController](https://github.com/pkluz/PKRevealController)\n    > 安装简便，高度定制且对手势识别良好\n    \n### NavigationBar\n\n* [AMScrollingNavbar](https://github.com/andreamazz/AMScrollingNavbar)\n    > `Swift`语言编写上下滑动时动态隐藏标题栏\n* [LTNavigationbar](https://github.com/ltebean/LTNavigationbar)\n    > 导航栏颜色动态改变\n* [JZNavigationExtension](https://github.com/JazysYu/JZNavigationExtension)\n    > Navigation的扩展，推荐\n    \n### ScrollView相关\n\n* [SwipeView](https://github.com/nicklockwood/SwipeView)\n    > SwipeView is a class designed to simplify the implementation of horizontal, paged scrolling views on iOS. It is based on a UIScrollView, but adds convenient functionality such as a UITableView-style dataSource/delegate interface for loading views dynamically, and efficient view loading, unloading and recycling.\n* [SWTableViewCell](https://github.com/CEWendel/SWTableViewCell)\n    > 自定义Cell侧滑动作\n* [MGSwipeTableCell](https://github.com/MortimerGoro/MGSwipeTableCell)\n    > 自定义Cell侧滑动作，效果多样\n* [CHTCollectionViewWaterfallLayout](https://github.com/chiahsien/CHTCollectionViewWaterfallLayout)\n    > 瀑布流布局\n* [TYSlidePageScrollView](https://github.com/12207480/TYSlidePageScrollView)\n    > An easy solution to page views or controllers with header and page tabbar,footer\n* [XLPagerTabStrip](https://github.com/wangruofeng/XLPagerTabStrip)\n    > Android PagerTabStrip for iOS. nice    \n    \n### MJ系列\n\n* [MJExtension](https://github.com/CoderMJLee/MJExtension)\n    > model <--> dic <--> json 框架\n* [MJRefresh](https://github.com/CoderMJLee/MJRefresh)\n    > 刷新控件\n    \n### 数据库\n\n* [realm-cocoa](https://github.com/realm/realm-cocoa)\n    > 跨平台轻量级数据库解决方案,励志取代`Core Data` & `SQLite`\n* [fmdb](https://github.com/ccgus/fmdb)\n    > 对`sqlite`实现面向对象的封装\n\n### 图标库\n\n* [PNChart](https://github.com/kevinzhow/PNChart)\n    > 提供各种图标样式，性能还非常不错\n* [Charts](https://github.com/danielgindi/Charts)\n    > Beautiful charts for iOS/tvOS/OSX! The Apple side of the crossplatform MPAndroidChart.\n\n### 图片处理以及展示相关\n  \n* [GPUImage](https://github.com/BradLarson/GPUImage)\n    > 开源基于GPU的图片渲染引擎，带有很多款滤镜\n* [FXBlurView](http://github.com/nicklockwood/FXBlurView)\n    > 背景模糊\n* [IDMPhotoBrowser](https://github.com/ideaismobile/IDMPhotoBrowser)\n    > 照片浏览器\n* [AGImagePickerController](https://github.com/arturgrigor/AGImagePickerController)\n    > 相册选择\n* [DNImagePicker](https://github.com/AwesomeDennis/DNImagePicker)\n    > 仿照微信的照片选取器\n* [JFImagePickerController](https://github.com/johnil/JFImagePickerController)\n    > 又一个照片选取器\n* [Nuke](https://github.com/kean/Nuke)\n    > Image loading, processing, caching and preheating\n    \n### 日历选择\n\n* [FSCalendar](https://github.com/WenchaoD/FSCalendar)\n    > iOS7+风格的日历控件，非常漂亮\n      \n### 音频/视频\n\n* [KRVideoPlayer](https://github.com/36Kr-Mobile/KRVideoPlayer)\n    > 36氪开源的视频播放器\n* [DOUAudioStreamer](https://github.com/douban/DOUAudioStreamer)\n    > 豆瓣开源的音频播放器\n    \n### 内购/推广\n\n* [IAPHelper](https://github.com/saturngod/IAPHelper)\n    > in app purchases helper for iOS\n* [DAAppsViewController](https://github.com/danielamitay/DAAppsViewController)\n    > 应用推广界面，填写合作app的appleId即可\n* [TAPromotee](https://github.com/JanC/TAPromotee.git)\n    > 交叉推广应用是你可以免费实现的最佳市场推广策略之一。\n    \n### 存储相关\n\n* [SSKeychain](https://github.com/soffes/sskeychain)\n    > 钥匙串存储\n* [PINCache](https://github.com/wangruofeng/PINCache)\n    > [Pinterest](https://github.com/pinterest)出品的非阻塞式异步缓存工具\n* [TMCache](https://github.com/tumblr/TMCache)\n    > [tumblr](https://github.com/tumblr)出品的对象快速异步缓存，支持`iOS`和`OS X`\n* [MagicalRecord](https://github.com/magicalpanda/MagicalRecord)\n    >  简化`Core Data`抓取数据的逻辑，推荐\n* [KeychainAccess](https://github.com/kishikawakatsumi/KeychainAccess)\n    > Simple Swift wrapper for Keychain that works on iOS and OS X\n*  [UICKeyChainStore](https://github.com/kishikawakatsumi/UICKeyChainStore) \n\t> `UICKeyChainStore`的简单封装 \n\t\n### 实用控件\n\n* [HCSStarRatingView](https://github.com/hsousa/HCSStarRatingView)\n    > 简单的评分控件\n* [LNNotificationsUI](https://github.com/LeoNatan/LNNotificationsUI)\n    > 模仿iOS标准通知界面，可以以假乱真\n* [SCLAlertView-Swift](https://github.com/vikmeup/SCLAlertView-Swift)\n    > 非常漂亮的动画`Alert View`，使用`Swift`书写\n* [Wonderful](https://github.com/dsxNiubility/Wonderful)    \n\t> 跑马灯,彩色标签,渐变等。。。\n* [VVeboTableViewDemo](https://github.com/johnil/VVeboTableViewDemo)    \n\t> VVebo剥离的TableView绘制\n* [FXForms](https://github.com/nicklockwood/FXForms)\n\t> 快速创建表单,设置页,用户数据任务,非常棒\n* [SVPullToRefresh](https://github.com/samvermette/SVPullToRefresh)\n    > 一行代码实现UIScrollView下拉刷新或者无限滚动  \n \t\n### 辅助类\n\n* [Surge](https://github.com/mattt/Surge)\n    > 利用`Accelerate`高性能数学计算框架\n* [KMCGeigerCounter](https://github.com/kconner/KMCGeigerCounter)\n    > 显示当前动画的帧率\n* [XNGMarkdownParser](https://github.com/xing/XNGMarkdownParser)\n    > `Markdown`解析器，将`Markdown`格式的字符串解析成`NSAttributedString`格式的字符串\n* [TransformerKit](https://github.com/mattt/TransformerKit)\n\t> 封装了一些常用的`NSValueTransformer`类\n* [RuntimeBrowser](https://github.com/nst/RuntimeBrowser)\n\t> Objective-C Runtime Browser, for Mac OS X and iOS\n* [iOS-Runtime-Headers](https://github.com/nst/iOS-Runtime-Headers) \n    > iOS Objective-C headers as derived from runtime introspection\n* [appledoc](https://github.com/tomaz/appledoc)\n\t> Objective-C代码，苹果风格文档生成器\n* [Markingbird](https://github.com/kristopherjohnson/Markingbird)\n\t> Markdown processor written in Swift (translation of MarkdownSharp)\t\n\n### Swift\n\n* [30DaysofSwift](https://github.com/allenwong/30DaysofSwift)\n    > allenwong自学Swift的30个工程 👍\n* [SwiftGuide](https://github.com/ipader/SwiftGuide)\n    > 这份指南汇集了Swift语言主流学习资源，并以开发者的视角整理编排\n* [swift-package-manager](https://github.com/apple/swift-package-manager)\n    > Swift包管理工具\n* [Carthage](https://github.com/Carthage/Carthage)\n    > Swift依赖管理工具，类似OC的`CocoaPods`\n* [swift-style-guide](https://github.com/raywenderlich/swift-style-guide)\n\t> [raywenderlich.com](https://github.com/raywenderlich)官方Swift编程风格规\n* [RxSwift](https://github.com/ReactiveX/RxSwift)\n\t> Reactive Programming in Swift\n\t\t\n### 其它\n\n* [FreeCodeCamp](https://github.com/FreeCodeCamp/FreeCodeCamp)\n    > The [https://FreeCodeCamp.com](https://FreeCodeCamp.com) open source codebase and curriculum. Learn to code and help nonprofits.   \n* [libextobjc](https://github.com/jspahrsummers/libextobjc)\n    > 拓展了一些`Cocoa`类库\n* [ParseSourceCodeStudy](https://github.com/ChenYilong/ParseSourceCodeStudy)\n    > Facebook开源的Parse源码分析【系列】\n* [hugo](https://github.com/spf13/hugo)\n    > 使用`Google` `Go`语言书写的静态博客网站生成器\n* [CocoaPods](https://github.com/CocoaPods/CocoaPods)\n    > Cocoa包依赖管理工具\n* [MDCSwipeToChoose](https://github.com/wangruofeng/MDCSwipeToChoose)\n\t> 实现某App，左滑不喜欢，右滑喜欢的卡片堆叠功能\n* [Dash-Plugin-for-Xcode](https://github.com/omz/Dash-Plugin-for-Xcode)\n\t> `Xcode`的一个插件，整合`Dash`，方便快速查阅文档\n* [iOS 开发面试问题](https://github.com/lzyy/iOS-Developer-Interview-Questions)\n\t> 汇总一些常见的iOS面试问题\n* [XMPPFramework](https://github.com/robbiehanson/XMPPFramework)\n\t> `XMPP`即时通信协议框架\t\n* [WebViewJavascriptBridge](https://github.com/marcuswestin/WebViewJavascriptBridge)\n    > `Objective-C`与`JavaScript`在`UIWebViews`/`WKWebView`之间交互解决方案\n* [articles-1](https://github.com/objccn/articles)\n\t> Articles for objccn.io. objc.io的完整、准确、优雅的中文翻译版本\n* [articles](https://github.com/NSHipster/articles)\n\t> Weekly articles for NSHipster.com\n* [ebook](https://github.com/onestraw/ebook)\t\n\t> 收集了一些coding相关的电子书\n* [dev-blog](https://github.com/nixzhu/dev-blog)\n    > nixzhu的一些 iOS / Web 开发相关的翻译或原创博客文章\n* [KVOController](https://github.com/facebook/KVOController)\n\t> Simple, modern, thread-safe key-value observing for iOS and OS X.\n* [LBXScan](https://github.com/MxABC/LBXScan)\n\t> 二维码、扫码、扫一扫、ZXing和ios系统自带扫码封装，扫码界面效果封装\n\t\n参考链接：\n\n* [iOS学习资源汇总](http://blog.treney.com/index.php/archives/iOSShare.html) -- 鹏威の博客博客\n","tags":["网站"],"categories":["资料收集"]},{"title":"如何利用 LLDB 来 Debug","url":"/2016/04/15/2016-04-15-ru-he-li-yong-lldblai-debug/","content":"\n### 介绍\n\n鉴于现在调试的频繁性和重要性，此文记录了一些基本的`LLDB`调试命令，方便日后查阅。\n\n### 常用命令 p、po、call、print\n\n```\np         -- ('expression --')  Evaluate an expression (ObjC++ or Swift) in\n             the current program context, using user defined variables and\n             variables currently in scope.\npo        -- ('expression -O  -- ')  Evaluate an expression (ObjC++ or Swift)\n             in the current program context, using user defined variables and\n             variables currently in scope.\nprint     -- ('expression --')  Evaluate an expression (ObjC++ or Swift) in\n             the current program context, using user defined variables and\n             variables currently in scope.\ncall      -- ('expression --')  Evaluate an expression (ObjC++ or Swift) in\n             the current program context, using user defined variables and\n             variables currently in scope.\n```\n\n从官方的描述来看，`p`、`print`、`call`是一样的，但是`po`就不太一样了，输入一样但是输出不一样。`po`的输出的是具体对象的内容。\n\n如果想要按照特定的格式来打印，如下：\n\n```\n(lldb) p/s self.title\n(__NSCFString *) $0 = @\"目的地\"\n(lldb) p self.title\n(__NSCFString *) $1 = 0x00007fe0c0d4d230 @\"目的地\"\n(lldb) p/x self.title\n(__NSCFString *) $2 = 0x00007fe0c0d4d230 @\"目的地\"\n(lldb) p/t self.title\n(__NSCFString *) $3 = 0b0000000000000000011111111110000011000000110101001101001000110000 @\"目的地\"\n(lldb) p/a self.title\n(__NSCFString *) $4 = 0x00007fe0c0d4d230 -> 0x000000010d2fd2c8 (void *)0x000000010d2fd278: __NSCFString @\"目的地\"\n```\n\n### 打印输出格式化\n\n| name  | description |\n|-------|:-------|\n| x\t    |Regard the bits of the value as an integer, and print the integer in hexadecimal. |\n|d\t    |Print as integer in signed decimal. |\n|u      |Print as integer in unsigned decimal.|\n|o      |Print as integer in octal.|\n|t      |Print as integer in binary. The letter ‘t’ stands for “two”.|\n|a      |Print as an address, both absolute in hexadecimal and as an offset from the nearest preceding symbol. You can use this format used to discover where (in what function) an unknown address is located:(gdb) p/a 0x54320  $3 = 0x54320 <_initialize_vx+396>\n|c      |Regard as an integer and print it as a character constant. This prints both the numerical value and its character representation. The character representation is replaced with the octal escape ‘\\nnn’ for characters outside the 7-bit ascii range.Without this format, gdb displays char, unsigned char, and signed char data as character constants. Single-byte members of vectors are displayed as integer data.|\n|f      |Regard the bits of the value as a floating point number and print using typical floating point syntax. |\n|s      |Regard as a string, if possible. With this format, pointers to single-byte data are displayed as null-terminated strings and arrays of single-byte data are displayed as fixed-length strings. Other values are displayed in their natural types.Without this format, gdb displays pointers to and arrays of char, unsigned char, and signed char as strings. Single-byte members of a vector are displayed as an integer array.|\n|z      |Like ‘x’ formatting, the value is treated as an integer and printed as hexadecimal, but leading zeros are printed to pad the value to the size of the integer type. |\n|r      |Print using the ‘raw’ formatting. By default, gdb will use a Python-based pretty-printer, if one is available (see Pretty Printing). This typically results in a higher-level display of the value's contents. The ‘r’ format bypasses any Python pretty-printer which might exist.|\n\n--- \n\n格式： `p/x $pc`\n\n参考链接：[打印输出格式化](https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html)\n\n### lldb声明变量\n\n```\n(lldb) e NSString *$str = @\"http://www.baidu.com\"\n(lldb) po $str\nhttp://www.baidu.com\n```\n\t\n我们使用`e`开头声明了变量\n\n### 调用变量的API  \n\n```\n(lldb) po [self.title uppercaseString]\n```\n\n### 强转返回值类型\n\n```\n(lldb) po [self.title characterAtIndex:0]\nU+76ee u'目'\n\n(lldb) po (unsigned int)[self.title characterAtIndex:0]\n30446\n\n(lldb) po (char)[self.title characterAtIndex:0]\n'\\xee'\n\n(lldb) po (NSString *)[self.title characterAtIndex:0]\n0x00000000000076ee\n\n(lldb) po (unichar)[self.title characterAtIndex:0]\nU+76ee u'目'\n```\n\n### 添加断点\n\n```\nb 120\nb [KLNewDestinationVC setupUI]\n```\n\n`b`命令后面加行号，或者指定某个对象调用的方法\n\n### 设置断点触发条件\n\n右键断点处,在condition处编辑，如果设置了条件，只要当条件满足时，才会进入断点，也可以设置条件满足时发出声音和打印提示语。\n\n### 常用打印视图层次结构\n\n```\n(lldb) po [self.view recursiveDescription]\n```\n\t\n### 临时刷新界面UI\n\n```\n(lldb) e ((UIButton *)sender).backgroundColor = [UIColor redColor]\n(UICachedDeviceRGBColor *) $41 = 0x00007fdd10715b00\n(lldb) e (void)[CATransaction flush]\n```\n","tags":["LLDB"],"categories":["调试"]},{"title":"使用 facebook 的 chisel 来调试","url":"/2016/04/15/2016-04-15-shi-yong-facebookde-chisellai-diao-shi/","content":"\n### 介绍\n\n[`chisel`](https://github.com/facebook/chisel)是`facebook`开源的调试框架，封装了很多方便的`LLDB`命令便于调试iOS App，今天介绍一下使用心得以及一些常用的命令，希望对你有写帮助。\n\n**测试环境**：\n\nXcode 7.3 and iOS 9.3 simulator.\nOS:OSX 10.11.4\n\npviews and presponder doesn't work and no output.\n\n[Chisel issue on Xcode 7.3 #149](https://github.com/facebook/chisel/issues/149)\n\n作者正在努力修复中。。。\n\nXcode7.2版本没有问题\n\n### 安装\n\n\tbrew update\n\tbrew install chisel\n\t\n### 创建`~/.lldbinit` 假如不存在\n\n编辑内容: **command script import /usr/local/opt/chisel/libexec/fblldb.py**\n\n### 查看命令\n\n\t（lldb）help\n\t\n### 查看具体怎样使用\n\n\t(lldb) help border\n\t\n### 常用命令说明\n\n|Command        |Description   \t                                |\n|---------------|----------------------------------------------|\n|pviews         |Print the recursive view description for the key window.\n|pvc            |Print the recursive view controller description for the key window.\n|visualize      |Open a `UIImage`, `CGImageRef`, `UIView`, `CALayer`, `NSData` (of an image), `UIColor`, `CIColor`, or `CGColorRef` in Preview.app on your Mac.\n|fv             |Find a view in the hierarchy whose class name matches the provided regex.                        \n|fvc            |Find a view controller in the hierarchy whose class name matches the provided regex.\n|show/hide      |Show or hide the given view or layer. You don't even have to continue the process to see the changes!\n|mask/unmask    |Overlay a view or layer with a transparent rectangle to visualize where it is.\n|border/unborder|Add a border to a view or layer to visualize where it is.                               \n|caflush        |Flush the render server (equivalent to a \"repaint\" if no animations are in-flight).            \n|bmessage       |Set a symbolic breakpoint on the method of a class or the method of an instance without worrying which class in the hierarchy actually implements the method.\n|wivar          |Set a watchpoint on an instance variable of an object.\n|presponder     |Print the responder chain starting from the given object.\n\n---\n\n> Tips：直接点控制台上方第三个按钮呼出`LLDB`。\n\n#### pviews(暂不可用)\n\n显示view的层级。\n\n#### border&unborder\n\n`border`:给view或者layer添加边框颜色和边框的宽度。\n\n使用如下：\n\n\t(lldb) border 0x7ffc017b2970 -c green -w 10\n\n标示设置`0x7ffc017b2970`视图或者图层一个宽度为2的绿色边框。\n\n`unborder`:去掉view或者layer的边框颜色和边框宽度。\n\n使用如下：\n\n\tunborder 0x7ffc017b2970\n\n#### pinternals\n\n这个命令就是打印出来的一个控件（`id`）类型的内部结构。\n\n使用如下：\n\n\tpinternals 0x7ffc017b2970\n\n#### presponder（暂不可用）\n\n打印出一个继承于`UIResponder`控件的消息传递链。\n\n#### visualize\n\n可以使用mac下的预览app打开我们的图片`UIImage`, `CGImageRef`格式的图片，甚至view和layer的图片。\n\n使用如下：\n\n\tvisualize 0x79ec3140//或者变量名，此地址是id类型的\n\t\t\n#### pclass\n\npclass可以打印出一个对象的继承关系。\n\n使用如下：\n\n\tpclass 0x7fcd15108800\n\n#### taplog\n\n这个命令是模拟敲击一下屏幕，并且打印出你敲击屏幕时候事件接收的对象。\n\n#### hide&show\n\nhide命令可以直接隐藏一个对象,移除当前遮挡的对象便于你观察后面的对象。show命令会让它再次显示出来。\n\n#### bmessage\n\n这个命令就是`LLDB`添加一个断点，譬如`-viewWillAppear:`这个方法，在当前控制器中你没有实现它，但是你又想在调用它的时机触发中断。\n\n这个我就不解释了，需要补充一点的是`Objectiv-c`的方法是带`：`的。\n\n#### pvc\n\n打印出当前的控制器层级。\n\n#### wivar\n\n这个命令是加`watchPoint`。\n\n参考链接：\n\n* [Chisel常用命令总结](http://www.jianshu.com/p/f6ddf8c6485f) -- 简书\n* [与调试器共舞 - LLDB 的华尔兹](http://objccn.io/issue-19-2/) -- objccn.io\n* [Dancing in the Debugger — A Waltz with LLDB](https://www.objc.io/issues/19-debugging/lldb-debugging/) -- objc.io\n\t                               \n","tags":["chisel"],"categories":["调试"]},{"title":"Associated Objects 关联对象","url":"/2016/04/14/2016-04-14-associated-objects-guan-lian-dui-xiang/","content":"\n##  Associated Objects 介绍\n`<objc/runtime.h>`中的函数号称是**iOS**中最后一把神兵利刃，具有其他方式做不到的，能为应用和框架提供强大功能的能力。但使用不当也可能废掉代码的,一切代码和逻辑都可能被异常糟糕的副作用影响。\n\n就像和魔鬼做交易一样常常让人怀着巨大的恐惧。\n\n## 历史\n\n对象关联（或称为关联引用）本来是`Objective-C 2.0`运行时的一个特性，起始于`OS X Snow Leopard`和`iOS4`。\n\n核心函数3个 -- 允许将任何键值在允许时关联到对象上\n\n* objc_setAssociatedObject\n* objc_getAssociatedObject\n* objc_removeAssociatedObjects\n\n这有什么用呢？这允许开发者对**已经存在的类在扩展中添加自定义的属性**\n\n## 实现的3种方式\n\n* `static char`\n* `selector`\n* `_cmd_`\n\n### 使用 `static char` 实现\n\n**NSObject+AssociatedObject.h**\n\n```objc\n@interface NSObject (AssociatedObject)\n@property (nonatomic, strong) id associatedObject;\n@end\n```\n**NSObject+AssociatedObject.m**\n\n```objc\n@implementation NSObject (AssociatedObject)\n\nstatic char kAssociatedObjectKey;\n\n- (id)associatedObject\n{\n    return objc_getAssociatedObject(self,&kAssociatedObjectKey);\n}\n\n- (void)setAssociatedObject:(id)associatedObject\n{\n    objc_setAssociatedObject(self, &kAssociatedObjectKey, associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n@end\n```\n\n### 使用 `selector` 实现\n\n**NSObject+AssociatedObject.h**\n\n```objc\n@interface NSObject (AssociatedObject)\n@property (nonatomic, strong) id associatedObject;\n@end\n```\n\n**NSObject+AssociatedObject.m**\n\n```objc\n@implementation NSObject (AssociatedObject)\n\n- (id)associatedObject\n{\n    return objc_getAssociatedObject(self, @selector(associatedObject));\n}\n\n- (void)setAssociatedObject:(id)associatedObject\n{\n    objc_setAssociatedObject(self, @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n@end\n```\n\n### 使用 `_cmd_` 实现\n\n**NSObject+AssociatedObject.h**\n\n```objc\n@interface NSObject (AssociatedObject)\n@property (nonatomic, strong) id associatedObject;\n@end\n```\n\n**NSObject+AssociatedObject.m**\n\n```objc\n@implementation NSObject (AssociatedObject)\n\n- (id)associatedObject\n{\n    return objc_getAssociatedObject(self, _cmd_);\n}\n\n- (void)setAssociatedObject:(id)associatedObject\n{\n    objc_setAssociatedObject(self, @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n@end\n```\n\n## 关联对象的行为\n\n属性根据枚举类型`objc_AssociationPolicy`来决定被关联在对象上的行为：\n\n\n|Behavior                          |与之等效的@property             |\n|----------------------------------|-------------------------------|\n|OBJC_ASSOCIATION_ASSIGN           | @property (assign) 或@property (unsafe_unretained)                |\n|OBJC_ASSOCIATION_RETAIN_NONATOMIC | @property (nonatomic, strong) |\n|OBJC_ASSOCIATION_COPY_NONATOMIC   | @property (nonatomic, copy)   |\n|OBJC_ASSOCIATION_RETAIN           | @property (atomic, strong)    |\n|OBJC_ASSOCIATION_COPY \t\t\t    | @property (atomic, copy)      |\n\n----\n\n> `OBJC_ASSOCIATION_ASSIGN`类型关联对象的弱引用不代表**weak**的弱引用，行为上更像`unsafe_unretained`属性。\n\n## 对象销毁时间\n\n被关联的对象在声明周期内比对象本身释放要晚很多，在对象调用`-dealloc`中的`object_dispose()`中释放。\n\n## 删除属性\n\n你或许想要使用`objc_removeAssociatedObjects（）`来进行删除操作，但官方文档不建议手动调用这个函数。\n\n这个函数可能会把其他用户对其添加的属性也移除了，正确的方式是调用`objc_setAssociatedObject`方法，传入`nil`值来清楚一个关联。\n\n## 优秀样例\n\n* 添加私有属性用于更好地去实现细节。\n* 添加public属性来增强category的功能。\n* 创建一个用于KVO的关联观察者。\n\n## 应用举例\n\n### UIImagePickerController 图片选择回调\n\n关联一个block实现完成选择图片后的回调。\n\n\n#### UIImagePickerController+RFBlocks.h\n\n```objc\n@interface UIImagePickerController (RFBlocks)<UIImagePickerControllerDelegate, UINavigationControllerDelegate>\n\ntypedef void(^RFImagePickerFinishBlock)(NSDictionary *info);\n\n@property (nonatomic, copy) RFImagePickerFinishBlock rf_finishBlock;\n\n+ (UIImagePickerController *)rf_imagePickerWithFinishBlock:(RFImagePickerFinishBlock)finishBlock;\n\n@end\n```\n\n#### UIImagePickerController+RFBlocks.m\n\n```objc\nstatic const char kFinishBlockKey;\n\n@implementation UIImagePickerController (RFBlocks)\n\n+ (UIImagePickerController *)rf_imagePickerWithFinishBlock:(RFImagePickerFinishBlock)finishBlock\n{\n    UIImagePickerController *picker = [[UIImagePickerController alloc] init];\n    picker.rf_finishBlock = finishBlock;\n    \n    return picker;\n}\n\n- (RFImagePickerFinishBlock)rf_finishBlock {\n    return objc_getAssociatedObject(self, &kFinishBlockKey);\n}\n\n- (void)setRf_finishBlock:(RFImagePickerFinishBlock)rf_finishBlock {\n    self.delegate = self;\n    \n    objc_setAssociatedObject(self, &kFinishBlockKey, rf_finishBlock, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n\n#pragma mark - UIImagePickerControllerDelegate\n\n- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary<NSString *,id> *)info\n{\n    RFImagePickerFinishBlock block = self.rf_finishBlock;\n    \n    if (block)  block(info);\n    \n    [self dismissViewControllerAnimated:YES completion:nil];\n    \n    self.rf_finishBlock = nil;\n}\n\n@end\n```\n\n使用：\n\n```objc\n__weak typeof(self)weakSelf = self;\n\nUIImagePickerController *picker =  [UIImagePickerController rf_imagePickerWithFinishBlock:^(NSDictionary *info) {\n        NSLog(@\"finish picke image\\n info:%@\",info);\n        \n        UIImage *img = info[@\"UIImagePickerControllerOriginalImage\"];\n        weakSelf.view.layer.contents = (id)img.CGImage;\n    }];\n[self presentViewController:picker animated:YES completion:nil];\n```\n或者\n\n```objc\nUIImagePickerController *picker = [[UIImagePickerController alloc] init];\n    \n__weak typeof(self)weakSelf = self;\n\npicker.rf_finishBlock = ^(NSDictionary *info) {\n    NSLog(@\"finish picke image\\n info:%@\",info);\n    \n    UIImage *img = info[@\"UIImagePickerControllerOriginalImage\"];\n    weakSelf.view.layer.contentsGravity = kCAGravityResizeAspect;\n    weakSelf.view.layer.contents = (id)img.CGImage;\n};\n\n[self presentViewController:picker animated:YES completion:nil];\n```\n\n### UIButton 按钮事件回调\n\n关联一个按钮事件block，当触发按钮`UIControlEventTouchUpInside`事件时回调。\n\n##### UIButton+RFBlcoks.h\n\n```objc\n@interface UIButton (RFBlcoks)\n\ntypedef void(^RFButtonClickBlock)(UIButton *button);\n\n@property (nonatomic, copy) RFButtonClickBlock rf_buttonClickBlock;\n\n@end\n```\n\n##### UIButton+RFBlcoks.m\n\n```objc\nstatic char kButttonClickBlockKey;\n\n@implementation UIButton (RFBlcoks)\n\n- (RFButtonClickBlock)rf_buttonClickBlock\n{\n    return objc_getAssociatedObject(self, &kButttonClickBlockKey);\n}\n\n- (void)setRf_buttonClickBlock:(RFButtonClickBlock)rf_buttonClickBlock\n{\n    objc_setAssociatedObject(self, &kButttonClickBlockKey, rf_buttonClickBlock, OBJC_ASSOCIATION_COPY_NONATOMIC);\n    \n    [self addTarget:self action:@selector(buttonClicked) forControlEvents:UIControlEventTouchUpInside];\n}\n\n- (void)buttonClicked\n{\n    if (self.rf_buttonClickBlock) {\n        self.rf_buttonClickBlock(self);\n    }\n}\n\n@end\n```\n\n使用：\n\n```\nself.button.rf_buttonClickBlock = ^(UIButton *button){\n        NSLog(@\"%@ clicked\",button);\n};\n```\n\nDemo地址：\n\n* [AssociatedObjectDemo](https://github.com/wangruofeng/AssociatedObjectDemo)\n\n参考资料：\n\n* [Associated Objects](http://nshipster.cn/associated-objects/) -- NSHipster\n* [Objective-C Associated Objects](http://kingscocoa.com/tutorials/associated-objects/) -- King's Cocoa\n* [Objective-C Associated Objects 的实现原理](http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/)-- 雷纯峰的技术博客\n* [Associated Objects by Example](http://www.sebastianrehnby.com/blog/2013/01/24/associated-objects-by-example/) -- Sebastian Rehnby\n","tags":["Runtime"],"categories":["系统原理"]},{"title":"玩转 iOS 剪切板","url":"/2016/04/14/2016-04-14-wan-zhuan-iosjian-qie-ban/","content":"\n\n### 前言\n\n移动应用风靡的今天，大家越来越觉得，一个App的处理事情的效率至关重要，包括一些细节处理，像`本地化`（**localization**）和`辅助功能`（**accessibility**）的支持是高品质的应用和其它应用区分开的两个特性，今天我们来聊聊一个增加用户体验和效率的功能--`编辑操作`\n\n### 编辑操作\n\n####  标准编辑动作\n\n##### 处理复制，剪切，删除和粘贴命令\n\n* `复制`（**copy:**）\n* `剪切`（**cut:**）\n* `删除`（**delete:**）\n* `粘贴`（**paste:**）\n\n##### 处理选择命令\n\n* `选择`（**select:**）\n* `全选`（**selectAll:**）\n\n##### 富文本编辑命令\n\n* `加粗`（**toggleBoldface:**）\n* `斜体`（**toggleItalics:**）\n* `下划线`（**toggleUnderline:**）\n\n##### 改变书写方向命令\n\n* `书写方向左到右`（**makeTextWritingDirectionLeftToLeft:**）\n* `书写方向右到左`（**makeTextWritingDirectionRightToLeft:**）\n\n##### 改变文本尺寸命令\n\n* `变大`（**increaseSize:**）\n* `变小`（**decreaseSize:**）\n\n### 实现label的复制粘贴功能\n\n```objc\n// RFLabel.h\n@interface RFLabel : UILabel\n@end\n\n// RFLabel.m\n@implementation RFLabel\n\n- (BOOL)canBecomeFirstResponder {\n    return YES;\n}\n\n- (BOOL)canPerformAction:(SEL)action\n              withSender:(id)sender\n{\n    return (action == @selector(copy:) || action == @selector(paste:));\n}\n\n#pragma mark - UIResponderStandardEditActions\n\n- (void)copy:(id)sender {\n    [[UIPasteboard generalPasteboard] setString:self.text];\n}\n\n- (void)paste:(id)sender {\n    NSString *toBePastedString = [[UIPasteboard generalPasteboard] string];\n    self.text = toBePastedString;\n}\n\n@end\n```\n\n在控制器中使用它：\n\n```objc\n#import \"ViewController.h\"\n#import \"RFLabel.h\"\n\n@interface ViewController ()\n\n@property (weak, nonatomic) IBOutlet RFLabel *topLabel;\n@property (weak, nonatomic) IBOutlet RFLabel *bottomLabel;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view, typically from a nib.\n\n    self.topLabel.userInteractionEnabled = YES;\n    self.bottomLabel.userInteractionEnabled = YES;\n\n    UIGestureRecognizer *gestureRecognizer1 = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handleLongPressGesture:)];\n    UIGestureRecognizer *gestureRecognizer2 = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handleLongPressGesture:)];\n\n    [self.topLabel addGestureRecognizer:gestureRecognizer1];\n    [self.bottomLabel addGestureRecognizer:gestureRecognizer2];\n}\n\n- (void)handleLongPressGesture:(UIGestureRecognizer *)recognizer\n{\n    if (recognizer.state == UIGestureRecognizerStateRecognized) {\n        [recognizer.view becomeFirstResponder];\n\n        UIMenuController *menuController = [UIMenuController sharedMenuController];\n        [menuController setTargetRect:recognizer.view.frame inView:recognizer.view.superview];\n        [menuController setMenuVisible:YES animated:YES];\n    }\n}\n\n@end\n```\n\n总结一下，为了能够支持复制粘贴一个label的文字，需要完成下面几步：\n\n* 必须继承 `UILabel`,在子类中实现`canBecomeFirstResponder`和`canPerformAction:withSender:`方法\n* 实现每个可以执行的操作，在方法中和`UIPasteboard`进行交互\n* 初始化label时，将label的`userInteractionEnabled`属性设置为`YES`\n* 向label添加一个手势（或者手动在子类中实现`UIResponder`的方法，例如`touchesBegan:withEvent:`）\n* 响应手势识别事件，指明`UIMenuController`的位置，设置为可见\n* 最后，使label成为第一响应者\n\n\n### UIMenuController\n\n`UIMenuController`负责展示编辑动作的菜单项。每个应用都持有自己的一个单例对象 sharedMenuController。\n默认情况下，菜单控制器会展示`UIResponderStandardEditActions`这个非正式协议（即不需要对应实现的协议）中的方法，\n假如`canPerformAction:withSender:`返回`YES`。\n\n### UIMenuItem\n\n可以通过`UIMenuController`的`menuItems`属性添加自定义的命令，每一个都是`UIMenuItem`对象，只需要指定每个动作的`title`和`action`\n\n```objc\n- (instancetype)initWithTitle:(NSString *)title action:(SEL)action NS_DESIGNATED_INITIALIZER;\n```\n\n### UITableView 和 UICollectionView\n\n`UITableView`和`UICollectionView`可以在cell上调出编辑菜单,其实任何自定义的`UIView`都能实现，`UIViewController`的子类只是以不同的方式实现而已。为了让`UITableView`和`UICollectionView`也能实现，你需要使用一些额外的方法否则屏幕上不会显示任何东西。这些方法给予了你更多的控制在显示指定的上下文菜单基于你将要显示在`UITableView`和`UICollectionView`的内容。\n\n#### **UITableViewDelegate** 方法\n\n* – tableView:shouldShowMenuForRowAtIndexPath:\n* – tableView:canPerformAction:forRowAtIndexPath:withSender:\n* – tableView:performAction:forRowAtIndexPath:withSender:\n\n#### **UICollectionViewDelegate** 方法\n\n* – collectionView:shouldShowMenuForItemAtIndexPath:\n* – collectionView:canPerformAction:forItemAtIndexPath:withSender:\n* – collectionView:performAction:forItemAtIndexPath:withSender:\n\n### Bonus\n\n实现`UIImageView`图片的复制粘贴功能\n\nDemo地址：\n\n* [Menu_Controller_Demo](https://github.com/wangruofeng/Menu_Controller_Demo)\n\n### 参考链接\n\n* [UIMenuController](http://nshipster.cn/uimenucontroller/) -- nshipster\n* [UIMenuController_Class](https://developer.apple.com/library/ios/documentation/iPhone/Reference/UIMenuController_Class/) -- UIMenuController Class Reference\n* [Show the UIMenuController and Display Custom Edit Menus](http://supereasyapps.com/blog/2014/4/17/show-the-uimenucontroller-and-display-custom-edit-menus-for-uiviewcontroller-uitableviewcontroller-and-uicollectionview-on-ios-7)\n* [UITableViewCell on iOS 5](https://www.captechconsulting.com/blogs/getting-started-with-uimenucontroller-in-ios-5)\n* [UITableViewController](https://github.com/jszumski/uimenucontroller-example) -- Demo\n","tags":["剪切板"],"categories":["系统原理"]},{"title":"创建自定义 View 在 IB 中实时渲染","url":"/2016/04/10/2016-04-10-chuang-jian-zi-ding-yi-viewzai-ibzhong-shi-shi-xuan-ran/","content":"\n曾想自定义的View，可以像系统自带属性一样，并且实时渲染，动态更新内容，现在在Xcode6终于让你可以轻松的做到。\n\n你不用编译就能实时预览，现在配置自定义界面方便多了，`IBInspectable`和`IBDesignable`使它成为可能。\n\n### IBInspectable\n\n`IBInspectable`属性提供访问旧功能的新方法：用户自定义的运行时属性。从目前的身份检查器（identity inspector）中访问，这些属性在Interface Builder整合到Xcode。可以通过它来配置Nib，Xib，storyboard实例中的任何键值编码（key-value-coded）属性：\n\n![runtime Attributes setting](/images/ib_Inspectable/ib_01.jpg)\n\n以前想实现，只能点+号手动添加例如想给`UIView`添加一个圆角半径，设置Key Path 为：layer.cornerRadius,type为Number ，Value为4，如果使用`IBInspectable`只需要在`@property` 声明后加上IBInspectable（或者swift 加上`@IBInspectable`），就可以在IB的观察面板中（inspector pannel）里直接编辑。其他交由Xcode自动完成，属性名字会自动分组，名称从驼峰（camel-）转换成 title-模式。\n\n![inspector pannel](/images/ib_Inspectable/ib_02.jpg)\n\n目前可检查属性支持\n\n![supported  types](/images/ib_Inspectable/ib_03.jpg)\n\n备注 :\n\n1. 经本人亲测，除`NSNumber`,`NSRange`不会产生观察面板属性，`NSRange`不会在runtime Attributes 中自动添加，其他都会自动生成。\n\n2. 支持颜色类型`UIColor`但是不支持`CALayer`的`CGColor`，设置颜色时只需设置`UIColor`，不要要设置`CGColor`，系统会自动将UIColor转换，例如设置borderColor。\n\n\n\n### IBDesignable\n\n当你应用到`UIView`或者`UIView`的子类中的时候，只需加上`IBDesignable`，就可以让IB在画布上实时渲染视图。当你更新属性后，视图会自动更新不需要重新运行程序。\n\n\n标记一个自定义视图为`IBDesignable`，只需要在类名前面加上`IB_DESIGNABLE`（`Swift`里加上`@IBDesignable`）。你的初始化，布置和绘制方法都将用来在画布上渲染你的自定义视图:\n\n```objc\nIB_DESIGNABLE\n\n@interface CustomView :UIView {\n\n@property (nonatomic, strong) IBInspectable UIColor *borderColor;\t\t\n@property (nonatomic, assign) IBInspectable CGFloat borderWidth;\n\n...\n\n}\n\n@end\n```\n\n实时效果：\n\n![custom view](/images/ib_Inspectable/ib_04.jpg)\n\n\n有了这个功能，一个设计师或者开放人员可以轻松调整自定义的控件呈现。任何改变，都将立即呈现，有的想`Swift`里面的playground功能，实现：**所见即所得**。\n\n\n由于在 Interface Builder 中呈现自定义视图不会有应用程序的完整上下文，你可能需要生成模拟数据以便显示，例如一个默认用户头像图片或仿制的天气数据。有两种方法可以为这个特殊的上下文添加代码：\n\n\n1. `prepareForInterfaceBuilder()` :此方法与你代码的其余部分一起编译，但只有当视图正在准备在Interface Builder显示时执行\n\n2. TARGET_INTERFACE_BUILDER:#if TARGET_INTERFACE_BUILDER预处宏,在 `Objective-C` 或 `Swift` 下都是工作的，它会视情况编译正确代码\n\n```C\n#if !TARGET_INTERFACE_BUILDE\n\n// this code will run in the app it self\n\n#els\n\n// this code will execute only in IB\n#endif\n```\n\n\n参考资料:\n\n* [IBInspectable-IBDesignable](http://nshipster.cn/ibinspectable-ibdesignable/)\n* [Apple 官方介绍](https://developer.apple.com/library/ios/recipes/xcode_help-IB_objects_media/Chapters/CreatingaLiveViewofaCustomObject.html)\n\nDemo地址:\n\n* [IBInspectable_IBDesignable_Demo](https://github.com/xyzyzyxyz/IBInspectable_IBDesignable_Demo_1.0/tree/master)\n","tags":["IB"],"categories":["系统 API"]},{"title":"Unix Shell 常用命令","url":"/2016/03/27/2016-03-27-unixshellchang-yong-ming-ling/","content":"\n输出文件内容到基本输出\n\n\tcat filename\n\n改变文件的权限\n\n\tchmod 或\n\tchange mode\n\n当前的时间和日期\n\n\tdate\n\n拷贝\n\n\tcopy\n\n显示当前目录下所有文件以及文件夹\n\n\tls\n\n显示dir文件夹下所有文件以及文件夹\n\n\tls dir\n\n查看磁盘空间状况\n\n\tdu\n\n查看当前进程状况\n\n\tps\n\n你的用户名和终端类型\n\n\twho\n\n创建目录\n\n\tmkdir  dir\n\n删除目录\n\n\trmdir  dir\n\n进入目录\n\n\tcd     dir\n\n删除文件\n\n\trm     file\n\n显示文件\n\n\tmore file\n\n显示指定文本\n\n\techo\n\n改文件名、移动文件\n\n\tmv  source target\n\n显示目录路径命令\n\n\tpwd\n\n清屏\n\n\tclear\n\n退出输入命令\n\n\tCtrl + c   \n\n改变文件或目录之最后修改时间\n\n\ttouch  name\n\n删除目录\n\n\t rmdir directory-name 或\n\t rm -r directory-name\n\n> * rmdir dir1 删除目录 dir1，但 dir1 下必须没有文件存在，否则无法删除。\n> * rm -r dir1 删除目录 dir1，及其下所有文件及子目录。\n\n删除文件\n\n\trm filename (filename 可为文件名，或文件名缩写符号。)\n\n> * rm file1 删除文件名为 file1 之文件。\n> * rm file? 删除文件名中有五个字符，前四个字符为file 之所有文件。\n> * rm f* 删除文件名中，以 f 为字首之所有文件。\n> * rm -rf file 删除名为file的文件夹及其里面的内容\n","tags":["shell"],"categories":["CLI"]},{"title":"Git 常用命令","url":"/2016/03/27/2016-03-27-gitchang-yong-ming-ling/","content":"\n\n### 创建新的仓库\n\n* 新建文件夹，打开，执行\n\n\t\tgit init\n\t\n### 检出仓库\n* 创建一个本地仓库克隆版本\n\n\t\tgit clone /path/to/repository\n\t\t\n* 创建远程服务器上的仓库\n\t\t\n\t\tgit clone username@host:/path/to/repository\n\n###  Git工作流\n\n一个本地仓库由git维护的3客\"树\"组成。\n\n1. 工作目录` working dic`。 -- 它持有实际文件\n2. 暂存区`Index`。 -- 它像个缓冲区域，临时保存你的改动\n3. `HEAD`。  -- 它指向你最后一次提交的结果\n\n \nwork flow：`working dic` --add-- ==> `Index` --commit-- ==>`HEAD`\n\n### 添加和提交\n\n* 添加到暂存区\n\t\n\t\tgit add <filename>\n\t\tgit add *\n\t\tgit add .\n\t\t\n* 提交到HEAD\n\t\t\n\t\tgit commit -m 'some comment'\n\t\tgit commit -m \"some comment\"\n\t\t\n* 添加提交二合一\t\n\t\n\t\tgit commit -a -m 'some comment'\n\n### 查看仓库修改状态\n\n\tgit status\n\t\n### 推送更改\n\n* 现在的改动已经提交到本地仓库的`HEAD`中，提交到远程仓库\n\t\n\t\tgit push\n\t\t\n> 格式`git push (remote) (branch)`,\n> 第一次push必须这样写 `git push origin master:master`\n\n### 推送到具体某一分支\n\n\tgit push origin someBranch\n\n### 分支操作\n\n* 查看分支\n\t\n\t\tgit branch\n* 查看分支最后提交状态\n\t\n\t\tgit branch -v\n> `--merged` 与 `--no-merged` 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 `git branch --merged`\n\n\t    aBranch\n\t    iss53\n      * master\n\n* 新建分支\n\t\n\t\tgit branch aBranch\n\n* 切换到`aBranch`分支\n\t\n\t\tgit checkout aBranch\n\t\t\n* 新建切换分支2合一\n\t\n\t\tgit checkout - b aBranch\n\t\t\n* 删除分支\n\t\t\n\t\tgit branch -d aBranch\n\t\t\n如果将要删除的分支还有没有合并的内容，删除将会失败，使用`-D`强制删除\n\n\terror: The branch 'testBranch' is not fully merged.\n\tIf you are sure you want to delete it, run 'git branch -D testBranch'.\n\n* 分支重命名\n\t\t\n\t\tgit branch -m oldBranchName newBranchName\n\n\n### 分支操作实例\n`master`是默认的分支。在其他分支上进行开发，完成后再将他们合并到主分支上。\n\n1. 创建一个叫“feature_x”的分支，并切换过去\n\t\n\t\tgit checkout -b feature_x\n\n2. 切换回主分支：\n\t\t\n\t\tgit checkout master\n\t\t\n3. 删除新建分支\n\t\n\t\tgit branch -d feature_x\n\t\t\n4. 将分支推送到远程仓库\n\t\n\t\tgit push origin <branch>\n\t\t\n\n### 更新与合并\n\n* 更新你的本地仓库到最新改动\n\t\n\t\tgit pull\n\n会在你的工作目录 抓取`fetch`并合并`merge`远端的改动\n\n* 合并`aBranch`分支回`master`分支\n\n\t\tgit checkout master\n\t\tgit merge aBranch\n\n这种方式叫做直接合并（straight merge）\n注意没参数的情况下`merge`是`fast-forward`的，即Git将`master`分支的指针直接移到`aBranch`的最前方。\n\n换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么Git在合并两者时，只会简单移动指针，所以这种合并成为快进式(`Fast-forward`)\n\n### 如何避免每次输入密码\n\n如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。\n\n如果不想在每一次推送时都输入用户名与密码，你可以设置一个 `credential cache`。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 `git config --global credential.helper cache` 来设置它。\n\n### 压合合并`squashed commits`\n\n将一条分支上的若干个提交条目压合成一个提交条目，提交到另一条分支的末梢。\n\n把`aBranch`分支上的所有提交压合成主分支上的一个提交，即压合提交：\n\n\tgit checkout master\n\tgit merge --squash aBranch\n\n此时，`aBranch`上的所有提交已经合并到当前工作区并暂存，但还没有作为一个提交，可以像其他提交一样，把这个改动提交到版本库中：\n\n\tgit commit -m 'some comment'\n\t\n### 拣选合并`cherry-picking`\n\n拣选另一条分支上的某个提交条目的改动带到当前分支上。\n\n每一次提交都会产生一个全局唯一的提交名称，利用这个名称就可以进行拣选提交。\n\n比如在dev上的某个提交叫：`321d76f`\n\n把它合并到`master`中：\n\n\tgit checkout master\n\tgit cherry-pick 321d76f\n\t\n要拣选多个提交，可以给`git cherry-pick`命令传递`-n`选项，比如：\n\n\tgit cherry-pick –n 321d76f\n\n这样在拣选了这个改动之后，进行暂存而不立即提交，接着可以进行下一个拣选操作，一旦拣选完需要的各个提交，就可以一并提交。\n\n如果发生冲突，解决冲突完后执行`git cherry-pick --continue`继续拣选合并。\n\t\t\n### 解决冲突（conflicts）\n\n1. 通过`CONFLICT (content):`找到冲突文件所在的位置\n2. 打开冲突文件，修改冲突后保存\n3. 通过`git status`查看冲突是否解决\n4. 通过`git diff <source_branch> <target_banch>`预览差异 \n5. 提交更改`git commit -a -m 'some comment'`\n\n### 查看远程分支的完整列表\n\n\tgit ls-remote\n\n### 获取远程分支更多信息\n\t\n\tgit remote show\n\n### 新建远程分支\n\n\tgit push --set-upstream origin newBranch\n\t\n### 提交分支数据到远程服务器\n\t\n\tgit push origin <local_branch_name>:<remote_branch_name>\n\n### 删除远程分支\n\n\tgit push origin :develop\n\tgit push origin --delete develop\n\t\n### 标签\n\n创建一个1.0.0的标签\n\t\n\tgit tag 1.0.0 1b2e1d63ff\n\t\n**1b2e1d63ff**是你想要标记的提交ID的前10位字符，可使用下列命令获取提交ID\n\n\tgit log\n\t\n### 替换本地改动\n\t\n\tgit checkout -- <filename>\n\t\n此命令会使用`HEAD`中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。\n\n假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它\n\n\tgit fetch orgin\n\tgit reset --hard origin/master\n\t\n\n参考链接\n\n* [Git - 简明指南](http://rogerdudler.github.io/git-guide/index.zh.html)\n* [Git社区参考指南](https://git-scm.com/book/en/v2)\n* [Github Help](https://help.github.com)\n* [图解Git](http://marklodato.github.io/visual-git-guide/index-zh-cn.html)\n* [Think like a git](http://think-like-a-git.net)\n","tags":["Git"],"categories":["CLI"]},{"title":"使用 Mantle 高效构建 Model","url":"/2016/03/03/2016-03-03-shi-yong-mantlegao-xiao-gou-jian-model/","content":"\n### 概述\n\n在iOS开发中，从服务器获取数据，然后解析成本地的模型是经常的要做事，而且重复次数特别多，每次增加一个网络请求或者增加一个模型都需要完成`JSON`到`Model`层的转换，手写通过字典`valueForKey:`直接解析已经更不上时代的步伐，学会利用工具提高自己的工作效率，今天就分享一下`Mantle`这个框架解析的心得。\n\n`Mantle`解决的痛点：\n\n* 服务器经常更新（添加或者删除）字段，客服端需要在`Model`层初始化的时候修改取值字段，易出错，而且繁琐。\n* 实现自定义的`Model`的序列化，以便将数据保存到本地，也就是说实现`NSCoding`协议，在模型复制的情况下添加或者修改字段非常麻烦。\n* 自定义的`Model`的`Copy`,你必须手动实现`NSCopying`协议,而且没有办法反序列化成`JSON`。\n\n`Mantle`很好的解决的以上痛点：\n\n* 实现了`NSCopying`协议。\n* 实现了`NSCoding`协议，可以通过`NSKeyedArchiver`将数据归档到本地。\n* 提供了`isEqual:`和`hash`的默认实现。\n* 可以在`Model`和`JSON`之间互相转换。\n\n\n\n\n以一个`CATProfile`模型类为例，演示这个框架怎样以一种非常简单的方式将一个`NSDictionary`对象映射成一个`Objective-C`,反之亦然。\n\n下面的`CATProfile`模型\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Objective Cat\",\n  \"birthday\": \"2013-09-12 13:29:36 +0100\",\n  \"website\": \"http://objc.at\",\n  \"location\": { \"lat\": \"48.2083\", \"lon\": \"16.3731\" },\n  \"relationship_status\": \"single\",\n  \"awesome\": true\n}\n```\n\n下面我们创建一个`MTLModel`子类代表以上的`Json`对象。\n\n```objc\n\n// CATProfile.h\ntypedef NS_ENUM(NSInteger, CATRelationshipStatus) {\n    CATRelationshipStatusSingle = 0,\n    CATRelationshipStatusInRelationship,\n    CATRelationshipStatusComplicated\n};\n\n@interface CATProfile : MTLModel<MTLJSONSerializing>\n\n@property(strong, nonatomic) NSNumber *profileId;\n@property(strong, nonatomic) NSString *name;\n@property(strong, nonatomic) NSDate *birthday;\n@property(strong, nonatomic) NSURL *website;\n@property(nonatomic) CLLocationCoordinate2D locationCoordinate;\n@property(nonatomic) CATRelationshipStatus relationshipStatus;\n@property(nonatomic, getter=isAwesome) BOOL awesome;\n\n@end\n\n```\n\n`CATProfile`类继承自`MTLModel`并且实现了`MTLJSONSerializing`，协议要求实现`+JSONKeyPathsByPropertyKey`方法\n\n```objc\n\n// CATProfile.m\n@implementation\n\n+ (NSDictionary *)JSONKeyPathsByPropertyKey {\n    // properties defined in header < : > key in JSON Dictionary\n    return @{\n             @\"profileId\":          @\"id\",\n             @\"websiteURL\":         @\"website\",\n             @\"locationCoordinate\": @\"location\",\n             @\"relationshipStatus\": @\"relationship_status\",\n            };\n}\n\n@end\n\n```\n\n`+JSONKeyPathsByPropertyKey`方法返回一个在JSON数据中需要模型的属性匹配的值的字典，这能确保`Mantle`知道那个JSON键键使用来构成一个指定的模型接口。\n\n很明显除了这个列表中的`name`,`birthday`和`awesome`属性。假如一个属性在字典中被忽略，`Mantle`将自动在JSON中查找带有相同名称的接口。\n\n**NSValueTransformer**\n\n`Mantle`还能够处理任意类型的转换，例如 `NSString` 和 `NSNumber` 默认支持。然而，它也需要一些帮助对于处理非任意的类型例如`NSURL`和`枚举`还有自定义的结构体像`CLLocationCoordinate2D`。\n\n`Mantle`依赖**Foundation**框架下`NSValueTransformer`对象来实现在模型代表的JSON层和OC对象的实际接口之间的值的映射。\n\n创建一个自定义**transformer**给某个属性，我们需要实现一个叫做`+<propertyName>JSONTransformer`的类方法并且返回一个想要的`NSValueTransformer`对象。\n\n```objc\n// mapping birthday to NSDate and vice-versa\n+ (NSValueTransformer *)birthdayJSONTransformer {\n    return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSString *dateString) {\n        return [self.dateFormatter dateFromString:dateString];\n    } reverseBlock:^(NSDate *date) {\n        return [self.dateFormatter stringFromDate:date];\n    }];\n}\n\n+ (NSDateFormatter *)dateFormatter {\n    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];\n    dateFormatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@\"en_US_POSIX\"];\n    dateFormatter.dateFormat = @\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n\n    return dateFormatter;\n}\n```\n\n`Mantle`在`runtime`调用这个方法来决定怎样变换 **birthday** 属性，正向转换block从一个字符串对象到一个`NSDate`对象，反向转换block将`NSDate`对象转换回一个字符串对象，非常棒！\n\n下面列举了一些变换方法，对于所有的我们需要注意的非任意属性以供参考。\n\n### NSURL ↔︎ JSON string\n\n```objc\n+ (NSValueTransformer *)websiteURLJSONTransformer {\n    return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];\n}\n```\n\n### CLLocationCoordinate2D ↔︎ JSON object\n\n```objc\n+ (NSValueTransformer *)locationCoordinateJSONTransformer {\n    return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSDictionary *coordinateDict) {\n        CLLocationDegrees latitude = [coordinateDict[@\"lat\"] doubleValue];\n        CLLocationDegrees longitude = [coordinateDict[@\"lon\"] doubleValue];\n        return [NSValue valueWithMKCoordinate:CLLocationCoordinate2DMake(latitude, longitude)];\n    } reverseBlock:^(NSValue *coordinateValue) {\n        CLLocationCoordinate2D coordinate = [coordinateValue MKCoordinateValue];\n        return @{@\"lat\": @(coordinate.latitude), @\"lon\": @(coordinate.longitude)};\n    }];\n}\n```\n\n### enum ↔︎ JSON string\n\n```objc\n+ (NSValueTransformer *)relationshipStatusJSONTransformer {\n    return [NSValueTransformer mtl_valueMappingTransformerWithDictionary:@{\n        @\"single\": @(CATRelationshipStatusSingle),\n        @\"relationship\": @(CATRelationshipStatusInRelationship),\n        @\"complicated\": @(CATRelationshipStatusComplicated)\n    }];\n}\n```\n\n### BOOL ↔︎ JSON boolean\n\n```objc\n+ (NSValueTransformer *)awesomeJSONTransformer {\n    return [NSValueTransformer valueTransformerForName:MTLBooleanValueTransformerName];\n}\n```\n\n###  从JSON创建模型对象\n\n一旦模型配置完成，就该获得JSON对象从API中，并且把它转换成我们模型的一个实例。首先，我们需要把JSON呈现转换成一个`NSDictionary`,它能够用来通过`Mantle`来创建我们的模型，很幸运的是iOS提供了一个非常棒的方法来处理它，就是通过`NSJSONSerialization`。\n\n那样以后，`MTLJSONAdapter`类就能利用`Mantle`做繁重的工作来创建我们的模型。\n\n```objc\n// create NSDictionary from JSON data\nNSData JSONData = ... // the JSON response from the API\nNSDictionary *JSONDict = [NSJSONSerialization JSONObjectWithData:JSONData options:0 error:NULL];\n\n// create model object from NSDictionary using MTLJSONSerialisation\nCATProfile *profile = [MTLJSONAdapter modelOfClass:CATProfile.class fromJSONDictionary:JSONDict error:NULL];\n```\n\n### 从模型对象创建JSON\n\n`MTLJSONAdapter`也有能力创建一个字典从我们的的模型类中，以便能直接编码回一个JSON字符串。\n\n```objc\n// create NSDictionary from model class using MTLJSONSerialisation\nCATProfile *profile = ...\nNSDictionary *profileDict = [MTLJSONAdapter JSONDictionaryFromModel:profile];\n\n// convert NSDictionary to JSON data\nNSData *JSONData = [NSJSONSerialization dataWithJSONObject:profileDict options:0 error:NULL];\n```\n\n> 假如当创建一个JSON呈现你的模型是在你的模型中有一个属性不应该包括，你应该返回`NSNull.null`,例如。在`+JSONKeyPathsByPropertyKey`的@{\"name\" : \"NSNull.null\"}。`Mantle`将安全的忽略这个属性。\n\n### 映射数组和字典\n\n大多数情况，模型和其他模型有关系，这些关系普遍通过JSON数组或者对象来呈现。\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"Objective Cat\",\n  ...,\n\n  \"owner\": {\n    \"id\": 99,\n    \"name\": \"Alexander Schuch\"\n  },\n  \"friends\": [\n    {\n      \"name\": \"Owly\",\n      \"type\": \"bird\"\n    },\n    {\n      \"name\": \"Hedgy\",\n      \"type\": \"mammal\"\n    }\n  ]\n}\n```\n\n`Mantle`支持映射这些关系到新的模型，为了让`Mantle`知道怎样变换关系，我们可以使用下面提供的分类方法中的一个来返回`NSValueTransformer`。\n\n\n```objc\n+ (NSValueTransformer *)mtl_JSONDictionaryTransformerWithModelClass:(Class)modelClass;\n+ (NSValueTransformer *)mtl_JSONArrayTransformerWithModelClass:(Class)modelClass;\n```\n\n当然`Mantle`需要知道这些官和他们的将要转换的`MTLModel`子类，就像和创建一个新的`MTLModel`子类并且实现将要映射到这些对象的`MTLJSONSerializing`协议一样简单。然后我们可以添加一些新的属性到我们`CATProfile`类中并且实现两个新的转换器。\n\n```objc\n// CATProfile.h\n@property(strong, nonatomic) CATOwner *owner;   // CATOwner is a MTLModel subclass\n@property(strong, nonatomic) NSArray *friends;  // Array of CATFriend objects\n\n// CATProfile.m\n+ (NSValueTransformer *)ownerJSONTransformer {\n    return [NSValueTransformer mtl_JSONDictionaryTransformerWithModelClass:CATOwner.class];\n}\n\n+ (NSValueTransformer *)friendsJSONTransformer {\n    return [NSValueTransformer mtl_JSONArrayTransformerWithModelClass:CATFriend.class];\n}\n```\n\n### 一些有用的补充\n\n我们简单的聊了一下`NSValueTransformer`在前面,`NSValueTransformer`有一个非常棒的特征让通过名字全局注册一个变换器成为可能。假如你正在使用相同的变换器在你整个app中，确保子类化`NSValueTransformer`，注册你的自定义变换器一次并且在你随后的`MTLModels`中使用它。\n\n```objc\n// In CATProfile.m\nNSString * const kCATCustomValueTransformerName = @\"CATCustomValueTransformer\";\n\n+ (void)initialize\n{\n  // Register NSValueTransformer\n  if (self == CATProfile.class) {\n    CATCustomValueTransformer *transformer = [CATCustomValueTransformer new];\n    [NSValueTransformer setValueTransformer:transformer forName:kCATCustomValueTransformerName];\n  }\n}\n\n// Then use the custom transformer to translate properties using Mantle\n+ (NSValueTransformer *)whateverPropertyJSONTransformer {\n    return [NSValueTransformer valueTransformerForName:kCATCustomValueTransformerName];\n}\n```\n\n### 结论\n\n`Mantle`是一个非常棒的补充处理`JSON`APIs，然而，你也必须意识到假如你不得不处理非常复杂的数据或者不稳定的APIs它也是不合适的。\n\n参考资料\n\n* [Mantle-Cat](http://www.objc.at/mantle)\n* [Mantle Framework on Github](https://github.com/MantleFramework/Mantle)\n* [NSValueTransformer at NSHipster](http://nshipster.com/nsvaluetransformer/)\n* [Mantle as a Model Layer for iOS and OS X Apps](http://www.dominikgruber.com/articles/2013/08/mantle-as-a-model-layer-for-ios-and-os-x-apps)\n* [iOS JSON 模型转换库评测](http://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/)\n","tags":["序列化"],"categories":["三方 API"]},{"title":"4 种方式实现 iOS 模糊效果","url":"/2016/01/31/2016-01-31-3chong-fang-shi-shi-xian-iosmo-hu-xiao-guo/","content":"\n介绍iOS中以下四种方式实现：\n\n* `CoreImage`中的模糊滤镜\n* `UIImage + ImageEffects`的category模糊效果\n* iOS8中`UIVisualEffectView`模糊效果\n* iOS7以后通过`UIToolBar`实现模糊效果\n\n\n### `CoreImage`中的模糊滤镜实现\n\n`CoreImage`主要通过`CIFilter`这个类来实现。\n\n这个类支持的滤镜多达14类，每个类又细分多款滤镜：\n\n1. CICategoryBlur\n\t* CIBoxBlur\n\t* CIDiscBlur\n\t* **CIGaussianBlur**\n\t* CIMaskedVariableBlur\n\t* CIMedianFilter\n\t* CIMotionBlur\n\t* CINoiseReduction\n\t* CIZoomBlur\n* CICategoryColorAdjustment\n\t* CIColorClamp\n\t* CIColorControls\n\t* CIColorMatrix\n\t* CIColorPolynomial\n\t* CIExposureAdjust\n\t* CIGammaAdjust\n\t* CIHueAdjust\n\t* CILinearToSRGBToneCurve\n\t* CISRGBToneCurveToLinear\n\t* CITemperatureAndTint\n\t* CIToneCurve\n\t* CIVibrance\n\t* CIWhitePointAdjust\n* CICategoryColorEffect\n* CICategoryCompositeOperation\n* CICategoryDistortionEffect\n* CICategoryGenerator\n* CICategoryGeometryAdjustment\n* CICategoryGradient\n* CICategoryHalftoneEffect\n* CICategoryReduction\n* CICategorySharpen\n* CICategoryStylize\n* CICategoryTileEffect\n* CICategoryTransition\n\n我们这里使用的是高斯模糊，也就是`CIGaussianBlur`。\n\n**Sample Code：**\n\n```objective-c\n\n    UIImage *avatar = [UIImage imageNamed:@\"avatar\"];\n    \n    /********** CoreImage ************/\n    \n    // CIImage\n    CIImage *ciImage = [[CIImage alloc] initWithImage:avatar];\n    \n    // CIFilter\n    CIFilter *blurFilter = [CIFilter filterWithName:@\"CIGaussianBlur\"];\n    \n    // 设置模糊滤镜半径\n    [blurFilter setValue:@(20) forKey:@\"inputRadius\"];\n    \n    // 将图片输入到滤镜\n    [blurFilter setValue:ciImage forKey:kCIInputImageKey];\n    \n    // 将处理好的图片输出\n    CIImage *outCiImage = [blurFilter valueForKey:kCIOutputImageKey];\n    \n    // 查询可以设置的参数和一些信息\n    NSLog(@\"%@\",[blurFilter attributes]);\n    \n    // CIContext\n    CIContext *contex = [CIContext contextWithOptions:nil];\n    \n    // 获取CGImage句柄\n    CGImageRef outCGImage = [contex createCGImage:outCiImage fromRect:[outCiImage extent]];\n    \n    // 最终获取到图片\n    UIImage *blurImage = [UIImage imageWithCGImage:outCGImage];\n    \n    // 释放CGImage句柄\n    CGImageRelease(outCGImage);\n    \n```\n\n此时`blurImage`图片就是经过滤镜处理后的图片，在放在`ImageView`上加载即可看到效果。\n\n![avatar](/images/img_blur.jpg)\n\n\n### `UIImage + ImageEffects`的category模糊效果\n\n使用Apple开源的一个图片处理分类来实现，这个使用起来只需一行代码，简洁明了。\n\n```objective-c\n\n\tUIImage *blurImage = [sourceImage blurImage];\n\t\n```\n\n这里封装了一个区域模糊效果的方法\n\n```objective-c\n\n\t- (UIImage *)blurImageAtFrame:(CGRect)frame;\n\t\n```\n\n### iOS8中`UIVisualEffectView`模糊效果\n\n这个效果只支持iOS8.0以上的版本，通过`UIVisualEffectView`来实现。\n\n**Sample Code：**\n\n```objective-c\n\n\t// 1.创建模糊view\n    UIVisualEffectView *effectView = [[UIVisualEffectView alloc] initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]];\n    \n    // 2.设置尺寸\n    effectView.frame = CGRectMake(0, 100, [UIScreen mainScreen].bounds.size.width, 200);\n    \n    // 3.添加到view当中\n    [self.view addSubview:effectView];\n    \n```\n\n**😊Bonus:**\n实现iOS高版本通知中心炫酷的Label模糊效果。\n\n```objective-c\n\n\t// 添加一个文本标签\n    UILabel *label = [[UILabel alloc] initWithFrame:effectView.bounds];\n    label.text = @\"www.blog.wangruofeng007\";\n    label.textAlignment = NSTextAlignmentCenter;\n    label.font = [UIFont systemFontOfSize:30];\n    [effectView.contentView addSubview:label];\n    \n    /***************** 添加模糊效果 *****************/\n    \n    // 1.创建子模糊view\n    UIVisualEffectView *subEffectView = [[UIVisualEffectView alloc] initWithEffect:[UIVibrancyEffect effectForBlurEffect:(UIBlurEffect *)effectView.effect]];\n    \n    // 2.设定尺寸\n    subEffectView.frame = effectView.bounds;\n    \n    // 3.将子模糊view添加到effectView的contenView才能生效\n    [effectView.contentView addSubview:subEffectView];\n    \n    // 4.添加要显示的view来达到特殊的效果\n    [subEffectView.contentView addSubview:label];\n    \n```\n\n效果图：\n\n<img src=\"https://github.com/wangruofeng/BlurEffectDemo/raw/master/sample.png\" style=\"witdh:50%; height:50%\">\n</img>\n\nDemo地址：\n\n* [BlurEffectDemo \n](https://github.com/wangruofeng/BlurEffectDemo) -- 本文效果Demo\n* [UIVisualEffects_Objective-c](https://github.com/wangruofeng/UIVisualEffects_Objective-c) -- 详细介绍`UIVisualEffects`的使用\n\n### iOS7以后通过`UIToolBar`实现模糊效果\n\n在iOS7以后，`UINavigationBar`和`UIToolBar`自带毛玻璃模糊效果，可以通过手动创建`UIToolBar`对象，然后添加到view中实现，UIToolBar区域就可以实现动态毛玻璃模糊效果。\n\n例如在一个状态栏后方添加一个模糊view,可以在控制器中这样实现，假设没有导航栏\n\n```objective-c\nUIToolbar *statusBar = [[UIToolbar alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 20)];\n[self.view addSubview:statusBar];\n```\n\n这个方法非常简单实用😊，快去试试吧。\n\n参考资料：\n\n* [Core Image Programming Guide](https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_tasks/ci_tasks.html)\n* [Core Image Filter Reference](https://developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html)\n* [UIImageBlur](https://github.com/wangruofeng/UIImageBlur)\n","tags":["特效"],"categories":["最佳实践"]},{"title":"Watch App 开发之 Interface Elements 详解","url":"/2016/01/29/2016-01-29-watch-app-kai-fa-zhi-interface-elements-xiang-jie/","content":"\n`iWatch`原生态支持的控件主要有以下类型,下面对每个类型一一解刨。\n\n* Labels\n* Images\n* Groups\n* Pickers\n* Tables\n* Buttons\n* Switches\n* Sliders\n* Maps\n* Movies\n* Date and Timer Labels\n* Menus\n\n\n### Labels -- WKInterfaceLabel\n\n`Labels`使用静态的文本来传达简短的消息，是你App中最常见的一个元素之一。它能支持多行显示也可通过代码动态更新内容。\n\n`iWatch`,设计一个标签事，首先应该把精力集中在`易读性`,使用更亮的颜色和使用动态类型（` Dynamic Type`）来保证文本尺寸的正确，内置已经提供了最佳的易读性和自动的动态的类型支持。假如需要使用自定义的字体，应该避免使用过度格式化的。\n\n更多信息查看：[Typography](https://developer.apple.com/watch/human-interface-guidelines/typography/)\n<img src=\"/images/iwatch/img_iwatch_00.jpg\" style='width:50%;height:50%'></img>\n\n\n### Images -- WKInterfaceImage\n\n<img src=\"/images/iwatch/img_iwatch_01.jpg\" style='width:50%;height:50%'></img>\n\n一个`Image`元素用来显示单张图片或者一系列动画图片。Images支持在`iOS`上的的任何格式，但是跟偏向于PNG格式。动画系列图片可以通过代码控制启停。\n\n`38mm`和`42mm`共用一套图片资源，只要内容能够表达清晰。\n\nApple Watch支持高清屏显示，所有没有必要创建一个标准的分辨率图片，在图片名应该包括`@2x`。\n\n**当图片正在加载时，应该使用占位图片来占据它的空间**。\n\n优化图片查看：[Image Optimizations](/images/iwatch/img_iwatch_02.jpg)\n\n### Groups -- WKInterfaceGroup\n\n`Group`这个概念是专为有限空间的`iWatch`打造的，可以帮你对其他元素进行布局。它有`postion`,`size`,`marigns`以及其他布局相关的接口，一个`Group`对象本身也是一个可见的元素，它也有背景图片，颜色，圆角半径等属性。\n\n**支持水平`horizontally`和垂直`vertically`布局**，可以让放在里面的项目实现相应的布局，可以使用`spacing`属性来设置内部项目之间的间距，使用`margins`来控制`Group`和它周边的元素的距离。\n\n`Group`支持镶嵌操作，你可以通过镶嵌来指定你想要的布局样式。\n\n你应该优化你的`Group`的背景图片来获得更好的体验，因为太大可能使你的App变得卡顿。优化请参考：[Image Optimizations](https://developer.apple.com/watch/human-interface-guidelines/icons-and-images/#image-optimizations)\n\n外观大概这样:\n<img src=\"/images/iwatch/img_iwatch_02.jpg\" style='width:50%;height:50%'></img>\n\n### Pickers -- WKInterfacePicker\n\n`Pickers`能够显示一个可以使用数字表冠导航的列表。这意味着你可以使用一种更精确和迷人的方式选择。`Pickers`可以通过下面三种方式的一种来展示它们的项目：\n<img src=\"/images/iwatch/img_iwatch_03.jpg\" style='width:50%;height:50%'></img>\n\n* `List style`,可以显示文本或者图片在一个滚动列表里面\n* `Stack style`,栈风格以一个卡片风格的界面显示图片，当用户滚动，被选择的图片动画进入最上方，这种风格适合浏览照片。\n* `Sequence style`,序列显示，可以显示一系列的图片。当用户转动表冠时，`Picker`显示先前或下一张图片在这个序列中没有动画，这种风格适合于构建自定义的界面使用你自己的图片。\n\n\n`Pickers`还能被配置成显示一个`轮廓`，`标题`，`滚动指示器`。这些元素可以让你分辨出屏幕上的`Pickers`并且可以帮助用户导航它的内容。\n\n**使用标题来指明你选择项目的意义或者picker本身的作用**\n\n你可以给项目指定一个独特的标题当那些项目的意思表达不清晰的时候，可选，你也可以设置所有的项目相同的标题来标明`Picker`它本身的作用。\n<img src=\"/images/iwatch/img_iwatch_04.jpg\" style='width:50%;height:50%'></img>\n\n\n\n**显示一个滚动指示器当所有的内容不是全部可见时**\n<img src=\"/images/iwatch/img_iwatch_05.jpg\" style='width:50%;height:50%'></img>\n\n\n### Tabels -- WKInterfaceTable\n\n`Tabels`在一列中展示多行的内容。一个表的一行是动态配置的，它的内容可以在随时改变。`Tabels`天生可滚动，支持各种交互，能够设置背景颜色或者图片。\n<img src=\"/images/iwatch/img_iwatch_06.jpg\" style='width:50%;height:50%'></img>\n\n使用注意事项：\n\n* **统一使用行的风格类型**，即使一个表可以包含多行，它应该呈现一个全局统一的外观，每一行使用你的主要内容开始，然后随你的需要添加更多支持的其他类型的内容，例如`headers`或者`footers`,总是用原来设计的目的来使用行类型。例如，你不应该用一行来显示`headers`或`footers`的内容。\n\n* **限制行数最大20**，显示最重要的行在顶部，让用户能够浏览尽可能的多。行数越少越容易快速浏览。\n\n* **不要在`groups`里面镶嵌`tables`**,`Tabels`会动态改变它的尺寸基于它所包含的行的数目。它会忽略`groups`对高度的限制。\n* **不要在table行内包含`∧`或者`∨`符号**，行后台实现可以自然点击，你不需要包含一个`∧`或者`∨`符号或者文字来表明行是可点击的。\n\n### Buttons -- WKInterfaceButton\n\n一个`button`可以执行一个app指定的动作，`button`可以自定背景和圆角半径。它还可以充当容器使用，包含一个标签`labe;`，图片`image`，或者一个组`group`对象。\n<img src=\"/images/iwatch/img_iwatch_07.jpg\" style='width:50%;height:50%'></img>\n\n使用事项：\n\n* **创建横跨屏幕的Buttons** ，全宽的buttons看起来更容易点击，假如有两个buttons，必须有相同的水平间距，两者使用相同的高度使用相同的图或者简短的文本标签。\n\n* **使用相同的高度对于`vertical stacks`风格布局一行和两行文本按钮**，原则是，尽可能的，使用一致到高度让他们在视觉上统一。\n\n* **使用标准的圆角半径**，标准的圆角半径的是`6点`，使用标准的圆角半径可以提升整个app的视觉的一致性并且可以增强button的内容。\n\n* **让butotns足够大以便容易点击**，创建让用户很容易点击的button，buttons应该遵循下面最小的值。\n\n\n\n|                         |38mm (minimum)  |42mm (minimum)   |\n|-------------------------|----------------|-----------------|\n|Circular buttons         |75 pixels       | 80 pixels            |\n|Round rectangular buttons|50 pixels high  | 52 pixels high          |\n\n\n### Switches -- WKInterfaceSwitch\n\n开关控件更`iOS`类似，让用户在量个互斥的选择或者状态中选择，例如开或者关，一个靠近`switch`的标签应该指定响应的效果当，开关切换时。\n\n效果像这样：\n<img src=\"/images/iwatch/img_iwatch_08.jpg\" style='width:50%;height:50%'></img>\n\n### Sliders -- WKInterfaceSlider\n\n一个滑动条让用户来调整到某一个值。一个`slider`用来显示它设置的一系列的值或者是一个持续的`bar`, 它可以在一个有限的范围内根据预定的数量自增或者自减。\n\n<img src=\"/images/iwatch/img_iwatch_09.jpg\" style='width:50%;height:50%'> </img>\n\n\nNote：你可以像使用`slider`那样使用自定图片,系统默认显示`+`和`-`符号。\n\n### Maps -- WKInterfaceMap\n\n`Maps`是地理位置的静态快照。你可以放一张地图在你的界面里面在预计的时间，但是你`WatchKit extension`必须配置显示的区域在运行时。显示区域是不可交互的，但是点击一个地图将会打开你`Apple Watch`上的`Maps`app。\n\n你可以在地图上用一个高亮的点对你感兴趣或者其他相关信息进行标注。地图能显示标准的`红`，`黄`，`绿`大头针，它也可以显示自定义的图片，系统允许你最多添加`5个`在一张地图上。\n\n使用注意实现：\n\n* **让你地图的元素根据屏幕自动适应**。用户应该能够看到整个地图元素在Apple Watch上而不用滚动屏幕。\n* **配置显示的地图区域到包含兴趣点的最小范围**，地图元素内容本身不能滚动，所有所有内容必须附着在一个指定的地图区域\n\n### Movies -- WKInterfaceMovie\n\n一个`movie`对象会显示一张海报图片，当点击时，模态呈现一份视频或者音频对象，使用这个元素来放置简短的媒体剪切和你内容内联。媒文件的重放由系统来管理。\n\n使用注意事项：\n\n* **使用一种海报图片来呈现剪切的内容**，海报图片能让用户提前做决定是否观看与这个剪切关联的媒体，不要使用没有意义的剪切图片。\n* **不要创建海报图片像系统控件**，`Movies`会让视频和音频内容看起来像你节目的一部分，所以不要通过让他们看起来像其他东西的方式把他们隐藏起来。你应该使用一个`Button`（而不是一个`movie`）来呈现媒体回放界面假如你喜欢的话。\n* **保证视频或者音频剪辑得足够短**，剪辑不应该超过30秒，首选更短的。长的剪辑会占用更多的磁盘空间并且要求用户保持他们的手腕抬起更长时间，这样可能导致疲劳。\n* **适当的设置剪辑视频的尺寸**，无论时候都应该使用推荐的尺寸来剪切，缩放视频剪辑将影响性能导致不理想的外观。更多信息关于推荐的尺寸和编码的值，参考[Audio & Video](https://developer.apple.com/watch/human-interface-guidelines/watch-technologies/#audio-and-video)\n\n<div style=\"text-align:center\">\n<video src='https://developer.apple.com/watch/human-interface-guidelines/ui-elements/images/iwatch/ui-elements-movies.mp4' style='width:50%;height:50%;'>\n</video>\n</div>\n\n### Date & Timer Labels -- WKInterfaceDate,WKInterfaceTimer\n\nDate 和 Timer 标签用来显示真实的时间在`Apple Watch`上。\n\n<img src=\"/images/iwatch/img_iwatch_10.jpg\" style='width:50%;height:50%'></img>\n\n一个`date label`显示了现在的日期，现在的时间或者两者的组合。它可以使用各种样式，日历和时区来配置，在你配置好后，日期标签直接跟新它的值而不需要通过你app的进一步输入。\n\n<img src=\"/images/iwatch/img_iwatch_11.jpg\" style='width:50%;height:50%'></img>\n\n一个`timer label`用来显示一个精准的倒计时和和计数定时器。它能够配置它显示的计数的值以各种形式，在你配置完成后，一个`timer label`能够计数或者倒计时不用从你的app的进一步输入。\n\n### Menus -- WKMenuItemIcon\n\n强力触摸`Apple Watch`将调出当前屏幕的`menu`（假如有点话）。一个菜单能够显示多达4个有关的动作对于当前屏幕，而不用从你的界面离开。\n\n<img src=\"/images/iwatch/img_iwatch_12.jpg\" style='width:50%;height:50%'></img>\n\n使用注意事项：\n\n* **包含一个Menu当现在屏幕有相关的操作的时候**，菜单是可选的。假如没有菜单呈现，系统将播放一段动画来响应用户的强力触摸操作。\n* **使用一个label和一个icon来传达每个菜单动作的意图**，label和icon都需要，label限制2行，所以文本应该尽量的短。\n* **使用菜单来响应它们预期的目的**，`Menus`是一种能够修改当前界面控制器内容的方式，不要使用它们来作为主要的导航形式在你的app中。\n* **避免复制你的其他app中菜单的视觉风格**，假如你必须使用一个相似的布局，加上颜色给你的界面或者排列的项目，用一种不同于其他菜单的方式。\n\n<img src=\"/images/iwatch/img_iwatch_13.jpg\" style='width:50%;height:50%'></img>\n\n<img src=\"/images/iwatch/img_iwatch_14.jpg\" style='width:50%;height:50%'></img>\n\n<img src=\"/images/iwatch/img_iwatch_15.jpg\" style='width:50%;height:50%'></img>\n\n更多menu icons 设计的信息，参考[ Menu Icons](https://developer.apple.com/watch/human-interface-guidelines/icons-and-images/#menu-icons)。\n\n参考资料：\n\n* [human-interface-guidelines](https://developer.apple.com/watch/human-interface-guidelines/)\n* [human-interface-guidelines Visual Design](https://developer.apple.com/watch/human-interface-guidelines/visual-design/)\n* [Apple Watch指南](https://github.com/ipader/SwiftGuide/tree/master/Apple%20Watch)\n* [Best-apple-watch-apps](http://www.wareable.com/apple-watch/best-apple-watch-apps-832)\n","tags":["WatchOS2"],"categories":["系统 API"]},{"title":"MVVM 资料整理","url":"/2016/01/20/2016-01-20-mvvmzi-liao-zheng-li/","content":"\n\n> MVVM，作为一种新的架构设计，有别于MVC，MVP，它有很多自己的特性和优势，例如易于调试，业务逻辑集中方便管理，统一各种通信机制，将业务和控制器解耦。这框架现在很多公司都在尝试使用，像美团等，以后可能是一种趋势，鉴于它学习成本比较高，此文意在记录和收集相关的资料，以便以后查阅。\n\n**Github地址**：[ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa)\n\n比较不错的学习资料：\n\n* [ReactiveCocoa 讨论会](http://blog.devtang.com/blog/2016/01/03/reactive-cocoa-discussion/) -- 唐巧\n* [MVVM without ReactiveCocoa](http://limboy.me/ios/2015/09/27/ios-mvvm-without-reactivecocoa.html) -- limboy\n* [ReactiveCocoa](http://tech.meituan.com/tag/ReactiveCocoa) -- 美团\n* [ReactiveCocoa v2.5 源码解析之架构总览](http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/) -- 雷纯峰 \n* [Functor、Applicative 和 Monad](http://blog.leichunfeng.com/blog/2015/11/08/functor-applicative-and-monad/) -- 雷纯峰 \n* [Principles of Reactive Programming](https://www.coursera.org/course/reactive) -- 这里有一些视频课程，很不错\n* [ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2](http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1)\n* [ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2](http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2)\n* [MVVM Tutorial with ReactiveCocoa: Part 1/2](http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1)\n* [MVVM Tutorial with ReactiveCocoa: Part 2/2](http://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2)\n* [Functional Reactive Programming on iOS](http://pan.baidu.com/share/link?uk=3726868924&shareid=2347251856&third=0&adapt=pc&fr=ftw) -- 这本书介绍函数式编程配有例子，可以快速理解这种思想，入门级推荐\n* [Reactive​Cocoa](http://nshipster.cn/reactivecocoa/) -- NSHipster\n* [ReactiveCocoa 入坑 ing](http://www.jianshu.com/p/1fc8c809e2c0) -- 简书\n* [ReactiveCocoa学习资源收集](http://www.jianshu.com/p/335f236b8a5b) -- 简书\n* [ReactiveCocoa学习资料汇总](http://www.jianshu.com/p/b56402adfc93) -- 简书\n","tags":["MVVM"],"categories":["设计模式"]},{"title":"TableView 性能优化","url":"/2016/01/18/2016-01-18-tableviewxing-neng-you-hua/","content":"\n\n> 此文整理一下TableView优化相关的方案和思路。\n \n#### TableView为什么会卡？\n\n主要由以下原因：\n\n* `cellForRowAtIndexPath:`方法中处理了过多业务\n* tableviewCell的subview层级太复杂，做了大量透明处理\n* cell的height动态变化时计算方式不对\n\n#### 优化核心思想：`UITableViewCell`重用机制\n \n简单的理解就是：UITableView只会创建一屏幕（或一屏幕多一点）的UITableViewCell，其他都是从中取出来重用的。每当Cell滑出屏幕时，就会放入到一个集合（或数组）中（这里就相当于一个重用池），当要显示某一位置的Cell时，会先去集合（或数组）中取，如果有，就直接拿来显示；如果没有，才会创建。这样做的好处可想而知，极大的减少了内存的开销。\n\n\n\n#### Tips：\n\n1. 提前计算并缓存好高度（布局），因为`heightForRowAtIndexPath:`是调用最频繁的方法；\n2. 异步绘制,遇到复杂界面,参考`Facebook`的`AsyncDisplayKit`和[YYAsyncLayer](https://github.com/ibireme/YYAsyncLayer)异步绘制框架；\n3. 缓存图片（`SDWebImage`），提前处理好`UIImageView`图片的尺寸按需加载而不是加载原图；\n4. 计算等耗时操作异步处理，处理完再回主线程更新UI；\n5. 图文混排不定高度采用`CoreText`排版，缓存Cell高度参考[YYKit](https://github.com/ibireme/YYKit)；\n6. 实现Cell的`drawRect:`方法直接绘制，减少`UIView`，`UIImageView`，`UILabel`等容器的使用。\n\n#### Bonus：\n\n1. 正确使用reuseIdentifier来重用Cell；\n2. 尽量少用或不用透明图层或View；\n3. 如果Cell内现实的内容来自web，使用异步加载，缓存请求结果；\n4. 减少subviews的数量在`heightForRowAtIndexPath:`中尽量不使用`cellForRowAtIndexPath:`，如果你需要用到它，只用一次然后缓存结果；\n5. 尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示；\n6. 固定高度不要实现`heightForRowAtIndexPath:`方法。\n\n可以通过实现以下方法，可以减少高度计算次数\n\n```objc\n@property (nonatomic) CGFloat rowHeight;             // will return the default value if unset\n@property (nonatomic) CGFloat sectionHeaderHeight;   // will return the default value if unset\n@property (nonatomic) CGFloat sectionFooterHeight;   // will return the default value if unset\n@property (nonatomic) CGFloat estimatedRowHeight NS_AVAILABLE_IOS(7_0); // default is 0, which means there is no estimate\n@property (nonatomic) CGFloat estimatedSectionHeaderHeight NS_AVAILABLE_IOS(7_0); // default is 0, which means there is no estimate\n@property (nonatomic) CGFloat estimatedSectionFooterHeight NS_AVAILABLE_IOS(7_0); // default is 0, which means there is no estimate\n```\n\n\n参考资料：\n\n* [code-uitableviewcell-optimizations-part-1](http://ealui.com/index.php/blog/view/code-uitableviewcell-optimizations)\n* [code-uitableviewcell-optimization-part-2](http://ealui.com/blog/view/code-uitableviewcell-optimization-part-2)\n* [Perfect smooth scrolling in UITableViews](https://medium.com/ios-os-x-development/perfect-smooth-scrolling-in-uitableviews-fd609d5275a5#.b176bxlm3)\n*  [优化UITableViewCell高度计算的那些事](http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/)\n*  [详细整理：UITableView优化技巧](http://www.cocoachina.com/ios/20150602/11968.html)\n*  [UITableview性能优化总结](http://www.cnblogs.com/wengzilin/p/4288027.html)\n*  [AsyncDisplayKit 教程：达到 60 FPS 的滚动帧率](https://github.com/nixzhu/dev-blog/blob/master/2014-11-22-asyncdisplaykit-tutorial-achieving-60-fps-scrolling.md)\n*  [AsyncDisplayKit](https://github.com/facebook/AsyncDisplayKit) \n*  [YYAsyncLayer](https://github.com/ibireme/YYAsyncLayer)\n","tags":["TableView"],"categories":["性能优化"]},{"title":"iOS Animation Swift 版","url":"/2016/01/16/2016-01-16-ios-animation-swift-ban/","content":"\n![coreAnimation](/images/ios_animation_swift/ios_animation_swift_cover.jpg)\n\n\n### 简介\n此文主要记录我学习iOS的动画相关内容用`Swift`语言，记录下来以供参考，不定时更新。\n\n### 目录结构\n\n* Section I: View 动画\n    * View animation\n    * 弹簧动画 - Springs\n    * 转场动画 - Transitions\n    * 关键帧动画 - Keyframe\n* Section II: Auto Layout 动画\n* Section III: Layer 动画\n* Section IV: 3D 动画\n* Section V: 未来类型的动画\n* Section VI: View Controller 动画\n* Section VII：第三方动画库\n* Section VIII: Apple Watch 动画\n\n#### Section I: View 动画\n\n##### 1.View animation\n\n简介：view 的动画主要是通过UIView的类方法创建，动画内容一般\n放在block里面，可以镶嵌使用，构成链式动画，主要有3个方法,三个访法只需会参数最多的那个就行，函数名`animateWithDuration(_:delay:options:animations:completion:)`，其他的使用起来都类似。\n\n```swift\nclass func animateWithDuration(_ duration: NSTimeInterval, animations animations: () -> Void)\nclass func animateWithDuration(_ duration: NSTimeInterval, animations animations: () -> Void, completion completion: ((Bool) -> Void)?)\nclass func animateWithDuration(_ duration: NSTimeInterval, delay delay: NSTimeInterval, options options: UIViewAnimationOptions, animations animations: () -> Void, completion completion: ((Bool) -> Void)?)\n```\n\n使用：\n\n```swift\nUIView.animateWithDuration(0.5, delay: 0, options: [], animations: {\n    //do something\n  }, completion: {_ in\n    //do something\n})\n```\n\n> 说明：`options`，动画选项，这个运行你设置一个动画选项集合，传`[]`表示不需要选项，单个时可以省略放括号例如`.Repeat`,多个用逗号连接`[.Repeat, .CurveEaseInOut]`\n\n> `completion`闭包需要一个参数，不需要使用参数可以用`_`表示，不需要实现可以直接传`nil`\n\n或者像下面这样写\n\n```swift\nUIView.animateWithDuration(0.5, delay: 0, options: [], animations: { () -> Void in\n  //do something\n  }) { (_) -> Void in\n  //do something\n}\n```\n\n##### 2.弹簧动画 - Springs\n\n简介：弹簧动画是iOS 7.0新增的API，函数名`animateWithDuration(_:delay:usingSpringWithDamping:initialSpringVelocity:opti ons:animations:completion:)`，\n\n\n```swift\nclass func animateWithDuration(_ duration: NSTimeInterval, delay delay: NSTimeInterval, usingSpringWithDamping dampingRatio: CGFloat, initialSpringVelocity velocity: CGFloat, options options: UIViewAnimationOptions, animations animations: () -> Void, completion completion: ((Bool) -> Void)?)\n```\n\n使用：\n\n```swift\nUIView.animateWithDuration(0.5, delay: 0.5, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.0, options: [], animations: {\n// do something\n}, completion: nil)\n```\n\n> 说明：`usingSpringWithDamping`:设置弹簧的阻尼，范围（0.0-1.0），越接近0.0弹簧越有弹性，越接近1.0，效果越僵硬，你可以把当成弹簧的刚度来理解，\n> `initialSpringVelocity`:设置弹簧初始化的速度，设置1.0表示用1秒在动画跨度上完成整个动画距离，值越大或者越小会导致动画有相应的大的或者较小的速度，可以当成弹簧的初始动量来理解。\n\n##### 3.转场动画 - Transitions\n\n简介：前两种创建的动画是基于可动画的接口例如，position，alpha，frame等等，Transitions是专门处理添加或者移除一个view的动画,系统有2个标准函数，一个是对单个view的处理，一个是处理2个view替换。\n\n```swift\nclass func transitionWithView(_ view: UIView, duration duration: NSTimeInterval, options options: UIViewAnimationOptions, animations animations: (() -> Void)?, completion completion: ((Bool) -> Void)?)\nclass func transitionFromView(_ fromView: UIView, toView toView: UIView, duration duration: NSTimeInterval, options options: UIViewAnimationOptions, completion completion: ((Bool) -> Void)?)\n```\n\n使用：\n\n```swift\n//add the new view via transition\nUIView.transitionWithView(animationContainerView!, duration: 0.33,\noptions: [.CurveEaseOut, .TransitionFlipFromBottom], animations: {\nself.animationContainerView!.addSubview(newView) }, completion: nil)\n\n//remove the view via transition\nUIView.transitionWithView(animationContainerView!, duration: 0.33,\noptions: [.CurveEaseOut, .TransitionFlipFromBottom], animations: {\nself.newView.removeFromSuperview() }, completion: nil)\n\n//hide the view via transition\nUIView.transitionWithView(self.newView, duration: 0.33, options: [.CurveEaseOut, .TransitionFlipFromBottom], animations: {\nself.newView.hidden = true }, completion: nil)\n\n//replace via transition\nUIView.transitionFromView(self.oldView!, toView: self.newView!, duration: 0.33, options: [.TransitionFlipFromTop],\ncompletion: nil)\n```\n\n##### 4.关键帧动画 - Keyframe\n\n简介：关键帧顾名思义就是设定关键的一些帧然后系统会根据一套算法计算中间的其他帧，这样改变的可动画属性时看看起来更加流畅自然，主要有两个函数,一个创建关键帧动画，一个设置具体每帧内容\n\n```swift\nclass func animateKeyframesWithDuration(_ duration: NSTimeInterval, delay delay: NSTimeInterval, options options: UIViewKeyframeAnimationOptions, animations animations: () -> Void, completion completion: ((Bool) -> Void)?)\n+ (void)addKeyframeWithRelativeStartTime:(double)frameStartTime relativeDuration:(double)frameDuration animations:(void (^)(void))animations\n```\n\n例如：\n\n```swift\nfunc planeDepart() {\n\n  UIView.animateKeyframesWithDuration(1.5, delay: 0.0, options: [], animations: {\n    //add keyframes\n\n    UIView.addKeyframeWithRelativeStartTime(0.0, relativeDuration: 0.25, animations: {\n      self.planeImage.center.x += 100.0\n      self.planeImage.center.y -= 10.0\n      })\n\n      UIView.addKeyframeWithRelativeStartTime(0.1, relativeDuration: 0.4) {\n        self.planeImage.transform = CGAffineTransformMakeRotation(CGFloat(-M_PI_4/2))\n      }\n\n      UIView.addKeyframeWithRelativeStartTime(0.25, relativeDuration: 0.25) {\n        self.planeImage.center.x += 100.0\n        self.planeImage.center.y -= 60.0\n        self.planeImage.alpha = 0.0\n      }\n\n      UIView.addKeyframeWithRelativeStartTime(0.51, relativeDuration: 0.01) {\n        self.planeImage.transform = CGAffineTransformIdentity\n        self.planeImage.center = CGPoint(x: 0.0, y: originalCenter.y)\n      }\n\n      UIView.addKeyframeWithRelativeStartTime(0.55, relativeDuration: 0.45) {\n        self.planeImage.alpha = 1.0\n        self.planeImage.center = originalCenter\n      }\n\n      }, completion: nil)\n}\n```\n\n> 说明：这是设计一个飞机沿一条路径起飞然后再归位的一段动画，`addKeyframeWithRelativeStartTime(_:relativeDuration:animations:)`,第一个参数相对开始时间，是相对于动画持续时间的百分比，例如0.1就是10%，0.25就是25%，如果整个动画持续2秒，0.1就是在2*0.1=0.2秒的时候开始，后面的一个参数是相对持续时间，范围更第一参数类似也(0.0-1.0),只从相对开始时间起，往后推移的相对时间。\n\n#### Section II: Auto Layout 动画\n\n```swift\n\n// change Constraint\n\n// init layout\nview.layoutIfNeeded()\n\nUIView.animateWithDuration(0.8, delay: 0.0,\n      usingSpringWithDamping: 0.4, initialSpringVelocity: 0.0,\n      options: [], animations: {\n      \n        // do something change constraint\n        \n        // layout\n        self.view.layoutIfNeeded()\n      }, completion: nil)\n      \n```\n\n原理就是，修改约束,让添加一个动画，在动画`block`里面执行布局更新，`block`里面也可以添加修改约束代码，修改约束的本质是修改相关`View`的`frame`和`bounds`，由于修改`View`的这个属性是支持动画的，所以修改约束其实是间接修改`View`的这些属性，所以也是支持动画的，这个动画的强大的之处在于，可以实现一系列`View`相互协作的动画。\n\n\n\n#### Section VIII: Apple Watch 动画\n\n概述：在Apple Watch 中有两种技术来创建动画，一个是一次性创建一系列静态可动画的图片序列或者循环动画，另一种是对标签和其他项目通过改变尺寸，对齐，颜色，透明度进行布局和外观动画。\n\n**Animated Image Sequences**\n\n`Animated Image Sequences`是由两个或者更多的独立图片组成的序列来随时间按序列显示。每张图片组成了动画的一个单独的帧，整个动画运行在一个循环中除了你在运行的时候修改了播放的行为。主要把它安装在你界面中的`image`，`group`,`button`等元素中。通过`WKImageAnimatable`协议来实现动画，也就是说凡是遵循这个协议的对象都支持动画，`WatchKit`中遵循这个协议的对象有：`WKInterfaceGroup`，`WKInterfaceImage`\n\n你可以控制`image`和`group`元素`Animated Image Sequences`的播放的速度，方向，帧率,否则界面元素将会无限循环显示一个完整的动画。\n\n> Notes:\n  1. `Animated Image Sequences`可以正向播放动画也可以反向执行动画在运行的时候，你不应该提供一套一样的图片以反向的方式，你应该使用这个技术来降低App的尺寸。\n  2. 如果你是从`storyboard`创建序列图片对象，可以通过`func startAnimating()`方法开始执行动画，通过`func stopAnimating()`来停止动画的执行。\n\n实例：\n\n实现`WKInterfaceGroup`加载进度动画\n\n1.在`Watch`里面的`Interface.storyboard`里面拖拽一个`WKInterfaceGroup`命名为`backgroundGroup`\n2.创建一个`WKInterfaceButton`按钮来触发这个动画事件,在控制器里面实现下面的代码\n\n```swift\n@IBAction func checkInButtonTapped() {\n    // 1\n    let duration = 0.35\n    let delay = dispatch_time(DISPATCH_TIME_NOW, Int64((duration + 0.15) * Double(NSEC_PER_SEC)))\n    // 2\n    backgroundGroup.setBackgroundImageNamed(\"Progress\")\n    // 3\n    backgroundGroup.startAnimatingWithImagesInRange(NSRange(location: 0, length: 10), duration: duration, repeatCount: 1)\n    // 4\n    dispatch_after(delay, dispatch_get_main_queue()) { () -> Void in\n      // 5\n      dosomething\n    }\n  }\n```\n> 参数说明：`imageRange`,将要执行动画的图片范围，`0`表示第一张图片，`1`表示第二张图片，以此类推；`duration`,单位秒，表示动画执行单个循环的时间，`正值`表示从第一帧到最后一帧执行，`负值`表示以相反的顺序执行动画，以第一帧结束；`repeatCount`,动画的重复次数，设置`0`表示无限循环。\n\n3.将素材文件拖入`Watch`的`Asset.xcassets`的文件里面，以`Progress`开始命名后面接一串连续的数字，效果应该像下面这样。\n\n![iWatchProgress](/images/ios_animation_swift/ios_animation_swift_01.jpg)\n\n4.然后在模拟器上运行就OK了。\n\n**Layout and Appearance Animations**\n\n你可以动画改变所有界面元素的布局和外观。动画改变布局让你修改元素的尺寸或者动态的改变布局的方向。你可以移动在屏幕上的元素或者让它们的内容重新对齐。你也可以动画改变元素的外观，包括改变他们的`backgroud color`或者`opactiy`。这些类型的动画让你创建动态的界面用来响应用户的交互并且提供一个更好的反馈。\n\n所有的`layout- and appearance-based animations`在动画开始和结束都以`easing`的曲线方式自动构建 。你不能关闭或者自定义缓动曲线。相当于`UIView`的动画选项里面的`easeInOut`。\n\n可动画属性：\n\n* Opacity\n* Height\n* Width\n* Group Insets\n* Alignment\n* Background Color\n* Tint Color\n\n核心代码：\n\n```swift\n\nclass func animateWithDuration(_ duration: NSTimeInterval, animations animations: () -> Void)\n\n```\n\n说明:这个方法在`WKInterfaceController`中，目前发现只有这一个动画API，你可以在这个闭包里面执行相应的动画操作，实现跟`UIView`的block动画类似。\n\n![iWatchAnimation](/images/ios_animation_swift/ios_animation_swift_02.jpg)\n\n实例：\n\n> 在界面已经出现的时候对`planeImage`进行着色动画,改变`separator`的颜色\n\n```swift\n\nvar planeImage: WKInterfaceImage!\nvar separator: WKInterfaceSeparator!\n\noverride func didAppear() {\n    super.didAppear()\n    // 1\n      animateWithDuration(0.35, animations: { () -> Void in\n        // 2\n        let color = UIColor(red: 90/255, green: 200/255, blue: 250/255, alpha: 1)\n        planeImage.setTintColor(color)\n        separator.setColor(color)\n      })\n    }\n}\n\n```\n\n参考资料：\n\n* [Apple Human-interface-guidelines](https://developer.apple.com/watch/human-interface-guidelines/) -- Apple\n* [Apple WatchKit Programming Guide](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/index.html#//apple_ref/doc/uid/TP40014969-CH8-SW1) -- Apple\n* [Apple Watch](https://github.com/ipader/SwiftGuide/blob/master/Apple%20Watch/README.md) -- SwiftGuide\n* [Swift Guide](https://github.com/ipader/SwiftGuide) -- SwiftGuide\n\n\n备注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["Swift"],"categories":["动画"]},{"title":"NSURLSession 教程","url":"/2016/01/15/2016-01-15-nsurlsession/","content":"\n本文翻译自 http://www.raywenderlich.com/51127/nsurlsession-tutorial\n\n原作者： Charlie Fulton\n\n译者：[@oneruofeng](https://twitter.com/oneruofeng)\n\n\n注意：这是一篇来自我们作为即将发布[ iOS 7 Feast](http://www.raywenderlich.com/?p=49762)的一部分[iOS 7 by Tutorials](http://www.raywenderlich.com/?page_id=48020)的简短版本的章节。我们希望你们喜欢。\n\n每一个新的iOS版本发布都会包含一些极好的新的网络APIs，iOS7也不例外，在iOS7中，Apple引入了`NSURLSession`,这是为了取代`NSURLConnection`作为偏好的网络请求的一系列类。\n\n在这个`NSURLSession`的教程中，你将了解到这个新类究竟是什么，为什么你要使用它以及你怎样使用它，它和以前的类库比较而言怎样，最后最重要的是：获得一个整合到一个真正的App的实践。\n\n请注意：这个课程是假设你熟悉基本的网络概念。假如网络对你来说完全是新的，你仍然可以跟我一起一步一步的学习，但是可能有些你不熟悉的概念需要需要自己查询在这个过程中。\n\n#### 为什么使用`NSURLSession`\n\n为什么你要使用`NSURLSession`? 饿，因为它可以带给你一些好处和优势相比以前的：\n\n* **后台上传和下载** ： 当你创建`NSURLSession`的时候你只需配置一个选项即可，你便可以进行所有的后台网络任务。这将有对你的电池寿命有利，它支持`UIKit`多任务并且当切换线程的时候使用相同的代理模型。\n* **使你的网络操作可以暂停和恢复** ：你稍后将会看到，任何使用`NSURLSession`API的网络任务都可以被暂停，停止，重新开始。而没有使用`NSOperation`子类的必要。\n* **可配置的容器**：对于放进里面的请求而言每一个`NSURLSession`都是可配置的。例如，假如你需要设置一个HTTP header选项，你只需要设置一次然后每个在session中的请求就都会有相同的配置了。\n* **可子类化和私密存储**： `NSURLSession`是可子类化的并且你可以配置一个session用来作为私密存储在某个会话中。这允许你拥有私密存储对象在全局状态下。\n* **优化的授权处理机制**：授权被完成基于某个特定的连接。当使用`NSURLConnection`的时候假如发生了一处授权改变，这个改变将返回一个随意的请求，你不能确定你具体得到的那个。使用`NSURLSession`的话，代理回来处理授权。\n* **丰富的代理模型**：`NSURLConnection`有些基于block的同步方法，然而代理就不能使用它们了。当一个请求建立了无论它是成功还是失败，哪怕需要授权。使用`NSURLSession`就就可以混合接入，使用基于block的异步方法同时也可以设置代理来处理授权。\n* **通过文件系统上传和下载**：苹果鼓励把（文件内容）数据跟(URL和一些设置)元数据分开。\n\n#### `NSURLSession` vs `NSURLConnection`\n\n\"哇哦，`NSURLSession`听起来很复杂呀！\",你可能这么想。\"我可能还是继续使用我的老朋友`NSURLConnection`。\"\n\n别担心--使用`NSURLSession`使用起来其实和它的前辈`NSURLConnection`一样简单对于简单的任务来说。例如，让我来看一个在获取伦敦最新的天气的一个简单网络请求，通过它来获取JSON数据的例子。\n\n假设你用这个`NSString`来构造这个`NSURL`:\n\n```objc\nNSString *londonWeatherUrl = @\"http://api.openweathermap.org/data/2.5/weather?q=London,uk\";\n```\n\n这里是第一步你使用`NSURLConnection`来调用：\n\n```objc\nNSURLRequest *request = [NSURLRequest requestWithURL:\n[NSURL URLWithString:londonWeatherUrl]];\n\n[NSURLConnection sendAsynchronousRequest:request\n   queue:[NSOperationQueue mainQueue]\n   completionHandler:^(NSURLResponse *response,\n                       NSData *data,\n                       NSError *connectionError) {\n      // handle response\n}];\n```\n\n现在让我们来使用`NSURLSession`。注意这是使用`NSURLSession`的最简单的方式来快速构造一个请求。在后面的课程你将看到怎样配置session和设置其他特征比如像代理。\n\n```objc\nNSURLSession *session = [NSURLSession sharedSession];\n[[session dataTaskWithURL:[NSURL URLWithString:londonWeatherUrl]\n          completionHandler:^(NSData *data,\n                              NSURLResponse *response,\n                              NSError *error) {\n            // handle response\n\n  }] resume];\n```\n\n注意你并不需要指定它运行在那个队列中。除了你特别指定，这个调用将会在后台线程。你可能很难注意到这两者之间有什么不同，它就是故意这样的。Apple提到打算使用`dataTaskWithURL`来取代在`NSURLConnection`中的`sendAsynchronousRequest`。\n\n所有从根本上来讲--对于简单的任务使用`NSURLSession`就和使用`NSURLConnection`一样简单，并且它还有一些列额外的定制功能当你需要它的时候。\n\n#### `NSURLSession` vs `AFNetworking`\n\n不提到`AFNetworking`框架就谈不上谈论网络编程。这个事在`iOS/OS X`上最流行的框架，有杰出的`Mattt Thompson`创建。\n\n> 注意：想了解更多关于`AFNetworking`,请检出在<https://github.com/AFNetworking/AFNetworking>的github页面。我们也有一个关于它的课程：<http://www.raywenderlich.com/30445/afnetworking-crash-course>\n\n下面是的使用`AFNetworking` 1.x版本处理相同的数据任务的代码：\n\n```objc\nNSURLRequest *request = [NSURLRequest requestWithURL:\n                         [NSURL URLWithString:londonWeatherUrl]];\n\nAFJSONRequestOperation *operation =\n[AFJSONRequestOperation JSONRequestOperationWithRequest:request\n    success:^(NSURLRequest  *request,\n              NSHTTPURLResponse  *response,\n              id JSON) {\n    // handle response\n} failure:nil];\n[operation start];\n```\n\n使用`AFNetworking`的一个好处是处理响应的数据的数据根据类型被归类。使用`AFJSONRequestOperation`(或者诸如`XML`和plist相似的类),成功block已经被解析根据响应并且为你返回你想要的数据。使用`NSURLSession`你将收到一个`NSData`对象在`completion handler`,所有你只需要把`NSData`转换成`JOSN`或者其他形式。\n\n> 注意：你能够很方便的把数据从`NSData`转换成`JSON`使用在iOS 5引入的`NSJSONSerialization`这个类。如果你想了解更多，请查看23章的iOS 5 教程，“Working with JSON”。\n\n你或许想知道你是应该使用`AFNetworking`还是仅仅是继续使用`NSURLSession`。\n\n就个人而言，我认为对于简单的需求最好还是继续使用`NSURLSession`--这样可以避免不必要的引入一个第三方库在你的工程中。另外，使用新的代理，配置，和基于很多添加到`AFNetworking`中的的“遗失特征”现在都被包括了的API的任务。\n\n然而，假如你想使用一些在`AFNetworking`中2.0版本的新特性，诸如序列化和将来对\n`UIKit`的整合（添加到`UIIImageView`分类中），然后这样很难争辩不使用它！\n\n> 注意：在`AFNetworking`2.0分支中，它们已经转换到使用`NSURLSession`。更多信息看这篇帖子：<https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-2.0-Migration-Guide>\n\n#### 介绍 Byte Club\n\n在这篇`NSURLSession`教程中，你将探索这个新的API通过构建一篇日记好图片分享app基于` Dropbox Core API`,因为是顶级机密组织因此姑且命名它`Byte Club`。\n\n考虑到这个课程是你接受到`Byte Club`的官方邀请！什么是你可能会问到的关于`Byte Club`的第一条规则？没人谈论`Byte Club`--除了那些足够炫酷的人将会阅读这个教程。并且那些Android用户完全不知道；他们被他们俩的生活劫持了。 ：]\n\n开始构建app迎战下一个章节，将充当被`Byte Club`组织邀请。\n\n主要到这个教程是假设你对基本的网络有基本的了解在先前的版本iOS。它非常有用假如你已经使用过诸如`NSURLConnection`或者`NSURLSession`在过去。假如在iOS方面你是网络方面的新手，在继续这个课程之前你应该查询我们的iOS学徒系列作为最初的开发者。\n\n#### 现在开始吧\n\n`Byte Club`是iOS 开发者专有的组织，一起来加入挑战你的编程吧。由于每个成员都是远程工作，在这个挑战中有一个是跨越世界，成员通过分享他们“战场”的全景照片也能找到它的乐趣。\n\n例如，下面是Ray的办公场所的全景照片：\n![Ray's office setup](/images/nsurlsession/nsurlsession_01.jpg)\n\n> 注意：你可能想创建你自己办公室的全景照片--它很有趣，在这个课程的后续中我们将会处理。\n\n> 在 iOS 7中，你可以通过打开相机选择一个叫`Pano`（全景）的标签照一张全景照片。\n\n> 加入你喜欢那张，把它设置成你锁屏界面的墙纸通过打开`设置`让后选择`墙纸`  \\选择墙纸 \\我的全景照片。\n\n当然-`Byte Club `有它自己的app，我们来见证奇迹。你可以和其他成员使用app来完成编程挑战或者分享全景照片。在幕后，这是通过网络实现-明确的说，就是通过`Dropbox API`来分享文件。\n\n#### 开始的工程概述\n\n首先，下载[教程开始的工程](http://cdn1.raywenderlich.com/downloads/ByteClub_Starter.zip)。\n\n开始的工程包含了为你预先准备好的UI，所以你只需把精力集中在这个教程中app的网络部分。开始的工程也包含一些处理`Dropbox`授权的代码,在后面你将学到更多。\n\n在Xcode中打开工程让后在你设备或者模拟器上运行，你应该看到像下面这样：\n\n![networking2](/images/nsurlsession/nsurlsession_02.jpg)\n\n然而你还并不能登录它-你不得不先配置app，你将做一点。\n\n下一步打开` Main.storyboard `纵览一下整个app的设计：\n\n![networking2](/images/nsurlsession/nsurlsession_03.jpg)\n\n这是一个最基本的使用2个标签的的TabBarController app：一个是为了挑战编程，另\n一个是为了放全景照片。这里也有预先让用户登录到app中的一步。你将要配置登录在你创建完`Dropbox`平台下的App后。\n\n感到很轻松浏览一下App剩余的部分并且找到到目前为止相似的地方。你将会注意到除了授权组件，这里没有检索挑战编程或者全景照片的网络代码-那就是你的工作！\n\n#### 创建一个新的`Dropbox`平台App\n\n为了开始你的新的`Dropbox` App,打开 Dropbox App 位于<https://www.dropbox.com/developers/apps>的控制台\n\n用你的`Dropbox`账号登录，假如没有，没问题：马上创建一个免费的Dropbox账号。假如这是你第一次使用Dropbox的API，你需要通知Dropbox的条款和条件。\n\n经过这个法定的材料以后就是上路了，选择创建App选项。将呈现给你一系列问题-提供下面的答案\n\n* What type of app do you want to create?\n    * Choose: **Dropbox API app**\n* What type of data does your app need to store on Dropbox?\n    * Choose: **Files and Datastore**\n* Can your app be limited to its own, private folder?\n    * Choose: **No – My App needs access to files already on Dropbox**\n* What type of files does your app need access to?\n    * Choose: **All File Types**\n\n最终，为你的App准备一个名字，选择什么并没有关系只有它是唯一的。假如你选择了一个别人已经在使用的名字`Dropbox `将会告诉你。你的屏幕应该看起来像下面这样：\n\n![networking3](/images/nsurlsession/nsurlsession_04.jpg)    \n\n点击`Create App`，你将开始上路了！\n\n下一个屏幕你将看到显示到屏幕中的包含 **App key** 和 **App secret** :\n\n![networking5](/images/nsurlsession/nsurlsession_05.jpg)\n\n先不要关闭这个屏幕，你将需要需要下一步的`App Key`和`App Secret`。\n\n打开`Dropbox.m`文件找到下面这些行：\n\n```objc\n#warning INSERT YOUR OWN API KEY and SECRET HERE\nstatic NSString *apiKey = @\"YOUR_KEY\";\nstatic NSString *appSecret = @\"YOUR_SECRET\";\n```\n\n填写你的app key 和 secret，让后删除 #warning line，现在你可以关闭`Dropbox` Web App 页面。\n\n下面，创建一个文件夹在你Dropbox主文件下的根目录给它命一个你想要的名字。假如你把这个文件夹个和其他的Dropbox用户分享，发送他们在构建 Byte Club App的时候，他们将能够创建笔记并且能够上传所有人都能看得见的照片。\n\n在Dropbox.m中找打下面这些行：\n\n```objc\n#warning THIS FOLDER MUST BE CREATED AT THE TOP LEVEL OF YOUR DROPBOX FOLDER, you can then share this folder with others\nNSString * const appFolder = @\"byteclub\";\n```\n\n改变字符串的值，设置成你创建的Dropbox文件夹的名字，让后删除 #warning pragma.\n\n为了把这个app分发给其他用户，给他们接入`access tokens`,你将需要为你的Dropbox 平台 App打开`Enable additional users`设置。\n\n去在<https://www.dropbox.com/developers/apps>Dropbox app的控制台。点击你app 名称。然后点击`Enable Additional Users`按钮。将出现一个状态对话框表明你已经增加了你的用户限制。点击Okay关闭对话框。你的App 页面将像下面这样显示：\n\n![networking5](/images/nsurlsession/nsurlsession_06.jpg)\n\n> 注意：你可能注意到当你正在开发你的app的时候，你可以接入多达100个用户。当你准备发布app销售的时候，你必须申请生产状态，你可以通过点击`Apply for production`按钮来发送给`Dropbox`一些额外的信息。\n\n> Dropbox 将随后审核你的App 来确保它遵守指南，假如所有的一切进行得顺利的话，你将打开你的app的 API接入无线的用户。\n\n#### Dropbox 授权: 概览\n\n假如你曾经使用过第三方`twitter`客服端app，像`TweetBot`,你将会熟悉`OAuth`授权处理步骤从一个用户的角度。`OAuth`授权接入过程对你app来说是完全一样的。\n\n构建运行你的app，按照步骤登录。你将看到一个有2个标签的空白屏幕，一个是Notes，一个是PanoPhotos，如下图显示：\n\n![networking7](/images/nsurlsession/nsurlsession_07.jpg)\n\n`OAuth`授权发生在3和高级的步骤：\n\n1. 获取用来处理剩下的授权一个OAuth请求 token。这是请求token。\n2. 一个web 页面被呈现到用户面前通过他们的web浏览器。没有这一步的用户授权，对你的应用想获取一个第三步中的接入token几乎不可能。\n3. 在第二步完成后，应用调用web服务来交换临时请求token（从第一步中的）为了一个将存储在app里面的持久接入token。\n\n> 注意：为了保证这个教程的简洁，我们不打算进行更详细的讲解关于这里Dropbox授权工作。然而，假如你想了解更多点击整个教程的完全版本，它是[iOS 7 by Tutorials.](http://www.raywenderlich.com/?page_id=48020)的一部分。\n\n#### NSURLSession 的一系列类\n\nApple已经把`NSURLSession`描述成一个新类和一系列旧类的组合。这些新的工具是为了处理 上传，下载，处理授权已经处理在HTTP协议里面的任何事情。\n\n![networking12](/images/nsurlsession/nsurlsession_08.jpg)\n\n一个`NSURLSession`用一个带可选代理的`NSURLSessionConfiguration`构造。在你创建会话以后，你应该能够满足你的网络需要通过创建`NSURLSessionTask`的任务。\n\n#### NSURLSessionConfiguration\n\n这里有三种方式创建`NSURLSessionConfiguration`:\n\n* **defaultSessionConfiguration** - 创建一个使用全局缓存，cookie的配置对象和凭证存储的对象。这个配置会使你的会话最像`NSURLConnection`。\n* **ephemeralSessionConfiguration** - 这个配置是用来作为‘私有的’会话并且不会持久化存储缓存，cookie，或者信用存储对象。\n* **backgroundSessionConfiguration** - 当你想要从远程推送或者当app被暂时挂起时进行网络业务使用这个这个配置。参考17章和18章在[ iOS 7 by Tutorials](http://www.raywenderlich.com/?page_id=48020),`Beginning and Intermediate Multitasking`,有更详细的讲解。\n\n一旦你创建一个`NSURLSessionConfiguration`对象，你就可以在它上面设置各种接口像这样：\n\n```objc\nNSURLSessionConfiguration *sessionConfig =\n[NSURLSessionConfiguration defaultSessionConfiguration];\n\n// 1\nsessionConfig.allowsCellularAccess = NO;\n\n// 2\n[sessionConfig setHTTPAdditionalHeaders:\n          @{@\"Accept\": @\"application/json\"}];\n\n// 3\nsessionConfig.timeoutIntervalForRequest = 30.0;\nsessionConfig.timeoutIntervalForResource = 60.0;\nsessionConfig.HTTPMaximumConnectionsPerHost = 1;\n```\n\n1. 你限制了网络操作只有wifi才能进行。\n2. 这将设置所有的请求只接受 JSON类型的响应。\n3. 这些接口将配置资源或者请求超时时间。你也可以限制你的app对你的主机只能有一个网络连接。\n\n这些仅仅是你能配置的一些东西，确保检查所有列表的文档。\n\n#### NSURLSession\n\n`NSURLSession`被设计成替代`NSURLConnection`的API。Sessions做了他们的工作通过他们的部下，也就是非常出名的`NSURLSessionTask`对象。使用`NSURLSession`你能够创建任务使用基于block的便利方法，设置一个代理，或者同时两者。例如，假如你想要下载一张\n图片（ *challenge hint *）,你就需要创建一个`NSURLSessionDownloadTask`。\n\n第一步，你需要创建(会话)session。 这里有一个例子：\n\n```objc\n// 1\nNSString *imageUrl =\n@\"http://www.raywenderlich.com/images/store/iOS7_PDFonly_280@2x_authorTBA.png\";\n\n// 2\nNSURLSessionConfiguration *sessionConfig =\n  [NSURLSessionConfiguration defaultSessionConfiguration];\n\n// 3\nNSURLSession *session =\n  [NSURLSession sessionWithConfiguration:sessionConfig\n                                delegate:self\n                           delegateQueue:nil];\n```\n\nOk,这个仅仅是你目前所看到的一点点不同。让我们一步步重温。\n\n1. 用这个代码片段我们将一样进行下载在两个任务中。\n2. 你总是以创建`NSURLConfiguration`开始。\n3. 这里创建一个会话使用现在的类作为代理。\n\n在你创建会话后，你可以通过创建一个带一个`completion handler`的任务下载这张图片，想下面这样:\n\n```objc\n// 1\nNSURLSessionDownloadTask *getImageTask =\n[session downloadTaskWithURL:[NSURL URLWithString:imageUrl]\n\n    completionHandler:^(NSURL *location,\n                        NSURLResponse *response,\n                        NSError *error) {\n        // 2\n        UIImage  *downloadedImage =\n          [UIImage imageWithData:\n              [NSData dataWithContentsOfURL:location]];\n      //3\n      dispatch_async(dispatch_get_main_queue(), ^{\n        // do stuff with image\n         _imageWithBlock.image = downloadedImage;\n      });\n}];\n\n// 4\n[getImageTask resume];\n```\n\nAh ha!现在这个看起来有点像网络代码！\n\n1. 任务总是被sessions创建。任务一旦被基于block的方法创建。记住你仍然可以使用`NSURLSessionDownloadDelegate`来跟踪下载进度。所以你将获得最好的两个单词！（ *hint for challenge *）\n\n    -URLSession:downloadTask\n    :didWriteData:totalBytesWritten\n    :totalBytesExpectedToWrite:\n\n2. 这里你使用在 `completion handler`提供的本地变量来获取一个指向图片的指针。\n3. 最终你能够，例如，更新 `UIIImageView`的图片来显示新的文件。(hint hint ☺)\n4. 你总得自己启动任务！\n5. 记住我在前面所说的，一个会话也可以创建将要发送消息给代理方法来通知你完成等的任务。\n\n应该长成这样，使用相同的会话从上面：\n\n```objc\n// 1\nNSURLSessionDownloadTask *getImageTask =\n  [session downloadTaskWithURL:[NSURL URLWithString:imageUrl]];\n\n[getImageTask resume];\n```\n\n1. 这当然是确定使用更少的代码☺ 然而，假如你只这样做，你将什么都看不到。\n你需要让你的代理实现一些`NSURLSessionDownloadDelegate`协议的方法。\n\n首先我们需要获得通知当下载完成时：\n\n```objc\n-(void)URLSession:(NSURLSession *)session\n     downloadTask:(NSURLSessionDownloadTask *)downloadTask\ndidFinishDownloadingToURL:(NSURL *)location\n{\n  // use code above from completion handler\n}\n```\n\n再有你需要提供将要下载的文件存放的位置，然后你就可以使用这个来处理图片。\n\n最后，假如你需要跟踪下载进度，对于任务创建方法，你需要像下面这样用：\n\n```objc\n-(void)URLSession:(NSURLSession *)session\n     downloadTask:(NSURLSessionDownloadTask *)downloadTask\n     didWriteData:(int64_t)bytesWritten\ntotalBytesWritten:(int64_t)totalBytesWritten\ntotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite\n{\n  NSLog(@\"%f / %f\", (double)totalBytesWritten,\n    (double)totalBytesExpectedToWrite);\n}\n```\n\n正如你所见，`NSURLSessionTask`是一匹通过网络来干活的真实的驮马。\n\n#### NSURLSessionTask\n\n目前为止你已经知道`NSURLSessionDataTask`和`NSURLSessionDownloadTask`怎样使用了。这两个的任务是来自他们共同的基类`NSURLSessionTask`，你可以在这类看到：\n\n![networking13](/images/nsurlsession/nsurlsession_09.jpg)\n\n`NSURLSessionTask`在你的会话中是任务的基类；他们只能通过一个会话创建并且它们是下面子类中的一个。\n\n#### NSURLSessionDataTask\n\n这个任务发起HTTP GET请求来从服服务器拉取数据。数据被返回以NSData的形式返回。你应该在随后将其把这个数据转换成正确的数据类型比如`XML`,`JSON`,UIImage，plist等等。\n\n```objc\nNSURLSessionDataTask *jsonData = [session dataTaskWithURL:yourNSURL\n      completionHandler:^(NSData  *data,\n                          NSURLResponse  *response,\n                          NSError  *error) {\n        // handle NSData\n}];\n```\n\n#### NSURLSessionUploadTask\n\n使用这个类当你需要上传一些东西到web服务器时，使用HTTP `POST` 或者 `PUT` 命令。任务带来也允许你监视网络状况当它正在传输的时候。\n\n上传一张图片：\n\n```objc\nNSData *imageData = UIImageJPEGRepresentation(image, 0.6);\n\nNSURLSessionUploadTask *uploadTask =\n  [upLoadSession uploadTaskWithRequest:request\n                              fromData:imageData];\n```\n\n在这类任务被创建从一个会话中并且图片以NSData的形式上传。这里也可以通使用一个文件或者流的方法来进行上传。\n\n#### NSURLSessionDownloadTask\n\n`NSURLSessionDownloadTask`让通过远程服务下载文件变得超级简单，并且可以暂停和恢复下载只要你想。这个子类有别于其他两个。\n\n* 这个类型的任务直接写入一个临时文件。\n* 在下载会话中将调用` URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite: `来更新状态信息。\n* 当任务完成时，`URLSession:downloadTask:didFinishDownloadingToURL: `被调用。这就是你该保存文件从临时位置到一个永久位置的时候。\n* 当下载失败或者取消时，你可以让数据重新开始下载。\n\n这个特性将极其有用当你在下载一个`Byte Club`定位 全景照片给你的设备的相机胶卷。你看到的一个下载任务例子在上面下载图片片段中。\n\n##### 上述全部\n\n所有的上述任务被创建在一个暂停的状态；在创建一个任务时你需要调用它的继续方法像下面演示的那样：\n\n```objc\n[uploadTask resume];\n```\n\n当你一次不只管理一个任务时，`taskIdentifier`接口允许你唯一标示一个在会话中的任务\n\n这就是！既然你已经知道了`NSURLSession`系列的主要类，让我们尝试一下。\n\n#### Sharing notes with NSURLSession\n\nOK，这不是死亡诗社，这是`Byte Club`!是时候开始看看一下这个的网络代码在起作用了。\n\n你需要一个方法来给`Byte Club`的其他成员发送消息。既然你已经设置了接入token，下一步就是实例化`NSURLSesssion`对象，让后调用你的第一个Dropbox API。\n\n##### Creating an NSURLSession\n\n添加下面的接口到 **NotesViewController.m** 文件，就在 NSArray  *notes 行的后面：\n\n```objc\n@property (nonatomic, strong) NSURLSession *session;\n```\n\n你将创造所有你的下属从上面的session中。\n\n添加下面的方法到`NotesViewController.m`就在`initWithStyle`方法的上面：\n\n\n```objc\n- (id)initWithCoder:(NSCoder *)aDecoder\n{\n    self = [super initWithCoder:aDecoder];\n    if (self) {\n        // 1\n        NSURLSessionConfiguration  *config = [NSURLSessionConfiguration ephemeralSessionConfiguration];\n\n        // 2\n        [config setHTTPAdditionalHeaders:@{@\"Authorization\": [Dropbox apiAuthorizationHeader]}];\n\n        // 3\n         _session = [NSURLSession sessionWithConfiguration:config];\n    }\n    return self;\n}\n```\n\n下面是上面代码注释的注释的解释：\n\n1. 你的app调用 `initWithCoder`当你实例化一个控制器从一个故事版中;因此这是一个完美的时刻初始化和创建`NSURLSession`。你并不想积极缓存或者持久化这里，所有你使用`ephemeralSessionConfiguration`便利方法，它返回一个没有持久化缓存，cookies，或者认证存储的会话。这是一个\"私有浏览\"配置。\n2. 下一步，你添加授权HTTP头道配置对象中。apiAuthorizationHeader是一个我写的辅助方法，返回一个字符串，以授权制定的格式。这个字符串包含access token，token secret和你的 Dropbox App API 秘钥。记住这是必要的因为每个对 Dropbox API 的调用都需要被授权。\n3. 最后，你使用上面的配置创建了`NSURLSession`。\n\n会话现在准备好创建在你app中你所需要的任何网络任务。\n\n##### GET Notes through the Dropbox API\n\n为了模拟一条笔记被另一个用户添加，添加任何你在设置在你的Dropbox根目录下的文件夹中选择的文本文件。例如位于Dropbox文件夹下 **byteclub** 下面显示的 **test.txt**：\n\n![networking14](/images/nsurlsession/nsurlsession_10.jpg)\n\n等待直到`Dropbox`确认它已经同步完你的文件，让后继续下面代码。\n\n添加下面的代码到空的`notesOnDropBox`方法中在`NotesViewController.m`:\n\n```objc\n[UIApplication sharedApplication].networkActivityIndicatorVisible = YES;\n// 1\nNSURL *url = [Dropbox appRootURL];\n\n// 2\nNSURLSessionDataTask *dataTask =\n[self.session dataTaskWithURL:url\n            completionHandler:^(NSData  *data,\n                                NSURLResponse  *response,\n                                NSError  *error) {\n    if (!error) {            \n        // TODO 1: More coming here!\n    }                \n}];\n\n// 3  \n[dataTask resume];\n```\n\n这个方法的目标是检索在app的Dropbox文件下的文件列表。让我们来重温一下这是怎样工作的一步步。\n\n1. 在Dropbox中，你能看到一个文件夹的内容通过进行一个已经授权的`GET`请求到某个特别的URL - 像https://api.dropbox.com/1/metadata/dropbox/byteclub. 我已经创建了一个便利的方法在Dropbox类中来为你产生这个URL。\n2. `NSURLSession`用便利构造方法来简单的创建各种类型的任务。这是你创建的一个数据任务为了执行一个GET请求到那个URL。当请求完成时，你的`completionHandler` block被调用。一会儿你将添加一下代码到这里。\n3. 记住一个任务默认是一个`暂停`的状态,因此你需要调用恢复方法来启动运行。\n\n那就是所有你需要做的来开始一个`GET`请求-现在让我们添加代码到解析的结果中。添加下面的这些行到\"TUDO 1\"注释的后面:\n\n```objc\n// 1\nNSHTTPURLResponse *httpResp = (NSHTTPURLResponse *) response;\nif (httpResp.statusCode == 200) {\n\n    NSError  *jsonError;\n\n    // 2\n    NSDictionary  *notesJSON =\n      [NSJSONSerialization JSONObjectWithData:data                                                                        \n        options:NSJSONReadingAllowFragments                                                                             \n        error:&jsonError];\n\n    NSMutableArray  *notesFound = [[NSMutableArray alloc] init];\n\n    if (!jsonError) {                    \n        // TODO 2: More coming here!\n    }\n}\n```\n\n下面是两个主要的部分:\n\n1. 你知道你已经发送一个HTTP请求，所以响应将是一个HTTPP响应。因此这里你可以抛出`NSURLResponse`到一个`NSHTTPURLRequest`响应以便你能够接入到接口的状态码。\n假如你收到了一个HTTP状态码200，然后一切正常。\n\n\tHTTP 错误码举例：\n\n\t* 400 - 输入参数错误。错误消息将表明那个和为什么错误。\n\t* 401 - token错误或者失效。这个可能发生假如用户或者`Dropbox`被撤销或者接入token过期。你可以通过重新授权修复这个用户。\n\t* 403 - 错误的授权请求（错误的用户键，坏的随机数，时间戳过期...）。不信的是，重新授权用户在这里并没有用。\n\t* 404 - 指定路径下的文件或者文件夹没找到。\n\t* 405 - 未知的请求方法（通常应该是 GET 或者 POST）。\n\t* 429 - 你的app发送太多请求超出了限制的速率，429能够触发在每个app或者每个用户根部。\n\t* 503 - 假如响应包括重发后的头，这就意味做你的`OAuth` 1.0 app 正在被限速。否则，这个表明了一个短暂的服务器错误，并且你的app应该重新发送这这个请求。\n\t* 507 - 用户超出 Dropbox 储存配额。\n\t* 5xx - 服务器错误。\n\n2. Dropbox API返回JSON类型的数据。所有你收到一个200的响应，然后应该把数据转发成JSON使用iOS的构建JSON序列化的方法。了解更多关于JSON和NSJSONSerialization，查看第23章在 `iOS 5 by Tutorials`,\"Working with JSON.\"\n\nJSON 数据返回从Dropbox将看起来像下面这样：\n\n```\n{\n    \"hash\": \"6a29b68d106bda4473ffdaf2e94c4b61\",\n    \"revision\": 73052,\n    \"rev\": \"11d5c00e1cf6c\",\n    \"thumb_exists\": false,\n    \"bytes\": 0,\n    \"modified\": \"Sat, 10 Aug 2013 21:56:50 +0000\",\n    \"path\": \"/byteclub\",\n    \"is_dir\": true,\n    \"icon\": \"folder\",\n    \"root\": \"dropbox\",\n    \"contents\": [{\n        \"revision\": 73054,\n        \"rev\": \"11d5e00e1cf6c\",\n        \"thumb_exists\": false,\n        \"bytes\": 16,\n        \"modified\": \"Sat, 10 Aug 2013 23:21:03 +0000\",\n        \"client_mtime\": \"Sat, 10 Aug 2013 23:21:02 +0000\",\n        \"path\": \"/byteclub/test.txt\",\n        \"is_dir\": false,\n        \"icon\": \"page_white_text\",\n        \"root\": \"dropbox\",\n        \"mime_type\": \"text/plain\",\n        \"size\": \"16 bytes\"\n    }],\n    \"size\": \"0 bytes\"\n}\n```\n\n所有最后一段添加的代码是拉取的部分你感兴趣的从JSON中。特别的，你想循环遍历“contents”数组来把“is_dir”设置成`false`。\n\n这样做，添加下面的代码到“TODO 2”注释后面：\n\n```objc\n// 1\nNSArray *contentsOfRootDirectory = notesJSON[@\"contents\"];\n\nfor (NSDictionary *data in contentsOfRootDirectory) {\n    if (![data[@\"is_dir\"] boolValue]) {\n        DBFile  *note = [[DBFile alloc] initWithJSONData:data];\n        [notesFound addObject:note];\n    }\n}\n\n[notesFound sortUsingComparator:\n  ^NSComparisonResult(id obj1, id obj2) {\n    return [obj1 compare:obj2];                    \n}];\n\nself.notes = notesFound;\n\n// 6\ndispatch_async(dispatch_get_main_queue(), ^{\n    [UIApplication sharedApplication].networkActivityIndicatorVisible = NO;\n    [self.tableView reloadData];\n});\n```\n\n这里有两部分：\n\n1. 你拉取数组对象从“contents”键中，让后循环便利数组。每个数组入口是一个文件，所以你创建一个相应的`DBFile`文件模型为每一个文件。\n\n    `DBFile`是一个我为你创建的辅助类，为了拉取信息从一个JSON字典到一个文件中 - 轻轻一瞥就能看到它是怎样工作的。\n\n    当你完成时，你添加所有的笔记到`self.notes`接口中。表视图被设置来显示数组中的任何记录。\n\n既然你的表视图数据源已经更新了，你需要重载表的数据。无论何时你正在处理异步网络请求时，你必须保证更新UIKit在主线程。\n\n机敏的读者将会注意到在上述代码中没有错误处理；假如你感觉你像一个哭丧女（大多数Byte Club 都是！）添加一些代码在这里（在随后的代码块中你将添加），代码在错误和警告用户的时候将重试。\n\n构建运行你的app；你应该看你添加到你的`Dropbox`文件夹的文件是否显示在列表中，就像下面例子一样显示：\n\n![networking16](/images/nsurlsession/nsurlsession_11.jpg)\n\n事情本来是小事，当时这证明了你正确的调用了Dropbox API。\n\n下一步是发布比较然后向其他俱乐部成员发起挑战，再一次使用Dropbox API 就当你是传送机构。\n\n##### POST Notes through the Dropbox API\n\n轻点右上角的 + 号，你将看到笔记add/edit屏幕出现，就像下面演示的一样：\n\n![networking17](/images/nsurlsession/nsurlsession_12.jpg)\n\n开始的app已经安装了DBFile 模型对象到NoteDetailsViewController在`prepareForSegue:sender:`方法中：\n\n加入你瞥一眼这个方法，你将看到`NoteViewController`被设置成`NoteDetailsViewController`的代理。这种方法，`NoteDetailsViewController`能够通知`NoteViewController`当用户完成编辑一篇笔记或者取消编辑一篇笔记时。\n\n打开`NotesViewController.m `,添加下面这行到`prepareForSegue:sender:`中，就在`showNote.delegate = self`行的后面；\n\n```objc\nshowNote.session = _session;\n```\n\n`NoteDetailsViewController`已经有一个`NSURLSession`的接口名字叫做`session`,因此你能够设置它在`prepareForSegue:sender: `载入之前。\n\n现在detail view controller将获得相同的`NSURLSession`,所有detail view controller能够使用它来进行DropBox 的API调用。\n\n`Cancel`和`Done`按钮已经呈现在你的app中；你只需要添加一些在他们背后保存或者取消在尚未完工的笔记逻辑。\n\n在`NoteDetailsViewController.m`,找到下面这一行在`(IBAction)done:(id)sender:`方法中：\n\n```objc\n// - UPLOAD FILE TO DROPBOX - //\n    [self.delegate noteDetailsViewControllerDoneWithDetails:self];\n```\n\n...用下面的替换它：\n\n```objc\n// 1\nNSURL  *url = [Dropbox uploadURLForPath: _note.path];\n\n// 2\nNSMutableURLRequest *request =\n  [[NSMutableURLRequest alloc] initWithURL:url];\n[request setHTTPMethod:@\"PUT\"];\n\n// 3\nNSData *noteContents = [_note.contents dataUsingEncoding:NSUTF8StringEncoding];\n\n// 4\nNSURLSessionUploadTask *uploadTask = [_session      \n  uploadTaskWithRequest:request                                                                  \n  fromData:noteContents                                                        \n  completionHandler:^(NSData *data,                                                                             \n  NSURLResponse *response,                                                                               \n  NSError *error)\n{   \n   NSHTTPURLResponse *httpResp = (NSHTTPURLResponse*) response;\n\n   if (!error && httpResp.statusCode == 200) {\n\n       [self.delegate noteDetailsViewControllerDoneWithDetails:self];\n   } else {\n       // alert for error saving / updating note\n   }\n}];\n\n// 5\n[uploadTask resume];\n```\n\n这个实现了你需要保存和分享你的笔记的所有事情。假如仔细观察每一块的注释，你将发现做了下面的事：\n\n1. 为了上传一个文件到Dropbox，你需要再次使用某个API URL。就像先前你需要一个URL来列出在一个文件夹中的文件，我已经构造了一个辅助方法来为你产生URL。你可以在这里调用。\n2. 下一步是你的老朋友`NSMutableURLRequest`,新的APIs能够同时使用普通的URL是和`NSURLRequest`对象，但是这里你需要可变的形式来使Dropbox API让它的请求变成PUT请求。设置HTTP方法作为PUT发信号给Dropbox来让它为你创建一个新的文件。\n3. 下一步是将文本从你的`UITextView`编码成NSData对象。\n4. 既然你已经创建好了请求和NSData数据，你下一步就是创建一个`NSURLSessionUploadTask`然后设置`completion handler` block.一旦成功，你就调用代理方法` noteDetailsViewControllerDoneWithDetails:`来关闭呈现的内容。在生产级别的应用中你可以回传一个新的BDFile给代理然后同步你需要持久化的数据。为了这个应用，你只需要刷新`NotesViewController `用一个网络调用。\n5. 再次提到，所有的任务以暂停的状态被创建，所以你必须调用恢复来启动他们。\n\n构建然后运行你的App，点击笔记标签上的+号。在`challenge name`字段上输入你的名字，输入一些文本在`note`字段想Ray发布一份挑战书，和下面的例子相似：\n\n![networking17](/images/nsurlsession/nsurlsession_13.jpg)\n\n当你清点`Done`时，`NoteViewController`将返回并且给你列出新的笔记像下面显示的那样：\n\n![networking18](/images/nsurlsession/nsurlsession_14.jpg)\n\n\n你已经正式的给Ray下发挑战书；然而，他有朋友在非常高的位置所有你最好尽力完成这场比赛。\n\n但是这里有一条非常重要的消息遗漏了。你能告诉我是什么么？\n\n轻点笔记包含的挑战；`NoteDetailsViewController`自己呈现，当时笔记的内容确实空白的。\n\nRay并不会找到你的发的非常有威胁的挑战假如他没有读的话！\n\n现在，app只是调用`Dropbox`元数据API来检索文件列表。你也需要添加一些代码来抓取笔记的内容。\n\n打开`NoteDetailsViewController.m`,用下面的实现替换空白的`retreiveNoteText`的实现：\n\n```objc\n-(void)retreiveNoteText\n{\n    // 1\n    NSString  *fileApi =\n      @\"https://api-content.dropbox.com/1/files/dropbox\";\n    NSString  *escapedPath = [ _note.path\n      stringByAddingPercentEscapesUsingEncoding:\n      NSUTF8StringEncoding];\n\n    NSString  *urlStr = [NSString stringWithFormat: @\"%@/%@\",\n      fileApi,escapedPath];\n\n    NSURL  *url = [NSURL URLWithString: urlStr];\n\n    [UIApplication sharedApplication].networkActivityIndicatorVisible = YES;\n\n    // 2\n    [[ _session dataTaskWithURL:url completionHandler:^(NSData  *data, NSURLResponse  *response, NSError  *error) {\n\n        if (!error) {\n            NSHTTPURLResponse  *httpResp = (NSHTTPURLResponse*) response;\n            if (httpResp.statusCode == 200) {\n                // 3\n                NSString  *text =\n                 [[NSString alloc]initWithData:data\n                   encoding:NSUTF8StringEncoding];\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    [UIApplication sharedApplication].networkActivityIndicatorVisible = NO;\n                    self.textView.text = text;\n                });\n\n            } else {\n                // HANDLE BAD RESPONSE //\n            }\n        } else {\n            // ALWAYS HANDLE ERRORS :-] //\n        }\n        // 4\n    }] resume];\n}\n```\n\n上面在笔记中的代码（没有错误检查）下面来解释：\n\n1. 设置请求的路径和你期望检索的文件的URL地址；/文件的端点在Dropbox API中将会返回给你一个指定文件的内容。\n2. 用指向感兴趣的文件的URL创建数据任务。这个调用应该开始，只要你纵览整个app你会相当熟悉。\n3. 假如你响应的代码表明所有的都是好的，在主线程用你在先前的步骤中检索到的文件内容设置textView。记住，UI更新必须切换到主线程。\n4. 一旦这个任务被初始化，调用恢复。这里有写不一样的方法和以前的相比，当恢复被直接调用时在任务还没有指派时。\n\n构建运行你的App，在列表中对你的挑战轻点，内容将直接正确的显示在view中，像下面这样：\n\n![networking19](/images/nsurlsession/nsurlsession_15.jpg)\n\n你可以扮演Ray然后通过向笔记中输入文本响应这个挑战；文件将很快更新当你轻点`Done`。\n\n#### 使用`NSURLSessionTask`代理发送照片\n\n你已经看到怎样使用`NSURLSession`异步便利构造方法。但是假如你想把注意力集中在文件传输上，例如上传一个大文件并且显示一个进度条怎么样？\n\n对于这种异步的，耗时任务类型你需要实现`NSURLSessionTaskDelegate`协议方。通过实现这个方法，你能够检索回调当一个任务接收到数据和完成接收数据时。\n\n你可能已经注意到`PanoPhotos`标签是空的当你启动App的时候。然而，`Byte Club`组织的创办成员已经慷慨的提供了一些他们自己的全景照片，你可以用它来填充你的app。\n\n下载这些 我们为你放在一起的[全景照片](http://cdn4.raywenderlich.com/downloads/ByteClub_photos.zip)。解压文件，拷贝到你的app在Dropbox目录下的照片目录。你文件夹的内容应该和下面一样：\n\n![networking20](/images/nsurlsession/nsurlsession_16.jpg)\n\nDropbox和核心API可以提供照片的缩略图；使用一个 UITableView cell这听起来想一件非常完美的事。\n\n打开` PhotosViewController.m`然后在`“GO GET THUMBNAILS`注释后面添加下面的代码到`tableView:cellForRowAtIndexPath: `\n\n```objc\n[UIApplication sharedApplication].networkActivityIndicatorVisible = YES;\nNSURLSessionDataTask *dataTask = [_session dataTaskWithURL:url\n  completionHandler:^(NSData  *data, NSURLResponse  *response,\n  NSError  *error) {\n    if (!error) {\n      UIImage  *image = [[UIImage alloc] initWithData:data];\n      photo.thumbNail = image;\n      dispatch_async(dispatch_get_main_queue(), ^{\n        [UIApplication sharedApplication].networkActivityIndicatorVisible = NO;\n        cell.thumbnailImage.image = photo.thumbNail;\n      });\n    } else {\n      // HANDLE ERROR //\n    }\n}];\n[dataTask resume];\n```\n\n上面的代码显示了照片的缩略图图在表视图的cell中。。。或者至少它会是，假如`_photoThumbnails`现在不是空的话。\n\n找到`refreshPhotos`用下面的实现替换：\n\n```objc\n- (void)refreshPhotos\n{\n    [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES];\n    NSString  *photoDir = [NSString stringWithFormat:@\"https://api.dropbox.com/1/search/dropbox/%@/photos?query=.jpg\",appFolder];\n    NSURL  *url = [NSURL URLWithString:photoDir];\n\n    [[ _session dataTaskWithURL:url completionHandler:^(NSData\n       *data, NSURLResponse  *response, NSError  *error) {\n        if (!error) {\n            NSHTTPURLResponse  *httpResp =\n             (NSHTTPURLResponse*) response;\n            if (httpResp.statusCode == 200) {\n\n                NSError  *jsonError;\n                NSArray  *filesJSON = [NSJSONSerialization  \n                  JSONObjectWithData:data                                                                     \n                  options:NSJSONReadingAllowFragments                                                                           \n                  error:&jsonError];\n                NSMutableArray  *dbFiles =\n                  [[NSMutableArray alloc] init];\n\n                if (!jsonError) {\n                    for (NSDictionary  *fileMetadata in\n                      filesJSON) {\n                        DBFile  *file = [[DBFile alloc]\n                          initWithJSONData:fileMetadata];\n                        [dbFiles addObject:file];\n                    }\n\n                    [dbFiles sortUsingComparator:^NSComparisonResult(id obj1, id obj2) {\n                        return [obj1 compare:obj2];\n                    }];\n\n                     _photoThumbnails = dbFiles;\n\n                    dispatch_async(dispatch_get_main_queue(), ^{\n                        [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO];\n                        [self.tableView reloadData];\n                    });\n                }\n            } else {\n                // HANDLE BAD RESPONSE //\n            }\n        } else {\n            // ALWAYS HANDLE ERRORS :-] //\n        }\n    }] resume];\n}\n```\n\n这个和你早期载入挑战笔记时写的代码很像。这次，API调用来查找在`photos`目录的内容，并且只会以.jpg拓展的文件。\n\n既然`_photoThumbnails`数组已经填充好了，缩略图将出现在表视图中并且异步更新。\n\n构建运行你的app，然后切换到`PanoPhotos`标签；缩略图将载入并且像下面这样出现：\n\n![networking21](/images/nsurlsession/nsurlsession_19.jpg)\n\n照片看起来非常的棒--只是请当心Matthijs家撕裂代码的猫🐱！\n\n#### 上传一张全景照片\n\n你的app能够下载相片，如果它也能上传照片并且显示上传进度的话就非常棒了。\n\n为了跟踪上传的进度，`PhotosViewController`必须成为`NSURLSessionDelegate`和`NSURLSessionTaskDelegate`协议的代理，以便你能收到进度回调。\n\n修改在`PhotosViewController.m`中`PhotosViewController`的接口声明，添加`NSURLSessionTaskDelegate`,像下面这样：\n\n```objc\n @ interface PhotosViewController ()UITableViewDelegate, UITableViewDataSource, UIImagePickerControllerDelegate, UINavigationControllerDelegate, NSURLSessionTaskDelegate>\n```\n\n下一步，添加下面的私有接口：\n\n```objc\n@property (nonatomic, strong)\n  NSURLSessionUploadTask *uploadTask;\n```\n\n上面的指针引用了任务对象；通过哪种方式，你就可以接入到对象的成员中来跟踪上传任务的进度了。\n\n当用户选择一张图片上传时，`didFinishPickingMediaWithInfo`调用`uploadImage:`方法来执行文件上传。\n现在，那个方法空了-这是你的工作让它丰满起来。\n\n替换`uploadImage: `用下面的代码：\n\n```objc\n- (void)uploadImage:(UIImage*)image\n{\n    NSData  *imageData = UIImageJPEGRepresentation(image, 0.6);\n\n    // 1\n    NSURLSessionConfiguration  *config = [NSURLSessionConfiguration defaultSessionConfiguration];\n    config.HTTPMaximumConnectionsPerHost = 1;\n    [config setHTTPAdditionalHeaders:@{@\"Authorization\": [Dropbox apiAuthorizationHeader]}];\n\n    // 2\n    NSURLSession  *upLoadSession = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:nil];\n\n    // for now just create a random file name, dropbox will handle it if we overwrite a file and create a new name..\n    NSURL  *url = [Dropbox createPhotoUploadURL];\n\n    NSMutableURLRequest  *request = [[NSMutableURLRequest alloc] initWithURL:url];\n    [request setHTTPMethod:@\"PUT\"];\n\n    // 3\n    self.uploadTask = [upLoadSession uploadTaskWithRequest:request fromData:imageData];\n\n    // 4\n    self.uploadView.hidden = NO;\n    [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES];\n\n    // 5\n    [ _uploadTask resume];\n}\n```\n\n下面是上面的代码做的事：\n\n1. 起先，你使用设置在`initWithCoder`的会话和相关的便利方法来创建异步任务。这个时候，你使用一个`NSURLSessionConfiguration `,它只允许一个连接连接到远程主机，因为你上传进度处理一次就是一个文件。\n2. 上传和下载任务报告信息通过它们的代理返回；你将简短的实现。\n3. 这里你设置了`uploadTask`接口使用从`UIImagePicker`获得的JPEG图片。\n4. 下一步，你显示`UIProgressView`让它隐藏在`PhotosViewController`内部。\n5. 开始任务--额，抱歉，是恢复任务。\n\n既然代理已经设置了，你就可以实现`NSURLSessionTaskDelegate`方法来更新进度视图。\n\n添加下面的代码到` PhotosViewController.m`文件末尾：\n\n```objc\n#pragma mark - NSURLSessionTaskDelegate methods\n\n- (void)URLSession:(NSURLSession *)session\n  task:(NSURLSessionTask *)task\n  didSendBodyData:(int64_t)bytesSent\n  totalBytesSent:(int64_t)totalBytesSent\n  totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [ _progress setProgress:\n          (double)totalBytesSent /\n          (double)totalBytesExpectedToSend animated:YES];\n    });\n}\n```\n\n上面的代理方法将定期报告信息给调用者关于上传任务的信息。它同时会更新`UIProgressView`（ _progress）的进度以便显示 totalBytesSent/totalBytesExpectedToSend,这比显示一个完成的百分比跟有意义（也更极客）。\n\n剩下唯一的事就是当上传任务结束时指示一下。添加下面的代码到` PhotosViewController.m`文件末尾：\n\n```objc\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error\n{\n    // 1\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO];\n         _uploadView.hidden = YES;\n        [ _progress setProgress:0.5];\n    });\n\n    if (!error) {\n        // 2\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self refreshPhotos];\n        });\n    } else {\n        // Alert for error\n    }\n}\n```\n\n这里没有很多代码，但是它执行了两项非常重要的任务：\n\n1. 打开网络指示器，然后隐藏`_uploadView`作为上传完成的一点点清理工作。\n2. 刷新`PhotosViewController`以便包含你刚刚上传的照片，由于demo app是不能进行任何本地储存的上传\n。在一个真正的app中，你应该把图片在本地进行储存和缓存。\n\n构建运行你的app，导航到`PanoPhotos`标签，点击照相图标选择一张照片。\n\n![networking22](/images/nsurlsession/nsurlsession_17.jpg)\n\n> 注意：假如你说使用模拟器测试app，很显然你不能用你的Mac拍照，所有仅仅是拷贝一张全景照片\n给模拟器然后上传。这样做，可以确保没有其他的Xcode工程现在连接到这个模拟器，在Xcode中选择 **Xcode   Open Developer Tool   iOS Simulator**。\n\n> 从Finder中拖拽一张全景照片带模拟器中，在模拟器中图片将会在Safari中打开。长按图片然后保存图片到图库中。\n\n在选择一张图片后上传，uploadView显示在屏幕的中央，并且带有上传进度，乡下面这一样显示：\n\n![networking23](/images/nsurlsession/nsurlsession_18.jpg)\n\n你可能注意到一张图片上传需要花一些时间由于上传任务设置了`better quality`缩放因子。对于那些A类性格的人，你应该提供一个取消函数假如上传花费太长的时间。\n\n取消按钮在`uploadView`已经被封装起来在故事板中，所有你只需实现清楚逻辑来杀死下载操作就行。\n\n用下面的代码替换` PhotosViewController.m`的`cancelUpload: `：\n\n```objc\n- (IBAction)cancelUpload:(id)sender {    \n    if ( _uploadTask.state == NSURLSessionTaskStateRunning) {\n        [ _uploadTask cancel];\n    }\n}\n```\n\n在这类你会看到，取消一个任务相当简单就是调用一个取消方法。\n\n现在构建运行你的app，选择一张照片上传然后点击`Cancel`。图片上传将会停止并且`uploadView`将会被隐藏。\n\n就这样--`Byte Club`完成了！\n\n#### 何去何从？\n\n这里是[完成的工程](http://cdn5.raywenderlich.com/downloads/ByteClub_Completed.zip)在这个`NSURLSession`教程中。\n\n假如你做到这一步，恭喜你可以享受到`Byte Club`的时光！不要告诉任何`Android`的小伙伴们！ :]\n你现在能够处理在你app需要的任何网络任务了。\n\n假如你喜欢这个课程，你可能想要查阅我们的新书[ iOS 7 by Tutorials](http://www.raywenderlich.com/?page_id=48020),这是这本书的一个简略版本，这本书几乎涵盖了在iOS 7中最新和最多的APIs，这些你应该清楚的知道作为一个开发者。\n\n我几乎忘记了。。。\n\n    /slap <you the reader> have been slapped around a bit with a large trout.\n\n（不要问我为什么 hehe！😄）\n\n假如你有任何问题或者评论关于这个教程或者`NSURLSession`,请加入到下面的论坛讨论！\n\n\n参考资料：\n\n* [从 NSURLConnection 到 NSURLSession](http://objccn.io/issue-5-4/)\n* [NSURLSession Tutorial](http://www.raywenderlich.com/51127/nsurlsession-tutorial)\n\n\n译者注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["翻译","NSURLSession"],"categories":["系统 API"]},{"title":"iOS 线程安全-锁","url":"/2016/01/14/2016-01-14-iosxian-cheng-an-quan-suo/","content":"\n## Objective－C\n\n### **使用 @synchronized 类实现锁**\n\n```objc\n// 实例类person\nPerson *person = [[Person alloc] init];\n// 线程A\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    @synchronized(person) {\n        [person personA];\n        [NSThread sleepForTimeInterval:3];\n        // 线程休眠3秒\n    }\n});\n// 线程B\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    @synchronized(person) {\n        [person personB];\n    }\n});\n\n```\n\n### **使用 NSRecursiveLock 类实现锁**\n> 递归锁，递归或循环方法时使用此方法实现锁，可避免死锁等问题\n\n\n```objc\n// 实例类person\nPerson *person = [[Person alloc] init];\n\n// 创建锁对象\nNSRecursiveLock *theLock = [[NSRecursiveLock alloc] init];\n\n// 创建递归方法\nstatic void (^testCode)(int);\ntestCode = ^(int value) {\n    [theLock tryLock];\n    if (value > 0)  {\n        [person personA];\n        [NSThread sleepForTimeInterval:1];\n        testCode(value - 1);\n    }\n    [theLock unlock];\n};\n\n//线程A\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    testCode(5);\n});\n\n//线程B\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    [theLock lock];\n    [person personB];\n    [theLock unlock];\n});\n\n```\n\n### **使用 NSConditionLock（条件锁）类实现锁**\n> 使用此方法可以指定，只有满足条件的时候才可以解锁\n\n```objc\n// 实例类person\nPerson *person = [[Person alloc] init];\n// 创建条件锁\nNSConditionLock *conditionLock = [[NSConditionLock alloc] init];\n// 线程A\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    [conditionLock lock];\n    [person personA];\n    [NSThread sleepForTimeInterval:5];\n    [conditionLock unlockWithCondition:10];\n });\n// 线程B\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    [conditionLock lockWhenCondition:10];\n    [person personB];\n    [conditionLock unlock];\n });\n\n```\n\n### **NSDistributedLock（分布式锁）**\n> 在iOS中不需要用到，也没有这个方法，因此本文不作介绍，这里写出来只是想让大家知道有这个锁存在。\n如果想要学习NSDistributedLock的话，你可以创建MAC OS的项目自己演练，方法请自行Google，谢谢\n\n## C语言\n\n### **使用 pthread_mutex_t 实现锁**\n> 注意：必须在头文件导入：#import <pthread.h>\n\n```objc\n// 实例类person\nPerson *person = [[Person alloc] init];\n// 创建锁对象\n__block pthread_mutex_t mutex;\npthread_mutex_init(&mutex, NULL);\n// 线程A\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    pthread_mutex_lock(&mutex);\n    [person personA];\n    [NSThread sleepForTimeInterval:5];\n    pthread_mutex_unlock(&mutex);\n});\n// 线程B\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    pthread_mutex_lock(&mutex);\n    [person personB];\n    pthread_mutex_unlock(&mutex);\n});\n\n```\n### **使用 GCD 实现“锁”(信号量）**\n> GCD提供一种信号的机制，使用它我们可以创建“锁”\n\n```objc\n// 实例类person\nPerson *person = [[Person alloc] init];\n\n// 创建并设置信量\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(1);\n\n// 线程A\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n    [person personA];\n    [NSThread sleepForTimeInterval:5];\n    dispatch_semaphore_signal(semaphore);\n});\n\n// 线程B\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n    [person personB];\n    dispatch_semaphore_signal(semaphore);\n});\n\n```\n\n我在这里解释一下代码。`dispatch_semaphore_wait`方法是把信号量加1，`dispatch_semaphore_signal`\n是把信号量减1。\n\n我们把信号量当作是一个计数器，当计数器是一个非负整数时，所有通过它的线程都应该把这个整数减1。\n\n如果计数器大于0，那么则允许访问，并把计数器减1。如果为0，则访问被禁止，所有通过它的线程都处于\n等待的状态。\n\n### **使用POSIX（条件锁）创建锁）**\n\n```objc\n// 实例类person\nPerson *person = [[Person alloc] init];\n\n// 创建互斥锁\n __block pthread_mutex_t mutex;\n pthread_mutex_init(&mutex, NULL);\n\n // 创建条件锁\n __block pthread_cond_t cond;\n pthread_cond_init(&cond, NULL);\n\n // 线程A\n dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n     pthread_mutex_lock(&mutex);\n     pthread_cond_wait(&cond, &mutex);\n     [person personA];\n     pthread_mutex_unlock(&mutex);\n });\n\n // 线程B\n dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n     pthread_mutex_lock(&mutex);\n     [person personB];\n     [NSThread sleepForTimeInterval:5];\n     pthread_cond_signal(&cond);\n     pthread_mutex_unlock(&mutex);\n });\n\n```\n\n效果：程序会首先调用线程B，在5秒后再调用线程A。因为在线程A中创建了等待条件锁，线程B有激活锁，只有当线程B执行完后会激活线程A。\n\n`pthread_cond_wait`方法为等待条件锁。\n\n`pthread_cond_signal`方法为激活一个相同条件的条件锁。\n\n> 注意:自旋锁`OSSpinLock`已经不再线程安全\n\n## 参考资料\n\n* <http://www.liuhaihua.cn/archives/25316.html>\n* [不再安全的 OSSpinLock](http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/)\n","tags":["锁"],"categories":["多线程"]},{"title":"SQLite 教程(七)","url":"/2016/01/14/2016-01-14-sqlite-jiao-cheng-qi/","content":"\n#### SQLite Order By\n\nSQLite 的 **ORDER BY** 子句是用来基于一个或多个列按升序或降序顺序排列数据。\n\n---\n\n**语法**\n\nORDER BY 子句的基本语法如下：\n\n\tSELECT column-list\n\tFROM table_name\n\t[WHERE condition]\n\t[ORDER BY column1, column2, .. columnN] [ASC | DESC];\n\n您可以在 ORDER BY 子句中使用多个列。确保您使用的排序列在列清单中。\n\n**实例**\n\n假设 COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面是一个实例，它会将结果按 SALARY 升序排序：\n\n\tsqlite> SELECT * FROM COMPANY ORDER BY SALARY ASC;\n\n这将产生以下结果：\n\n\t\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t7           James       24          Houston     10000.0\n\t2           Allen       25          Texas       15000.0\n\t1           Paul        32          California  20000.0\n\t3           Teddy       23          Norway      20000.0\n\t6           Kim         22          South-Hall  45000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\n下面是一个实例，它会将结果按 NAME 和 SALARY 升序排序：\n\n\tsqlite> SELECT * FROM COMPANY ORDER BY NAME, SALARY ASC;\n\n这将产生以下结果：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t2           Allen       25          Texas       15000.0\n\t5           David       27          Texas       85000.0\n\t7           James       24          Houston     10000.0\n\t6           Kim         22          South-Hall  45000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t1           Paul        32          California  20000.0\n\t3           Teddy       23          Norway      20000.0\n\n下面是一个实例，它会将结果按 NAME 降序排序：\n\n\tsqlite> SELECT * FROM COMPANY ORDER BY NAME DESC;\n\n这将产生以下结果：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t3           Teddy       23          Norway      20000.0\n\t1           Paul        32          California  20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\t5           David       27          Texas       85000.0\n\t2           Allen       25          Texas       15000.0\n\n\n#### SQLite Group By\n\nSQLite 的 **GROUP BY** 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。\n在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。\n\n---\n\n**语法**\n\n\n下面给出了 GROUP BY 子句的基本语法。GROUP BY 子句必须放在 WHERE 子句中的条件之后，必须放在 ORDER BY 子句之前。\n\n\tSELECT column-list\n\tFROM table_name\n\tWHERE [ conditions ]\n\tGROUP BY column1, column2....columnN\n\tORDER BY column1, column2....columnN\n\n您可以在 GROUP BY 子句中使用多个列。确保您使用的分组列在列清单中。\n\n**实例**\n\n假设 COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n如果您想了解每个客户的工资总额，则可使用 GROUP BY 查询，如下所示：\n\n\tsqlite> SELECT NAME, SUM(SALARY) FROM COMPANY GROUP BY NAME;\n\n这将产生以下结果：\n\n\tNAME        SUM(SALARY)\n\t----------  -----------\n\tAllen       15000\n\tDavid       85000\n\tJames       20000\n\tKim         45000\n\tMark        65000\n\tPaul        40000\n\tTeddy       20000\n\n让我们把 ORDER BY 子句与 GROUP BY 子句一起使用，如下所示：\n\n\tsqlite>  SELECT NAME, SUM(SALARY)\n\t         FROM COMPANY GROUP BY NAME ORDER BY NAME DESC;\n\n这将产生以下结果：\n\n\tNAME        SUM(SALARY)\n\t----------  -----------\n\tTeddy       20000\n\tPaul        40000\n\tMark        65000\n\tKim         45000\n\tJames       20000\n\tDavid       85000\n\tAllen       15000\n\n#### SQLite Having 子句\nHAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。\n\nWHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。\n\n---\n\n**语法**\n\n下面是 HAVING 子句在 SELECT 查询中的位置：\n\n\tSELECT\n\tFROM\n\tWHERE\n\tGROUP BY\n\tHAVING\n\tORDER BY\n\n在一个查询中，HAVING 子句必须放在 GROUP BY 子句之后，必须放在 ORDER BY 子句之前。下面是包含 HAVING 子句的 SELECT 语句的语法：\n\n\tSELECT column1, column2\n\tFROM table1, table2\n\tWHERE [ conditions ]\n\tGROUP BY column1, column2\n\tHAVING [ conditions ]\n\tORDER BY column1, column2\n\n**实例**\n\n假设 COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\t8           Paul        24          Houston     20000.0\n\t9           James       44          Norway      5000.0\n\t10          James       45          Texas       5000.0\n\n下面是一个实例，它将显示名称计数小于 2 的所有记录：\n\n\tsqlite > SELECT * FROM COMPANY GROUP BY name HAVING count(name) < 2;\n\n这将产生以下结果：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t2           Allen       25          Texas       15000\n\t5           David       27          Texas       85000\n\t6           Kim         22          South-Hall  45000\n\t4           Mark        25          Rich-Mond   65000\n\t3           Teddy       23          Norway      20000\n\n下面是一个实例，它将显示名称计数大于 2 的所有记录,注意其实这里只返回最后一条记录：\n\n\tsqlite > SELECT * FROM COMPANY GROUP BY name HAVING count(name) > 2;\n\n这将产生以下结果：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t10          James       45          Texas       5000\n\n\n#### SQLite Distinct 关键字\nSQLite 的 **DISTINCT** 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。\n有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。\n\n---\n**语法**\n\n用于消除重复记录的 DISTINCT 关键字的基本语法如下：\n\n\tSELECT DISTINCT column1, column2,.....columnN\n\tFROM table_name\n\tWHERE [condition]\n\n**实例**\n\n假设 COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\t8           Paul        24          Houston     20000.0\n\t9           James       44          Norway      5000.0\n\t10          James       45          Texas       5000.0\n\n首先，让我们来看看下面的 SELECT 查询，它将返回重复的工资记录：\n\n\tsqlite> SELECT name FROM COMPANY;\n\n这将产生以下结果：\n\n\tNAME\n\t----------\n\tPaul\n\tAllen\n\tTeddy\n\tMark\n\tDavid\n\tKim\n\tJames\n\tPaul\n\tJames\n\tJames\n\n现在，让我们在上述的 SELECT 查询中使用 DISTINCT 关键字：\n\n\tsqlite> SELECT DISTINCT name FROM COMPANY;\n\n这将产生以下结果，没有任何重复的条目：\n\n\tNAME\n\t----------\n\tPaul\n\tAllen\n\tTeddy\n\tMark\n\tDavid\n\tKim\n\tJames\n\n资料整理于：[RUNOOB.COM-SQLite教程](http://www.runoob.com/sqlite/sqlite-tutorial.html)\n转载请注明出处。\n","tags":["SQLite"],"categories":["数据库"]},{"title":"SQLite 教程(六)","url":"/2016/01/14/2016-01-14-sqlite-jiao-cheng-liu/","content":"\n#### SQLite Delete 语句\nSQLite 的 **DELETE** 查询用于删除表中已有的记录。可以使用带有 WHERE 子句的 DELETE 查询来删除选定行，否则所有的记录都会被删除。\n\n---\n\n**语法**\n\n带有 WHERE 子句的 DELETE 查询的基本语法如下：\n\n\tDELETE FROM table_name\n\tWHERE [condition];\n\n您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。\n\n**实例**\n\n假设 COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n现在，COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\n如果您想要从 COMPANY 表中删除所有记录，则不需要使用 WHERE 子句，DELETE 查询如下：\n\n\tsqlite> DELETE FROM COMPANY;\n\n现在，COMPANY 表中没有任何的记录，因为所有的记录已经通过 DELETE 语句删除。\n\n\n#### SQLite Like 子句\nSQLite 的 **LIKE** 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。这里有两个通配符与 LIKE 运算符一起使用：\n\n* 百分号 （%）\n* 下划线 （_）\n\n\n百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。\n\n---\n\n**语法**\n\n% 和 _ 的基本语法如下：\n\n\tSELECT FROM table_name\n\tWHERE column LIKE 'XXXX%'\n\n\tor\n\n\tSELECT FROM table_name\n\tWHERE column LIKE '%XXXX%'\n\n\tor\n\n\tSELECT FROM table_name\n\tWHERE column LIKE 'XXXX_'\n\n\tor\n\n\tSELECT FROM table_name\n\tWHERE column LIKE '_XXXX'\n\n\tor\n\n\tSELECT FROM table_name\n\tWHERE column LIKE '_XXXX_'\n\n您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。在这里，XXXX 可以是任何数字或字符串值。\n\n**实例**\n\n下面一些实例演示了 带有 '%' 和 '_' 运算符的 LIKE 子句不同的地方：\n\n| 语句 \t\t\t\t\t\t|描述 \t\t\t|\n|--------------------------|--------------|\n|WHERE SALARY LIKE '200%'\t|查找以 200 开头的任意值\n|WHERE SALARY LIKE '%200%'\t|查找任意位置包含 200 的任意值\n|WHERE SALARY LIKE '\\_00\\%' |查找第二位和第三位为 00 的任意值\n| WHERE SALARY LIKE '2\\_%_%'|查找以 2 开头，且长度至少为 3 个字符的任意值\n|WHERE SALARY LIKE '%2'    |查找以 2 结尾的任意值\n|WHERE SALARY LIKE '_2%3'  |查找第二位为 2，且以 3 结尾的任意值\n|WHERE SALARY LIKE '2___3' |查找长度为 5 位数，且以 2 开头以 3 结尾的任意值\n\n让我们举一个实际的例子，假设 COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面是一个实例，它显示 COMPANY 表中 AGE 以 2 开头的所有记录：\n\n\tsqlite> SELECT * FROM COMPANY WHERE AGE  LIKE '2%';\n\n这将产生以下结果：\n\n\t\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面是一个实例，它显示 COMPANY 表中 ADDRESS 文本里包含一个连字符（-）的所有记录：\n\n\tsqlite> SELECT * FROM COMPANY WHERE ADDRESS  LIKE '%-%';\n\n这将产生以下结果：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t4           Mark        25          Rich-Mond   65000.0\n\t6           Kim         22          South-Hall  45000.0\n\n#### SQLite Glob 子句\nSQLite 的 **GLOB** 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。与 LIKE 运算符不同的是，GLOB 是大小写敏感的，对于下面的通配符，它遵循 UNIX 的语法。\n\n* 星号 （*）\n* 问号 （?）\n\n星号（*）代表零个、一个或多个数字或字符。问号（?）代表一个单一的数字或字符。这些符号可以被组合使用。\n\n---\n\n**语法**\n\n\\* 和 ? 的基本语法如下：\n\n\tSELECT FROM table_name\n\tWHERE column GLOB 'XXXX*'\n\n\tor\n\n\tSELECT FROM table_name\n\tWHERE column GLOB '*XXXX*'\n\n\tor\n\n\tSELECT FROM table_name\n\tWHERE column GLOB 'XXXX?'\n\n\tor\n\n\tSELECT FROM table_name\n\tWHERE column GLOB '?XXXX'\n\n\tor\n\n\tSELECT FROM table_name\n\tWHERE column GLOB '?XXXX?'\n\n\tor\n\n\tSELECT FROM table_name\n\tWHERE column GLOB '????'\n\n您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。在这里，XXXX 可以是任何数字或字符串值。\n\n---\n\n**实例**\n\n下面一些实例演示了 带有 '*' 和 '?' 运算符的 GLOB 子句不同的地方：\n\n| 语句                                  |描述\t      |\n|--------------------------------------|-------------|\n|WHERE SALARY GLOB '200\\*'\t            |查找以 200 开头的任意值|\n|WHERE SALARY GLOB '\\*200\\*'\t        |查找任意位置包含 200 的任意值|\n|WHERE SALARY GLOB '?00\\*'\t            |查找第二位和第三位为 00 的任意值|\n|WHERE SALARY GLOB '2??'\t            |查找以 2 开头，且长度至少为 3 个字符的任意值|\n|WHERE SALARY GLOB '\\*2'\t            |查找以 2 结尾的任意值 |\n|WHERE SALARY GLOB '?2*3'\t            |查找第二位为 2，且以 3 结尾的任意值|\n|WHERE SALARY GLOB '2???3'\t            |查找长度为 5 位数，且以 2 开头以 3 结尾的任意值|\n\n让我们举一个实际的例子，假设 COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面是一个实例，它显示 COMPANY 表中 AGE 以 2 开头的所有记录：\n\n\tsqlite> SELECT * FROM COMPANY WHERE AGE  GLOB '2*';\n\n这将产生以下结果：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面是一个实例，它显示 COMPANY 表中 ADDRESS 文本里包含一个连字符（-）的所有记录：\n\n\tsqlite> SELECT * FROM COMPANY WHERE ADDRESS  GLOB '*-*';\n\n这将产生以下结果：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t4           Mark        25          Rich-Mond   65000.0\n\t6           Kim         22          South-Hall  45000.0\n\n#### SQLite Limit 子句\nSQLite 的 **LIMIT** 子句用于限制由 SELECT 语句返回的数据数量。\n\n---\n\n**语法**\n\n带有 LIMIT 子句的 SELECT 语句的基本语法如下：\n\n\tSELECT column1, column2, columnN\n\tFROM table_name\n\tLIMIT [no of rows]\n\n下面是 `LIMIT` 子句与 `OFFSET` 子句一起使用时的语法：\n\n\tSELECT column1, column2, columnN\n\tFROM table_name\n\tLIMIT [no of rows] OFFSET [row num]\n\nSQLite 引擎将返回从下一行开始直到给定的 `OFFSET` 为止的所有行，如下面的最后一个实例所示。\n\n**实例**\n\n假设 COMPANY 表有以下记录：\n\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面是一个实例，它限制了您想要从表中提取的行数：\n\n\tsqlite> SELECT * FROM COMPANY LIMIT 6;\n\n这将产生以下结果：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\n但是，在某些情况下，可能需要从一个特定的偏移开始提取记录(`OFFSET下标从0开始`)。下面是一个实例，从第三位开始提取 3 个记录：\n\n\tsqlite> SELECT * FROM COMPANY LIMIT 3 OFFSET 2;\n\n这将产生以下结果：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\n资料整理于：[RUNOOB.COM-SQLite教程](http://www.runoob.com/sqlite/sqlite-tutorial.html)\n转载请注明出处。\n","tags":["SQLite"],"categories":["数据库"]},{"title":"SQLite 教程(五)","url":"/2016/01/14/2016-01-14-sqlite-jiao-cheng-wu/","content":"\n#### SQL表达式\n表达式是一个或多个值、运算符和计算值的SQL函数的组合。\n\nSQL 表达式与公式类似，都写在查询语言中。您还可以使用特定的数据集来查询数据库。\n\n---\n\n**语法**\n\n假设 SELECT 语句的基本语法如下：\n\n\tSELECT column1, column2, columnN\n\tFROM table_name\n\tWHERE [CONTION | EXPRESSION];\n\n有不同类型的 SQLite 表达式，具体讲解如下：\n\n#### SQLite - 布尔表达式\nSQLite 的布尔表达式在匹配单个值的基础上获取数据。语法如下：\n\n\tSELECT column1, column2, columnN\n\tFROM table_name\n\tWHERE SINGLE VALUE MATCHTING EXPRESSION;\n\n假设 COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面的实例演示了 SQLite 布尔表达式的用法：\n\n\tsqlite> SELECT * FROM COMPANY WHERE SALARY = 10000;\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t4           James        24          Houston   10000.0\n\n#### SQLite - 数值表达式\n这些表达式用来执行查询中的任何数学运算。语法如下：\n\n\tSELECT numerical_expression as  OPERATION_NAME\n\t[FROM table_name WHERE CONDITION] ;\n\n在这里，numerical_expression 用于数学表达式或任何公式。下面的实例演示了 SQLite 数值表达式的用法：\n\n\tsqlite> SELECT (15 + 6) AS ADDITION\n\tADDITION = 21\n\n有几个内置的函数，比如 avg()、sum()、count()，等等，执行被称为对一个表或一个特定的表列的汇总数据计算。\n\n\tsqlite> SELECT COUNT(*) AS \"RECORDS\" FROM COMPANY;\n\tRECORDS = 7\n\n---\n\n#### SQLite - 日期表达式\n日期表达式返回当前系统日期和时间值，这些表达式将被用于各种数据操作。\n\n\tsqlite>  SELECT CURRENT_TIMESTAMP;\n\tCURRENT_TIMESTAMP = 2016-01-13 16:29:56\n\n#### SQLite Where 子句\nSQLite的 WHERE 子句用于指定从一个表或多个表中获取数据的条件。\n\n如果满足给定的条件，即为真（true）时，则从表中返回特定的值。您可以使用 WHERE 子句来过滤记录，只获取需要的记录。\n\nWHERE 子句不仅可用在 SELECT 语句中，它也可用在 UPDATE、DELETE 语句中，等等，这些我们将在随后的章节中学习到。\n\n---\n\n**语法**\n\nSQLite 的带有 WHERE 子句的 SELECT 语句的基本语法如下：\n\n\tSELECT column1, column2, columnN\n\tFROM table_name\n\tWHERE [condition]\n\n**实例**\n\n您还可以使用比较或逻辑运算符指定条件，比如 >、<、=、LIKE、NOT，等等。假设 COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面的实例演示了 SQLite 逻辑运算符的用法。下面的 SELECT 语句列出了 AGE 大于等于 25 且工资大于等于 65000.00 的所有记录：\n\n\tsqlite> SELECT * FROM COMPANY WHERE AGE >= 25 AND SALARY >= 65000;\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\n下面的 SELECT 语句列出了 AGE 大于等于 25 或工资大于等于 65000.00 的所有记录：\n\nsqlite> SELECT * FROM COMPANY WHERE AGE >= 25 OR SALARY >= 65000;\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\n下面的 SELECT 语句列出了 AGE 不为 NULL 的所有记录，结果显示所有的记录，意味着没有一个记录的 AGE 等于 NULL：\n\n\tsqlite>  SELECT * FROM COMPANY WHERE AGE IS NOT NULL;\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面的 SELECT 语句列出了 NAME 以 'Ki' 开始的所有记录，'Ki' 之后的字符不做限制（不区分大小写）：\n\n\tsqlite> SELECT * FROM COMPANY WHERE NAME LIKE 'Ki%';\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t6           Kim         22          South-Hall  45000.0\n\n下面的 SELECT 语句列出了 NAME 以 'Ki' 开始的所有记录，'Ki' 之后的字符不做限制（区分大小写）：\n\n\tsqlite> SELECT * FROM COMPANY WHERE NAME GLOB 'Ki*';\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t6           Kim         22          South-Hall  45000.0\n\n下面的 SELECT 语句列出了 AGE 的值为 25 或 27 的所有记录：\n\n\tsqlite> SELECT * FROM COMPANY WHERE AGE IN ( 25, 27 );\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t2           Allen       25          Texas       15000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\n\n#### SQLite AND/OR 运算符\nSQLite 的 AND 和 OR 运算符用于编译多个条件来缩小在 SQLite 语句中所选的数据。这两个运算符被称为连接运算符。\n\n这些运算符为同一个 SQLite 语句中不同的运算符之间的多个比较提供了可能。\n\n---\n\n#### AND 运算符\nAND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。使用 AND 运算符时，只有当所有条件都为真（true）时，整个条件为真（true）。例如，只有当 condition1 和 condition2 都为真（true）时，[condition1] AND [condition2] 为真（true）。\n\n**语法**\n\n带有 WHERE 子句的 AND 运算符的基本语法如下：\n\n\tSELECT column1, column2, columnN\n\tFROM table_name\n\tWHERE [condition1] AND [condition2]...AND [conditionN];\n\n您可以使用 AND 运算符来结合 N 个数量的条件。SQLite 语句需要执行的动作是，无论是事务或查询，所有由 AND 分隔的条件都必须为真（TRUE）。\n\n**实例**\n\n假设 COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面的 SELECT 语句列出了 AGE 大于等于 25 且工资大于等于 65000.00 的所有记录：\n\n\n\tsqlite> SELECT * FROM COMPANY WHERE AGE >= 25 AND SALARY >= 65000;\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\n#### OR 运算符\nOR 运算符也用于结合一个 SQL 语句的 WHERE 子句中的多个条件。使用 OR 运算符时，只要当条件中任何一个为真（true）时，整个条件为真（true）。例如，只要当 condition1 或 condition2 有一个为真（true）时，[condition1] OR [condition2] 为真（true）\n\n**语法**\n\n带有 WHERE 子句的 OR 运算符的基本语法如下：\n\n\tSELECT column1, column2, columnN\n\tFROM table_name\n\tWHERE [condition1] OR [condition2]...OR [conditionN]\n\n您可以使用 OR 运算符来结合 N 个数量的条件。SQLite 语句需要执行的动作是，无论是事务或查询，只要任何一个由 OR 分隔的条件为真（TRUE）即可。\n\n**实例**\n\n假设 COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面的 SELECT 语句列出了 AGE 大于等于 25 或工资大于等于 65000.00 的所有记录：\n\n\tsqlite> SELECT * FROM COMPANY WHERE AGE >= 25 OR SALARY >= 65000;\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\n\n#### SQLite Update 语句\nSQLite 的 **UPDATE **查询用于修改表中已有的记录。可以使用带有 WHERE 子句的 UPDATE 查询来更新选定行，否则所有的行都会被更新。\n\n---\n\n**语法**\n\n带有 WHERE 子句的 UPDATE 查询的基本语法如下：\n\n\tUPDATE table_name\n\tSET column1 = value1, column2 = value2...., columnN = valueN\n\tWHERE [condition];\n\n您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。\n\n---\n\n**实例**\n\n假设 COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面是一个实例，它会更新 ID 为 6 的客户地址：\n\n\tsqlite> UPDATE COMPANY SET ADDRESS = 'Texas' WHERE ID = 6;\n\n现在，COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          Texas       45000.0\n\t7           James       24          Houston     10000.0\n\n如果您想修改 COMPANY 表中 ADDRESS 和 SALARY 列的所有值，则不需要使用 WHERE 子句，UPDATE 查询如下：\n\n\tsqlite> UPDATE COMPANY SET ADDRESS = 'Texas', SALARY = 20000.00;\n\n现在，COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          Texas       20000.0\n\t2           Allen       25          Texas       20000.0\n\t3           Teddy       23          Texas       20000.0\n\t4           Mark        25          Texas       20000.0\n\t5           David       27          Texas       20000.0\n\t6           Kim         22          Texas       20000.0\n\t7           James       24          Texas       20000.0\n资料整理于：[RUNOOB.COM-SQLite教程](http://www.runoob.com/sqlite/sqlite-tutorial.html)\n转载请注明出处。\n","tags":["SQLite"],"categories":["数据库"]},{"title":"SQLite 教程(四)","url":"/2016/01/13/2016-01-13-sqlite-jiao-cheng-si/","content":"\n### SQLite 运算符\n\n**SQLite 运算符是什么？**\n\n运算符是一个保留字或字符，主要用于 SQLite 语句的 WHERE 子句中执行操作，如比较和算术运算。\n\n运算符用于指定 SQLite 语句中的条件，并在语句中连接多个条件。\n\n* 算术运算符\n* 比较运算符\n* 逻辑运算符\n* 位运算符\n\n---\n\n#### SQLite 算术运算符\n\n假设变量 a=10，变量 b=20，则：\n\n|运算符  |描述      \t\t\t     |实例      |\n|-------|-----------------------|---------|\n|+      |加法 - 把运算符两边的值相加|a + b 将得到 30\n|-      |减法 - 左操作数减去右操作数|a - b 将得到 -10\n|*      |乘法 - 把运算符两边的值相乘|a * b 将得到 200\n|/      |除法 - 左操作数除以右操作数|b / a 将得到 2\n|%      |取模 - 左操作数除以右操作数后得到的余数|b % a will give 0\n\n**实例**\n\n下面是 SQLite 算术运算符的简单实例：\n\n\tsqlite> .mode line\n\tsqlite> select 10 + 20;\n\t10 + 20 = 30\n\n\n\tsqlite> select 10 - 20;\n\t10 - 20 = -10\n\n\n\tsqlite> select 10 * 20;\n\t10 * 20 = 200\n\n\n\tsqlite> select 10 / 5;\n\t10 / 5 = 2\n\n\n\tsqlite> select 12 %  5;\n\t12 %  5 = 2\n\n#### SQLite 比较运算符\n\n假设变量 a=10，变量 b=20，则：\n\n|运算符  |描述      \t\t\t                      |实例     |\n|-------|----------------------------------------|---------|\n|==     |检查两个操作数的值是否相等，如果相等则条件为真。|(a == b) 不为真。\n|=      |检查两个操作数的值是否相等，如果相等则条件为真。|(a = b) 不为真。\n|!=     |检查两个操作数的值是否相等，如果不相等则条件为真。|(a != b) 为真。\n|<>\t\t|检查两个操作数的值是否相等，如果不相等则条件为真。|(a <> b) 为真。\n|>\t\t|检查左操作数的值是否大于右操作数的值，如果是则条件为真。|(a > b) 不为真。\n|<\t\t|检查左操作数的值是否小于右操作数的值，如果是则条件为真。|(a < b) 为真。\n|>=\t    |检查左操作数的值是否大于等于右操作数的值，如果是则条件为真。|(a >= b) 不为真。\n|<=     |检查左操作数的值是否小于等于右操作数的值，如果是则条件为真。|(a <= b) 为真。\n|!<     |检查左操作数的值是否不小于右操作数的值，如果是则条件为真。|(a !< b) 为假\n|!>     |检查左操作数的值是否不大于右操作数的值，如果是则条件为真。|(a !> b) 为真\n\n**实例**\n假设 COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面的实例演示了各种 SQLite 比较运算符的用法。\n\n> 在这里，我们使用 WHERE 子句，这将会在后边单独的一个章节中讲解，但现在您需要明白，WHERE 子句是用来设置 SELECT 语句的条件语句。\n\n下面的 SELECT 语句列出了 SALARY 大于 50,000.00 的所有记录：\n\n\tsqlite> SELECT * FROM COMPANY WHERE SALARY > 50000;\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\n下面的 SELECT 语句列出了 SALARY 等于 20,000.00 的所有记录：\n\n\tsqlite>  SELECT * FROM COMPANY WHERE SALARY = 20000;\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t3           Teddy       23          Norway      20000.0\n\n下面的 SELECT 语句列出了 SALARY 不等于 20,000.00 的所有记录：\n\n\tsqlite>  SELECT * FROM COMPANY WHERE SALARY != 20000;\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t2           Allen       25          Texas       15000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面的 SELECT 语句列出了 SALARY 不等于 20,000.00 的所有记录：\n\n\tsqlite> SELECT * FROM COMPANY WHERE SALARY <> 20000;\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t2           Allen       25          Texas       15000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面的 SELECT 语句列出了 SALARY 大于等于 65,000.00 的所有记录：\n\n\tsqlite> SELECT * FROM COMPANY WHERE SALARY >= 65000;\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\n#### SQLite 逻辑运算符\n下面是 SQLite 中所有的逻辑运算符列表。\n\n|运算符    |描述      \t\t\t     \t\t   |\n|---------|----------------------------------|\n|AND      |AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。\n|BETWEEN  |BETWEEN 运算符用于在给定最小值和最大值范围内的一系列值中搜索值。\n|EXISTS   |EXISTS 运算符用于在满足一定条件的指定表中搜索行的存在。\n|IN\t\t  |IN 运算符用于把某个值与一系列指定列表的值进行比较。\n|NOT IN   |IN 运算符的对立面，用于把某个值与不在一系列指定列表的值进行比较。\n|LIKE     |LIKE 运算符用于把某个值与使用通配符运算符的相似值进行比较。\n|GLOB     |GLOB 运算符用于把某个值与使用通配符运算符的相似值进行比较。GLOB 与 LIKE 不同之处在于，它是大小写敏感的。\n|NOT      |NOT 运算符是所用的逻辑运算符的对立面。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。它是否定运算符。\n|OR       |OR 运算符用于结合一个 SQL 语句的 WHERE 子句中的多个条件。\n|IS NULL  |NULL 运算符用于把某个值与 NULL 值进行比较。\n|IS       |IS 运算符与 = 相似。\n|IS NOT   |IS NOT 运算符与 != 相似。\n|\\|\\|     |连接两个不同的字符串，得到一个新的字符串。\n|UNIQUE   |UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。\n\n**实例**\n假设 COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面的实例演示了 SQLite 逻辑运算符的用法。\n下面的 SELECT 语句列出了 AGE 大于等于 25 且工资大于等于 65000.00 的所有记录：\n\n\tsqlite> SELECT * FROM COMPANY WHERE AGE >= 25 AND SALARY >= 65000;\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\n下面的 SELECT 语句列出了 AGE 大于等于 25 或工资大于等于 65000.00 的所有记录：\n\n\tsqlite> SELECT * FROM COMPANY WHERE AGE >= 25 OR SALARY >= 65000;\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\n下面的 SELECT 语句列出了 AGE 不为 NULL 的所有记录，结果显示所有的记录，意味着没有一个记录的 AGE 等于 NULL：\n\n\tsqlite>  SELECT * FROM COMPANY WHERE AGE IS NOT NULL;\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面的 SELECT 语句列出了 NAME 以 'Ki' 开始的所有记录，'Ki' 之后的字符不做限制：\n\n\tsqlite> SELECT * FROM COMPANY WHERE NAME LIKE 'Ki%';\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t6           Kim         22          South-Hall  45000.0\n\n\n下面的 SELECT 语句列出了 NAME 以 'Ki' 开始的所有记录，'Ki' 之后的字符不做限制：\n\n\tsqlite> SELECT * FROM COMPANY WHERE NAME GLOB 'Ki*';\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t6           Kim         22          South-Hall  45000.0\n\n下面的 SELECT 语句列出了 AGE 的值为 25 或 27 的所有记录：\n\n\tsqlite> SELECT * FROM COMPANY WHERE AGE IN ( 25, 27 );\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t2           Allen       25          Texas       15000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\n下面的 SELECT 语句列出了 AGE 的值既不是 25 也不是 27 的所有记录：\n\n\tsqlite> SELECT * FROM COMPANY WHERE AGE NOT IN ( 25, 27 );\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t3           Teddy       23          Norway      20000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面的 SELECT 语句使用 SQL 子查询，子查询查找 SALARY > 65000 的带有 AGE 字段的所有记录，后边的 WHERE 子句与 EXISTS 运算符一起使用，列出了外查询中的 AGE 存在于子查询返回的结果中的所有记录：\n\n\tsqlite> SELECT AGE FROM COMPANY\n\t        WHERE EXISTS (SELECT AGE FROM COMPANY WHERE SALARY > 65000);\n\tAGE\n\t----------\n\t32\n\t25\n\t23\n\t25\n\t27\n\t22\n\t24\n\n下面的 SELECT 语句使用 SQL 子查询，子查询查找 SALARY > 65000 的带有 AGE 字段的所有记录，后边的 WHERE 子句与 > 运算符一起使用，列出了外查询中的 AGE 大于子查询返回的结果中的年龄的所有记录：\n\n\tsqlite> SELECT * FROM COMPANY\n\t        WHERE AGE > (SELECT AGE FROM COMPANY WHERE SALARY > 65000);\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\n#### SQLite 位运算符\n\n位运算符作用于位，并逐位执行操作。真值表 & 和 | 如下：\n\n|p  |q  |p&q|p\\|q|\n|---|---|---|---|\n|0\t|0\t|0\t|0\n|0\t|1\t|0\t|1\n|1\t|1\t|1\t|1\n|1\t|0\t|0\t|1\n\n假设如果 A = 60，且 B = 13，现在以二进制格式，它们如下所示：\n\nA = 0011 1100\n\nB = 0000 1101\n\n-----------------\n\nA&B = 0000 1100\n\nA|B = 0011 1101\n\n~A  = 1100 0011\n\n下表中列出了 SQLite 语言支持的位运算符。假设变量 A=60，变量 B=13，则：\n\n|运算符  |描述   \t\t\t\t\t\t\t |实例     |\n|-------|-------------------------------|--------|\n|&      |\t如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。\t|(A & B) 将得到 12，即为 0000 1100\n|\\|\t    |如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。\t|(A | B) 将得到 61，即为 0011 1101\n|~\t    |二进制补码运算符是一元运算符，具有\"翻转\"位效应。\t|(~A ) 将得到 -61，即为 1100 0011，2 的补码形式，带符号的二进制数。\n|<<   \t|二进制左移运算符。左操作数的值向左移动右操作数指定的位数。\t|A << 2 将得到 240，即为 1111 0000\n|>>\t    |二进制右移运算符。左操作数的值向右移动右操作数指定的位数。\t|A >> 2 将得到 15，即为 0000 1111\n\n**实例**\n\n下面的实例演示了 SQLite 位运算符的用法：\n\n\tsqlite> .mode line\n\tsqlite> select 60 | 13;\n\t60 | 13 = 61\n\n\tsqlite> select 60 & 13;\n\t60 & 13 = 12\n\n\tsqlite> select  60 ^ 13;\n\t10 * 20 = 200\n\n\n\tsqlite>  select  (~60);\n\t(~60) = -61\n\n\tsqlite>  select  (60 << 2);\n\t(60 << 2) = 240\n\n\tsqlite>  select  (60 >> 2);\n\t(60 >> 2) = 15\n\n\n资料整理于：[RUNOOB.COM-SQLite教程](http://www.runoob.com/sqlite/sqlite-tutorial.html)\n转载请注明出处。\n","tags":["SQLite"],"categories":["数据库"]},{"title":"SQLite 教程(三)","url":"/2016/01/13/2016-01-13-sqlite-jiao-cheng-san/","content":"\n#### SQLite Insert 语句\n\nSQLite 的 INSERT INTO 语句用于向数据库的某个表中添加新的数据行。\n\n---\n\n**语法**\n\nINSERT INTO 语句有两种基本语法，如下所示：\n\n\tINSERT INTO TABLE_NAME (column1, column2, column3,...columnN)]  \n\tVALUES (value1, value2, value3,...valueN);\n\n在这里，column1, column2,...columnN 是要插入数据的表中的列的名称。\n如果要为表中的所有列添加值，您也可以不需要在 SQLite 查询中指定列名称。但要确保值的顺序与列在表中的顺序一致。SQLite 的 INSERT INTO 语法如下：\n\n\tINSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);\n\n---\n\n**实例**\n\n假设您已经在 testDB.db 中创建了 COMPANY表，如下所示：\n\n\tsqlite> CREATE TABLE COMPANY(\n\t   ID INT PRIMARY KEY     NOT NULL,\n\t   NAME           TEXT    NOT NULL,\n\t   AGE            INT     NOT NULL,\n\t   ADDRESS        CHAR(50),\n\t   SALARY         REAL\n\t);\n\n现在，下面的语句将在 COMPANY 表中创建六个记录：\n\n\tINSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)\n\tVALUES (1, 'Paul', 32, 'California', 20000.00 );\n\n\tINSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)\n\tVALUES (2, 'Allen', 25, 'Texas', 15000.00 );\n\n\tINSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)\n\tVALUES (3, 'Teddy', 23, 'Norway', 20000.00 );\n\n\tINSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)\n\tVALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );\n\n\tINSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)\n\tVALUES (5, 'David', 27, 'Texas', 85000.00 );\n\n\tINSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)\n\tVALUES (6, 'Kim', 22, 'South-Hall', 45000.00 );\n\n您也可以使用第二种语法在 COMPANY 表中创建一个记录，如下所示：\n\n\tINSERT INTO COMPANY VALUES (7, 'James', 24, 'Houston', 10000.00 );\n\n上面的所有语句将在 COMPANY 表中创建下列记录。下一章会教您如何从一个表中显示所有这些记录。\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n#### 使用一个表来填充另一个表\n\n您可以通过在一个有一组字段的表上使用 select 语句，填充数据到另一个表中。下面是语法：\n\n\tINSERT INTO first_table_name [(column1, column2, ... columnN)]\n\t   SELECT column1, column2, ...columnN\n\t   FROM second_table_name\n\t   [WHERE condition];\n\n#### SQLite Select 语句\n\nSQLite 的 SELECT 语句用于从 SQLite 数据库表中获取数据，以结果表的形式返回数据。这些结果表也被称为结果集。\n\n---\n\n**语法**\n\nSQLite 的 SELECT 语句的基本语法如下：\n\n\tSELECT column1, column2, columnN FROM table_name;\n\n在这里，column1, column2...是表的字段，他们的值即是您要获取的。如果您想获取所有可用的字段，那么可以使用下面的语法：\n\n\tSELECT * FROM table_name;\n\n---\n\n**实例**\n\n假设 COMPANY 表有以下记录：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n下面是一个实例，使用 SELECT 语句获取并显示所有这些记录。在这里，前三个命令被用来设置正确格式化的输出。\n\n\tsqlite>.header on\n\tsqlite>.mode column\n\tsqlite> SELECT * FROM COMPANY;\n\n最后，将得到以下的结果：\n\n\tID          NAME        AGE         ADDRESS     SALARY\n\t----------  ----------  ----------  ----------  ----------\n\t1           Paul        32          California  20000.0\n\t2           Allen       25          Texas       15000.0\n\t3           Teddy       23          Norway      20000.0\n\t4           Mark        25          Rich-Mond   65000.0\n\t5           David       27          Texas       85000.0\n\t6           Kim         22          South-Hall  45000.0\n\t7           James       24          Houston     10000.0\n\n如果只想获取 COMPANY 表中指定的字段，则使用下面的查询：\n\n\tsqlite> SELECT ID, NAME, SALARY FROM COMPANY;\n\n上面的查询会产生以下结果：\n\n\tID          NAME        SALARY\n\t----------  ----------  ----------\n\t1           Paul        20000.0\n\t2           Allen       15000.0\n\t3           Teddy       20000.0\n\t4           Mark        65000.0\n\t5           David       85000.0\n\t6           Kim         45000.0\n\t7           James       10000.0\n\n---\n\n**设置输出列的宽度**\n\n有时，由于要显示的列的默认宽度导致 .mode column，这种情况下，输出被截断。此时，您可以使用 .width num, num.... 命令设置显示列的宽度，如下所示：\n\n\tsqlite>.width 10, 20, 10\n\tsqlite>SELECT * FROM COMPANY;\n\n上面的 .width 命令设置第一列的宽度为 10，第二列的宽度为 20，第三列的宽度为 10。因此上述 SELECT 语句将得到以下结果：\n\n\tID          NAME                  AGE         ADDRESS     SALARY\n\t----------  --------------------  ----------  ----------  ----------\n\t1           Paul                  32          California  20000.0\n\t2           Allen                 25          Texas       15000.0\n\t3           Teddy                 23          Norway      20000.0\n\t4           Mark                  25          Rich-Mond   65000.0\n\t5           David                 27          Texas       85000.0\n\t6           Kim                   22          South-Hall  45000.0\n\t7           James                 24          Houston     10000.0\n\n**Schema 信息**\n因为所有的点命令只在 SQLite 提示符中可用，所以当您进行带有 SQLite 的编程时，您要使用下面的带有 sqlite_master 表的 SELECT 语句来列出所有在数据库中创建的表：\n\n\tsqlite> SELECT tbl_name FROM sqlite_master WHERE type = 'table';\n\n假设在 testDB.db 中已经存在唯一的 COMPANY 表，则将产生以下结果：\n\n\ttbl_name\n\t----------\n\tCOMPANY\n\n您可以列出关于 COMPANY 表的完整信息，如下所示：\n\n\tsqlite> SELECT sql FROM sqlite_master WHERE type = 'table' AND tbl_name = 'COMPANY';\n\n假设在 testDB.db 中已经存在唯一的 COMPANY 表，则将产生以下结果：\n\n\tCREATE TABLE COMPANY(\n\t   ID INT PRIMARY KEY     NOT NULL,\n\t   NAME           TEXT    NOT NULL,\n\t   AGE            INT     NOT NULL,\n\t   ADDRESS        CHAR(50),\n\t   SALARY         REAL\n\t)\n\n资料整理于：[RUNOOB.COM-SQLite教程](http://www.runoob.com/sqlite/sqlite-tutorial.html)\n转载请注明出处。\n","tags":["SQLite"],"categories":["数据库"]},{"title":"SQLite 教程(二)","url":"/2016/01/13/2016-01-13-sqlite-jiao-cheng-er/","content":"\n#### SQLite 数据类型\n\nSQLite 数据类型是一个用来指定任何对象的数据类型的属性。SQLite 中的每一列，每个变量和表达式都有相关的数据类型。\n\n您可以在创建表的同时使用这些数据类型。SQLite 使用一个更普遍的动态类型系统。在 SQLite 中，值的数据类型与值本身是相关的，而不是与它的容器相关。\n\n#### SQLite 存储类\n\n每个存储在 SQLite 数据库中的值都具有以下存储类之一：\n\n|存储类  |描述      \t\t\t     |\n|-------|-----------------------|\n|NULL   |值是一个 NULL 值。\t\t |\n|INTEGER|\t值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中。|\n|REAL\t|值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。|\n|TEXT\t|值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 |UTF-16LE）存储。|\n|BLOB\t|值是一个 blob 数据，完全根据它的输入存储。|\n\nSQLite 的存储类稍微比数据类型更普遍。INTEGER 存储类，例如，包含 6 种不同的不同长度的整数数据类型。\n\n---\n\n#### SQLite Affinity 类型\nSQLite 支持列上的类型 affinity 概念。任何列仍然可以存储任何类型的数据，但列的首选存储类是它的 **affinity**。在 SQLite3 数据库中，每个表的列分配为以下类型的 affinity 之一：\n\n|Affinity |描述      \t\t\t     |\n|---------|-------------------------|\n|TEXT\t  |该列使用存储类 NULL、TEXT 或 BLOB 存储所有数据。\n|NUMERIC  |该列可以包含使用所有五个存储类的值。\n|INTEGER  |与带有 NUMERIC affinity 的列相同，在 CAST 表达式中带有异常。\n|REAL\t  |与带有 NUMERIC affinity 的列相似，不同的是，它会强制把整数值转换为浮点表示。\n|NONE\t  |带有 affinity NONE 的列，不会优先使用哪个存储类，也不会尝试把数据从一个存储类强制转换为另一个存储类。\n\n#### SQLite Affinity 及类型名称\n\n下表列出了当创建 SQLite3 表时可使用的各种数据类型名称，同时也显示了相应的应用 Affinity：\n\n|数据类型  |Affinity      \t\t\t     |\n|---------|-----------------------------|\n|INT <br> INTEGERTINYINT <br> SMALLINT <br> MEDIUMINT <br> BIGINT <br> UNSIGNED BIG INT <br> INT2 <br> INT8  <br> | INTEGER  |            \n|CHARACTER(20) <br> VARCHAR(255) <br> VARYING CHARACTER(255) <br> NCHAR(55) <br> NATIVE CHARACTER(70) <br> NVARCHAR(100) <br> TEXT <br> CLOB                   \t\t\t\t\t\t\t  | TEXT    |\n|BLOB <br> no datatype specified                 | NONE    |\n|REAL <br> DOUBLE <br> DOUBLE PRECISION <br> FLOAT | REAL  |\n|NUMERIC <br> DECIMAL(10,5) <br> BOOLEAN <br> DATE <br> DATETIME | NUMERIC |\n\n---\n\n#### Boolean 数据类型\nSQLite 没有单独的 Boolean 存储类。相反，布尔值被存储为整数 0（false）和 1（true）。\n\n---\n\n#### Date 与 Time 数据类型\n\nSQLite 没有一个单独的用于存储日期和/或时间的存储类，但 SQLite 能够把日期和时间存储为 TEXT、REAL 或 INTEGER 值。\n\n|存储类\t  |日期格式      \t\t\t     |\n|---------|-----------------------------|\n|TEXT\t  |格式为 \"YYYY-MM-DD HH:MM:SS.SSS\" 的日期。\n|REAL\t  |从公元前 4714 年 11 月 24 日格林尼治时间的正午开始算起的天数。\n|INTEGER  |\t从 1970-01-01 00:00:00 UTC 算起的秒数。\n\n您可以以任何上述格式来存储日期和时间，并且可以使用内置的日期和时间函数来自由转换不同格式。\n\n#### SQLite 创建数据库\n\nSQLite 的 sqlite3 命令被用来创建新的 SQLite 数据库。您不需要任何特殊的权限即可创建一个数据。\n\n---\n\n**语法**\n\nsqlite3 命令的基本语法如下：\n\n\t$sqlite3 DatabaseName.db\n\n通常情况下，数据库名称在 RDBMS 内应该是唯一的。\n\n**实例**\n\n如果您想创建一个新的数据库 <testDB.db>，SQLITE3 语句如下所示：\n\n\t$sqlite3 testDB.db\n\tSQLite version 3.8.10.2 2015-05-20 18:17:19\n\tEnter \".help\" for usage hints.\n\tsqlite>\n\n上面的命令将在当前目录下创建一个文件 testDB.db。该文件将被 SQLite 引擎用作数据库。如果您已经注意到 sqlite3 命令在成功创建数据库文件之后，将提供一个 sqlite> 提示符。\n一旦数据库被创建，您就可以使用 SQLite 的 .databases 命令来检查它是否在数据库列表中，如下所示：\n\n\tsqlite>.databases\n\tseq  name             file                                                      \n\t---- ---------------- --------------------------------------------\n\t0    main             /Users/wangruofeng/Documents/SQLitePractice/testDB.db\n\n您可以使用 SQLite .quit 命令退出 sqlite 提示符，如下所示：\n\n\tsqlite>.quit\n\t$\n\n#### .dump 命令\n\n您可以在命令提示符中使用 SQLite .dump 点命令来导出完整的数据库在一个文本文件中，如下所示：\n\n\t$sqlite3 testDB.db .dump > testDB.sql\n\n上面的命令将转换整个 testDB.db 数据库的内容到 SQLite 的语句中，并将其转储到 ASCII 文本文件 testDB.sql 中。您可以通过简单的方式从生成的 testDB.sql 恢复，如下所示：\n\n\t$sqlite3 testDB.db < testDB.sql\n\n此时的数据库是空的，一旦数据库中有表和数据，您可以尝试上述两个程序。现在，让我们继续学习下一章。\n\n#### SQLite 附加数据库\n\n假设这样一种情况，当在同一时间有多个数据库可用，您想使用其中的任何一个。SQLite 的 ATTACH DTABASE 语句是用来选择一个特定的数据库，使用该命令后，所有的 SQLite 语句将在附加的数据库下执行。相当于给数据库取一个别名\n\n---\n\n**语法**\n\nSQLite 的 ATTACH DATABASE 语句的基本语法如下：\n\n\tATTACH DATABASE 'DatabaseName' As 'Alias-Name';\n\n如果数据库尚未被创建，上面的命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库 'Alias-Name' 绑定在一起。\n\n---\n\n**实例**\n如果想附加一个现有的数据库 testDB.db，则 ATTACH DATABASE 语句将如下所示：\n\n\tsqlite> ATTACH DATABASE 'testDB.db' as 'TEST';\n\n使用 SQLite .database 命令来显示附加的数据库。\n\n\tsqlite> .database\n\tseq  name             file\n\t---  ---------------  ----------------------\n\t0    main             /home/sqlite/testDB.db\n\t2    test             /home/sqlite/testDB.db\n\n数据库名称 main 和 temp 被保留用于主数据库和存储临时表及其他临时数据对象的数据库。这两个数据库名称可用于每个数据库连接，且不应该被用于附加，否则将得到一个警告消息，如下所示：\n\n\tsqlite>  ATTACH DATABASE 'testDB.db' as 'TEMP';\n\tError: database TEMP is already in use\n\tsqlite>  ATTACH DATABASE 'testDB.db' as 'main';\n\tError: database main is already in use\n\n---\n\n#### SQLite 分离数据库\n\nSQLite的 **DETACH DTABASE** 语句是用来把命名数据库从一个数据库连接分离和游离出来，连接是之前使用 ATTACH 语句附加的。如果同一个数据库文件已经被附加上多个别名，DETACH 命令将只断开给定名称的连接，而其余的仍然有效。您无法分离 main 或 temp 数据库。\n\n> 如果数据库是在内存中或者是临时数据库，则该数据库将被摧毁，且内容将会丢失。\n\n**语法**\n\nSQLite 的 DETACH DATABASE 'Alias-Name' 语句的基本语法如下：\n\n\tDETACH DATABASE 'Alias-Name';\n\n在这里，'Alias-Name' 与您之前使用 ATTACH 语句附加数据库时所用到的别名相同。\n\n**实例**\n\n假设在前面的章节中您已经创建了一个数据库，并给它附加了 'test' 和 'currentDB'，使用 .database/.databases 命令，我们可以看到：\n\n\tsqlite> .databases\n\tseq  name             file\n\t---  ---------------  ----------------------\n\t0    main             /home/sqlite/testDB.db\n\t2    test             /home/sqlite/testDB.db\n\t3    currentDB        /home/sqlite/testDB.db\n\n现在，让我们尝试把 'currentDB' 从 testDB.db 中分离出来，如下所示：\n\n\tsqlite> DETACH DATABASE 'currentDB';\n\n现在，如果检查当前附加的数据库，您会发现，testDB.db 仍与 'test' 和 'main' 保持连接。\n\n\tsqlite> .databases\n\tseq  name             file\n\t---  ---------------  ----------------------\n\t0    main             /home/sqlite/testDB.db\n\t2    test             /home/sqlite/testDB.db\n\n---\n\n#### SQLite 创建表\n\nSQLite 的 CREATE TABLE 语句用于在任何给定的数据库创建一个新表。创建基本表，涉及到命名表、定义列及每一列的数据类型。\n\n---\n\n**语法**\n\nCREATE TABLE 语句的基本语法如下：\n\n\tCREATE TABLE database_name.table_name(\n\t   column1 datatype  PRIMARY KEY(one or more columns),\n\t   column2 datatype,\n\t   column3 datatype,\n\t   .....\n\t   columnN datatype,\n\t);\n\nCREATE TABLE 是告诉数据库系统创建一个新表的关键字。CREATE TABLE 语句后跟着表的唯一的名称或标识。您也可以选择指定带有 table_name 的 *database_name*。\n\n**实例**\n\n下面是一个实例，它创建了一个 COMPANY 表，ID 作为主键，NOT NULL 的约束表示在表中创建纪录时这些字段不能为 NULL：\n\n\tsqlite> CREATE TABLE COMPANY(\n\t   ID INT PRIMARY KEY     NOT NULL,\n\t   NAME           TEXT    NOT NULL,\n\t   AGE            INT     NOT NULL,\n\t   ADDRESS        CHAR(50),\n\t   SALARY         REAL\n\t);\n\n让我们再创建一个表，我们将在随后章节的练习中使用：\n\n\tsqlite> CREATE TABLE DEPARTMENT(\n\t   ID INT PRIMARY KEY      NOT NULL,\n\t   DEPT           CHAR(50) NOT NULL,\n\t   EMP_ID         INT      NOT NULL\n\t);\n\n您可以使用 SQLIte 命令中的 .tables/.table 命令来验证表是否已成功创建，该命令用于列出附加数据库中的所有表。\n\n\tsqlite> .tables\n\tCOMPANY          DEPARTMENT       TEST.COMPANY     TEST.DEPARTMENT\n\n在这里，可以看到 COMPANY 表出现两次，一个是主数据库的 COMPANY 表，一个是为 testDB.db 创建的 'test' 别名的 test.COMPANY 表。您可以使用 SQLite .schema 命令得到表的完整信息，如下所示：\n\n\tsqlite>.schema COMPANY\n\tCREATE TABLE COMPANY(\n\t   ID INT PRIMARY KEY     NOT NULL,\n\t   NAME           TEXT    NOT NULL,\n\t   AGE            INT     NOT NULL,\n\t   ADDRESS        CHAR(50),\n\t   SALARY         REAL\n\t);\n\n#### SQLite 删除表\n\nSQLite 的 DROP TABLE 语句用来删除表定义及其所有相关数据、索引、触发器、约束和该表的权限规范。\n\n> 使用此命令时要特别注意，因为一旦一个表被删除，表中所有信息也将永远丢失。\n\n---\n\n**语法**\n\nDROP TABLE 语句的基本语法如下。您可以选择指定带有表名的数据库名称，如下所示：\n\n\tDROP TABLE database_name.table_name;\n\n**实例**\n\n让我们先确认 COMPANY 表已经存在，然后我们将其从数据库中删除。\n\n\tsqlite> .tables\n\tCOMPANY       test.COMPANY\n\n这意味着 COMPANY 表已存在数据库中，接下来让我们把它从数据库中删除，如下：\n\n\tsqlite> DROP TABLE COMPANY;\n\tsqlite>\n\n现在，如果尝试 .TABLES 命令，那么将无法找到 COMPANY 表了：\n\n\tsqlite> .tables\n\tsqlite>\n\n显示结果为空，意味着已经成功从数据库删除表。\n\n资料整理于：[RUNOOB.COM-SQLite教程](http://www.runoob.com/sqlite/sqlite-tutorial.html)\n转载请注明出处。\n","tags":["SQLite"],"categories":["数据库"]},{"title":"SQLite 教程(一)","url":"/2016/01/13/2016-01-13-sqlite-jiao-cheng-[?]/","content":"\n#### 简介：\nSQLite 是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite 是在世界上最广泛部署的 SQL 数据库引擎。SQLite 源代码不受版权限制。\n本教程将告诉您如何使用 SQLite 编程，并让你迅速上手。\n\n#### 什么是 SQLite？\nSQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。\n就像其他数据库，SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件\n\n#### 为什么要用 SQLite？\n* 不需要一个单独的服务器进程或操作的系统（无服务器的）。\n* SQLite 不需要配置，这意味着不需要安装或管理。\n* 一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。\n* SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于250KiB。\n* SQLite 是自给自足的，这意味着不需要任何外部的依赖。\n* SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。\n* SQLite 支持 SQL92（SQL2）标准的大多数查询语言的功能。\n* SQLite 使用 ANSI-C 编写的，并提供了简单和易于使用的 API。\n* SQLite 可在 UNIX（Linux, Mac OS-X, Android, iOS）和 Windows（Win32, WinCE, WinRT）中运行。\n\n#### SQLite 命令\n与关系数据库进行交互的标准 SQLite 命令类似于 SQL。命令包括 CREATE、SELECT、INSERT、UPDATE、DELETE 和 DROP。这些命令基于它们的操作性质可分为以下几种：\n\n#### DDL - 数据定义语言\n| 命令   | 描述 |\n|-------|-----|\n|CREATE\t|创建一个新的表，一个表的视图，或者数据库中的其他对象。|\n|ALTER\t|修改数据库中的某个已有的数据库对象，比如一个表。     |\n|DROP\t|删除整个表，或者表的视图，或者数据库中的其他对象。   |\n\n#### DML - 数据操作语言\n| 命令   | 描述 |\n|-------| -----|\n|INSERT |创建一条记录。|\n|UPDATE\t|修改记录。      |\n|DELETE\t|删除记录。      |\n\n#### DQL - 数据查询语言\n| 命令   | 描述 |\n|-------| -----|\n|SELECT |\t从一个或多个表中检索某些记录。|\n\n#### 在 Mac OS X 上安装 SQLite\n最新版本的 Mac OS X 会预安装 SQLite，但是如果没有可用的安装，只需按照如下步骤进行：\n请访问 [SQLite 下载页面](http://www.sqlite.org/download.html)，从源代码区下载 sqlite-autoconf-*.tar.gz。\n步骤如下：\n\n\t$tar xvfz sqlite-autoconf-3071502.tar.gz\n\t$cd sqlite-autoconf-3071502\n\t$./configure --prefix=/usr/local\n\t$make\n\t$make install\n\n\n上述步骤将在 Mac OS X 机器上安装 SQLite，您可以使用下列命令进行验证：\n\n\t$sqlite3\n\tSQLite version 3.7.15.2 2013-01-09 11:53:05\n\tEnter \".help\" for instructions\n\tEnter SQL statements terminated with a \";\"\n\tsqlite>\n\n最后，在 SQLite 命令提示符下，使用 SQLite 命令做练习。\n\n#### SQLite语法\n\n**大小写敏感性**\n\n有个重要的点值得注意，SQLite 是不区分大小写的，但也有一些命令是大小写敏感的，比如 GLOB 和 glob 在 SQLite 的语句中有不同的含义。\n\n**注释**\n\nSQLite 注释是附加的注释，可以在 SQLite 代码中添加注释以增加其可读性，他们可以出现在任何空白处，包括在表达式内和其他 SQL 语句的中间，但它们不能嵌套。\nSQL 注释以两个连续的 \"-\" 字符（ASCII 0x2d）开始，并扩展至下一个换行符（ASCII 0x0a）或直到输入结束，以先到者为准。\n您也可以使用 C 风格的注释，以 \"/\\*\" 开始，并扩展至下一个 \"*/\" 字符对或直到输入结束，以先到者为准。SQLite的注释可以跨越多行。\n\n#### SQLite 语句\n所有的 SQLite 语句可以以任何关键字开始，如 SELECT、INSERT、UPDATE、DELETE、ALTER、DROP 等，所有的语句以分号（;）结束。\n\nSQLite ANALYZE 语句：\n\n\tANALYZE;\n\tor\n\tANALYZE database_name;\n\tor\n\tANALYZE database_name.table_name;\n\nSQLite AND/OR 子句：\n\n\tSELECT column1, column2....columnN\n\tFROM   table_name\n\tWHERE  CONDITION-1 {AND|OR} CONDITION-2;\n\nSQLite ALTER TABLE 语句：\n\n\tALTER TABLE table_name ADD COLUMN column_def...;\n\tSQLite ALTER TABLE 语句（Rename）：\n\tALTER TABLE table_name RENAME TO new_table_name;\n\nSQLite ATTACH DATABASE 语句：\n\n\tATTACH DATABASE 'DatabaseName' As 'Alias-Name';\n\tSQLite BEGIN TRANSACTION 语句：\n\tBEGIN;\n\tor\n\tBEGIN EXCLUSIVE TRANSACTION;\n\nSQLite BETWEEN 子句：\n\n\tSELECT column1, column2....columnN\n\tFROM   table_name\n\tWHERE  column_name BETWEEN val-1 AND val-2;\n\nSQLite COMMIT 语句：\n\n\tCOMMIT;\n\nSQLite CREATE INDEX 语句：\n\n\tCREATE INDEX index_name\n\tON table_name ( column_name COLLATE NOCASE );\n\nSQLite CREATE UNIQUE INDEX 语句：\n\n\tCREATE UNIQUE INDEX index_name\n\tON table_name ( column1, column2,...columnN);\n\nSQLite CREATE TABLE 语句：\n\n\tCREATE TABLE table_name(\n\t   column1 datatype,\n\t   column2 datatype,\n\t   column3 datatype,\n\t   .....\n\t   columnN datatype,\n\t   PRIMARY KEY( one or more columns )\n\t);\n\nSQLite CREATE TRIGGER 语句：\n\n\tCREATE TRIGGER database_name.trigger_name\n\tBEFORE INSERT ON table_name FOR EACH ROW\n\tBEGIN\n\t   stmt1;\n\t   stmt2;\n\t   ....\n\tEND;\n\nSQLite CREATE VIEW 语句：\n\n\tCREATE VIEW database_name.view_name  AS\n\tSELECT statement....;\n\nSQLite CREATE VIRTUAL TABLE 语句：\n\n\tCREATE VIRTUAL TABLE database_name.table_name USING weblog( access.log );\n\tor\n\tCREATE VIRTUAL TABLE database_name.table_name USING fts3( );\n\nSQLite COMMIT TRANSACTION 语句：\n\n\tCOMMIT;\n\tSQLite COUNT 子句：\n\tSELECT COUNT(column_name)\n\tFROM   table_name\n\tWHERE  CONDITION;\n\nSQLite DELETE 语句：\n\n\tDELETE FROM table_name\n\tWHERE  {CONDITION};\n\nSQLite DETACH DATABASE 语句：\n\n\tDETACH DATABASE 'Alias-Name';\n\nSQLite DISTINCT 子句：\n\n\tSELECT DISTINCT column1, column2....columnN\n\tFROM   table_name;\n\nSQLite DROP INDEX 语句：\n\n\tDROP INDEX database_name.index_name;\n\nSQLite DROP TABLE 语句：\n\n\tDROP TABLE database_name.table_name;\n\nSQLite DROP VIEW 语句：\n\n\tDROP INDEX database_name.view_name;\n\nSQLite DROP TRIGGER 语句：\n\n\tDROP INDEX database_name.trigger_name;\n\nSQLite EXISTS 子句：\n\n\tSELECT column1, column2....columnN\n\tFROM   table_name\n\tWHERE  column_name EXISTS (SELECT * FROM   table_name );\n\nSQLite EXPLAIN 语句：\n\n\tEXPLAIN INSERT statement...;\n\tor\n\tEXPLAIN QUERY PLAN SELECT statement...;\n\nSQLite GLOB 子句：\n\n\tSELECT column1, column2....columnN\n\tFROM   table_name\n\tWHERE  column_name GLOB { PATTERN };\n\nSQLite GROUP BY 子句：\n\n\tSELECT SUM(column_name)\n\tFROM   table_name\n\tWHERE  CONDITION\n\tGROUP BY column_name;\n\nSQLite HAVING 子句：\n\n\tSELECT SUM(column_name)\n\tFROM   table_name\n\tWHERE  CONDITION\n\tGROUP BY column_name\n\tHAVING (arithematic function condition);\n\nSQLite INSERT INTO 语句：\n\n\tINSERT INTO table_name( column1, column2....columnN)\n\tVALUES ( value1, value2....valueN);\n\nSQLite IN 子句：\n\n\tSELECT column1, column2....columnN\n\tFROM   table_name\n\tWHERE  column_name IN (val-1, val-2,...val-N);\n\nSQLite Like 子句：\n\n\tSELECT column1, column2....columnN\n\tFROM   table_name\n\tWHERE  column_name LIKE { PATTERN };\n\nSQLite NOT IN 子句：\n\n\tSELECT column1, column2....columnN\n\tFROM   table_name\n\tWHERE  column_name NOT IN (val-1, val-2,...val-N);\n\nSQLite ORDER BY 子句：\n\n\tSELECT column1, column2....columnN\n\tFROM   table_name\n\tWHERE  CONDITION\n\tORDER BY column_name {ASC|DESC};\n\nSQLite PRAGMA 语句：\n\n\tPRAGMA pragma_name;\n\n\tFor example:\n\n\tPRAGMA page_size;\n\tPRAGMA cache_size = 1024;\n\tPRAGMA table_info(table_name);\n\nSQLite RELEASE SAVEPOINT 语句：\n\n\tRELEASE savepoint_name;\n\nSQLite REINDEX 语句：\n\n\tREINDEX collation_name;\n\tREINDEX database_name.index_name;\n\tREINDEX database_name.table_name;\n\nSQLite ROLLBACK 语句：\n\n\tROLLBACK;\n\tor\n\tROLLBACK TO SAVEPOINT savepoint_name;\n\nSQLite SAVEPOINT 语句：\n\n\tSAVEPOINT savepoint_name;\n\tSQLite SELECT 语句：\n\tSELECT column1, column2....columnN\n\tFROM   table_name;\n\nSQLite UPDATE 语句：\n\n\tUPDATE table_name\n\tSET column1 = value1, column2 = value2....columnN=valueN\n\t[ WHERE  CONDITION ];\n\nSQLite VACUUM 语句：\n\n\tVACUUM;\n\nSQLite WHERE 子句：\n\n\tSELECT column1, column2....columnN\n\tFROM   table_name\n\tWHERE  CONDITION;\n\n资料整理于：[RUNOOB.COM-SQLite教程](http://www.runoob.com/sqlite/sqlite-tutorial.html)\n转载请注明出处。\n","tags":["SQLite"],"categories":["数据库"]},{"title":"CocoaPods 使用指南","url":"/2016/01/13/2016-01-13-cocoapodsshi-yong-zhi-nan/","content":"\n\n\n## 简介\n\nCocoaPods是iOS最常用的第三方类库管理工具，绝大部分有名的开源类库支持CocoaPods。\n\nCocoaPods是用Ruby实现的，要使用它首先需要有Ruby的环境。\n\n## 安装\n\n幸亏OS X系统默认已经可以运行Ruby了，我们只需执行以下命令：\n\n```shell\nsudo gem install cocoapods\n```\n\n由于某些原因，执行时会出现下面的错误提示：\n\n```shell\nERROR :Could not find a valid gem `cocoapods` (>= 0), here is why:\n        Unable to download data from https://rubygems.org/ - Errno::EPIPI:\n        Broken pipe - SSL_connect\n(https://rubygems.org/lastest_specs.4.8.gz)\n```\n\n安装成功后，接着执行命令：\n\n```shell\npod setup\n```\n\n如果Ruby环境不够新，可能需要更新以下：\n\n```shell\nsudo gem update --system\n```\n\n至此安装就完成了，我们可以尝试搜索一个第三方类库：\n\n```shell\npod search AFNetworking\n```\n\n## 使用\n\n使用CocoaPods第一步，是在当前项目下，新建一个Podfile文件：\n\n```shell\ntouch Podfile\n```\n\n然后利用vim打开Podfile文件编辑，加入你想要的类库，格式如下：\n\n```ruby\nplatform :ios\npod  'Reachability', '3.1.0'\n\nplatform :ios, '6.0'\npod 'JSONKit', '1.4'\npod 'AFNetworking', '~> 2.3.1'\n```\n\n如果是拷贝别人的项目，或是一个很久没打开过的项目，可能需要先执行一下：\n\n```shell\npod update\n```\n\n最后一步，执行命令：\n\n```shell\npod install\n```\n\n当终端出现类似下面的提示后，就代表成功了：\n\n```shell\n[!] From now no use `Sample0814.xcworkspace`.\n```\n\n这个时候会看到项目文件夹多了一个xxx.xcworkspace,以后要通过这个文件\n打开项目，老项目xxx.xcodeproj不再使用。\n\n> 1. 上面的每一步都可能出现问题，但大部分问题都是因为局域网的原因，用一个网速稳\n定的境外VPN可破\n> 2. 如果上面因为权限问题安装失败，必须每次都要删除\n>\n```sh\nrm -rf /User/loginname/Library/Caches/CocoaPods/\n```\n因为这个缓冲中会存下你的github的东西，造成每次调用上次权限问题的缓存。\n> 3. 关于Podfile文件编辑时，第三方版本号的各种写法:\n\n\n```ruby\npod 'AFNetworking'      \t\t # 不显式指定依赖库版本，表示每次都获取最新版本\npod 'AFNetworking', '2.0'        # 只使用2.0版本\npod 'AFNetworking', '>2.0'       # 使用高于2.0的版本\npod 'AFNetworking', '>=2.0'      # 使用大于或等于2.0的版本\npod 'AFNetworking', '<2.0'       # 使用小于2.0的版本\npod 'AFNetworking', '<=2.0'      # 使用小于或等于2.0的版本\npod 'AFNetworking', '~>0.1.2'    # 使用大于等于0.1.2但小于0.2的版本，相当于>=0.1.2并且<0.2.0\npod 'AFNetworking', '~>0.1'      # 使用大于等于0.1但小于1.0的版本\npod 'AFNetworking', '~>0'        # 高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本\n```\n\n## 参考资料\n\n* [语义化版本 2.0.0](http://semver.org)\n","tags":["CocoaPods"],"categories":["包管理"]},{"title":"GET&amp;POST","url":"/2016/01/13/2016-01-13-get-and-post/","content":"\n\nGET和POST是两种最常用的与服务器进行交互的HTTP方法。\n\n### GET\n* GET的语义是获取指定的URL资源, 将数据按照 variable = value 的形式, 添加到action所指向的URL后面, 并且两者使用 ' ? '连接, 各变量之间使用 ' & '连接。\n* 对用户来说不安全, 因为在传输过程中, 数据被放在请求的URL中。\n* 传输的数据量小, 这主要是因为受URL长度限制。\n\n### URL长度限制\n\n 在http协议中，其实并没有对url长度作出限制，往往url的最大长度和用户浏览器和Web服务器有关，不一样的浏览器，能接受的最大长度往往是不一样的，当然，不一样的Web服务器能够处理的最大长度的URL的能力也是不一样的。\n\n    IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应；\n    \n    Firefox浏览器URL的长度限制为65,536个字符；\n    \n    Apache(Server)能够接受的最大URL长度为8192个字符；\n    \n    如果浏览器的编码为UTF8的话，一个汉字最终编码后的字符长度为9个字符。\n\nGET请求示例\n\n![GetRequest](/images/post_get/requst_01.webp)\n\n\n### POST\n* POST语义是向指定URL的资源添加数据。\n* 将数据放在数据体中, 按照变量和值相对应的方式, 传递到action所指向的URL。\n* 所有数据对用户来说不可见。\n* 可以传输大量数据, 上传文件只能使用POST。\n\nPOST请求示例\n\n![GetRequest](/images/post_get/requst_02.webp)\n\n### 在浏览器中判断GET&POST请求\n\n因为POST请求会向服务器发送数据体, 因此刷新页面时会出现提示窗口. 而GET请求不会向服务器发送数据体, 因此没有提示 .\n\n从请求本质来看, GET请求要比POST更安全, 效率也会更高 .(对服务器而言)\n\n### iOS网络发送网络请求的步骤\n1. 实例化URL( 网络资源 ) ;\n\n2. 根据URL建立URLRequest ( 网络请求 ) ;\n\n    默认为GET请求; 对于POST请求,  需要创建请求的数据体 .\n\n3. 利用 URLConnection 发送网络请求(发送请求并获得结果) ;\n\nNSURLConnection提供了两个静态方法可以直接以同步或异步的方式向服务器发送网络请求.   \t\n\n    同步请求:\n    sendSynchronousRequest : returningResponse : error :\n    \n    异步请求:\n    sendAsynchronousRequest : queue : completionHandler :\n\n在网络请求过程中, 接收数据的过程实际上是通过 NSURLConnectionDataDelegate来实现的, 常用代理方法包括:\n\n```objc\n// 服务器开始返回数据\n- (void)connection:didReceiveResponse:\n// 收到服务器返回的数据，本方法会被调用多次\n- (void)connection:didReceiveData:\n// 数据接收完毕，做数据的最后处理\n- (void)connectionDidFinishLoading:\n// 网络连接错误\n- (void)connection:didFailWithError:\n```\n\n备注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["GET、POST"],"categories":["网络协议"]},{"title":"HTTP POST and multipart forms","url":"/2016/01/13/2016-01-13-http-post-and-multipart-forms/","content":"\n#### `HTTP POST` 使用注意事项：\n\n* http Body 中的NSData 编码方式要用`NSASCIIStringEncoding`而不是`NSUTF8StringEncoding`\n* 通过\n\t`NSString *postLength = [NSString stringWithFormat:@\"%d\",[postData length]];`\t\t\n计算数据的长度\n\n#### POST参数设置\n\n```objc\n\t\t//设置header Content-Length\n\t\t[request setValue:postLength forHTTPHeaderField:@\"Content-Length\"];\n\t\t//设置header contentType\n\t\t[request setValue:@\"application/x-www-form-urlencoded\" forHTTPHeaderField:@\"Current-Type\"];\n\t\t//设置body\n\t\t[request setHTTPBody:postData];\n```\n\n> 备注:普通`post`的`header`的`Current-Type`为`application/x-www-form-urlencoded`\n\n#### Multipart Forms POST参数设置\n\n```objc\n\t\t//设置header contentType\n\t\tNSString *contentType = [NSString stringWithFormat:@\"multipart/form-data; boundary=%@\", boundary];\n\t\t[request addValue:contentType forHTTPHeaderField:@\"Content-Type\"];\n\n\t\t//设置body contentType\n\t\t[body appendData:[@\"Content-Type: application/octet-stream\\r\\n\\r\\n\" dataUsingEncoding:NSUTF8StringEncoding]];\n```\n\n> 备注:`Multipart Forms`的`header`的`Current-Type`为`multipart/form-data`\n\nrequest body like this\n\n\t\t--YOUR_BOUNDARY_STRING\n\t\tContent-Disposition: form-data; name=\"photo\"; filename=\"calm.jpg\"\n\t\tContent-Type: image/jpeg\n\n\t\tYOUR_IMAGE_DATA_GOES_HERE\n\t\t--YOUR_BOUNDARY_STRING\n\t\tContent-Disposition: form-data; name=\"message\"\n\n\t\tMy first message\n\t\t--YOUR_BOUNDARY_STRING\n\t\tContent-Disposition: form-data; name=\"user\"\n\n\t\t1\n\t\t--YOUR_BOUNDARY_STRING\n\nI’m sending over three variables: an image named photo, a string named message, and an integer named user. It’s important to note the linebreaks and the dashes before the boundary string. These must be included in order to build a good request. Now lets write some objective-c:\n\n\n```objc\n\n\tNSString *boundary = @\"YOUR_BOUNDARY_STRING\";\n\tNSString *contentType = [NSString stringWithFormat:@\"multipart/form-data; boundary=%@\", boundary];\n\t[request addValue:contentType forHTTPHeaderField:@\"Content-Type\"];\n\n\tNSMutableData *body = [NSMutableData data];\n\n\t[body appendData:[[NSString stringWithFormat:@\"\\r\\n--%@\\r\\n\", boundary] dataUsingEncoding:NSUTF8StringEncoding]];\n\t[body appendData:[[NSString stringWithFormat:@\"Content-Disposition: form-data; name=\\\"photo\\\"; filename=\\\"%@.jpg\\\"\\r\\n\", self.message.photoKey] dataUsingEncoding:NSUTF8StringEncoding]];\n\t[body appendData:[@\"Content-Type: application/octet-stream\\r\\n\\r\\n\" dataUsingEncoding:NSUTF8StringEncoding]];\n\t[body appendData:[NSData dataWithData:imageData]];\n\n\t[body appendData:[[NSString stringWithFormat:@\"\\r\\n--%@\\r\\n\", boundary] dataUsingEncoding:NSUTF8StringEncoding]];\n\t[body appendData:[[NSString stringWithFormat:@\"Content-Disposition: form-data; name=\\\"message\\\"\\r\\n\\r\\n%@\", self.message.message] dataUsingEncoding:NSUTF8StringEncoding]];\n\n\t[body appendData:[[NSString stringWithFormat:@\"\\r\\n--%@\\r\\n\", boundary] dataUsingEncoding:NSUTF8StringEncoding]];\n\t[body appendData:[[NSString stringWithFormat:@\"Content-Disposition: form-data; name=\\\"user\\\"\\r\\n\\r\\n%d\", 1] dataUsingEncoding:NSUTF8StringEncoding]];\n\n\t[body appendData:[[NSString stringWithFormat:@\"\\r\\n--%@\\r\\n\", boundary] dataUsingEncoding:NSUTF8StringEncoding]];\n\n\t[request setHTTPBody:body];\n\n```\n\n\nNow all we need to do is make a connection to the server and send the request:\n\n\t[request setHTTPBody:body];\n\n```objc\n\tNSURLResponse *response;\n\tNSError *error;\n\n\t[NSURLConnection sendSynchronousRequest:request returningResponse:&response error:&error];\n```\n\n参考资料：\n\n* [Sending Multipart Forms with Objective-C](http://nthn.me/posts/2012/objc-multipart-forms.html)\n* [POST multipart/form-data with Objective-C](http://stackoverflow.com/questions/24250475/post-multipart-form-data-with-objective-c)\n* [Sending an HTTP POST request on iOS](http://stackoverflow.com/questions/15749486/sending-an-http-post-request-on-ios)\n* [The Multipart Content-Type--w3规范](http://www.w3.org/Protocols/rfc1341/7_2_Multipart.html)\n\n备注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["Networking"],"categories":["网络协议"]},{"title":"工厂模式详解","url":"/2016/01/13/2016-01-13-gong-han-mo-shi-xiang-jie/","content":"\n## 3 种工厂模式\n概述：工厂模式是个系列，分为简单工厂模式， 工厂方法模式， 抽象工厂模式，这三种模式也非常常用。这些模式最最经典的就例子就是设计计算器。\n* Factory Method (工厂方法模式)\n* Abstract Factory (抽象工厂模式）\n* Simple Factory（简单工厂模式）\n\n`参考 GoF《Design Patterns》一书`\n\nGOF 是这样描述工厂模式的：\n > “Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.”\n\n> 在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。\n\n### 简单工厂模式\n  严格的说，简单工厂模式并不是 23 种常用的设计模式之一，它只算工厂模式的一个特殊实现。简单工厂模式在实际中的应用相对于其他 2 个工厂模式用的还是相对少得多，因为它只适应很多简单的情况，最最重要的是它违背了我们在概述中说的开放-封闭原则。因为每次你要新添加一个功能，都需要在生 switch-case 语句（或者 if-else 语句）中去修改代码，添加分支条件\n\n  简单工厂模式角色分配：\n\n1. Creator（产品创建者）\n简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。\n\n2.  Product （ 产品抽象类）\n简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。\n\n3. Concrete Product （具体产品）\n是简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。\n\n简单的工厂模式 UML 图\n![简单工厂模式](/images/factory_pattern/uml_1.jpg)\n\n\n考虑下面一个事例： 加入你是一个商人，你做的的是手机生意。现在你生产 android 手机和 iphone 等，考虑到以后你可能还会生产其他手机例如 ubuntu 手机。假定你选择了简单工厂模式来实现。那么显然，我们需要所有产品的抽象基类（Product） 即是 Phone 类：\n\n```java\nclass Phone   \n{  \npublic:  \n    virtual ~Phone(){};//在删除的时候防止内存泄露  \n    virtual void call(string number) = 0;  \n};\n```\n\n然后我们需要具体的产品类 Concrete Product： AndroidPhone 和 iOSPhone\n\n```java\nclass AndroidPhone : public Phone   \n{  \npublic:  \n    void call(string number){ cout<<\"AndroidPhone is calling...\"<<endl;}  \n};  \n\nclass IosPhone : public Phone  \n{  \npublic:  \n    void call(string number) { cout<<\"IosPhone is calling...\"<<endl;}  \n};\n```\n\n最后我们需要 Creator\n\n```java\nclass PhoneFactory  \n{  \npublic:  \n    Phone* createPhone(string phoneName)  \n    {  \n        if(phoneName == \"AndroidPhone\")  \n        {  \n            return new AndroidPhone();  \n        }else if(phoneName == \"IosPhone\")  \n        {  \n            return new IosPhone();  \n        }  \n\n        return NULL;  \n    }  \n};\n```\n\n客户端这样实现：\n\n```java\nvoid main()  \n{  \n    PhoneFactor factory;  \n    Phone* myAndroid = factory.createPhone(\"AndroidPhone\");  \n    Phone* myIPhone = factory.createPhone(\"iOSPhone\");  \n    if(myAndroid)  \n    {  \n        myAndroid->call(\"123\");  \n        delete myAndroid;  \n        myAndroid = NULL;  \n    }  \n\n    if(myIPhone)  \n    {  \n        myIPhone->call(\"123\");  \n        delete  myIPhone;  \n        myIPhone = NULL;  \n    }  \n}\n```\n\n这就是简单工厂方法，把所有的创建交给 creator,creator 通过 switch-case(或者 if-else)语句来选择具体创建的对象。简单明了。但是就如上面所说，它最致命的问题的违背了开放-封闭原则。每次你要新添加一个功能，都要修改 factor 里面的 createPhone 代码。 但是工厂方法模式可以解决这个问题。\n\n### 工厂方法模式\n个人觉得工厂方法模式在工厂模式家族中是用的最多模式。上面说过了，如果简单工厂模式，要添加一个新功能，比如我现在要增加 WinPhone 的生产，那么我要修改 PhoneFactory 中的 createPhone 中的分支判断条件。这违背了开放-封闭原则，那为什么不能将创建方法放到子类中呢？\n工厂方法的定义就是：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。\n\n  工厂方法模式角色：\n1. 抽象工厂(Creator)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。\n2. 具体工厂(Concrete Creator)角色：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。\n3. 抽象产品(Product)角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。\n4. 具体产品(Concrete Product)角色：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应\n\n工厂方法模式 UML 图：\n![工厂方法模式](/images/factory_pattern/uml_2.jpg)\n\n\n看定义看的晕乎乎的？那么我们来看代码：产品接口，以及其相应的子类。\n\n```java\nclass Phone   \n{  \npublic:  \n    virtual ~Phone(){};//在删除的时候防止内存泄露  \n    virtual void call(string number) = 0;  \n};  \n\nclass AndroidPhone : public Phone   \n{  \npublic:  \n    void call(string number){ cout<<\"AndroidPhone is calling...\"<<endl;}  \n};  \n\nclass iOSPhone : public Phone  \n{  \npublic:  \n    void call(string number) { cout<<\"iOSPhone is calling...\"<<endl;}  \n};\n```\n\n上面这个和简单工厂方法还是一样的。接下来不一样的来了...\n\n```java\nclass PhoneFactory  \n{  \npublic:  \n    virtual ~PhoneFactory(){};  \n    virtual Phone* createPhone() = 0;  \n};  \n\nclass AndroidPhoneFactory : public PhoneFactory  \n{  \npublic:  \n    virtual Phone* createPhone()  \n    {  \n        return new AndroidPhone();  \n    }  \n};  \n\nclass IosPhoneFactory : public PhoneFactory  \n{  \npublic:  \n    virtual Phone* createPhone()  \n    {  \n        return new IosPhone();  \n    }  \n};\n```\n\n工厂方法将 PhoneFactory 抽象成了基类，PhoneFactory 的 createPhone 不在像以前那样将所有的判断塞到里面。而是改由其子类来实现创建功能，这感觉就是权力下放。\n客户端：\n\n```java\nvoid main()  \n{  \n    PhoneFactory*  androidCreator = new AndroidPhoneFactory();  \n    PhoneFactory*  iosCreator = new IosPhoneFactory();  \n    Phone*  myAndroid = androidCreator->createPhone();  \n    Phone* myIPhone = iosCreator->createPhone();  \n    if(myAndroid)  \n    {  \n        myAndroid->call(\"123\");  \n        delete myAndroid;  \n        myAndroid = NULL;  \n    }  \n\n    if(myIPhone)  \n    {  \n        myIPhone->call(\"123\");  \n        delete  myIPhone;  \n        myIPhone = NULL;  \n    }  \n\n    delete androidCreator;  \n    delete iosCreator;  \n}\n```\n\n在工厂方法模式中，核心工厂类不在负责产品的创建，而是将具体的创建工作交给子类去完成。也就是后所这个核心工厂仅仅只是提供创建的接口，具体实现方法交给继承它的子类去完成。当我们的系统需要增加其他新功能时，只需要继承 PhoneFactory 这个类，并且实现 createPhone 接口。 不需要对原工厂 PhoneFactory 进行任何修改，这样很好地符合了“开放-封闭“原则。\n\n虽然工厂方法模式满足了\"开放-封闭”原则，但是这个模式也仍然有缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\n\n### 抽象工厂模式\n在工厂方法模式中，其实我们有一个潜在意识的意识。那就是我们生产的都是同一类产品，例如我们生产的都是手机！那么现在假如现在我们又要生产平板了了呢？那么就要用到抽象工厂模式。我抽象工厂模式也用的比较多在工厂模式家族中，仅次于工厂方法模式。在了解抽象工厂模式之前，还是老生常谈的理清下产品等级结构和产品簇的概念。下面的图还是老图。但是我讲讲我的理解：\n\n![抽象工厂模式](/images/factory_pattern/uml_3.jpg)\n\n产品等级结构：产品的等级结构也就是产品的继承结构。我理解就是同一类产品，比如手机是一个系列，有 android 手机，ios 手机，win 手机，那么这个抽象类手机和他的子类就构成了一个产品等级结构。那其他的平板显然不是和手机一个系列的，一个平板，一个是手机，所以他们是不同的产品等级结构。\n\n产品族: 在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。比如分为 android 产品，和 ios 产品。其中一个 ios 产品包含 ios 手机和 ios 平板。显然 ios 手机和 ios 平板不是同一个产品等级结构的，因为一个是手机，一个是平板。但他们是同一个产品簇---都是 ios 产品。\n希望大家通过上面的例子大家明白了这两个概念。\n\n 抽象工厂模式的 UML 图：\n ![抽象工厂模式](/images/factory_pattern/uml_4.jpg)\n\n接着上面的话题，现在假如我要增加对平板的支持，那么我们肯定先添加两个产品等级结构，一个是手机，一个是平板：\n\n```java\n//产品等级结构--手机  \nclass Phone   \n{  \npublic:  \n    virtual ~Phone(){};//在删除的时候防止内存泄露  \n    virtual void call(string number) = 0;  \n};  \n\nclass AndroidPhone : public Phone   \n{  \npublic:  \n    void call(string number){ cout<<\"AndroidPhone is calling...\"<<endl; }  \n};  \n\nclass IosPhone : public Phone  \n{  \npublic:  \n    void call(string number) { cout<<\"IosPhone is calling...\"<<endl; }  \n};  \n\n//产品等级结构--平板  \nclass Pad  \n{  \npublic:  \n    virtual ~Pad(){};  \n    virtual void playMovie() = 0;  \n};  \n\nclass AndroidPad : public Pad  \n{  \npublic:  \n    virtual void playMovie(){ cout<<\"AndriodPad is playing movie...\"<<endl; }  \n};  \n\nclass IosPad : public Pad  \n{  \npublic:  \n    virtual void playMovie(){ cout<<\"IosPad is playing movie...\"<<endl; }  \n};   \n```\n然后具体的工厂我们整个工厂是生产移动设备的所以我们取名为 MobileFactory,然后工厂可以生产平板和手机，故有了 createPhone 和 createPad 两个接口。\n\n```java\nclass MobileFactory  \n{  \npublic:  \n    virtual ~MobileFactory(){};  \n    virtual Phone* createPhone() = 0;  \n    virtual Pad* createPad() = 0;  \n};\n```\n接着是 android 产品簇 的工厂类，负责生产 android 的手机和平板：\n\n```java\nclass AndroidFactory : public MobileFactory  \n{  \npublic:  \n    Phone* createPhone()  \n    {  \n        return new AndroidPhone();  \n    }  \n    Pad* createPad()  \n    {  \n        return new AndroidPad();  \n    }  \n};\n```\n\n接着是 ios 的产品簇的工厂类，负责生产 ios 的手机和平板：\n\n```java\nclass IosFactory : public MobileFactory  \n{  \npublic:  \n    Phone* createPhone()  \n    {  \n        return new IosPhone();  \n    }  \n\n    Pad* createPad()  \n    {  \n        return new IosPad();  \n    }  \n};\n```\n\n最后客户端这样实现：\n\n```java\nvoid main()  \n{  \n    MobileFactory*  androidCreator = new AndroidFactory();  \n    MobileFactory*  iosCreator = new IosFactory();  \n    Phone*  myAndroidPhone = androidCreator->createPhone();  \n    Pad* myAndroidPad = androidCreator->createPad();  \n    Phone* myIosPhone = iosCreator->createPhone();  \n    Pad* myIosPad = iosCreator->createPad();  \n\n    myAndroidPhone->call(\"123\");  \n    myAndroidPad->playMovie();  \n\n    myIosPhone->call(\"123\");  \n    myIosPad->playMovie();  \n    //这里没有做释放和判断，请自己判断和释放  \n}\n```\n\n总结：\n抽象工厂模式适用于那些有多种产品的产品簇，并且每次使用其中的某一产品簇的产品。\n缺点 ： 抽象工厂模式的添加新功能也非常麻烦，比工厂方法模式都还要复杂的多。\n优点： 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象\n\n## 主要用途\n工厂方法要解决的问题是对象的创建时机，它提供了一种扩展的策略，很好地符合了开放封闭原则。工厂方法也叫做虚构造器（Virtual Constructor）。\n\n![工厂方法的类结构图](http://cdn.cocimg.com/cms/uploads/allimg/130516/4196_130516112054_1.png)\n\n## 什么时候使用工厂方法\n当是如下情况是，可以使用工厂方法：一个类不知道它所必须创建的对象的类时，一个类希望有它的子类决定所创建的对象时。\n\n更多关于工厂方法的介绍，可以参考本文最后给出的参考内容。下面我们就来看看在 iOS 中工厂方法的一种实现方法。\n\n## iOS 中工厂方法的实现实例\n如下有一个类图，该图描述了下面即将实现的工厂方法（利用工厂方法，创建出不同的形状）。其中 BVShapeFactory 为工厂方法的基类，BVShape 为形状的基类，BVClient 通过 BVShapeFactory，利用 BVShapeFactory 的子类（BVCircleShapeFactory 和 BVSquareShapeFactory）分别创建出 BVCircleShape 和 BVSquareShape。\n![工厂方法](http://cdn.cocimg.com/cms/uploads/allimg/130516/4196_130516112123_1.png)\n\n\ngithub 下载地址:<https://github.com/BeyondVincent/ios_patterns/tree/master/FactoryMethodPattern>\n\n## 参考资料\n\n* [iOS设计模式——工厂方法（简单工厂模式，工厂方法模式， 抽象工厂模式）](http://doc.okbase.net/luozhonglan/archive/103843.html)\n* [iOS设计模式(03):工厂方法](http://www.cocoachina.com/ios/20130516/6219.html)\n* [Objective-C类族和工厂模式](http://www.cocoachina.com/ios/20141124/10296.html)\n* [Objective C Design Patterns - Factory](http://crosbymichael.com/objective-c-design-patterns-factory.html)\n* [Class Factory Methods](https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/ClassFactoryMethods/ClassFactoryMethods.html)--Apple\n* [iOS Design Patterns](http://www.raywenderlich.com/46988/ios-design-patterns)--raywenderlich\n* [Abstract Factory Design Pattern Objective C](http://www.knowstack.com/abstract-factory-design-pattern-objective-c/)\n* [The factory design pattern explained by example](https://www.binpress.com/tutorial/the-factory-design-pattern-explained-by-example/142)-php\n* [Design Patterns Series, Day 3: Factory and Singleton Patterns](https://www.safaribooksonline.com/blog/2014/12/10/design-patterns-series-day-3-factory-singleton-patterns/)--safaribooksonline\n* [Automagic Factories in Objective-C](http://www.bobmccune.com/2011/04/08/automagic-factories-in-objective-c/)--bobmccune\n\n备注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["工厂模式"],"categories":["设计模式"]},{"title":"多线程之 NSThread","url":"/2016/01/13/2016-01-13-duo-xian-cheng-zhi-nsthread/","content":"\n## 前言\n\n每个 iOS 应用程序都有个专门用来更新显示 UI 界面、处理用户触摸事件的主线程，因此不能将其他太耗时的操作放在主线程中执行，不然会造成主线程堵塞(出现卡机现象)，带来极坏的用户体验。一般的解决方案就是将那些耗时的操作放到另外一个线程中去执行，多线程编程是防止主线程堵塞，增加运行效率的最佳方法。\n\niOS 中有 3 种常见的多线程编程方法\n1. `NSThread`\n这种方法需要管理线程的生命周期、同步、加锁问题，会导致一定的性能开销\n\n2. `NSOperation`和`NSOperationQueue`\n是基于 OC 实现的。NSOperation 以面向对象的方式封装了需要执行的操作，然后可以将这个操作放到一个 NSOperationQueue 中去异步执行。不必关心线程管理、同步等问题。\n\n3. `Grand Centeral Dispatch`\n简称 GCD，iOS4 才开始支持，是纯 C 语言的 API。自 iPad2 开始，苹果设备开始有了双核 CPU，为了充分利用这 2 个核，GCD 提供了一些新特性来支持多核并行编程\n\n这篇文章简单介绍`NSThread 这`个类，一个`NSThread`实例就代表着一条线程\n\n## 获取当前线程\n\n```objc\n    NSThread *current = [NSThread currentThread];\n```\n\n## 获取主线程\n```objc\n    NSThread *main = [NSThread mainThread];\n    NSLog(@\"主线程:%@\", main);    \n```\n\n打印结果是：\n\n    2013-04-18 21:36:38.599 thread[7499:c07] 主线程:<NSThread: 0x71434e0>{name = (null), num = 1}\n\nnum 相当于线程的 id，主线程的 num 是为 1 的\n\n## NSThread 的创建\n### a.动态方法\n    - (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument;\n\n在第 2 行创建了一条新线程，然后在第 4 行调用`start`方法启动线程，线程启动后会调用 self 的`run:`方法，并且将@\"mj\"作为方法参数\n\n```objc\n// 初始化线程\nNSThread *thread = [[[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@\"mj\"] autorelease];\n// 开启线程\n[thread start];\n```\n\n假如 run:方法是这样的：\n\n```objc\n- (void)run:(NSString *)string {\n     NSThread *current = [NSThread currentThread];\n     NSLog(@\"执行了 run:方法-参数：%@，当前线程：%@\", string, current);\n}\n```\n\n打印结果为：\n\n    2013-04-18 21:40:33.102 thread[7542:3e13] 执行了 run:方法-参数：mj，当前线程：<NSThread: 0x889e8d0>{name = (null), num = 3}\n\n可以发现，这条线程的 num 值为 3，说明不是主线程，主线程的 num 为 1\n\n### b.静态方法\n```objc\n    + (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument;\n```\n\n```objc\n[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@\"mj\"];\n```\n\n### c.隐式创建线程\n```objc\n[self performSelectorInBackground:@selector(run:) withObject:@\"mj\"];\n```\n会隐式地创建一条新线程，并且在这条线程上调用 self 的 run:方法，以@\"mj\"为方法参数\n\n## 暂停当前线程\n\n```objc\n    [NSThread sleepForTimeInterval:2];\n```\n\n```objc\nNSDate *date = [NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]];  \n[NSThread sleepUntilDate:date];\n```\n\n上面两种做法都是暂停当前线程 2 秒\n\n## 线程的其他操作\n### a.在指定线程上执行操作\n\n```objc\n [self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES];\n```\n\n* 上面代码的意思是在 thread 这条线程上调用 self 的 run 方法\n* 最后的 YES 代表：上面的代码会阻塞，等 run 方法在 thread 线程执行完毕后，上面的代码才会通过\n\n### b.在主线程上执行操作\n\n```objc\n[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES];  \n```\n\n在主线程调用 self 的 run 方法\n\n### c.在当前线程执行操作\n\n```objc\n[self performSelector:@selector(run) withObject:nil];\n```\n在当前线程调用 self 的 run 方法\n\n## 优缺点\n1. 优点：`NSThread`比其他多线程方案较轻量级，更直观地控制线程对象\n2. 缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销\n\n备注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["NSThread"],"categories":["多线程"]},{"title":"NSOperation and NSOperationQueue Tutorial in Swift","url":"/2016/01/13/2016-01-13-nsoperation-and-nsoperationqueue-tutorial-in-swift/","content":"\n* 译自 Written by [ Richard Turton](http://www.raywenderlich.com/u/jrturton) — on October 7, 2014\n* 原文链接：<http://www.raywenderlich.com/76341/use-nsoperation-nsoperationqueue-swift>\n* 译者[@oneruofeng](https://twitter.com/oneruofeng)\n\n> **Post info**: Updated for Xcode 7.1 and Swift 2.1 -- 1 January 2016\n> **Update note**: This tutorial was updated to iOS 8, Xcode 6.1 and Swift by Richard Turton.\n> [Original post](http://www.raywenderlich.com/76341/use-nsoperation-nsoperationqueue-swift) by Tutorial Team member [Soheil Azarpour](http://www.raywenderlich.com/u/Canopus).\n\n每个人都有点击一个按钮或者进入一些文本在iOS或者Mac App上的令人沮丧的经历，就是突然-WHAM，用户交互停止了响应。\n\n在Mac上，你的用户开始盯着一个沙漏或者一个七彩的轮子开始旋转直到它们再次恢复UI交互为止。在一个iOS app中，用户期望App立即响应它们的触摸事件，无响应的app给人的感觉是笨重和缓慢，这样通常会导致收到差评。\n\n保持你的app的可交互的状态说起来容易做起来难，一旦你的app需要执行不仅仅是少量的任务，事情很快就变得很复杂，我们并没有多少事件在主事件循环执行繁重的工作并且同时提供一个可以响应的UI。\n\n低级的开发者是怎样做的呢？解决方案就是把工作从主线程中移除通过并发。并发意味着你应用所有的操作同时执行在多个流（或者线程）中--这样的话用户界面就能保持响应的要执行的工作。\n\n一种实现并发操作在iOS是通过`NSOperation`和`NSOperationQueue`这两个类。在这个教程中，你将学会怎样使用它们！你将从一个没有使用并发的App开始，所以它将出现的非常迟钝和无响应。然后你将重做你的应用给它们添加并发操作并且--希望--呈现一个更加响应良好的可交互界面给用户！\n\n### 我们开始吧\n\n这份样品工程的总的目标的就是展示一个滤镜处理过的图片的表视图。图片将从网络上下载，经过一个滤镜处理后，然后在表视图中显示。\n\n下面是这个app模型的示意图\n\n![app模型的示意图](http://ww2.sinaimg.cn/mw690/64124373gw1ezk3rh3ebyj20i20nmq4k.jpg)\n\n<!--\n<img src = \"http://ww2.sinaimg.cn/mw690/64124373gw1ezk3rh3ebyj20i20nmq4k.jpg\" with= 300 height = 600>-->\n\n\n### 第一个版本尝试\n下载你将在这个教程中使用的[第一个版本的项目](http://cdn5.raywenderlich.com/wp-content/uploads/2014/10/ClassicPhotos-Starter63.zip)\n\n> 注意：所以的图片来自[ stock.xchng.](http://sxc.hu/)。一下图片在数据源故意错误命名，以便这里有些例子是图片下载失败好处理失败的情况。\n\n构建并且运行这个工程，最终你将看到这个app运行起来显示一列照片。尝试滚动这个列表，很痛苦，不是吗？\n![list of photoes](http://ww3.sinaimg.cn/mw690/64124373gw1ezk45qmdigj205x08wdga.jpg)\n\n*传统的相册，运行缓慢*\n\n所有的操作都发生在`ListViewController.swift`里，并且最主要的是发生在` tableView(_:cellForRowAtIndexPath:)`方法里。看一下那个方法和注释这里有两件相当集中的事情需要思考：\n\n1. `从网络载入图片数据`。即使网络状况良好，app将仍然必须等待直到下载完成了才能继续。\n2. 使用*Core Image*给图片加滤镜。这个方法给图片应用一个深褐色的滤镜，假如你想了解更多关于`Core Image`滤镜的知识，请点击[Beginning Core Image in Swift](http://www.raywenderlich.com/76285/beginning-core-image-swift)\n\n还有，你将载入一系列图片请求从网络当它第一次被请求时:\n\n```swift\n  lazy var photos = NSDictionary(contentsOfURL:dataSourceURL)\n```\n\n所有的工作发生在应用的主线程。由于主线程也负责用户交互，让它一直忙于从网络下载东西和给图片加滤镜消磨掉了响应中的app。你可以通过使用Xcode的仪表测量视图获得这样一个快速的概述。你可以通过显示`调试导航`(Commnad+6)接入这个仪表视图,让后选择`CPU`当app正在运行的时候。\n\n![gauges](http://ww4.sinaimg.cn/mw690/64124373gw1ezk4seggwgj20jg0a0ta0.jpg)\n\n*Xcode的仪表视图表明，主线程的任务非常重*\n\n你会看到那些所有的长钉在`Thread 1`，那就是app的主线程。更多详细的信息你可以运行app的`Instruments`,但是那个在[ whole other tutorial :\\].](http://www.raywenderlich.com/?p=23037)中\n\n是时候考虑怎样改善一下你的用户体验了！\n\n### 任务，线程和进程\n在你专研这篇教程之前，这里有一下技术上的慨念需要理一下，我将定义一些专用术语：\n\n* **任务** ：一个简单单个的需要完成的工作\n* **线程** ：操作系统提供的机制允许多个用户操作同时进行在一个应用中\n* **进程** ：一个可执行的代码块，它可以由多个线程构成\n\n> 注意：在iOS和OS X中，线程的功能由POSIX线程API（或者 pthreads）实现，并且它使操作系统的一部分。而这个又是相当底层的东西，你将发现它很容易犯错误；或许关于线程最糟糕的事情是那些很难被发现的错误！\n\n> `Foundation`框架包含了一个叫做`NSThread`的类，这让我们处理事情更容易，但是用`NSThread`管理多个线程仍是一件令人头疼的事情。`NSOperation`和`NSOperationQueue`是为了最大化简化处理多线程的更高级的类。\n\n在这个图解中，你会看到进程，线程和任务之间的关系：\n\n![the relationship between a process, threads, and tasks](http://ww3.sinaimg.cn/mw690/64124373gw1ezk5dwtbhuj20go03n0t2.jpg)\n\n*进程，线程和任务*\n\n正如你所见，一个进程可以包涵多个执行的线程，每个线程能够同时执行多个任务。\n\n在这个图集中, `thread 2`执行文件的读的工作，同时`thread 1`执行UI相关的代码。这和你应该怎样在iOS中构建你的代码（主线程执行任何和UI相关的工作，第二线程应当执行慢的或者长时间运行的耗时操作例如读取文件，接入网络等等）有点相似。\n\n### NSOperation vs. Grand Central Dispatch (GCD)\n\n你应该听说过[Grand Central Dispatch (GCD).](http://developer.apple.com/library/ios/#documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html)。简单的来说，`GCD`由语言的特征，运行时库和系统增强组成来提供一个在`iOS`和`OS X`多核硬件中支持并发系统并且综合的改良。假如你想了解更多关于GCD相关的知识，有可以阅读我们的[Multithreading and Grand Central Dispatch on iOS for Beginners Tutorial](http://www.raywenderlich.com/?p=4295)。\n\n`NSOperation`和`NSOperationQueue`构建在GCD之上。普遍来说，苹果推荐使用最高级别抽象，当需要显示他们一些需要的测量工作时回到最底层。\n\n下面是关于这两者的一些简单比较，将帮助你决定何时何地选择使用`GCD`或者`NSOperation`：\n\n* **GCD** 是一个轻量级的方式来描述将要被并发执行的工作单元。你不必定制这个工作单元的时刻表；系统为你定制时刻表。在blocks中增加依赖是一件头疼的事情。取消或者暂停一个block来进行额外的工作为作为开发者的你！ :]\n\n* **NSOperation** 和GCD相比增加了一些额外开支，但是你能够在各种操作之间增加依赖并且恢复，取消，暂停他们。\n\n这个教程将使用`NSOperation`,因为你将处理一个列表为了好的表现并且由于它大量的消耗的资源你需要能够取消一个操作针对某个图片，假如用户已经将那张图片滚出屏幕。即使这些操作在后台线程，假如这里有一打事情在队列里等着它们去处理，这将表现得跟糟糕。\n\n### 重构 App Model\n\n是时候重构开始的非多线程的模型了！假如你仔细观察先前的模型，你会发现这里有三个可以被改进的线程受困区域。通过切割这三个区域让后把他们放在单独的线程里，主线程的压力将得到缓解并且能够保持和用户交互。\n\n![NSOperation_model_improved](http://ww3.sinaimg.cn/mw690/64124373gw1ezk6m9a5xzj20i20nm416.jpg)\n\n*改进后的 model*\n\n为了摆脱你应用的瓶颈，你需要一个指定一个线程来响应你的用户时间，一个线程专注于下载资源和图片，一个线程执行图片滤镜操作。在新的模型中，app从主线程启动让后载入一个空的表视图。同时，app启动第二个线程开始下载数据资源。\n\n一旦数据资源下载完成，你将通知表视图重新载入。这些事情必须在主线程完成，因为它涉及到用户界面相关的操作。从这一点来说，表视图知道有多少行，并且它知道他将显示图片的URL地址，但是她不知道它是否真的有图片！假如你立即开始下载所有的图片在这个点上，这可能导致效率极其低下，因为你不需要一次性把所有图片下载完！\n\n为了让这个变得更好我们能够做什么？\n\n一个更好的模型就是可交互的行在屏幕范围内可见时才开始下载图片。所以你的代码开始将询问表视图有多少行可见。因此，代码应该直到这里有一个未加滤镜的图片等待处理时才开始处理图片加滤镜操作。\n\n为了使app更加快速响应，代码将要让图片一旦下载完毕立即显示。让后才开始进行图片加滤镜操作，让后更新UI界面来显示已经经过滤镜处理后的图片。下面的图标显示了这个过程的控制流：\n\n![Control Flow](http://ww3.sinaimg.cn/mw690/64124373gw1ezk75nd4bdj20i206yq3q.jpg)\n\n*Cotroll Flow*\n\n为了获得这些对象，你需要跟踪这张图片现在是否正在被下载，一旦完成下载，假如图片的滤镜被应用上。你需要跟跟踪每个操作的状态，它是否正在下载中或者执行滤镜操作，以便你能够取消，暂停或者恢复每个操作当用户滚动的时候。\n\nOkey！ 现在你准备好开始码代码了！ :]\n\n打开你下载的工程，添加一个新的**Swift File**到你的工程中命名为** PhotoOperations.swift**。添加下面代码：\n\n\n```swift\nclass PendingOperations {\n  lazy var downloadsInProgress = [NSIndexPath:NSOperation]()\n  lazy var downloadQueue:NSOperationQueue = {\n    var queue = NSOperationQueue()\n    queue.name = \"Download queue\"\n    queue.maxConcurrentOperationCount = 1\n    return queue\n    }()\n\n  lazy var filtrationsInProgress = [NSIndexPath:NSOperation]()\n  lazy var filtrationQueue:NSOperationQueue = {\n    var queue = NSOperationQueue()\n    queue.name = \"Image Filtration queue\"\n    queue.maxConcurrentOperationCount = 1\n    return queue\n    }()\n}\n```\n\n这回类包含了2个字典为了跟踪激活和正在进行中的下载和滤镜操作对表中的每一行，并且两个操作队列都有各自的操作类型。\n\n所有的值被懒加载的方式创建，意味着他们不会被初始化知道他们第一次被接入。这样改善了你app的表现性能。\n\n创建一个`NSOperationQueue`是非常简单的，正如你所见，给你的队列命名是非常有用的，因为名字会在仪器或者调速器中显示。`maxConcurrentOperationCount`在这里由于这个教程的缘故被设置成1，是为了让你看到操作一个接一个完成。你可以离开这一部分允许队列决定他一次处理多少个操作--这样会进一步改善性能。\n\n队列是怎样决定一次运行多少个操作的呢？这是一个非常好的问题！ :] 这取决于硬件。默认，`NSOperationQueue`将要处理一写计算在屏幕背后，决定什么是最好的需要看代码是运行在某个具体的平台，和将载入的最大数量的线程数。\n\n考虑到下面的例子，假设系统此时是空闲的，这里有很多资源可用，所以这个队列能够载入可能8条并发的线程。下一个时刻你运行程序，系统可能忙于其他不相关的正在抢夺资源的操作，这时队列就仅仅载入2个并发的线程。因为你已经设置了一个最大并发操作数，在这个app中一次只会进行一个操作。\n\n> 注意：你可能想知道为什么你必须跟踪所有的激活的和正在进行中操作。队列有一个`operations`的方法，它将返回一个操作的数组，所有为什么不用它呢？在这个工程中这样做效果不是很好。你需要跟踪更表视图行数关联的操作，它可能会重复执行数组每次你需要一个的时候。把它们储存在一个字典中用index path来作为他的key方便快速和高效的查找。\n\n是时候考虑下载和过滤操作了。添加下列代码到` PhotoOperations.swift:`文件的末尾：\n\n```swift\nclass ImageDownloader: NSOperation {\n  //1\n  let photoRecord: PhotoRecord\n\n  //2\n  init(photoRecord: PhotoRecord) {\n    self.photoRecord = photoRecord\n  }\n\n  //3\n  override func main() {\n    //4\n    if self.cancelled {\n      return\n    }\n    //5\n    let imageData = NSData(contentsOfURL:self.photoRecord.url)\n\n    //6\n    if self.cancelled {\n      return\n    }\n\n    //7\n    if imageData?.length > 0 {\n      self.photoRecord.image = UIImage(data:imageData!)\n      self.photoRecord.state = .Downloaded\n    }\n    else\n    {\n      self.photoRecord.state = .Failed\n      self.photoRecord.image = UIImage(named: \"Failed\")\n    }\n  }\n}\n```\n\n`NSOperation`是一个抽象类，为它的子类而设计。每个子类代表了一个特别的`任务`正如呈现在列表早期那样。\n\n下面是上面代码每行注释到底发生了什么的说明：\n\n1. 添加一个常量引用到和操作相关的`PhotoRecord`对象\n2. 创建一个设计初始化方法允许`photo record`参数可以被传进来\n3. `main`是你在`NSOperation`子类中需要重写的方法，用来执行相关工作\n4. 在启动开始前检查是否被取消，操作应该定期检查是否已经被取消在尝试长时间或密集的工作之前\n5. 下载图片数据\n6. 再次检查是否被取消\n7. 假如这里有数据，创建一个图片对象然后把它添加到记录中，同时改变它的状态，假如这里没有数据，把这条记录标记成失败然后设置适当的图片\n\n下一步，你将创建另一个操作来处理图片加滤镜的操作！添加下面的代码到`PhotoOperations.swift`文件末尾：\n\n```swift\nclass ImageFiltration: NSOperation {\n  let photoRecord: PhotoRecord\n\n  init(photoRecord: PhotoRecord) {\n    self.photoRecord = photoRecord\n  }\n\n  override func main () {\n    if self.cancelled {\n      return\n    }\n\n    if self.photoRecord.state != .Downloaded {\n      return\n    }\n\n    if let filteredImage = self.applySepiaFilter(self.photoRecord.image!) {\n      self.photoRecord.image = filteredImage\n      self.photoRecord.state = .Filtered\n    }\n  }\n}\n```\n\n除了你对图片应用滤镜（使用一个未实现的方法，因此编译1错误）而不是下载它之外，这个看起来和下载操作非常相像。\n\n添加遗失的图片滤镜处理方法到`ImageFiltration`类中:\n\n\n```swift\n(image:UIImage) -> UIImage? {\n  let inputImage = CIImage(data:UIImagePNGRepresentation(image))\n\n  if self.cancelled {\n    return nil\n  }\n  let context = CIContext(options:nil)\n  let filter = CIFilter(name:\"CISepiaTone\")\n  filter.setValue(inputImage, forKey: kCIInputImageKey)\n  filter.setValue(0.8, forKey: \"inputIntensity\")\n  let outputImage = filter.outputImage\n\n  if self.cancelled {\n    return nil\n  }\n\n  let outImage = context.createCGImage(outputImage, fromRect: outputImage.extent())\n  let returnImage = UIImage(CGImage: outImage)\n  return returnImage\n}\n```\n\n图片添加滤镜操作使用先前`ListViewController`中相同的实现。已经把它移动到这里来了以至于它它能在后台的一个单独的操作中完成。再次强调，你应该非常频繁的检查取消操作；最佳实践是在进行任何耗时操作调用之前和之后。一旦加滤镜操作完成，你应该立即设置photo record 实例的值。\n\n很棒！现在你已经有了所有的工具和基础为了处理后台任务进程的操作。是时候回到控制器修改它以便能利用所有这些新的福利。\n\n切换到`ListViewController.swift`文件，然后删除`lazy var photos`接口声明。添加下面声明：\n\n```swift\nvar photos = [PhotoRecord]()\nlet pendingOperations = PendingOperations()\n```\n\n这些将持有一个数组的你在开始创建的`PhotoDetails`对象，`PendingOperations`对象来管理操作。\n\n添加一个下载`photos property`列表新的方法到类中：\n\n```swift\nfunc fetchPhotoDetails() {\n  let request = NSURLRequest(URL:dataSourceURL!)\n  UIApplication.sharedApplication().networkActivityIndicatorVisible = true\n\n  NSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue.mainQueue()) {response,data,error in\n    if data != nil {\n      let datasourceDictionary = NSPropertyListSerialization.propertyListWithData(data, options: Int(NSPropertyListMutabilityOptions.Immutable.rawValue), format: nil, error: nil) as! NSDictionary\n\n      for(key : AnyObject,value : AnyObject) in datasourceDictionary {\n        let name = key as? String\n        let url = NSURL(string:value as? String ?? \"\")\n        if name != nil && url != nil {\n          let photoRecord = PhotoRecord(name:name!, url:url!)\n          self.photos.append(photoRecord)\n        }\n      }\n\n      self.tableView.reloadData()\n    }\n\n    if error != nil {\n      let alert = UIAlertView(title:\"Oops!\",message:error.localizedDescription, delegate:nil, cancelButtonTitle:\"OK\")\n      alert.show()\n    }\n    UIApplication.sharedApplication().networkActivityIndicatorVisible = false\n  }\n}\n```\n\n这个方法创建一个异步的网络请求，当完成的时候，将执行`completion block`在主线程。当下载完成property list的数据被萃取成一个`NSDictionary`,然后再次处理一个数组的`PhotoRecord`的对象。你不能直接使用这里的`NSOperation`,你应该在主线程中接入它使用`NSOperationQueue.mainQueue()`。\n\n在`viewDidLoad`调用新方法\n> fetchPhotoDetails()\n\n下一步找到` tableView(_:cellForRowAtIndexPath:)`然后替换它用下面的实现：\n\n```swift\noverride func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {\n  let cell = tableView.dequeueReusableCellWithIdentifier(\"CellIdentifier\", forIndexPath: indexPath) as! UITableViewCell\n\n  //1\n  if cell.accessoryView == nil {\n    let indicator = UIActivityIndicatorView(activityIndicatorStyle: .Gray)\n    cell.accessoryView = indicator\n  }\n  let indicator = cell.accessoryView as! UIActivityIndicatorView\n\n  //2\n  let photoDetails = photos[indexPath.row]\n\n  //3\n  cell.textLabel?.text = photoDetails.name\n  cell.imageView?.image = photoDetails.image\n\n  //4\n  switch (photoDetails.state){\n  case .Filtered:\n    indicator.stopAnimating()\n  case .Failed:\n    indicator.stopAnimating()\n    cell.textLabel?.text = \"Failed to load\"\n  case .New, .Downloaded:\n    indicator.startAnimating()\n    self.startOperationsForPhotoRecord(photoDetails,indexPath:indexPath)\n  }\n\n  return cell\n}\n```\n\n花点时间来通读注释区域下面的解释：\n\n1. 为了给用户提供反馈，创建`UIActivityIndicatorView`让后把它设成cell的accessory view。\n2. 数据源包含`PhotoRecord`实例。抓取正确的数据基于当前行的`indexPath`。\n3. cell的文本标签总是一样的，图片被正确的设置在`PhotoRecord`中当它被处理的时候，以便你能够设置他们两者，而不管记录的状态。\n4. 检查记录，正确的设置activity indicator和文本，然后开始操作（暂时还没实现）\n\n你可以移除`applySepiaFilter`的实现，因为那个将不再被调用了，添加下面的方法到类中来开始操作：\n\n```swift\nfunc startOperationsForPhotoRecord(photoDetails: PhotoRecord, indexPath: NSIndexPath){\n  switch (photoDetails.state) {\n  case .New:\n    startDownloadForRecord(photoDetails, indexPath: indexPath)\n  case .Downloaded:\n    startFiltrationForRecord(photoDetails, indexPath: indexPath)\n  default:\n    NSLog(\"do nothing\")\n  }\n}\n```\n\n这里，你将传递一个`PhotoRecord`类型的实例带有它的`index path`。\n依据`photo record`的状态，你选开始进行下载还是加滤镜的步骤。\n\n> 注意：下载图片和给图片加滤镜的方法分开实现，因为这里有可能出现当一个图片正在被下载，用户可能把它滚开了，这样你就不必对它应用滤镜操作。当下一次用户又来到相同的哪行时，你不必重新下载图片；你只需对它应用\n图片滤镜即可！ Efficiency rocks! :]\n\n现在你需要实现你在上面调用的方法。记住你创建的自定义的类，`PendingOperations`,保持跟踪操作；现在实际上你可以使用它了！添加下面的方法到类中：\n\n```swift\nfunc startDownloadForRecord(photoDetails: PhotoRecord, indexPath: NSIndexPath){\n  //1\n  if let downloadOperation = pendingOperations.downloadsInProgress[indexPath] {\n    return\n  }\n\n  //2\n  let downloader = ImageDownloader(photoRecord: photoDetails)\n  //3\n  downloader.completionBlock = {\n    if downloader.cancelled {\n      return\n    }\n    dispatch_async(dispatch_get_main_queue(), {\n      self.pendingOperations.downloadsInProgress.removeValueForKey(indexPath)\n      self.tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .Fade)\n    })\n  }\n  //4\n  pendingOperations.downloadsInProgress[indexPath] = downloader\n  //5\n  pendingOperations.downloadQueue.addOperation(downloader)\n}\n\nfunc startFiltrationForRecord(photoDetails: PhotoRecord, indexPath: NSIndexPath){\n  if let filterOperation = pendingOperations.filtrationsInProgress[indexPath]{\n    return\n  }\n\n  let filterer = ImageFiltration(photoRecord: photoDetails)\n  filterer.completionBlock = {\n    if filterer.cancelled {\n      return\n    }\n    dispatch_async(dispatch_get_main_queue(), {\n      self.pendingOperations.filtrationsInProgress.removeValueForKey(indexPath)\n      self.tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .Fade)\n      })\n  }\n  pendingOperations.filtrationsInProgress[indexPath] = filterer\n  pendingOperations.filtrationQueue.addOperation(filterer)\n}\n```\n\nOkey!下面是一个快速列表来帮助你立即上面的代码到底做了什么：\n\n1. 首先，检查特定的`indexPath`来看这里是否已经有一个操作在`downloadsInProgress`中。假如有，忽略它。\n2. 假如没有，通过`designated initializer`创建一个`ImageDownloader`实例\n3. 添加一个当操作完成时执行的完成block。这是最好的地方让你其余的应用知道一个操作已经完成。注意完成block必须被执行即使这个操作被取消，这相当的重要，所以你需要使用GCD来触发重新载入表视图在主线程。\n4. 添加操作到`downloadsInProgress`中来保持跟踪一些事情。\n5. 添加操作到下载队列中。这是你实际获取这些操作开始运行的方法--队列需要注意的是一旦你添加了操作它就会执行。\n\n过滤图片的方法遵循下面相同的类型，除了它使用`ImageFiltration`和`filtrationsInProgress`来跟踪操作。作为经验，你应该尝试不要重复这个区域的代码 :]\n\n你做到了！你的工程完成了。构建让后运行看有什么改进在操作上！当你滚动表视图的时候，app并没有停止，还是像它们变得可见一样继续下载图片和给图片加滤镜操作。\n\n![classicphotos-stalled-screenshot](http://ww2.sinaimg.cn/mw690/64124373gw1ezkc6fh23sj205x08wdga.jpg)\n\n*原来的图片，现在可以滚动了*\n\n是不是很酷？你能看到随做你的进步让你的应用更易于响应能做出的努力 --对用户来说更有趣！\n\n### 细微的调整\n\n你已经随着这个教程走过漫长的路！你的小项目现在反应灵敏表明了在原来的版本基础上有很多改进。然而，这里任然有一些遗留的细节我们需要考虑。你是想成为一名伟大的程序员，而不仅仅是一名优秀的程序员！\n\n你可能已经注意到了当你滚动表视图时，那些离屏的cell仍然在处理下载和给图片加滤镜的操作。假如你快速滚动，app将忙于下载和给图片处理滤镜的操作，在列表中从最前面甚至到不可见的地方。理想的情况下app应该对离开屏幕的cells就是现在不可见的取消滤镜操作。\n\n难道你没有把取消的规定放进你的代码里？ 是的，你做了--现在你应该充分利用它们！:]\n\n回到Xcode，让后打开`ListViewController.swift`文件。去到`tableView(_:cellForRowAtIndexPath:)`方法的实现，封装`startOperationsForPhotoRecord`调用在一个if条件向下面的：\n\n```swift\nif (!tableView.dragging && !tableView.decelerating) {\n  self.startOperationsForPhotoRecord(photoDetails, indexPath: indexPath)\n}\n```\n你需要告诉表视图开始操作仅仅当表视图没有滚动的时候。这实际上是`UIScrollView`的接口，由于`UITableView`是`UIScrollView`的子类，你自动继承了这些接口。\n\n下一步，添加到下面`UIScrollView`代理方法的实现到类中：\n\n```swift\noverride func scrollViewWillBeginDragging(scrollView: UIScrollView) {\n  //1\n  suspendAllOperations()\n}\n\noverride func scrollViewDidEndDragging(scrollView: UIScrollView, willDecelerate decelerate: Bool) {\n  // 2\n  if !decelerate {\n    loadImagesForOnscreenCells()\n    resumeAllOperations()\n  }\n}\n\noverride func scrollViewDidEndDecelerating(scrollView: UIScrollView) {\n  // 3\n  loadImagesForOnscreenCells()\n  resumeAllOperations()\n}\n```\n\n快速走查上面的代码显示在下面：\n\n1. 当用户开始滚动，你想暂停所有的操作让后看看用户想看到什么。你将要实现`suspendAllOperations`在一会儿工夫。\n2. 假如`decelerate`的值是`false`,那就意味着停止拖拽表视图，因此你想恢复暂停的，因为cell离开屏幕取消的操作，启动在屏幕内cells的操作。你将要一起实现`loadImagesForOnscreenCells`和`resumeAllOperations`。\n3. 代理方法告诉你表视图已经停止滚动，所以你将做和#2条相同的处理。\n\n现在，添加下面这些遗失的方法的实现到`ListViewController.swift`:\n\n```swift\nfunc suspendAllOperations () {\n  pendingOperations.downloadQueue.suspended = true\n  pendingOperations.filtrationQueue.suspended = true\n}\n\nfunc resumeAllOperations () {\n  pendingOperations.downloadQueue.suspended = false\n  pendingOperations.filtrationQueue.suspended = false\n}\n\nfunc loadImagesForOnscreenCells () {\n  //1\n  if let pathsArray = tableView.indexPathsForVisibleRows() {\n    //2\n    var allPendingOperations = Set(pendingOperations.downloadsInProgress.keys.array)\n    allPendingOperations.unionInPlace(pendingOperations.filtrationsInProgress.keys.array)\n\n    //3\n    var toBeCancelled = allPendingOperations\n    let visiblePaths = Set(pathsArray as! [NSIndexPath])\n    toBeCancelled.subtractInPlace(visiblePaths)\n\n    //4\n    var toBeStarted = visiblePaths\n    toBeStarted.subtractInPlace(allPendingOperations)\n\n    // 5\n    for indexPath in toBeCancelled {\n      if let pendingDownload = pendingOperations.downloadsInProgress[indexPath] {\n        pendingDownload.cancel()\n      }\n      pendingOperations.downloadsInProgress.removeValueForKey(indexPath)\n      if let pendingFiltration = pendingOperations.filtrationsInProgress[indexPath] {\n        pendingFiltration.cancel()\n      }\n      pendingOperations.filtrationsInProgress.removeValueForKey(indexPath)\n    }\n\n    // 6\n    for indexPath in toBeStarted {\n      let indexPath = indexPath as NSIndexPath\n      let recordToProcess = self.photos[indexPath.row]\n      startOperationsForPhotoRecord(recordToProcess, indexPath: indexPath)\n    }\n  }\n}\n```\n\n`suspendAllOperations`和`resumeAllOperations`有一个简单的实现。`NSOperationQueues`能够被暂停，通过设置`suspended`接口为`true`。这将暂停队列里面的所有操作--你不能单独暂停一个操作。\n\n`loadImagesForOnscreenCells`有一点小复杂。这里发生了什么事？\n\n1. 以一个包含了现在表视图可见的`index paths`的数组开始开始\n2. 构造一个所有进行中的操作的集合通过结合所有在下载的进度+所有在处理滤镜的进度。\n3. 构造一个`index paths`集合用来取消操作。开始所有的操作，然后移除可见行的`index paths`，这样讲留下一个离开屏幕的行正在执行的操作集合\n4. 构造一个`index paths`集合，需要操作启动，用所有可见行的`index paths`启动，让后移除它们中在进行的操作。\n5. 遍历那些被取消的操作，取消它们，然后移除它们的引用从`PendingOperations`。\n6. 遍历那些将要开始的操作，然后对他们每个调用`startOperationsForPhotoRecord`。\n\n\n构建运行然后你发现一个更流畅，资源管理德更好的应用！给你自己一轮掌声！\n\n![improved app](http://ww2.sinaimg.cn/mw690/64124373gw1ezkdl5q55nj20jg09qq4h.jpg)\n\n*原来的相册，载入东西一次一个*\n\n注意到当你完成滚动表视图，在可见区域行的cell的图片立即开始处理。\n\n### 何去何从？\n这里是[completed version of the project](http://cdn2.raywenderlich.com/wp-content/uploads/2014/10/ClassicPhotos-Final63.zip)。\n\n> 注意：此教程写于`Update 17 April 2015: Updated for Xcode 6.3 and Swift 1.2`,现在Swift最新版本2.1使用Xcode7+以上编辑会报错，这里打包一个新语法修改版[completed fixed version of the project](https://github.com/wangruofeng/ClassicPhotos-Starter-fixed/archive/master.zip)。\n>\n>\n\n假如你完成这个工程应该花时间来真正理解它，恭喜你！你可以认为你自己是一位更有价值iOS开发者了比起在教程刚开始的时候！大多数开发的公司是非常幸运的有一个或者两个人正在知道这个东西。\n\n当时请当心 -- 像多层嵌套的blocks,不必要的使用多线程可能让一个工程变得难以理解对维护你代码的人来说。线程可能引入一些难以捉摸的bugs，将永远不出现知道你网络非常慢，或者代码运行在一个更快（或更慢）的设备上，或一个不同数量的核的芯片上时。小心测试，尽量使用`Instruments`（或者你自己的观察）来确定引入多线程真的有很大改进。\n\n一个有用的特征使用操作时在这里没涉及到就是依赖（`dependency`）。你可以给一个操作添加一个或者更多的操作的依赖。这个操作不会开始直到它所有依赖的操作完成时。例如：\n\n```swift\n// MyDownloadOperation is a subclass of NSOperation\nlet downloadOperation = MyDownloadOperation()\n// MyFilterOperation  is a subclass of NSOperation\nlet filterOperation = MyFilterOperation()\n\nfilterOperation.addDependency(downloadOperation)\n```\n\n移除依赖：\n\n```swift\nfilterOperation.removeDependency(downloadOperation)\n```\n\n这个工程是否能使用依赖简化呢？把你学到的新技能用起来试一试 ：]\n有件非常重要的事需要注意的就是一个依赖操作将仍然启动假如它依赖的操作被取消，还有它将自然完成。你需要牢记在心。\n\n假如你有任何评论或者问题关于这个教程或者`NSOperations`,请加[Pull request](https://github.com/wangruofeng/Github_Blog/pulls)。\n\n\n\n\n\n译者注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["翻译","NSOperation"],"categories":["多线程"]},{"title":"多线程之 NSOperation","url":"/2016/01/13/2016-01-13-duo-xian-cheng-zhi-nsoperation/","content":"\n**本文目录**\n\n* 前言\n* NSInvocationOperation\n* NSBlokcOperation\n* NSOperation的其他用法\n* 自定义NSOperation\n* 参考资料\n\n## 前言\n1.虽然`NSThread`也可以实现多线程编程，但是需要我们去管理线程的生命周期，还要考虑线程同步、加锁问题，造成一些性能上的开销。我们也可以配合使用`NSOperation`和`NSOperationQueue`实现多线程编程，实现步骤大致是这样的\n\n* 先将需要执行的操作封装到一个NSOperation对象中\n* 然后将NSOperation对象添加到NSOperationQueue中\n* 系统会自动将`NSOperation`中封装的操作放到一条新线程中执行在此过程中，我们根本不用考虑线程的生命周期、同步、加锁等问题下面列举一个应用场景，比如微博的粉丝列表：\n\n![微博的粉丝列表](/images/common/weibo_fancy.png)\n\n每一行的头像肯定要从新浪服务器下载图片后才能显示的，而且是需要异步下载。这时候你就可以把每一行的图片下载操作封装到一个`NSOperation`对象中，上面有6行，所以要创建6个`NSOperation`对象，然后添加到`NSOperationQueue`中，分别下载不同的图片，下载完毕后，回到对应的行将图片显示出来。\n\n2 .默认情况下，`NSOperation`并不具备封装操作的能力，必须使用它的子类，使用NSOperation子类的方式有3种：\n\n* NSInvocationOperation\n* NSBlockOperation\n* 自定义子类继承NSOperation，实现内部相应的方法\n\n这讲先介绍如何用`NSOperation`封装一个操作，后面再结合`NSOperationQueue`来使用。\n\n## NSInvocationOperation\n\n```objc\nNSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run:) object:@\"mj\"];\n[operation start];\n```\n\n*  第1行初始化了一个`NSInvocationOperation`对象，它是基于一个对象和selector来创建操作\n* 第2行调用了start方法，紧接着会马上执行封装好的操作，也就是会调用self的run:方法，并且将@\"mj\"作为方法参数\n* 这里要注意：默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作。只有将operation放到一个NSOperationQueue中，才会异步执行操作。\n\n## NSBlockOperation\n\n### a.同步执行一个操作\n\n```objc\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^(){\n         NSLog(@\"执行了一个新的操作\");\n }];\n  // 开始执行任务\n[operation start];\n```\n\n*  第1行初始化了一个NSBlockOperation对象，它是用一个Block来封装需要执行的操作\n* 第2行调用了start方法，紧接着会马上执行Block中的内容\n* 这里还是在当前线程同步执行操作，并没有异步执行\n\n### b.并发执行多个操作\n\n```objc\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^(){\n　　NSLog(@\"执行第1次操作，线程：%@\", [NSThread currentThread]);\n}];\n\n[operation addExecutionBlock:^() {\n　　NSLog(@\"又执行了1个新的操作，线程：%@\", [NSThread currentThread]);\n}];\n\n[operation addExecutionBlock:^() {\n　　NSLog(@\"又执行了1个新的操作，线程：%@\", [NSThread currentThread]);\n}];\n\n[operation addExecutionBlock:^() {\n　　NSLog(@\"又执行了1个新的操作，线程：%@\", [NSThread currentThread]);\n}];\n\n// 开始执行任务\n[operation start];\n```\n\n* 第1行初始化了一个NSBlockOperation对象\n* 分别在第5、9、13行通过addExecutionBlock:方法添加了新的操作，包括第1行的操作，一共封装了4个操作\n* 在第18行调用start方法后，就会并发地执行这4个操作，也就是会在不同线程中执行\n\n\t\t1 2013-02-02 21:38:46.102 thread[4602:c07] 又执行了1个新的操作，线程：<NSThread: 0x7121d50>{name = (null), num = 1}\n\t\t2 2013-02-02 21:38:46.102 thread[4602:3f03] 又执行了1个新的操作，线程：<NSThread: 0x742e1d0>{name = (null), num = 5}\n\t\t3 2013-02-02 21:38:46.102 thread[4602:1b03] 执行第1次操作，线程：<NSThread: 0x742de50>{name = (null), num = 3}\n\t\t4 2013-02-02 21:38:46.102 thread[4602:1303] 又执行了1个新的操作，线程：<NSThread: 0x7157bf0>{name = (null), num = 4}\n\n可以看出，每个操作所在线程的num值都不一样，说明是不同线程\n\n## NSOperation的其他用法\n### a.取消操作\noperation开始执行之后, 默认会一直执行操作直到完成，我们也可以调用cancel方法中途取消操作\n\n\t[operation cancel];\n\n### b.在操作完成后做一些事情\n如果想在一个NSOperation执行完毕后做一些事情，就调用NSOperation的setCompletionBlock方法来设置想做的事情\n\n\toperation.completionBlock = ^() {\n\t    NSLog(@\"执行完毕\");\n\t};\n当operation封装的操作执行完毕后，就会回调Block里面的内容\n\n## 自定义NSOperation\n\n如果`NSInvocationOperation`和`NSBlockOperation`不能满足需求，我们可以直接新建子类继承NSOperation，并添加任何需要执行的操作。如果只是简单地自定义NSOperation，只需要重载`-(void)main`这个方法，在这个方法里面添加需要执行的操作。\n\n下面写个子类DownloadOperation来下载图片\n### a.继承NSOperation，重写main方法\n\n*DownloadOperation.h*\n\n```objc\n#import <Foundation/Foundation.h>\n@protocol DownloadOperationDelegate;\n\n@interface DownloadOperation : NSOperation\n// 图片的url路径\n@property (nonatomic, copy) NSString *imageUrl;\n// 代理\n@property (nonatomic, assign) id<DownloadOperationDelegate> delegate;\n\n- (id)initWithUrl:(NSString *)url delegate:(id<DownloadOperationDelegate>)delegate;\n@end\n\n// 图片下载的协议\n@protocol DownloadOperationDelegate <NSObject>\n- (void)downloadFinishWithImage:(UIImage *)image;\n@end\n```\n\n*DownloadOperation.m*\n\n```objc\n#import \"DownloadOperation.h\"\n\n@implementation DownloadOperation\n@synthesize delegate = _delegate;\n@synthesize imageUrl = _imageUrl;\n\n// 初始化\n- (id)initWithUrl:(NSString *)url delegate:(id<DownloadOperationDelegate>)delegate {\n    if (self = [super init]) {\n        self.imageUrl = url;\n        self.delegate = delegate;\n    }\n    return self;\n}\n// 释放内存\n- (void)dealloc {\n    [super dealloc];\n    [_imageUrl release];\n}\n\n// 执行主任务\n- (void)main {\n    // 新建一个自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池\n    @autoreleasepool {\n        // ....\n    }\n}\n@end\n```\n\n* 在第22行重载了main方法，等会就把下载图片的代码写到这个方法中\n* 如果这个DownloadOperation是在异步线程中执行操作，也就是说main方法在异步线程调用，那么将无法访问主线程的自动释放池，所以在第24行创建了一个属于当前线程的自动释放池\n\n### b.正确响应取消事件\n* 默认情况下，一个NSOperation开始执行之后，会一直执行任务到结束，就比如上面的DownloadOperation，默认会执行完main方法中的所有代码\n* NSOperation提供了一个cancel方法，可以取消当前的操作。\n* 如果是自定义NSOperation的话，需要手动处理这个取消事件。比如，一旦调用了cancel方法，应该马上终止main方法的执行，并及时回收一些资源。\n* 处理取消事件的具体做法是：在`main`方法中定期地调用`isCancelled`方法检测操作是否已经被取消，也就是说是否调用了`cancel`方法，如果返回YES，表示已取消，则立即让main方法返回。\n* 以下地方可能需要调用`isCancelled`方法:\n\t1. 在执行任何实际的工作之前，也就是在main方法的开头。因为取消可能发生在任何时候，甚至在operation执行之前。\n\t2. 执行了一段耗时的操作之后也需要检测操作是否已经被取消\n\n```objc\n- (void)main {\n    // 新建一个自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池\n    @autoreleasepool {\n        if (self.isCancelled) return;\n\n        // 获取图片数据\n        NSURL *url = [NSURL URLWithString:self.imageUrl];\n        NSData *imageData = [NSData dataWithContentsOfURL:url];\n\n        if (self.isCancelled) {\n            url = nil;\n            imageData = nil;\n            return;\n        }\n\n        // 初始化图片\n        UIImage *image = [UIImage imageWithData:imageData];\n\n        if (self.isCancelled) {\n            image = nil;\n            return;\n        }\n\n        if ([self.delegate respondsToSelector:@selector(downloadFinishWithImage:)]) {\n            // 把图片数据传回到主线程\n            [(NSObject *)self.delegate performSelectorOnMainThread:@selector(downloadFinishWithImage:) withObject:image waitUntilDone:NO];\n        }\n    }\n}\n```\n\n* 在第4行main方法的开头就先判断operation有没有被取消。如果被取消了，那就没有必要往下执行了\n* 经过第8行下载图片后，在第10行也需要判断操作有没有被取消\n* 总之，执行了一段比较耗时的操作之后，都需要判断操作有没有被取消\n* 图片下载完毕后，在第26行将图片数据传递给了代理(delegate)对象\n\n## 参考资料\n\n* NSHipster 的[NSOperation](http://nshipster.com/nsoperation/)\n* 雷纯锋的博客的[《iOS 并发编程之 Operation Queues》](http://www.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/)\n* objc的并发编程指南[《Concurrent Programming》](http://www.objc.io/issue-2/)\n* [StackOverflow: NSOperation vs. Grand Central Dispatch](http://stackoverflow.com/questions/10373331/nsoperation-vs-grand-central-dispatch)\n* [Blog: When to use NSOperation vs. GCD](http://eschatologist.net/blog/?p=232)\n\n\n备注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["NSOperation"],"categories":["多线程"]},{"title":"iOS 中的触摸事件和手势处理","url":"/2016/01/13/2016-01-13-ioszhong-de-hong-mo-shi-jian-he-shou-shi-chu-li/","content":"\n### iOS 触摸事件分类\n* 触摸事件\n* 加速事件\n* 远程事件\n\n### 谁能处理触摸事件?\n响应者对象\n\n在 iOS 中不是任何对象都能处理事件,只有继承了 `UIResponder` 的对象才能接收并处理事件.我们称之为响应者对象.\n\n`UIApplication`、`UIViewController`、`UIView` 都继承自 `UIResponder`,因此它们都是响应者对象,都能够接收并处理事件.\n\n### UIResponder\nUIResponder 内部提供了方法来处理事件\n\n1. 触摸事件\n\n    一次完成的触摸过程,会经历 3 个状态, UIView 的触摸事件处理\n    * 一根或多根手指开始触摸 view,系统会自动调用 view 下面的方法:\n        ```objc\n        - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;  //触摸开始\n        ```\n    * 一根或者多根手指在 view 上移动，系统会自动调用 view 下面的方法（随着手指的移动，会持续调用该方法）\n        ```objc\n        - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;  //触摸移动\n        ```\n    * 一根或者多根手指离开 view，系统会自动调用 view 下面的方法\n        ```objc\n        - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;  //触摸结束\n        ```\n    * 触摸结束前，某个系统事件（例如电话呼入   ）会打断触摸过程，系统会自动调用 view 下面的方法\n        ```objc\n        - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; //触摸取消(可能会经历)\n        ```\n\n    4 个触摸事件的处理方法中，都有 NSSet *touches 和 UIEvent *event 两个参数:\n    * 一次完整的触摸过程，只会产生一个事件对象，4 个触摸方法都是同一个 event 参数\n    * 如果两根手指同时触摸一个 view，那么 view 只会调用一次 touchesBegan:withEvent: 方法，touches 参数中装着两个 UITouch 对象；\n    * 如果这两根手指一前一后分开触摸同一个 view，那么 view 会分别调用两次 touchesBegan:withEvent:方法， 并且每次调用时的 touches 参数只包含一个 UITouch 对象；\n    * 根据 touches 中 UITouch 个数可以判断出使单点触摸还是多点触摸\n\n    提示：touches 中存放的都是 UITouch 对象。\n\n\n2. 加速计事件\n    ```objc\n    - (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;    \n    - (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;    \n    - (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;\n    ```\n\n3. 远程控制事件\n    ```objc\n        - (void)remoteControlReceivedWithEvent:(UIEvent *)event;\n    ```\n\n### UITouch\n当用户用一根手指触摸屏幕时，会创建一个与手指相关联的 UITouch 对象；一根手指对应一个 UITouch 对象\nUITouch 的作用:\n\n* 保存跟手指相关的信息，比如触摸的位置、时间、阶段；\n* 当手指移动时，系统会更新同一个 UITouch 对象，使之能够一直保存该手指的触摸位置；\n* 当手指离开屏幕时，系统会销毁相应的 UITouch 对象。\n\n提示：iPhone 开发中，要避免使用双击事件。\n\nUITouch 的属性:\n触摸产生时所处的窗口:\n\n```objc\n@property(nonatomic,readonly,retain) UIWindow *window;\n```\n\n触摸产生时所处的视图\n\n```objc\n@property(nonatomic,readonly,retain) UIView *view;\n```\n\n短时间内点按屏幕的次数，可以根据 tapCount 判断单击、双击或更多地点击\n\n```objc\n@property(nonatomic,readonly) NSUInteger tapCount;\n```\n\n记录了触摸事件产生或变化时的时间，单位是秒\n\n```objc\n@property(nonatomic,readonly) NSTimeInterval timestamp;\n```\n\n当前触摸事件所处的状态\n\n```objc\n/*\nUITouchPhase 是一个枚举类型，包含：\nUITouchPhaseBegan（触摸开始）\nUITouchPhaseMoved（接触点移动）\nUITouchPhaseStationary（接触点无移动）\nUITouchPhaseEnded（触摸结束）\nUITouchPhaseCancelled（触摸取消）\n*/\n@property(nonatomic,readonly) UITouchPhase phase;\n\n```\n\nUITouch 的方法：\n\n```objc\n- (CGPoint)locationInView:(UIView *)view;\n```\n\n1.返回值表示触摸在 view 上的位置；\n2.这里返回的位置是针对 view 坐标系的,（以 view 的左上角为原点（0，0））；\n3.调用时传入的 view 参数为 nil 的话，返回的是触摸点在 UIWindow 的位置。\n\n```objc\n- (CGPoint)previousLocationInView:(UIView *)view;\n```\n\n该方法记录了前一个触摸点的位置；\n\n### UIEvent\n> 每产生一个事件，就会产生一个 UIEvent 对象；\n> UIEvent:称为事件对象，记录事件产生的时刻和类型。\n\n常见属性：\n1.事件类型\n\n```objc\n@property(nonatomic,readonly) UIEventType  type;\n@property(nonatomic,readonly) UIEventSubtype  subtype;\n\ntypedef\nNS_ENUM(NSInteger, UIEventType) {\n    UIEventTypeTouches,\n    UIEventTypeMotion,\n    UIEventTypeRemoteControl,\n};\n\ntypedef\nNS_ENUM(NSInteger, UIEventSubtype) {\n    // available in iPhone OS 3.0\n    UIEventSubtypeNone                              = 0,    // for UIEventTypeMotion, available in iPhone OS 3.0\n    UIEventSubtypeMotionShake                       = 1,\n    // for UIEventTypeRemoteControl, available in iOS 4.0\n    UIEventSubtypeRemoteControlPlay                 = 100,\n    UIEventSubtypeRemoteControlPause                = 101,\n    UIEventSubtypeRemoteControlStop                 = 102,\n    UIEventSubtypeRemoteControlTogglePlayPause      = 103,\n    UIEventSubtypeRemoteControlNextTrack            = 104,    UIEventSubtypeRemoteControlPreviousTrack        = 105,\n    UIEventSubtypeRemoteControlBeginSeekingBackward = 106,    UIEventSubtypeRemoteControlEndSeekingBackward   = 107,    UIEventSubtypeRemoteControlBeginSeekingForward  = 108,    UIEventSubtypeRemoteControlEndSeekingForward    = 109,\n};\n```\n\n2.事件产生的时间\n\n```objc\n@property(nonatomic,readonly) NSTimeInterval  timestamp;\n```\n\n UIEvent 还提供了相应的方法可以获得在某个 view 上面的触摸对象（UITouch）。\n\n 触摸事件的产生：\n 1. 发生触摸事件后，系统会将该事件加入到一个由 UIApplication 管理的事件队列中；\n 2. UIApplication 会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）；\n 3. 主窗口会在视图层次结构中找到一个最合适的视图控件来处理触摸事件，这也是整个事件处理过程的第一步；\n 4. 找到合适的视图控件后，就会调用视图控件的 touches 方法来做具体的事件处理。\n\n触摸事件的传递：\n> 触摸事件的传递是从父控件传递到子控件；\n> 如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件。\n![触摸事件](http://ww4.sinaimg.cn/mw690/64124373gw1eznrp087anj205t07rdfx.jpg)\n![触摸事件2](http://ww2.sinaimg.cn/mw690/64124373gw1eznrrf36ymj2097077dhc.jpg)\n\nUIView 不接收触摸事件的三种情况:\n不接受用户交互 ：\n1. userInteractionEnable = NO;\n2. 隐藏 ：hidden = YES;\n3. 透明：alpha = 0.0 ~ 0.01\n\n提示：UIImageView 的 userInteractionEnable 默认就是 NO，因此 UIImageView 以及它的子控件默认是不能接收触摸事件的。\n\n触摸事件处理的详细过程：\n1. 用户点击屏幕后产生的一个触摸事件，经过一些列的传递过程后，会找到最合适的视图控件来处理这个事件\n2. 找到最合适的视图控件后，就会调用控件的 touches 方法来作具体的事件处理\n    touchesBegan…\n    touchesMoved…\n    touchedEnded…\n\n这些 touches 方法的默认做法是将事件顺着响应者链条向上传递，将事件交给上一个响应者进行处理\n\n响应者链的事件传递过程：\n 1. 如果 view 的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图；\n 2. 在视图层次结构最顶级的视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给 window 对象进行处理。\n 3. 如果 window 对象也不处理，则其将事件或消息传递给 UIApplication 对象；\n 4. 如果 UIApplication 也不能处理该事件或消息，则将其丢弃\n\n### 监听触摸事件的做法\n\n如果想监听一个 view 上面的触摸事件，之前的做法是：\n\n1. 自定义一个 view；\n2. 实现 view 的 touches 方法，在方法内部实现具体处理代码。\n    通过 touches 方法监听 view 触摸事件，有很明显的几个缺点：\n    * 必须得自定义 view；\n    * 由于是在 view 内部的 touches 方法中监听触摸事件，因此默认情况下，无法让其他外界对象监听 view 的触摸事件；\n    * 不容易区分用户的具体手势行为。\n\niOS 3.2 之后，苹果推出了手势识别功能（Gesture Recognizer）,在触摸事件处理方面，大大简化了开发者的开发难度。\n\n### UIGestureRescognizer\n\n为了完成手势识别，必须借助于手势识别器：UIGestureRecognizer 。\n利用 UIGestureRecognizer,能轻松识别用户在某个 view 上面做的一些常见手势。\nUIGestureRecognizer 是一个抽象类，定义了所有的手势基本行为，使用它的子类才能处理具体的手势\n\n* UITapGestureRecognizer(敲击)\n* UIPinchGestureRecognizer(捏合，用于缩放)\n* UIPanGestureRecognizer(拖拽)\n* UISwipeGestureRecognizer(轻扫)\n* UIRotationGestureRecognizer(旋转)\n* UILongPressGestureRecognizer(长按)\n\n每一个手势识别器的用法都差不多，比如 UITapGestureRecognizer 的使用步骤如下:\n\n1. 创建手势识别器对象；\n    ```objc\n    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];\n    ```\n2. 设置手势识别器对象的具体属性；\n    ```objc\n        // 连续敲击 2 次\n        tap.numberOfTapsRequired = 2;\n        // 需要 2 根手指一起敲击\n        tap.numberOfTouchesRequired = 2;\n    ```\n3. 添加手势识别器到对应的 view 上\n    ```objc\n    [self.iconView addGestureRecognizer:tap];\n    ```\n4. 监听手势的触发\n    ```objc\n    [tap addTarget:self action:@selector(tapIconView:)];\n    ```\n    \n手势识别的状态\n\n```objc\ntypedef NS_ENUM(NSInteger, UIGestureRecognizerState) {\n    // 没有触摸事件发生，所有手势识别的默认状态\n    UIGestureRecognizerStatePossible,\n    // 一个手势已经开始但尚未改变或者完成时\n    UIGestureRecognizerStateBegan,\n    // 手势状态改变\n    UIGestureRecognizerStateChanged,\n    // 手势完成\n    UIGestureRecognizerStateEnded,\n    // 手势取消，恢复至 Possible 状态\n    UIGestureRecognizerStateCancelled,\n    // 手势失败，恢复至 Possible 状态\n    UIGestureRecognizerStateFailed,\n    // 识别到手势识别\n    UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded\n};\n```\n\n备注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["事件处理"],"categories":["系统原理"]},{"title":"iOS 里程碑事件","url":"/2016/01/13/2016-01-13-iosli-cheng-bei-shi-jian/","content":"\n> 记录iOS各种重要里程碑事件\n\n\n### 私有成员变量的实现\n1.0 时代，在.h文件采用`@private`关键词\n\n```objc\n@interface ViewController : UIViewController {\n    @private\n    NSInteger _value;\n}\n```\n\n2.0 时代 通过在.m文件通过`匿名Category`\n\n```objc\n@interface ViewController ()\n\n@property (nonatomic) NSInteger value;\n\n@end\n```\n\n3.0 时代 2013 年的 WWDC 允许在 .m 的 `@implementation `中\n\n```objc\n@implementation ViewController {\n    NSInteger _value;\n}\n```\n\n\n### ARC推出\n2011\n\n### 自动生成getter和setter方法的`@synthesize`\n2012\n\n### AutoLayout引入\niOS 6.0\n\n### Swift\n\n* [WWDC](http://baike.baidu.com/view/404495.htm) 1.0 版本发布 -- 2014.06.02 \n* Swift 2.0发布   -- 2015.08.07\n* Open Source -- 2015.12.04  \n\n### Size Classes\niOS 8.0\n\n### Blocks\n[Mac OS X 10.6 \"Snow Leopard\"](https://en.wikipedia.org/wiki/Mac_OS_X_Snow_Leopard) and [iOS 4.0](https://en.wikipedia.org/wiki/IOS)\n\n### Objective-C 2.0\nAt the [2006 Worldwide Developers Conference](https://en.wikipedia.org/wiki/Apple_Worldwide_Developers_Conference) release of [Objective-C 2.0](https://en.wikipedia.org/wiki/Objective-C#Objective-C_2.0)\n\n### Watch OS\n2015.05.21\n\n### iOS API Differences\n\n#### iOS 2.1 to iOS 2.2 API Differences\n\nAdded frameworks:\n\n* AVFoundation\n\n#### iOS 2.2 to iOS 3.0 API Differences\n\nAdded frameworks:\n\n* CoreData\n* ExternalAccessory\n* GameKit\n* MapKit\n* MessageUI\n* MobileCoreServices\n* StoreKit\n\n#### iOS 3.2 to iOS 4.0 API Differences\n\nAdded frameworks:\n\n* Accelerate\n* AssetsLibrary\n* CoreMedia\n* CoreMotion\n* CoreTelephony\n* CoreVideo\n* EventKit\n* EventKitUI\n* iAd\n* ImageIO\n* QuickLook\n\n#### iOS 4.3 to iOS 5.0 API Differences\nAdded frameworks\n\n* Accounts\n* CoreBluetooth\n* CoreImage\n* GLKit\n* GSS\n* NewsstandKit\n* Twitter\n\n#### 5.1 to iOS 6.0 API Differences\nAdded frameworks\n\n* AdSupport\n* MediaToolbox\n* PassKit\n* Social\n\n#### 6.1 to iOS 7.0 API Differences\nAdded frameworks\n\n* GameController\n* JavaScriptCore\n* MediaAccessibility\n* MultipeerConnectivity\n* SafariServices\n* SpriteKit\n\n#### iOS 7.1 to iOS 8.0 API Differences\nAdded frameworks\n\n* Accelerate\n* Accounts\n* AddressBook\n* AddressBookUI\n* AudioToolbox\n* AudioUnit\n* AVFoundation\n* AVKit (Added)\n* CFNetwork\n* CloudKit (Added)\n* CoreAudio\n* CoreAudioKit (Added)\n* CoreAuthentication (Added)\n* CoreBluetooth\n* CoreData\n* CoreFoundation\n* CoreImage\n* CoreLocation\n* CoreMedia\n* CoreMotion\n* CoreText\n* CoreVideo\n* EventKit\n* EventKitUI\n* ExternalAccessory\n* Foundation\n* GameController\n* GameKit\n* GLKit\n* GSS\n* HealthKit (Added)\n* HomeKit (Added)\n* iAd\n* ImageIO\n* IOKit\n* JavaScriptCore\n* LocalAuthentication (Added)\n* MapKit\n* MediaAccessibility\n* MediaPlayer\n* MessageUI\n* Metal (Added)\n* MobileCoreServices\n* MultipeerConnectivity\n* NetworkExtension (Added)\n* NewsstandKit\n* NotificationCenter (Added)\n* OpenGLES\n* PassKit\n* Photos (Added)\n* PhotosUI (Added)\n* PushKit (Added)\n* QuartzCore\n* QuickLook\n* SceneKit (Added)\n* Security\n* Social\n* SpriteKit\n* StoreKit\n* UIKit\n* VideoToolbox\n* WebKit (Added)\n\n#### iOS 8.3 to iOS 9.0 API Differences\nAdded frameworks\n\n\nObjective-C\n\n* /usr/include\n* Accelerate\n* Accounts\n* AddressBook\n* AddressBookUI\n* AssetsLibrary\n* AudioToolbox\n* AudioUnit\n* AVFoundation\n* AVKit\n* CFNetwork\n* CloudKit\n* Contacts (Added)\n* ContactsUI (Added)\n* CoreAudio\n* CoreAudioKit\n* CoreBluetooth\n* CoreData\n* CoreFoundation\n* CoreGraphics\n* CoreImage\n* CoreLocation\n* CoreMedia\n* CoreMIDI\n* CoreMotion\n* CoreSpotlight (Added)\n* CoreTelephony\n* CoreText\n* CoreVideo\n* EventKit\n* EventKitUI\n* ExternalAccessory\n* Foundation\n* GameController\n* GameKit\n* GameplayKit (Added)\n* GLKit\n* GSS\n* HealthKit\n* HomeKit\n* iAd\n* ImageIO\n* JavaScriptCore\n* LocalAuthentication\n* MapKit\n* MediaPlayer\n* MediaToolbox\n* MessageUI\n* Metal\n* MetalKit (Added)\n* MetalPerformanceShaders (Added)\n* MobileCoreServices\n* ModelIO (Added)\n* MultipeerConnectivity\n* NetworkExtension\n* NewsstandKit\n* OpenAL\n* PassKit\n* Photos\n* PushKit\n* QuartzCore\n* QuickLook\n* ReplayKit (Added)\n* SafariServices\n* SceneKit\n* Security\n* SpriteKit\n* StoreKit\n* SystemConfiguration\n* UIKit\n* VideoToolbox\n* WatchConnectivity (Added)\n* WatchKit\n* WebKit\n\n备注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["历史事件"],"categories":["资料收集"]},{"title":"优雅处理 UIImage 图片旋转","url":"/2016/01/13/2016-01-13-you-ya-chu-li-uiimagetu-pian-xuan-zhuan/","content":"\n\n## UIImag构造方式\nUIImag构造方式大致有4种方式\n* 从本地bundle中加载 `imageNamed:`，传入一个bundle的文件名即可\n* 从本地一个文件路径读取 `imageWithContentsOfFile:`，需要传一个文件的文件路径path\n* 通过二进制数据`NSData`来创建`imageWithData:`\n* 通过一个`CoreGraphics`的`CGImageRef`来创建，`initWithCGImage:`\n* 通过一个`CoreImage`的`CIImage`来创建`initWithCIImage`\n\n通过查阅Apple官网文档我们发现有2个这样的方法，今天就来一探究竟\n\n```objc\n+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(4_0);\n+ (UIImage *)imageWithCIImage:(CIImage *)ciImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(6_0);\n\n- (instancetype)initWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(4_0);\n- (instancetype)initWithCIImage:(CIImage *)ciImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(6_0);\n```\n\n2个类方法2个实例方法都是类似，这里以`CGImageRef`为例\n\n```objc\n+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(4_0);\n```\n\n1. 新建的Xcode工程选择single Application\n2. 在storyboard中拖一个`UIImageView`设置它水平垂直居中对齐，宽带高度随便设一个值不要太大就行，设置`UIImageView`的`contentMode`为`Aspect Fit`方便查看以免变形\n3. 在`UIImageView`下发放一个`UIButton`控件方便后面好对图片进行旋转操作\n4. 在viewController中建立一个`UIImageView`引用,拉出一个rotate按钮的`IBAction`\n\n    现在大概界面大概这样\n    ![UIImageOrientation效果图](http://ww3.sinaimg.cn/mw690/64124373gw1ezhnagzyhpj20x7105doj.jpg)\n\n5. 下面我们实现\n`- (IBAction)rotateImage:(id)sender {}`这个方法\n\n    > 在这里我们想通过点击按钮实现图片旋转\n    为了方便使用我们使用Category的方式实现\n    新建一个UIImage的分类取名叫Rotate\n\n    > 这里需要传一张要处理的图片和一个待处理成的图片方向\n    >\n    ```objc\n    + (UIImage *)rotateImage:(UIImage *)oldImage\n             orientation:(UIImageOrientation)orientation;\n    ```\n\n```objc\n    + (UIImage *)rotateImage:(UIImage *)oldImage orientation:(UIImageOrientation)orientation{\n\n    UIImage *newImage = [UIImage imageWithCGImage:oldImage.CGImage scale:1 orientation:orientation];\n\n    NSString *orientationStr = nil;\n    switch (orientation) {\n        case UIImageOrientationUp: {\n            orientationStr = @\"UIImageOrientationUp\";\n            break;\n        }\n        case UIImageOrientationDown: {\n            orientationStr = @\"UIImageOrientationDown\";\n            break;\n        }\n        case UIImageOrientationLeft: {\n            orientationStr = @\"UIImageOrientationLeft\";\n            break;\n        }\n        case UIImageOrientationRight: {\n            orientationStr = @\"UIImageOrientationRight\";\n            break;\n        }\n        case UIImageOrientationUpMirrored: {\n            orientationStr = @\"UIImageOrientationUpMirrored\";\n            break;\n        }\n        case UIImageOrientationDownMirrored: {\n            orientationStr = @\"UIImageOrientationDownMirrored\";\n            break;\n        }\n        case UIImageOrientationLeftMirrored: {\n            orientationStr = @\"UIImageOrientationLeftMirrored\";\n            break;\n        }\n        case UIImageOrientationRightMirrored: {\n            orientationStr = @\"UIImageOrientationRightMirrored\";\n            break;\n        }\n\n    }\n\n    NSLog(@\"current orientation: %@\",orientationStr);\n\n    return newImage;\n}\n```\n\n在button点击事件触发时的这样使用\n\n```objc\n- (IBAction)rotateImage:(id)sender {\n\n    UIImage *oldImage = self.imgView.image;\n\n    UIImage *rotatedImage = [UIImage rotateImage:oldImage orientation:UIImageOrientationLeft];\n\n    self.imgView.image = rotatedImage;\n}\n```\n\n点击按钮测试发现第一次没问题，但是重逢点击无效\n原来`+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation`方法执行原理是执行前通过 `@property(nonatomic,readonly) UIImageOrientation imageOrientation;`接口先判断当前图片的方向是否为将要旋转的方向，如果是就直接返回不做处理，如果不是再作旋转处理，也就是说这个方法并没有实际上旋转image的数据，只是用一个枚举标记旋转的状态\n\n如果我们想每次旋转需要直接改变原始image的数据该怎么办呢？\n在这里我们通过`CGBitmapContext`,使用`CGContextRotateCTM`来设置旋转，再把UIImage通过`drawInRect`重新绘制出来，通过`UIGraphicsGetImageFromCurrentImageContext`获得处理后的图片\n\n下面是具体实现\n\n```objc\n- (UIImage *)fixedRotation{\n    if (self.imageOrientation == UIImageOrientationUp) return self;\n    CGAffineTransform transform = CGAffineTransformIdentity;\n\n    switch (self.imageOrientation) {\n        case UIImageOrientationDown:\n        case UIImageOrientationDownMirrored:\n            transform = CGAffineTransformTranslate(transform, self.size.width, self.size.height);\n            transform = CGAffineTransformRotate(transform, M_PI);\n            break;\n\n        case UIImageOrientationLeft:\n        case UIImageOrientationLeftMirrored:\n            transform = CGAffineTransformTranslate(transform, self.size.width, 0);\n            transform = CGAffineTransformRotate(transform, M_PI_2);\n            break;\n\n        case UIImageOrientationRight:\n        case UIImageOrientationRightMirrored:\n            transform = CGAffineTransformTranslate(transform, 0, self.size.height);\n            transform = CGAffineTransformRotate(transform, -M_PI_2);\n            break;\n        case UIImageOrientationUp:\n        case UIImageOrientationUpMirrored:\n            break;\n    }\n\n    switch (self.imageOrientation) {\n        case UIImageOrientationUpMirrored:\n        case UIImageOrientationDownMirrored:\n            transform = CGAffineTransformTranslate(transform, self.size.width, 0);\n            transform = CGAffineTransformScale(transform, -1, 1);\n            break;\n\n        case UIImageOrientationLeftMirrored:\n        case UIImageOrientationRightMirrored:\n            transform = CGAffineTransformTranslate(transform, self.size.height, 0);\n            transform = CGAffineTransformScale(transform, -1, 1);\n            break;\n        case UIImageOrientationUp:\n        case UIImageOrientationDown:\n        case UIImageOrientationLeft:\n        case UIImageOrientationRight:\n            break;\n    }\n\n    // Now we draw the underlying CGImage into a new context, applying the transform\n    // calculated above.\n    CGContextRef ctx = CGBitmapContextCreate(NULL, self.size.width, self.size.height,\n                                             CGImageGetBitsPerComponent(self.CGImage), 0,\n                                             CGImageGetColorSpace(self.CGImage),\n                                             CGImageGetBitmapInfo(self.CGImage));\n    CGContextConcatCTM(ctx, transform);\n    switch (self.imageOrientation) {\n        case UIImageOrientationLeft:\n        case UIImageOrientationLeftMirrored:\n        case UIImageOrientationRight:\n        case UIImageOrientationRightMirrored:\n            // Grr...\n            CGContextDrawImage(ctx, CGRectMake(0,0,self.size.height,self.size.width), self.CGImage);\n            break;\n\n        default:\n            CGContextDrawImage(ctx, CGRectMake(0,0,self.size.width,self.size.height), self.CGImage);\n            break;\n    }\n\n    // And now we just create a new UIImage from the drawing context\n    CGImageRef cgimg = CGBitmapContextCreateImage(ctx);\n    UIImage *img = [UIImage imageWithCGImage:cgimg];\n    CGContextRelease(ctx);\n    CGImageRelease(cgimg);\n    return img;\n\n}\n```\n\n现在再优化一下原来`+ (UIImage *)rotateImage:(UIImage *)oldImage orientation:(UIImageOrientation)orientation` 方法,修改成这样\n\n```objc\n+ (UIImage *)rotateImage:(UIImage *)oldImage orientation:(UIImageOrientation)orientation{\n\n    UIImage *newImage = [UIImage imageWithCGImage:oldImage.CGImage scale:1 orientation:orientation];\n\n    //fix original Image with gived orientation.\n    UIImage *fixedRotationImage = [newImage fixedRotation];\n\n    NSString *orientationStr = nil;\n    switch (orientation) {\n        case UIImageOrientationUp: {\n            orientationStr = @\"UIImageOrientationUp\";\n            break;\n        }\n        case UIImageOrientationDown: {\n            orientationStr = @\"UIImageOrientationDown\";\n            break;\n        }\n        case UIImageOrientationLeft: {\n            orientationStr = @\"UIImageOrientationLeft\";\n            break;\n        }\n        case UIImageOrientationRight: {\n            orientationStr = @\"UIImageOrientationRight\";\n            break;\n        }\n        case UIImageOrientationUpMirrored: {\n            orientationStr = @\"UIImageOrientationUpMirrored\";\n            break;\n        }\n        case UIImageOrientationDownMirrored: {\n            orientationStr = @\"UIImageOrientationDownMirrored\";\n            break;\n        }\n        case UIImageOrientationLeftMirrored: {\n            orientationStr = @\"UIImageOrientationLeftMirrored\";\n            break;\n        }\n        case UIImageOrientationRightMirrored: {\n            orientationStr = @\"UIImageOrientationRightMirrored\";\n            break;\n        }\n\n    }\n\n    NSLog(@\"current orientation: %@\",orientationStr);\n\n    return fixedRotationImage;\n}\n```\n\n 现在再测试一下，well，It‘s OK。\n\n have fun!!!\n\n## 参考资料\n\n*  [UIImageOrientation / EXIF orientation sample images](http://www.galloway.me.uk/2012/01/uiimageorientation-exif-orientation-sample-images/)\n*  [Apple-UIImage Class Reference](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImage_Class/#//apple_ref/c/tdef/UIImageOrientation)\n*  [ios-uiimageview-how-to-handle-uiimage-image-orientation](http://stackoverflow.com/questions/8915630/ios-uiimageview-how-to-handle-uiimage-image-orientation)\n\n备注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["技巧"],"categories":["iOS"]},{"title":"用 CAShapeLayer 动画绘制 CGPath","url":"/2016/01/13/2016-01-13-dong-hua-hui-zhi-cashapelayerde-lu-jing-cgpath/","content":"\n\n\n#### 这是什么？\n> 此文将讲解通过形状图层`CAShaperLayer`的`strokeStart`和`strokeEnd`来实现动画绘制路径`CGPath`,此文是[By Ole Begemann](http://oleb.net)创建于December 18, 2010,当时是发布iOS SDK 4.2时`CAShapeLayer`新增加的两个属性[strokeStart](http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAShapeLayer_class/Reference/Reference.html#//apple_ref/doc/uid/TP40008314-CH1-SW16)和[strokeEnd](http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAShapeLayer_class/Reference/Reference.html#//apple_ref/doc/uid/TP40008314-CH1-SW15),这两个值是两个浮点数取值范围0.0~1.0,用来表明形状图层所指向的路径在绘制开始和结束路径中的相对位置。\n\n`strokeStart`默认值是0.0，`strokeEnd`默认值是1.0，显然这会导致形状图层的路径将一整个被绘制。假如，你想说，如果设置了layer.strokeEnd = 0.5f,只让她绘制前半部分，那该多好。\n\n真正有趣的事情是这些接口都是可动画的。通过动画绘制`strokeEnd`从0.0到1.0在几秒内，我们就能很容易自己绘制路径像下面这样写：\n\n```objc\nCABasicAnimation *pathAnimation = [CABasicAnimation animationWithKeyPath:@\"strokeEnd\"];\npathAnimation.duration = 10.0;\npathAnimation.fromValue = [NSNumber numberWithFloat:0.0f];\npathAnimation.toValue = [NSNumber numberWithFloat:1.0f];\n[self.pathLayer addAnimation:pathAnimation forKey:@\"strokeEndAnimation\"];\n```\n\n最后，再添加第二个图层包含一个铅笔图片，使用关键帧动画` CAKeyframeAnimation`来让它随着这个路径以相同的速度绘制，就可以达到完美的错觉效果：\n\n```objc\nCAKeyframeAnimation *penAnimation = [CAKeyframeAnimation animationWithKeyPath:@\"position\"];\npenAnimation.duration = 10.0;\npenAnimation.path = self.pathLayer.path;\npenAnimation.calculationMode = kCAAnimationPaced;\n[self.penLayer addAnimation:penAnimation forKey:@\"penAnimation\"];\n```\n\n[绘制普通路径效果视频](http://oleb.net/media/AnimatedPathsHausVomNikolaus.mp4)\n\n[下载地址](http://oleb.net/media/AnimatedPathsHausVomNikolaus.mp4)\n\n这个对文本一样有效；我们只需要把字符转化成`CGPath`。`Core Text`提供了那样的功能的函数，[CTFontCreatePathForGlyph( )](http://developer.apple.com/library/ios/documentation/Carbon/Reference/CTFontRef/Reference/reference.html#//apple_ref/c/func/CTFontCreatePathForGlyph)。为了使用它，我们需要创建一个带属性的字符串用我们想要渲染的文本，先把它们分割成行在分割成一个个字符。在把所有的字符转换成路径后，我们以子路径方式把它添加到一个单个的`CGPath`路径中。更多细节可以查看[Ohmu](http://www.codeproject.com/script/Membership/View.aspx?mid=2887692)写的[Low-level text rendering](http://www.codeproject.com/KB/iPhone/Glyph.aspx)这篇文章。结果看以来非常的炫酷：\n\n[绘制文字路径效果视频](http://oleb.net/media/AnimatedPathsHelloWorld.mp4)\n\n[下载地址](http://oleb.net/media/AnimatedPathsHelloWorld.mp4)\n\n从Github上获得[iPad版的样品工程](http://github.com/ole/Animated-Paths)\n\n#### 你将学到的知识点\n* 使用`CAShapeLayer`的`strokeStart`和`strokeEnd`来实现路径动画,比较高级复杂的效果像google的下拉刷新转圈就可以从这里引申去实现。\n* `CABasicAnimation`和`CABasicAnimation`使用\n* 深入理解`CAShapeLayer`和`CALayer`\n* 通过文本创建路径，核心函数`CTFontCreatePathForGlyph()`\n\n\n#### 补充说明\n\n```objc\n    CAShapeLayer *pathLayer = [CAShapeLayer layer];\n    pathLayer.frame = self.animationLayer.bounds;\n    pathLayer.bounds = pathRect;\n    pathLayer.geometryFlipped = YES;\n    pathLayer.path = path.CGPath;\n    pathLayer.strokeColor = [[UIColor blackColor] CGColor];\n    pathLayer.fillColor = nil;\n    pathLayer.lineWidth = 10.0f;\n    pathLayer.lineJoin = kCALineJoinBevel;\n\n    [self.animationLayer addSublayer:pathLayer];\n```\n\n有一点非常重要，CALayer在iOS系统中相对坐标系是以屏幕左上`top-left`为坐标原点的，在Mac OS X上以坐下`bottom-left`为坐标原点,但是可以通过`CALayer`的接口`geometryFlipped`垂直翻转坐标系，这个值默认是`NO`，设置成`YES`就可以把坐标系转换成左下`bottom-left`了，这里作者使用的左下`bottom-left`的坐标系。\n\n\n```objc\n@property(getter=isGeometryFlipped) BOOL geometryFlipped;\n```\n关于这个属性使用时需要特别注意\n\n1. 翻转会同时作用于它的子图层\n2. 即使这个属性设置成`YES`,图片的`orientation`仍然是不变的（也就是说当设置`flipped=YES`和`flipped=NO`时一个`CGImageRef`储存在`contents`接口中的内容将会显示一致，赋值并不会真正变换底层的图层）\n\n#### pathLayer动画实现原理\n1. 先创建一个动画用的图层`animationLayer`类型`CALayer`，用来充当动画的画布。\n2. 创建真正的路径图层`pathLayer`类型为`CAShapeLayer`,让它的坐标系垂直翻转，并且让图层宽高同时向内收缩100个点,通过`CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)`实现\n3. 把`pathLayer`添加到`animationLayer`的子图层中去\n4. 创建一个铅笔图层`penLayer`类型为`CALayer`,把它添加到`pathLayer`去\n5. 对`pathLayer`添加`CABasicAnimation`动画，动画属性为`strokeEnd`\n6. 对`penLayer`添加`CAKeyframeAnimation`动画，动画属性为`position`\n\n#### textLayer动画实现原理\n1. 先创建一个动画用的图层`animationLayer`类型`CALayer`，用来充当动画的画布\n2. Create path from text,See:<http://www.codeproject.com/KB/iPhone/Glyph.aspx>，最终保存到一个类型为`CGMutablePathRef`的letter中\n3. 通过letter来创建文字`UIBezierPath`类型的`path`\n4. 通过path再创建`CAShapeLayer`pathLayer,并且把pathLayer添加到`animationLayer`中去\n5. 创建一个铅笔图层`penLayer`类型为`CALayer`,把它添加到`pathLayer`去\n5. 对`pathLayer`添加`CABasicAnimation`动画，动画属性为`strokeEnd`\n6. 对`penLayer`添加`CAKeyframeAnimation`动画，动画属性为`position`\n\n\n\n#### 修复一处bug\n重复点击`UISegmentedControl`导致铅笔消失，这是设置了` penAnimation.delegate = self;`在代理方法里面没有判断结束直接将设置`self.penLayer.hidden = YES`，导致连续切换时铅笔不见了，要修复这个bug只需加一个判断`    if (flag)   self.penLayer.hidden = YES;\n`即可,这样的意思是只有当动画完成时才设置`self.penLayer.hidden`的值，好了现在已经非常完美了，快去动手自己试试吧！🍺\n\n- [原文链接](http://oleb.net/blog/2010/12/animating-drawing-of-cgpath-with-cashapelayer/)\n\n备注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["CAShapeLayer"],"categories":["动画"]},{"title":"Blog 网站备忘录","url":"/2016/01/13/2016-01-13-blogwang-zhan-bei-wang-lu/","content":"\n\n## 简书\n* [叶孤城___](http://www.jianshu.com/users/b82d2721ba07/latest_articles)\n* [MarkNote](http://www.jianshu.com/users/39eeabac725a/latest_articles)\n* [lp_马建成](http://www.jianshu.com/users/384f80cdc57b/latest_articles)\n* [seedante\n](http://www.jianshu.com/users/7ba5d9065301/latest_articles)\n* [大灰灰iOS](http://www.jianshu.com/users/960f3b94323a/latest_articles)\n* [StrongX](http://www.jianshu.com/users/56475732c6e9/latest_articles)\n\n\n\n## 国内个人\n* [猫神onevcat](http://onevcat.com/?from=inf&wvr=5&loc=infblog) -- 地球人都知道\n* [唐巧](http://blog.devtang.com/)--猿题库作者\n* [虾神](http://blog.txx.im/?from=inf&wvr=5&loc=infblog)--话说你们晓得虾神年纪多大么？反正我是觉得白活了。90后太厉害了。\n* [sunnyxx](http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/) -- [FDFullscreenPopGesture](https://github.com/forkingdog/FDFullscreenPopGesture)作者，值得关注\n* [nixzhu](https://github.com/nixzhu/dev-blog)--有几篇翻译的文章质量不错\n* [破船之家](http://beyondvincent.com)--这让我想起，喝上一杯朗姆酒🍺\n* [Limboy](http://limboy.me) -- 蘑菇街一位资深iOS程序员\n* [MacTalk-池建强的随想录](http://macshuo.com/?page_id=93)--Mac开发大牛\n* [雨松MOMO](http://www.xuanyusong.com)--专注移动互联网，专注Unity3D游戏开发,国内最早开发Unity3d的大神之一\n* [玉令天下的博客](http://yulingtianxia.com) -- 关于runtime的资料整理得非常不错\n* [Chun Tips](http://chun.tips) -- 对Runtime,RunLoop,AutoLayout讲解得非常详细 ❤️\n* [鹏威の博客](http://blog.treney.com) -- 非常炫酷的博客，值得学习\n* [mgenware](https://www.mgenware.com/blog/) -- 往全栈方向发展ing\n\n## 国外个人\n* [mikeash](https://www.mikeash.com)--白天飞行员，晚上程序员 ：] just this guy, you know?\n* [shinobicontrols](https://www.shinobicontrols.com/blog)--iOS 最新 API 以及新功能用法\n* [iosdevelopertips](http://iosdevelopertips.com/user-interface/custom-visual-calendar-control-for-ios.html)--教程配合Demo让你学习成长立竿见影\n* [iosdevweekly](http://iosdevweekly.com)--很棒的个人技术博客网，已发表230篇文章\n* [ios-goodies](http://ios-goodies.com)--iOS,UI,UX,Objective-c,Swift,Xcode\n* [mattt-thompson](http://nshipster.cn/authors/mattt-thompson/) -- 不用解释\n* [subjc](http://subjc.com) --Subjective-C is a study of innovative iOS interfaces.\n* [thinkandbuild](http://www.thinkandbuild.it)--《Introduction To 3D Drawing in CoreAnimtion》作者\n* [robb.is](http://robb.is/)--《How to build a nice Hamburger transition in swift》作者\n* [commandshift](http://commandshift.co.uk)--不多说，质量极高\n* [indieambitions](http://indieambitions.com/)--raywenderlich常驻作者之一的blog，非常赞。\n* [nvie](http://nvie.com)--国外一个大神的blog，讲得比较杂，git，ios，python都有涉猎，但是每篇都很精彩。\n* [stuartkhall](http://stuartkhall.com)--很多关于app上线运营之类的blog，值得一看。\n* [ittybittyapps](http://blog.ittybittyapps.com)--神器Reveal的作者的blog。\n* [adoptioncurve](http://adoptioncurve.net/)--更新极快，当时iOS8还没出几个周，作者就写了篇sizeclass解析。非常棒\n* [ciechanowski](http://ciechanowski.me)--各种数学上几何变化\n* [bignerdranch](https://www.bignerdranch.com/blog/)\n* [cocoawithlove](http://www.cocoawithlove.com)--2008-2011的老文章，现在没怎么跟新了\n* [codinghorror](http://blog.codinghorror.com/) --[Jeff Atwood ](https://twitter.com/codinghorror)主站\n* [g8production](http://www.g8production.com/)\n* [lucida](http://lucida.me/about/) -- 我比较佩服一名程序员，想学算法找他推荐咯😁\n\n## 团体blog\n* [ibireme](http://blog.ibireme.com)--最近很🔥的YYKit的作者\n* [Glow技术团队](http://tech.glowing.com/cn/)\n* [美团点评技术团队](http://tech.meituan.com)\n\n\n## 优质iOS学习资源\n* [github](https://github.com)--这个不用我说吧\n* [stackoverflow](http://stackoverflow.com)--最专业的问答社区\n* [raywenderlich]( http://www.raywenderlich.com)--iOS界的百科全书\n* [nshipster](http://nshipster.com)--里面文章质量非常的高，最喜欢的几个网站之一[AFNetworkting](https://github.com/AFNetworking/AFNetworking)的作者[Mattt Thompson](http://nshipster.com/authors/mattt-thompson/)--经常出没\n* [nshipster中国](http://nshipster.cn)\n* [objc.io](http://www.objc.io)--这个也不用多说了，Raywenderlich是百科全书的话，这个就是深入深入再深入\n* [objc中国](http://objcio.cn)\n* [realm.io](https://realm.io)--一个跨平台的移动数据库引擎\n* [tutsplus](http://tutsplus.com/)--也是包罗万象的一个网站，有web ios ui，不比Raywenderlich逊色。\n* [maniacdev](https://maniacdev.com)--类似Raywenderlich，文章质量高，而且涵盖面广\n* [Appcoda](https://www.appcoda.com) -- 技术类学习网站，里面的技术更新挺及时的\n\n## 中文网站\n* [cocoachina](http://www.cocoachina.com)\n* [code4app](http://www.code4app.com)\n* [泰然网](http://www.tairan.com) --游戏教程不错的网站\n* [伯乐在线](http://blog.jobbole.com)\n\n## Swift：\n\n* [介紹 | 《The Swift Programming Language》中文版](http://wiki.jikexueyuan.com/project/swift/)\n* [Swift必备Tips](http://swifter.tips) -- 猫神的杰作\n* [Let's Swift ](http://letsswift.com/swift-site-index/) -- Swift站点导航\n* [Swiftify | Objective-C to Swift Converter ](https://objectivec2swift.com/#/converter/code) -- 辅助将旧的* Objective-C代码转成Swift。\n* [Swift.org](https://swift.org) -- Apple Swift 官网\n* [Swift - Blog](https://developer.apple.com/swift/blog/) -- Apple Swift 官方博客\n* [CocoaChina小组翻译的Swift版本](https://github.com/CocoaChina-editors/Welcome-to-Swift)\n* [tutorialspoint](http://www.tutorialspoint.com/swift/swift_environment.htm) -- 有一些Swift教程\n\n\n备注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["网站"],"categories":["资料收集"]},{"title":"__autoreleasing 的理解","url":"/2016/01/13/2016-01-13-autoreleasingde-li-jie/","content":"\n###  __autoreleasing 修饰符\n\n将对象赋值给附有 __autoreleasing 修饰符的变量等同于 ARC 无效时调用对象的 autorelease 方法。我们通过以下源代码来看一下\n\n```objc\n@autoreleasepool {\n    id __autoreleasing obj  = [[NSObject alloc] init];\n}\n```\n该源代码主要将NSObject 类对象注册到autoreleasepool 中，可作如下变换：\n\n```objc\n/* 编译器的模拟代码 */\nid pool = objc_autoreleasePoolPush();\nid obj = objc_msgSend(NSObject, @selector(alloc));\nobjc_msgSend(obj, @selector(init));\nobjc_autorelease(obj);\nobjc_autoreleasePoolPop(pool);\n```\n\n这与苹果的autorelease 实现中的说明（参考1.2.7 节）完全相同。虽然 ARC 有效和无效时，其在源代码上的表现有所不同，但 autorelease 的功能完全一样。\n\n在 alloc/new/copy/mutableCopy 方法群之外的方法中使用注册到 autoreleasepool 中的对象会如何呢？下面我们来看看 NSMutableArray 类的 array 类方法。\n\n```objc\n@autoreleasepool {\n    id __autoreleasing obj = [NSMutableArray array];\n}\n```\n\n这与前面的源代码有何不同呢？\n\n```objc\n/* 编译器的模拟代码 */\nid pool = objc_autoreleasePoolPush();\nid obj = objc_msgSend(NSMutableArray, @selector(array));\nobjc_retainAutoreleasedReturnValue(obj);\nobjc_autorelease(obj);\nobjc_autoreleasePoolPop(pool);\n```\n虽然持有对象的方法从alloc 方法变为objc_retainAutoreleasedReturnValue 函数， 但注册autoreleasepool 的方法没有改变，仍是objc_autorelease 函数。\n\n备注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["autoreleasing"],"categories":["系统原理"]},{"title":"__attribute__","url":"/2016/01/13/2016-01-13-attribute/","content":"\n* 译自 Written by [Mattt Thompson](http://nshipster.com/authors/mattt-thompson/) — January 14th, 2013\n* 原文链接：<http://nshipster.com/__attribute__/>\n* 译者[@oneruofeng](https://twitter.com/oneruofeng)\n\n重复发布这个主题已经说明了同编译器保存健康关系的重要性,像任何草稿一样，作为一个实践者的效率取决于他们怎样对待他们的工具，你照顾好它们，它们反过来也会对你有好处。\n\n `__attribute__`是一个编译器的指令在声明的时候指明了一些参数，这些参数允许更多的检查错误和高级的优化。\n\n 语法关键字是`__attribute__`紧跟2套圆括号（双圆括号让出现的宏更容易辨认，特别是在有多个属性的时候）。在括号内部是一个以逗号分隔的属性列表，`__attribute__`指令被放在函数，变量和类型声明后面。\n\n```objc\n // Return the square of a number\nint square(int n) __attribute__((const));\n\n// Declare the availability of a particular API\nvoid f(void)\n  __attribute__((availability(macosx,introduced=10.4,deprecated=10.6)));\n\n// Send printf-like message to stderr and exit\nextern void die(const char *format, ...)\n  __attribute__((noreturn, format(printf, 1, 2)));\n```\n\n假如这个让你想起ISO C语言的 `#pragma`,你就不会感到孤单了。\n\n实际上，当`__attribute__`被第一次引入到`GCC`编译器时，它面临一些阻力，有人建议使用专用的`#pragma`因为相同的目的。\n\n这里，然而，有2个非常好的理由为什么`__attribute__`被添加进来\n> * 从一个宏中产生`#pragma`命令几乎是不能的（在C99 _Pragma 预算符以前）。\n> * 这里没人知道相同的`#pragma`在另一个编译器中可能的意思。\n\n 引用[GCC Documentation for Function Attributes](http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html)\n\n > * 这里有2个原因被应用到几乎所有的应用推荐使用`#pragma`,这犯了一个低级错误就是把`#pragma`使用到任何地方。\n\n 确实，假如你在苹果的框架中和牛逼工程师的开源项目中的头文件看一下现代的`Objective-c`--`__attribute__`被大量使用。（相反，`#pragma`的主要声明名声来着这些天是装饰:`#pragma mark`）\n\n 所以为了以后不费力，我们还是先看一下最重要的属性：\n\n------\n\n### GCC\n\n**format**\n> `format`属性指定了一个函数像`printf`,`scanf`,`strftime`或者`strfmo`风格的参数，这个参数应该是可以进行类型检查的一个格式化字符串。\n\n```objc\nextern int\nmy_printf (void *my_object, const char *my_format, ...)\n  __attribute__((format(printf, 2, 3)));\n```\n\nObjective-C程序员也可使用`__NSString__`来格式化来做到相同的格式化规则，像在`NNString`中通过 ``+stringWithFormat:`` 和 `NSLog()`格式化字符串一样。\n\n**nonnull**\n> 这个`nonnull`属性指定了某些函数的参数必须是非空的指针。\n\n```objc\nextern void *\nmy_memcpy (void *dest, const void *src, size_t len)\n  __attribute__((nonnull (1, 2)));\n```\n\n使用`nonnull`编码期望这个值遵守一个明确的约定中，这样能帮助捕获潜伏在任何代码调用的NULL指针bugs，请记住：\n`编译时的错误 >>  运行时的错误。`\n\n**noreturn**\n> 一些标准库函数，例如`abort`和`exit`,是不能返回的。GCC自动知道这些东西，这个noreturn属性用于指定任何其他函数永远不会返回的情况。\n\n例如，AFNetworking 使用`noreturn`属性在它的[网络请求线程进入点的方法](https://github.com/AFNetworking/AFNetworking/blob/1.1.0/AFNetworking/AFURLConnectionOperation.m#L157)里面,这个方法用在当大量产生专用的网络的线程里用来保证分离的线程持续执行在应用的整个生命周期中。\n\n**pure/const**\n> `pure`属性指定了一个函数除了返回值没有副作用，例如它的返回值仅仅依赖参数和/或者全局变量。这样的函数可以用公共子表达式消除并且循环优化就像一个算数操作符那样。\n\n> `pure`属性指定了一个函数不会检查任何值除了它们的参数，并且返回值没有副作用。注意到一个函数有一个指针参数并且需呀检查数据的指向不能声明成`const`。同样的，一个函数调用一个非`nonst`函数通常不能为`const`,一个`const`函数返回`void`并没有什么意义。\n\n```objc\nint square(int n) __attribute__((const));\n```\n\n`pure`和`const`是两个执行在一个函数式编程惯例中的参数为了允许有效性能优化。`const`可以被认为是严格形式的`pure`因为它不依赖全局变量或者指针。\n\n例如，因为一个函数声明为`const`的结果并不依赖任何东西除了传进来的参数。函数的结果能够缓存那个结果并且当函数被调用时返回，这样的函数叫做相同的组合参数（也就是说，我们知道一个数字的平方是一个常量，所以我们仅仅需要只计算它一次)。\n\n**unused**\n> 这个属性，附着在一个函数后面，意味着那个函数很可能不会被使用，GCC不会对这个函数产生警告。\n\n用`__unused`关键词可以获得相同的效果，声明这个在方法实现中不会被使用的参数中。知道那以后一些上下文就可以允许编译器来做相应的优化。你很可能喜欢在delegate方法实现李勉使用`__unused`,因为协议频繁的提高更多的上下文比通常必要的情况，为了满足大量的潜在使用案例。\n\n### LLVM\n\n像GCC的很多特征一样，Clang也支持`__attribute__`,添加到它自己的小范围的扩展。为了检查某个属性的可用性，你可以直接使用`__has_attribute`属性。\n\n**availability**\n> Clang引进了availability属性，这个可以被取代在声明描述的生命周期中声明相对于操作系统的版本。思考对一个简单函数f：的函数声明\n\n```objc\nvoid f(void) __attribute__((availability(macosx,introduced=10.4,deprecated=10.6,obsoleted=10.7)));\n```\n\n> `availability`属性声明f在OS X老虎系统中被引入，在OS X雪豹系统中被弃用，在OS X 山狮系统中被废弃。\n\n> 这个信息被Clang用来决定什么时候使用f：函数式安全的，例如，假如Clang在OS X 美洲豹系统上编译，调用f()函数将成功。假如Clang在OS X雪豹系统中编译，函数调用将成功但是Clang会发出一个警告指明这个函数被弃用了。最后，假如Clang被引进编译OS X山狮系统的代码，函数调用将失败，因为f()函数已经不再可用了。\n\n> `availability`属性是一个逗号分隔的列表以平台名开始然后引入一些定语列举出生命周期内的重要里程碑事件附加额外的信息（以任何顺序）。\n\n* introduced：声明被引入的第一个版本\n* deprecated：声明被弃用的第一个版本，这意味着用户应该把这个API移走\n* obsoleted： 声明被废弃的第一个版本，这意味着它将被完全移除并且不能再使用\n* unavailable：声明在这个平台上将永远不可用\n* message：额外的消息将被Clang提供当忽略一个警告或者一个错误在使用一个被弃用或者被废弃的声明。对引导用户替换APIs很有用。\n\n> 在声明时可以使用多个availability属性，每个对应不同的平台，仅当availability属性对应相应的目标平台被使用的时候，任何其他才将被忽略。假如没有availability 属性指定可用性对现在的目标平台，availability 属性将被忽略。\n\n### 支持的平台\n\n* ios：苹果的iOS操作系统。最小的部署目标被指定通过`-mios-version-min=*version*`或者`-miphoneos-version-min=*version*`命令行参数。\n* macosx：苹果的OS X 操作系统，最小的部署目标被指定通过`-mmacosx-version-min=*version*`命令行参数\n\n**overloadable**\n\n> Clang提供对C++函数在C中重载的支持。在C中函数重载被引进使用`overloadable`属性。例如，一个可能提供一个重载版本的`tgsin`函数来精确执行相关的标准函数计算`float`,`double`,`long double`的正弦值：\n\n```objc\n#include <math.h>\nfloat __attribute__((overloadable)) tgsin(float x) { return sinf(x); }\ndouble __attribute__((overloadable)) tgsin(double x) { return sin(x); }\nlong double __attribute__((overloadable)) tgsin(long double x) { return sinl(x); }\n```\n请注意`overloadable`只对函数起作用。你可以重载方法声明在某种范围内通过使用通用的返回值和参数类型，想`id`或者`void *`.\n\n----\n\n上下文是国王当它遇到编译器优化时。通过提供限制在怎样解析你的代码，增加你参数尽可能高效代码的可能性。遇到编译器把你打断，这将是一项奖励。\n\n还有`__attribute__`并不仅仅对编译器有用：下一个人看代码也将感谢这些额外的上下文。所以多走几英尺远将对你的合作中和接替者或者从现在算2年以后的你(那个时候你已经忘记了所以的事情关于这份代码)自己有用\n\n你付出了多少爱,最终你会得到多少爱。\n\n译者注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["翻译","编译器"],"categories":["系统原理"]},{"title":"RunLoop 详解","url":"/2016/01/12/2016-01-13-runloopxiang-jie/","content":"\n##  NSRunLoop 是什么？\n\n在 Cocoa 中，每个线程( `NSThread` )对象中内部都有一个 RunLoop( `NSRunLoop` ) 对象用来循环处理输入事件.\n\n*NSRunloop 并不真的是一个 loop，在 Apple 的文档中也提到了需要自己写 while 或者 for 语句来实现,类似下面：*\n\n```objc\nwhile(running){\n    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n}\n```\n\n##  何为 RunLoop 事件源\n\n从字面翻译来看，RunLoop 就是一个运行循环，的确它就是一个处理输入时间的运行循环，为什么需要这样处理，难道没有事件发生的时候让线程空转浪费资源？很明显在有事件发生的时候唤醒线程，没有事件发生的时候让其 sleep 更好。\n\n下面我还是拿这张百看不厌的图来说事：\n\n![RunLoop](images/common/runloop.jpg)\n\n处理的事件包括两类\n\n- 来自 Timer sources 的同步事件\n- 来自 Input sources 的异步事件\n\n1. Time Source. Timer sources deliver synchronous events, occurring at a scheduled time or repeating interval. 苹果文档中有句话需要注意，\n\n> Timer sources deliver events to their handler routines but do not cause the RunLoop to exit.*\n\n创建 NSTimer 添加到 RunLoop 中的时候，这里需要注意的是， `NSTimer` 默认是处于 `NSDefaultRunloopMode` ，这也就可以解释为什么如果你在你的控制器中添加了一个 timer 定时刷新你的界面，而你在拖动视图的时候 timer 不回 fire，因为这个时候你的 runloop 是 `NSEventTrackingRunloopMode` ,在这个 mode 下 timer 不会 fire。\n\n2. input source input source 主要是一些异步的事件，比如来自其它线程或者其它 app 的消息。\n\ninput source 传递异步事件到其对应的处理函数，并且使 runUntilDate(与线程相关联的 RunLoop 对象调用)返回\n\n为了能够处理 input source， RunLoop 产生 notifications。通过注册成 RunLoop observers 可以接受到这些通知（通过 Core Foundation 来注册 observers）。\n\n##  RunLoopMode 有哪些？\n\nRunLoop 在处理输入事件时会产生通知，可以通过 Core Foundation 向线程中添加 RunLoop observers 来监听特定事件,以在监听的事件发生时做附加的处理工作。\n\n每个 RunLoop 可运行在不同的模式下，一个 RunLoop mode 是一个集合，其中包含其监听的若干输入事件源，定时器，以及在事件发生时需要通知的 RunLoop observers。运行在一种 mode 下的 RunLoop 只会处理其 RunLoop mode 中包含的输入源事件、定时器事件、以及通知 RunLoop mode 中包含的 observers。\n\nCocoa 中的预定义模式有:\n\n1. Default 模式\n   1. 定义 [NSDefaultRunLoopMode ](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSDefaultRunLoopMode)(Cocoa) [kCFRunLoopDefaultMode ](https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/data/kCFRunLoopDefaultMode)(Core Foundation)\n   2. 描述：默认模式中几乎包含了所有输入源(NSConnection 除外),一般情况下应使用此模式，这是最常用的 RunLoop mode。\n2. Connection 模式\n   1. 定义： `NSConnectionReplyMode` (Cocoa)\n   2. 描述：处理 `NSConnection` 对象相关事件，系统内部使用，这个 mode 表明 `NSConnection` 对象等待 reply,用户基本不会使用。\n3. Modal 模式\n   1. 定义： `NSModalPanelRunLoopMode` (Cocoa)\n   2. 描述：处理 modal panels 事件,需要等待处理的 input source 为 modal panel 时设置，比如 NSSavePanel 和 NSOpenPanel。\n4. Event tracking 模式\n   1. 定义： [UITrackingRunLoopMode ](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplication_Class/index.html#//apple_ref/doc/uid/TP40006728-CH3-SW38)(iOS) `NSEventTrackingRunLoopMode` (cocoa)\n   2. 描述：使用该模式来处理用户界面相关的事件,例如在拖动 loop 或其他 user interface tracking loops 时处于此种模式下，在此模式下会限制输入事件的处理。例如，当手指按住 UITableView 拖动时就会处于此模式。\n5. Common 模式\n   1. 定义： [NSRunLoopCommonModes ](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSRunLoopCommonModes)(Cocoa) [kCFRunLoopCommonModes ](https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/data/kCFRunLoopCommonModes)(Core Foundation)\n   2. 描述：这是一个伪模式，其为一组 RunLoop mode 的集合，将输入源加入此模式意味着在 Common Modes 中包含的所有模式下都可以处理。在 Cocoa 应用程序中，默认情况下 Common Modes 包含 default modes,modal modes,event Tracking modes, 可使用 [CFRunLoopAddCommonMode ](https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopAddCommonMode)方法向 Common Modes 中添加自定义 modes。\n\n**注意这个并不是一个特定的 mode，而是一个 mode 的集合，而 runloop 必须运行在一个特定的 mode 下** 。\n\n获取当前线程的 runloop mode\n\n```objc\nNSString *runLoopMode = [[NSRunLoop currentRunLoop] currentMode];\n```\n\n##  NSTimer、NSURLConnection 与 UITrackingRunLoopMode\n\nNSTimer 与 NSURLConnection 默认运行在 default mode 下，这样当用户在拖动 UITableView 处于 UITrackingRunLoopMode 模式时，NSTimer 不能 fire,NSURLConnection 的数据也无法处理。\n\nNSTimer 的例子: 在一个 UITableViewController 中启动一个 0.2s 的循环定时器，在定时器到期时更新一个计数器，并显示在 label 上。\n\n```objc\n- (void)viewDidLoad {\n\n    label =[[UILabel alloc]initWithFrame:CGRectMake(10, 100, 100, 50)];\n    [self.view addSubview:label];\n    count = 0;\n\n    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval: 0.2\n                                                      target: self\n                                                    selector: @selector(incrementCounter:)\n                                                    userInfo: nil\n                                                     repeats: YES];\n}\n\n- (void)incrementCounter:(NSTimer *)theTimer\n{\n    count++; \n    label.text = [NSString stringWithFormat:@\"%zd\",count];\n}\n```\n\n在正常情况下，可看到每隔 0.2s，label 上显示的数字 +1,但当你拖动或按住 tableView 时，label 上的数字不再更新，当你手指离开时，label 上的数字继续更新。当你拖动 `UItableView` 时，当前线程 RunLoop 处于 `UIEventTrackingRunLoopMode` 模式，在这种模式下，不处理定时器事件，即定时器无法 fire,label 上的数字也就无法更新。 解决方法，一种方法是在另外的线程中处理定时器事件，可把 Timer 加入到 `NSOperation` 中在另一个线程中调度;还有一种方法时修改 Timer 运行的 RunLoop 模式，将其加入到 `UITrackingRunLoopMode` 模式或 `NSRunLoopCommonModes` 模式中。 即\n\n```objc\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];\n```\n\n或\n\n```objc\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n```\n\n另外一种是放到 `NSThread` 中\n\n```objc\n- (void)viewDidLoad{\n    [super viewDidLoad];\n    NSLog(@\"主线程 %@\", [NSThread currentThread]);\n    \n    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];\n    [thread start];\n}\n\n- (void)newThread{\n    @autoreleasepool{\n        \n        [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(timer_callback) userInfo:nil repeats:YES];\n        \n        [[NSRunLoop currentRunLoop] run];\n    }\n}\n\n- (void)timer_callback{\n    NSLog(@\"Timer %@\", [NSThread currentThread]);\n}\n```\n\n`NSURLConnection` 也是如此，见 [SDWebImage ](https://github.com/rs/SDWebImage)中的描述,以及 [SDWebImageDownloader.m ](https://github.com/rs/SDWebImage/blob/master/SDWebImage/SDWebImageDownloader.m)代码中的实现。修改 NSURLConnection 的运行模式可使用 [scheduleInRunLoop:forMode: ](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURLConnection_Class/Reference/Reference.html#//apple_ref/occ/instm/NSURLConnection/scheduleInRunLoop:forMode:)方法。\n\n```objc\nNSURL *url = [NSURL URLWithString:@\"https://www.baidu.com\"];\nNSURLRequest *request = [[NSURLRequest alloc] initWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:15];\n\nself.connection = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:NO];\n[connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];\n[connection start];\n```\n\n##  参考资料：\n\n- [Threading Programming Guide – RunLoops](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1)\n- [NSRunLoop Class Reference](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html)\n- [NSURLConnection Class Reference](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURLConnection_Class/)\n- [NSTimer Class Reference](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html)\n- [CFRunLoop wiki](http://iphonedevwiki.net/index.php/CFRunLoop)\n- [SDWebImage](https://github.com/rs/SDWebImage)\n- [TestButtonDown](http://hayne.net/MacDev/TestButtonDown/)\n- [关于 NSRunloop 的学习和理解](http://billwang1990.github.io/blog/2013/12/30/nsrunloop-issue/)\n\n备注：欢迎转载，但请一定注明出处！ [http://blog.wangruofeng007.com](http://blog.wangruofeng007.com/)\n","tags":["RunLoop"],"categories":["系统原理"]},{"title":"iOS7 tintColor 详解","url":"/2016/01/12/2016-01-13-ios7-tintcolorxiang-jie/","content":"\n## 为什么需要出现tintColor ？\n\n> 解决以前不方便统一设置视图颜色风格的通点，方便自定义系统控件外观\n 跟`UIAppearance`协议设计有点类似，`UIAppearance`是为了方便统一 设置一类控件的外观，而`tintColor`是为方便设置某个控件的外观，或者 说某个容器内所有控件的风格。\n\n > 像在`UIViewController` 中，通过这段代码可以实现容器内，所有的子view风格统一化,这样在这个控制器中的所有子view都会以`tintColor`显示\n > ```objc\n self.view.tintAdjustmentMode = UIViewTintAdjustmentModeNormal\n ```\n\n\n`UIView`的`tintAdjustmentMode`需要说明一下，这是一个`UIViewTintAdjustmentMode`枚举\n\n* UIViewTintAdjustmentModeAutomatic（着色调整模式自动）\n* UIViewTintAdjustmentModeNormal（着色调整模式正常）\n* UIViewTintAdjustmentModeDimmed（着色调整模式变暗，打开控风格会变成灰白模式）\n\n\n\n## 先看看官方API说明\nhttps://developer.apple.com/documentation/uikit/uiview/1622467-tintcolor?language=objc\n\niOS7以后所有的UIView以及它的子类都新增了一个叫tintColor的接口，方便我们对视图进行颜色调整\n\n\n## 注意事项\n> `UIImageView`需要设置`renderingMode`为`UIImageRenderingModeAlwaysTemplate`才能生效。\n`renderingMode`是一个类型为`UIImageRenderingMode`的枚举\n\n* UIImageRenderingModeAutomatic （默认渲染模式，自动模式）\n* UIImageRenderingModeAlwaysOriginal（总是绘制原来的图片，不把它当成临时图片来处理）\n* UIImageRenderingModeAlwaysTemplate （总是绘制临时图片，会忽略它原本的颜色信息，也就是根据`tintColor`生产图片）\n\n## UIImageView的使用\n\n```objc\nUIImage *image = [UIImage imageNamed:@\"xxx.png\"];\nimage = [image imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];\n```\n\n## tintColor更新\n在子类中重写`- (void)tintColorDidChange` 方法，就可以实现每次更新`tintColor`的时候调用相关配置\n\n```objc\n - (void)tintColorDidChange\n {\n    _tintColorLabel.textColor = self.tintColor;\n    _tintColorBlock.backgroundColor = self.tintColor;\n }\n```\n","tags":["主色调"],"categories":["系统 API"]},{"title":"MacOSX10.11 上用 Octopress 和 GitHub 搭建个人博客","url":"/2015/12/12/2016-01-13-macosx10-dot-11shang-yong-octopresshe-githubda-jian-ge-ren-bo-ke/","content":"\n序言经过一晚上的折腾，终于从`Hexo`成功转入`Octopress`,那么本文就来细说一下如何使用 `Octopress`+`GitHub Pages`搭建个人博客\n\n### 为什么选择 Octopress & Github Pages?\n\n* 免费且独立。把 Octopress 博客系统搭建到 Github Pages 虽是免费，但不失独立性，即便 Github 全站关闭，你也将有一份本地全站备份，随时可以重新恢复。不必受托管商之气，而且还免费，如果你愿意，甚至可以自行插入广告挣钱。\n* 版本控制。写文章，建网站，做软件都需要修改，但有时候改完了又会后悔，如果有时光机就好了，Git 就是你的时光机。当然如果你不想了解这些看上去很唬人的 IT 名词，只是想写博客的话，请在需要的时候再研究这条的内容。\n* 相对其他托管到 Github 上的博客程序，Octopress 更加成熟易上手。打个比方，[Jekyll](http://jekyllcn.com) 可以说是毛坯房，[Hexo](https://hexo.io) 和 [Octopress](http://octopress.org) 算是简装修，但相比 Hexo，Octopress 有更多装修范例和更多熟练的装修工人，更容易获取帮助。当然如果你只想住精装修的房子，那不得不花点钱上 [WordPress](https://www.google.com.hk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=8&cad=rja&uact=8&ved=0ahUKEwiOv6rSnqbKAhVGKJQKHefnDGAQFghGMAc&url=https%3A%2F%2Fzh.wikipedia.org%2Fzh-cn%2FWordPress&usg=AFQjCNGIb2sxhqKIuZ22-NHO6nclaYYOSQ&sig2=GoW6MP3lSb9RasgVQGFxnw) 了\n* 使用 Markdown。[Markdown](https://zh.wikipedia.org/wiki/Markdown) 是现在最为流行的轻量级标记语言，也是已故的天才 Aaron Swartz 留给世人最好的礼物，窃以为每个在互联网上发布文章的人都该掌握。\n* 按照官方的说法，Octopress 是个`A blogging framework for hackers`(「为黑客设计的博客框架」)，这很酷，你不觉得吗？\n\n如果你之前没有写过博客，打算开始搭建自己第一个博客的话，其实也不妨试试 Octopress，免费还能学到东西，何乐而不为？\n\n\n本文是在`OS X EI Capitan`系统上搭建一个基于`Octopress`的个人博客系统，记录搭建过程的各种坑，希望对有想搭建个人博客的朋友有所帮助。\n\n本文是建立在你有Shell指令基础和Git操作基础之上，如果不了解的话，需要查阅相关资料。\n\n先解释几个专业术语：\n\n* [Ruby](https://www.ruby-lang.org/zh_cn/)\n\t* Ruby 是一种编程语言。Octopress 是用 Ruby语言 实现的。我们不需要对它有太多了解，只需要正确安装 Ruby 的环境（Ruby版本必须不低于1.9.3-p0，后面会详细介绍）及按步骤执行指令即可。\n* [RubyGems](https://rubygems.org/)\n\t* RubyGems（简称 gems）是一个用于对 Ruby组件进行打包的 Ruby 打包系统。它可以用来查找、安装、升级和卸载软件包。我们也是通过它安装Octopress包的\n* [RVM](https://rvm.io/)\n\t* RVM  是Ruby Version Manager的简称，是一款 Ruby 语言安装、管理的工具。我们对 Ruby 的操作是通过它的指令完成的。\n* [Jekyll](http://jekyll.bootcss.com/)\n\t* Jekyll 一个简单的博客形态的静态站点生产机器。\tJekyll 有一套模板目录，可以将 Markdown文件（或者Textile）转换为静态网页，并生成一个完整的可发布的静态网站。\n\t* 同时，我们可以将产生的静态网站布置到 GitHub Pages 上，生成个人博客站点。\n\t* 想了解更多内容可以查看[中文文档](http://jekyll.bootcss.com/docs/home/)。\n* [Octopress](http://niumeng.me/blog/2015/08/26/create-your-website-1-init/www.github.com/imathis/octopress)\n\t* Octopress 是基于 Jekyll 的博客框架。他们的关系就像 jQuery 与 js 的关系一样。\n\t* 它为我们提供了现成的美观的主题模板，并且配置简单，使用方便，大大降低了我们建站的门槛。\n* [Git](http://rogerdudler.github.io/git-guide/index.zh.html)\n\t* 分布式版本控制工具，跟它有点类似的是SVN，只是两者使用场景不一样。\n* [GitHub](https://www.github.com/)\n\t* GitHub 是全球最热的开源社区，程序界的 Facebook。它为我们提供代码托管服务，以及我们搭建博客所需要的 Pages 服务。\n* [GitHub Pages](https://pages.github.com/)\n\t* GitHub Pages 是 GitHub 提供的一项服务。它用于显示托管在 GitHub 上的静态网页。所以我们可以用 Github Pages 搭建博客，当然我们也可以把项目的文档和主页放在上面。\n\n通过以上内容，我们大概能够明白 Octopress 建站的原理：\n我们使用基于 Jekyll 的 Octopress 站点生成工具，生成本地的静态网站。然后将静态网站托管到 GitHub 为我们提供的 GitHub Pages 服务上。访问 **username**.github.io 即可显示你的个人博客站了\n\n---\n明白了上面这些内容，下面进行具体的搭建工作：\n### 第一步：安装 Ruby\nMac自带Ruby环境打开终端，安装 RVM ，终端执行指令：\n\n```bash\n$ curl -L https://get.rvm.io | bash -s stable --ruby\n```\n\n接下来我们要查看自己的 Ruby 环境\n\n```bash\n$ ruby -v\n```\n\n如果你的 Ruby 版本不低于 1.9.3-p0 可以忽略 Ruby 的安装（或升级），直接跳到安装 RubyGems 。 否则，我们执行之后的操作，终端执行指令：\n\n```\n$ rvm install 1.9.3\n$ rvm use 1.9.3\n```\n\n然后安装 RubyGems， 终端执行指令：\n\n```\n$ rvm rubygems latest\n```\n\n到这里第一步完成。我们可以再执行一次第一条指令 `ruby -v` 来查看当前 Ruby 的版本了。\n\n### 第二步：安装Octopress\n因为Mac系统自动git环境，所以我们不需要考虑git的安装。直接将 Octopress的项目clone到本地，在终端执行指令：\n\n```\n$ git clone git://github.com/imathis/octopress.git octopress\n```\n\n完成后进入 octopress 的目录\n\n```\n$ cd octopress\n```\n\n接下来，安装依赖：\n\n```\n$ gem install bundler\n# 这时你可能会遇到没有权限的问题，那么我们需要加上sudo重新执行，并输入密码。\n$ sudo gem install bundler\n# 接下来执行：\n$ bundle install\n```\n\n这时你可能还会遇到问题如下：\n\n```\nFetching gem metadata from https://rubygems.org/...........\nResolving dependencies...\n\nGem::RemoteFetcher::FetchError: SocketError: getaddrinfo: Name or service not known (https://rubygems.org/gems/rake-10.4.2.gem)\nAn error occurred while installing rake (10.4.2), and Bundler cannot continue.\n```\n\n这是因为被墙了，解决办法有两个： 一个是，可以使用自己的翻墙工具； 另一个，淘宝做了一个gem的镜像。我们需要在Octopress的文件目录下找到Gemfile文件，将其中的`source 'https://rubygems.org/'`改为`source 'https://ruby.taobao.org/'`\n\n再重新运行`bundle install`就可以了。 这段内容可以参考 [bundle install 提示如下，是需要翻墙解决么](http://www.imooc.com/qadetail/59105)。\n\n下面就可以安装 Octopress 的默认主题了，终端执行指令：\n\n```\nrake install\n```\n\n这样一个最基本的个人博客站就产生了。\n\n![Octoress init](http://ww3.sinaimg.cn/mw690/64124373gw1ezxvho05u3j20lx0ab764.jpg)\n\n#### 安装`octostrap3`主题（可选）\n\n```\n$ cd octopress\n$ git clone https://github.com/kAworu/octostrap3.git .themes/octostrap3\n$ rake \"install[octostrap3]\"\n$ rake generate\n```\n\n会提示以下信息\n\n```\nA theme is already installed, proceeding will overwrite existing files. Are you sure? [y/n]\n```\n\n输入`y`继续，然后开始安装。。。\n\n```\n## Copying octostrap3 theme into ./source and ./sass\nmkdir -p source\ncp -r .themes/octostrap3/source/. source\nmkdir -p sass\ncp -r .themes/octostrap3/sass/. sass\nmkdir -p source/_posts\nmkdir -p public\n```\n\n显示上面的内容完成后没有错误，就安装主题完成\n\n---\n\n可以看出，现在显示得都是预设值，并不是我们想要的，所以需要修改Octopress目录下的_config.yml文件。\n\n文件目录`_config.yml`\n\n描述：保存配置数据。很多配置选项都会直接从命令行中进行设置，但是如果你把那些配置写在这儿，你就不用非要去记住那些命令了。\n\n_config.yml 文件共分为3个部分内容\n\n* Main Configs\n* Jekyll & Plugins\n* 3rd Party Settings\n\n目前，我们只需要关注第一部分Main Configs。\n\n\t# ----------------------- #\n\t#      Main Configs       #\n\t# ----------------------- #\n\n\t#网站地址\n\turl: http://wangruofeng.github.io\n\n\t#网站标题\n\ttitle: 王若风的技术博客\n\n\t#网站副标题\n\tsubtitle: 天天向上.\n\n\t#网址作者，通常显示在页尾和每篇文章的尾部\n\tauthor: Ace\n\n\t#搜索引擎\n\t#simple_search: http://google.com/search\n\n\t#网站的描述，出现在HTML页面中的 meta 中的 description\n\t#description:\n\n\n\n\n对应填入你的个人信息，其中url为必填的，一般填GitHub仓库对应的连接，其内容大致就是 **username**.github.io ，这个地址我们会在后面步骤中获得。\n\n### 第三步：集成 GitHub Pages\n\n1.注册 Github 账号\n\n这个没什么好说的，早晚需要，去 <http://github.com> 注册吧。\n\n2.在 GitHub 上创建一个代码参考，项目名称命名规则为 **username**.github.io，username必须与用户名称一致。\n\n3. 域名指向（可选）\n如果你有自己的域名可用，可以在这时就配置好，毕竟解析起来需要一段时间，不如在我们搭建博客的时候让它开始，这样我们搭建完成后，基本上就可以直接用自有域名访问了。\n\n我的是在[万网](http://wanwang.aliyun.com/domain/?utm_medium=text&utm_source=baidu&utm_campaign=st1&utm_content=se_2485)申请的，原价一年100多点现在有活动便宜的几块的都有，想要个性域名的可以去注册一个。\n\n* 如果你用的是顶级域名，比如 wangruofeng007.com, 请创建两个 A 记录 (A Record) 分别指向 `192.30.252.153` 和 `192.30.252.154`.\n\n* 如果你使用二级域名，比如 blog.wangruofeng007.com, 请将该域名的 CNAME 指向 [your_username].github.io, 把其中的 [your_username]换成你自己在 Github 上的用户名。\n\n* 如果你暂时没有域名，这一步可以暂时不用管\n\nPs. 在创建过程中最好不要`添加忽略文件`和`README`文件。因为我们要把本地的 git 仓库同步到 GitHub 远程仓库中。如果再远程仓库中添加了其他文件，需要我们执行 pull 操作。除非你能非常熟练的使用 git ，否则不建议你制造不必要的麻烦。\n接下来将本地代码仓库同步到 GitHub 上，执行终端指令：\n\n```\n$ rake setup_github_pages\n```\n\n它会要求你绑定远程仓库的地址，此时只需要输入即可：\n\n```\n$ git@github.com:username/username.github.com.git\n```\n\n这样就会将 Octopress 生成的静态站点与 GitHub 进行绑定了。\n\n之后我们创建第一篇文章：\n\n```\nrake new_post[\"title\"]\n```\n\n然后会有一个名为 yyyy-mm-dd-Post-Title.markdown 的文件在 octopress/source/_posts 目录下生成，其中 yyyy-mm-dd 是你当时的日期。然后执行以下命令：\n\n```\ncd source/_posts/\nvim yyyy-mm-dd-Post-Title.markdown\n```\n\n即可用 vim 编辑器编辑的刚才的文章了，好吧我知道你作为这篇文章的读者并不是一个能熟练使用 vim 的人，那么请在命令行输入 q！退出这个编辑器。如果你不想假装是个黑客的话，其实发布文章并不需要这么麻烦。\n\n我们直接打开 `octopress/source/_posts` 文件夹，找到刚才生成的文件，用你喜欢的 Markdown 编辑器（免费的我推荐 [Mou](http://mouapp.com/)或者[Atom](https://atom.io)）或者文本编辑器打开，对文章内容进行编辑。\n\n打开文件后，你会发现文章开头有这么一段信息:\n\n```\n---  \nlayout: post  \ntitle: \"Post Title\"  \ndate: yyyy-mm-dd hh:mm:ss  \ncomments: true  \ncategories:  \"\"\n---\n```\n\n这其实是这篇文章的元数据：layout 暂时不要理会；title 是这篇文章显示在最终网页上的标题；date 部分是详细的文件生成时间，如 2014-01-28 03:35:00；comment 部分表示是否允许评论，目前显示是允许，如果想关闭评论，请改为 false；categories 指这篇文章的分类目录，请在后面引号中输入,不用引号也可以，多个分类用`空格`隔开，如果没有该目录，则会自动生成。请不要删除这段信息，在这段信息下面开始你的文章内容\n\n这件事情给我们的启发是，以后发布文章，其实并不需要使用终端命令行生成文件。可以直接将自己写好的文章放到这个文件夹下面，当然请按照 `yyyy-mm-dd-Post-Title.markdown` 这样的文件格式命名，同时记得在文章前面添加元数据信息。这种做法生成的文章与上面的方法无异\n\n生成的新文章在source/_post/目录下，文件名构成为时间和标题的拼音。我们可以用Markdown编辑器对文章进行修改。\n之后生成静态站点，终端执行指令：\n\n```\n# 生成静态站点\n$ rake generate\n```\n\n如果你想预览本地的站点，可以执行终端指令：\n\n```\n# 预览静态站点\n$ rake preview\n```\n\n此时，可以使用浏览器打开`localhost:4000` 查看效果。如果没有问题可以将静态站点同步到 GitHub 远程仓库中，终端执行指令：\n\n```\n# 同步内容\n$ rake deploy\n```\n\n你会发现我们的静态站点已经被 push 到 GitHub仓库的 master 分支上。稍等几分钟，访问 `username.github.io` (或者 `username.github.com`)，就会发现你的个人博客站已创建成功了。\n如果你还想给自己的本地资源文件（如Markdown文件等内容）也同步到 GitHub 中，可以执行以下指令：\n\n```\n$ git add .\n$ git commit -m \"comment\"\n$ git push origin source\n```\n\n这样我们的资源文件就会同步到 GitHub 的 source 分支了。\n\n### 使用自己的域名（可选）\n如果你有自己的域名，并且想指向这个新博客的话，请首先确保执行了第三步的`域名指向（可选）`的内容。如果没有执行，可以随时执行。\n然后执行下面的命令，注意把 your-domain.com 换成你自己的域名。\n\n```\necho 'your-domain.com' >> source/CNAME\n```\n\n这句话的意思是在`source`分支下创建一个CNAME的文件并且将`your-domain.com`写入文件\n\n然后再次执行以下命令：\n\n```\nrake generate\nrake deploy\n```\n\n或者二合一\n\n```\nrake gen_deploy\n```\n\n这样你就可以使用自己的域名了。域名解析需要一段时间，如果没有马上生效，请不要着急。如果长时间没有生效，请确保完整执行了 `域名指向（可选）`和`使用自己的域名（可选）`的内容。\n\n\n现在我们完成了个人博客的初级搭建，足够满足我们的基本需求。\n\n### 错误处理\n\n出现下面的错误：\n\n```\nPushing generated _deploy website Permission denied (publickey).\nfatal: Could not read from remote repository.\n```\n\n这个错误是因为缺少`SSH` keys ，只有拥有这个key才有权限push到远程仓库，通过这种方式实现权限安全控制。\n解决方案:[Generating SSH keys](https://help.github.com/articles/generating-ssh-keys/)\n\n出现下面错误：\n\n```\n## Pushing generated _deploy website\nTo git@github.com:wangruofeng/wangruofeng.github.io.git\n ! [rejected]        master -> master (non-fast-forward)\nerror: failed to push some refs to 'git@github.com:wangruofeng/wangruofeng.github.io.git'\nhint: Updates were rejected because the tip of your current branch is behind\nhint: its remote counterpart. Integrate the remote changes (e.g.\nhint: 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```\n\n原因，是修改了远程仓库，导致本地本地版本落后于远程仓库版本。\n最佳解决方案：\n\n```\ncd octopress/_deploy\ngit pull origin master\ncd ..\nrake deploy\n```\n\n参考链接：[rake-gen-deploy-rejected-in-octopress](http://stackoverflow.com/questions/17609453/rake-gen-deploy-rejected-in-octopress)\n\n\n参考资料：\n\n* 唐巧的博客: [象写程序一样写博客：搭建基于github的博客]（http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/）\n* 觅珠人: [第一篇博文：用Octopress搭建博客系统](http://tchen.me/posts/2012-12-16-first-blog.html)\n* 破船之家: [你好！github页面](http://beyondvincent.com/blog/2013/07/27/107-hello-page-of-github/)\n* opoo.org: [Octopress 博客系统 —— a Blogging Framework for Hackers](http://opoo.org/octopress/)\n* Ocotpress: [Octopress Documentation](http://octopress.org/docs/)\n* Havee’s Space: [为 Octopress 添加多说评论系统](http://havee.me/internet/2013-02/add-duoshuo-commemt-system-into-octopress.html)\n* colors4.us: [Octopress博客从零开始 III](http://colors4.us/blog/2012/01/08/octopressbo-ke-cong-ling-kai-shi-iii/)\n* 浮生猎趣:[用Octopress在Github搭建博客，并绑定独立域名](http://blog.lessfun.com/blog/2013/11/27/create-blog-in-github-page-using-octopress-and-binding-domain/)\n* Aster0id的个人博客:[制作个人博客站（一）：Mac系统下使用 Octopress + GitHub Pages 搭建个人博客](http://niumeng.me/blog/2015/08/26/create-your-website-1-init/)\n* [octopress博客搭建和个性化配置](http://www.jianshu.com/p/0ac2ac1a8e45)\n\n备注：欢迎转载，但请一定注明出处！ <http://blog.wangruofeng007.com>\n","tags":["Octopress"],"categories":["博客搭建"]}]