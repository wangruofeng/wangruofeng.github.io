<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王若风的技术博客</title>
  
  <subtitle>世界尽头の冷酷仙境</subtitle>
  <link href="https://blog.wangruofeng007.com/atom.xml" rel="self"/>
  
  <link href="https://blog.wangruofeng007.com/"/>
  <updated>2024-11-13T08:18:02.259Z</updated>
  <id>https://blog.wangruofeng007.com/</id>
  
  <author>
    <name>王若风</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 FFmpeg CLI 处理视频</title>
    <link href="https://blog.wangruofeng007.com/2024/11/13/%E4%BD%BF%E7%94%A8-FFmpeg-CLI-%E5%A4%84%E7%90%86%E8%A7%86%E9%A2%91/"/>
    <id>https://blog.wangruofeng007.com/2024/11/13/%E4%BD%BF%E7%94%A8-FFmpeg-CLI-%E5%A4%84%E7%90%86%E8%A7%86%E9%A2%91/</id>
    <published>2024-11-13T07:47:18.000Z</published>
    <updated>2024-11-13T08:18:02.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FFmpeg-概述"><a href="#FFmpeg-概述" class="headerlink" title="FFmpeg 概述"></a>FFmpeg 概述</h1><blockquote><p>TLDR：FFmpeg 是领先的多媒体框架，能够<strong>解码</strong>、<strong>编码</strong>、 <strong>转码</strong>、<strong>复用</strong>、<strong>解复用</strong>、流式<strong>传输</strong>、<strong>过滤</strong>和<strong>播放</strong>人类和机器创建的几乎所有内容。它支持从最晦涩的古老格式到最前沿的格式。无论它们是由某个标准委员会、社区还是公司设计的。它还具有高度的可移植性：FFmpeg 可以在各种构建环境、机器架构和配置下在 Linux、Mac OS X、Microsoft Windows、BSD、Solaris 等平台上编译、运行并通过我们的测试基础架构 <a href="http://fate.ffmpeg.org/">FATE</a>。</p><p>more: <a href="https://ffmpeg.org/about.html">官网介绍</a></p></blockquote><p><img src="https://blog.wangruofeng007.com/img/hexo/ffmpeg_cli.webp" alt=" "></p><span id="more"></span><h1 id="FFmpeg-特点"><a href="#FFmpeg-特点" class="headerlink" title="FFmpeg 特点"></a>FFmpeg 特点</h1><p>从技术的角度来看，FFmpeg 是一个非常强大的 <strong>开源多媒体框架</strong>，广泛应用于音视频处理、转换、流媒体传输等场景。它的特点可以从以下几个方面进行详细阐述：</p><h2 id="支持多种音视频格式与编解码器"><a href="#支持多种音视频格式与编解码器" class="headerlink" title="支持多种音视频格式与编解码器"></a><strong>支持多种音视频格式与编解码器</strong></h2><ul><li><strong>格式支持</strong>：FFmpeg 支持几乎所有主流的音视频文件格式（容器格式），如 MP4、AVI、MKV、FLV、MOV、WebM 等。它还支持各种音频格式，如 MP3、AAC、WAV、OGG 等。</li><li><strong>编解码器支持</strong>：FFmpeg 支持大量的编解码器（Codecs），包括视频编码（H.264、HEVC、VP9 等）和音频编码（AAC、MP3、Opus 等）。其内置的 <strong>libavcodec</strong> 库为最常用的音视频编解码器提供了全面支持。</li></ul><h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a><strong>跨平台</strong></h2><p>FFmpeg 支持多种操作系统，包括 <strong>Windows</strong>、<strong>Linux</strong>、<strong>macOS</strong> 等。开发者可以在不同平台上使用相同的工具和库，具有极强的跨平台兼容性。</p><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a><strong>命令行工具</strong></h2><p>FFmpeg 提供了一个非常强大的 <strong>命令行工具</strong>（<code>ffmpeg</code>），可以直接通过命令行进行音视频处理、转码、剪辑、合并、提取音频等操作。FFmpeg 的命令行工具不仅灵活、强大，还可以与脚本语言（如 Bash、Python 等）结合进行批量处理。</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a><strong>高性能</strong></h2><ul><li><strong>硬件加速支持</strong>：FFmpeg 支持硬件加速解码与编码（如 NVIDIA CUDA、Intel Quick Sync、AMD VCE 等），这对于处理高分辨率、高清视频时非常重要。硬件加速能显著提升 FFmpeg 处理的性能，减少 CPU 占用。</li><li><strong>多线程支持</strong>：FFmpeg 支持多线程解码、编码，能够在多核处理器上充分利用硬件资源，提升音视频处理的速度。</li></ul><h2 id="流媒体功能"><a href="#流媒体功能" class="headerlink" title="流媒体功能"></a><strong>流媒体功能</strong></h2><p>FFmpeg 在流媒体处理方面也非常强大，支持 <strong>RTMP、HLS、RTSP、MMS、DASH</strong> 等协议。它可以用来进行音视频推流和拉流，广泛应用于直播、视频会议、在线广播等领域。</p><h2 id="插件化架构"><a href="#插件化架构" class="headerlink" title="插件化架构"></a><strong>插件化架构</strong></h2><p>FFmpeg 是一个模块化的框架，各个模块（如编解码器、过滤器、复用器、解复用器等）都有独立的功能，开发者可以根据需要进行定制、扩展或优化。它提供了丰富的 API，允许开发者对其进行二次开发。</p><h2 id="强大的音视频处理功能"><a href="#强大的音视频处理功能" class="headerlink" title="强大的音视频处理功能"></a><strong>强大的音视频处理功能</strong></h2><p>FFmpeg 不仅仅是一个编解码工具，它还能进行多种音视频处理，如：</p><ul><li><strong>视频剪辑与合并</strong>：剪辑视频片段、合并多个视频文件。</li><li><strong>格式转换</strong>：将视频从一种格式转换为另一种格式（如 MP4 转为 WebM）。</li><li><strong>音视频提取</strong>：从视频中提取音频，或从音频中提取特定部分。</li><li><strong>视频缩放与旋转</strong>：改变视频的分辨率，或者旋转视频（如 90°、180°、270°）。</li><li><strong>字幕处理</strong>：提取、嵌入字幕，支持多种字幕格式（SRT、ASS 等）。</li><li><strong>音视频滤镜</strong>：如加水印、调整亮度、对比度，甚至是更复杂的视觉特效。</li></ul><h2 id="高可定制性"><a href="#高可定制性" class="headerlink" title="高可定制性"></a><strong>高可定制性</strong></h2><p>FFmpeg 提供了许多配置选项和灵活的参数，使得它可以根据用户需求进行高程度的定制。例如，开发者可以选择只编译需要的部分，裁剪不需要的编解码器，以减小程序体积或提高效率。</p><h2 id="强大的社区支持"><a href="#强大的社区支持" class="headerlink" title="强大的社区支持"></a><strong>强大的社区支持</strong></h2><p> FFmpeg 拥有一个活跃的开发者社区和广泛的文档资源，问题通常可以通过查阅官方文档或社区支持得到解决。开发者可以在社区中找到很多开源代码、教程、博客和技术文章。</p><h2 id="常见的使用场景"><a href="#常见的使用场景" class="headerlink" title="常见的使用场景"></a><strong>常见的使用场景</strong></h2><ul><li><strong>视频转换</strong>：例如将视频从 MKV 转换为 MP4，或者从 H.264 编码转换为 HEVC（H.265）编码。</li><li><strong>视频直播与点播</strong>：FFmpeg 支持 RTMP、HLS 等协议，广泛应用于流媒体服务器、直播推流等。</li><li><strong>音视频同步</strong>：处理多个音视频流的同步问题，特别是在直播和视频会议中。</li><li><strong>多媒体处理应用</strong>：开发音视频播放器、音视频编辑工具、流媒体服务等应用。</li></ul><p><strong>总结</strong></p><p>FFmpeg 的特点主要体现在其全面的 <strong>格式支持</strong>、高效的<strong>编解码能力</strong>、灵活的 <strong>命令行工具</strong>、跨平台特性、强大的 <strong>音视频处理功能</strong>、流媒体支持和极强的 <strong>定制性</strong>。它的 <strong>开源</strong> 特性使得它成为音视频开发领域的主流工具，广泛应用于视频转码、流媒体服务、视频处理、视频会议等各种场景。</p><h1 id="安装指引"><a href="#安装指引" class="headerlink" title="安装指引"></a>安装指引</h1><h2 id="通过源码"><a href="#通过源码" class="headerlink" title="通过源码"></a>通过源码</h2><p>参考官网的指引 <a href="https://ffmpeg.org/download.html">https://ffmpeg.org/download.html</a> ，选择对应的平台进行下载安装。</p><h2 id="通过-CLI"><a href="#通过-CLI" class="headerlink" title="通过 CLI"></a>通过 CLI</h2><p>通过 FFmpeg CLI 安装较为简单，推荐这种方式。</p><p>第一步：安装 Homebrew (<a href="http://brew.sh/">http://brew.sh/</a>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>第二步：安装 FFmpeg</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure><p>第三步：验证是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行</span></span><br><span class="line"><span class="built_in">where</span> ffmpeg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出下面信息代表安装成功</span></span><br><span class="line">/opt/homebrew/bin/ffmpeg</span><br></pre></td></tr></table></figure><h1 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h1><p>找点视频素材进行测试，这里通过 Demo 网址<a href="https://file-examples.com/index.php/sample-video-files/sample-mp4-files/">下载 Demo 视频</a>进行演示。</p><h2 id="剪辑"><a href="#剪辑" class="headerlink" title="剪辑"></a>剪辑</h2><p>有时候我们需要截取一个长视频的其中某一段内容，比如从一个视频的第 10 秒开始，截取 6 秒的内容，也就是 10~16 秒的内容，输入一个 out.mp4 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从00:00:10开始，截取的长度为00:00:06</span></span><br><span class="line">ffmpeg -i in.mp4 -ss 00:00:10 -t 00:00:06 -acodec aac -vcodec h264 -strict -2 out.mp4</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>-i 代表输入待处理的文件</li><li>-ss 代表开始的时间</li><li>-t 代表截取的长度。</li><li>-acodec 音频编解码器</li><li>-vcodec 音频编解码器</li></ul><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>很多时候我们需要把一个高分辨率的视频处理成一个低分辨率的视频，以达到减小视频体积的目的。举个例子：把一个 <em>1080</em>*<em>1920 的视频缩小到 360*640:</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1080*1920 --&gt; 360*640</span></span><br><span class="line">ffmpeg -i in.mp4 -vf scale=360:640 -acodec aac -vcodec h264 out.mp4</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>-i 代表输入</li><li>-vf 的全称是 video filter，即：视频滤镜，缩放其实就是给视频添加一个滤镜。</li><li>scale&#x3D;360:640 scale 是一种滤镜，缩放滤镜，格式是：scale&#x3D;width:height，其中，width 和 height 分别是处理后的宽和高</li></ul><h2 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h2><p>有时候我们想截取一个大视频的中间一部分画面，比如一个 <em>1080</em>*<em>1920 的视频，我们想截取中间的 540*540</em> 的部分，这个也可以实现的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i in.mp4 -strict -2 -vf crop=540:540:50:50 out.mp4 </span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>crop 和上面的 scale 一样，也是视频滤镜的一种，crop 是裁剪滤镜。四个参数分别是 width:height:x:y，其中 width 和 height 指的是裁剪的宽和高，x 和 y 代表裁剪的区域的左上角的坐标，坐标系原点为原视频的左上角。比如 0:0 就代表原视频的左上角，50:50 就代表以原视频的左上角为原点的坐标系的 50:50 位置</li></ul><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>使用 ffmpeg 可以轻松地旋转视频。举个例子：将一个视频顺时针旋转 90 度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i in.mp4 -vf rotate=PI/2:ow=1080:oh=1920 out.mp4</span><br></pre></td></tr></table></figure><p>参数解释：</p><p>视频旋转其实也是一直滤镜。</p><ul><li>rotate&#x3D;PI&#x2F;2 rotate 是旋转滤镜，后面的“PI&#x2F;2”旋转角度（正数代表顺时针），这里是 90 度 rotate 除了指定旋转角度的参数外，还有其他一些参数：<ul><li>ow 全称是 out width，输出视频的宽度，如果不指定，默认是输入视频的宽度</li><li>oh 全称是 out height，输出视频的高度，如果不指定，默认是输入视频的高度</li></ul></li></ul><h2 id="调节帧率"><a href="#调节帧率" class="headerlink" title="调节帧率"></a>调节帧率</h2><p>帧率会很大程度上影响画面的流畅度和视频的体积，帧率越大，画面越流畅，同时视频体积越大。</p><p>我们有时候需要通过降低帧率来减小视频的体积。</p><p>举个例子：将一个视频的帧率降到 15</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i in.mp4 -r 15 out.mp4</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>-r 帧率</li></ul><h2 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h2><p>ffmpeg 具备强大的格式转换功能，这里举几个常用的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mov --&gt; mp4</span></span><br><span class="line">ffmpeg -i in.mov -vcodec copy -acodec copy out.mp4</span><br><span class="line"><span class="comment"># flv --&gt; mp4</span></span><br><span class="line">ffmpeg -i in.flv -vcodec copy -acodec copy out.mp4</span><br><span class="line"><span class="comment"># gif --&gt; mp4</span></span><br><span class="line">ffmpeg -i in.gif -vf scale=420:-2,format=yuv420p out.mp4  </span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li><code>-vf</code> 参数用于设置视频过滤器（video filter）。这里使用了两个视频过滤器：<code>scale</code> 和 <code>format</code>。<ul><li><code>scale=420:-2</code>：<ul><li><code>scale</code> 是用来调整视频分辨率的过滤器。</li><li><code>420</code> 表示视频的 <strong>宽度</strong> 被设定为 420 像素。</li><li><code>-2</code> 表示高度将自动计算，以保持输入视频的纵横比。<code>-2</code> 的使用意味着 FFmpeg 会根据宽度的变化计算出一个合适的高度，以确保视频不会被拉伸或变形。FFmpeg 会自动计算这个高度，确保宽高比不变。</li></ul></li><li><code>format=yuv420p</code>：<ul><li><code>format</code> 用来设置视频的 <strong>像素格式</strong>。</li><li><code>yuv420p</code> 是一种常见的视频像素格式，特别是对于 MP4 格式来说。这种格式在视频压缩中效率较高，并且被广泛支持。<code>yuv420p</code> 是一种 <strong>YUV 色彩空间</strong>，其中每个像素的亮度信息（Y）是完整的，而色度信息（U、V）则进行了子采样，减少了数据量。</li></ul></li></ul></li></ul><h2 id="查看视频的详细信息"><a href="#查看视频的详细信息" class="headerlink" title="查看视频的详细信息"></a>查看视频的详细信息</h2><p>有的时候我们需要在处理之前先了解一下视频的参数信息，比如分辨率、比特率等等。可以使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不加任何参数，只指定输入的视频</span></span><br><span class="line">ffmpeg -i in.mp4</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;FFmpeg-概述&quot;&gt;&lt;a href=&quot;#FFmpeg-概述&quot; class=&quot;headerlink&quot; title=&quot;FFmpeg 概述&quot;&gt;&lt;/a&gt;FFmpeg 概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;TLDR：FFmpeg 是领先的多媒体框架，能够&lt;strong&gt;解码&lt;/strong&gt;、&lt;strong&gt;编码&lt;/strong&gt;、 &lt;strong&gt;转码&lt;/strong&gt;、&lt;strong&gt;复用&lt;/strong&gt;、&lt;strong&gt;解复用&lt;/strong&gt;、流式&lt;strong&gt;传输&lt;/strong&gt;、&lt;strong&gt;过滤&lt;/strong&gt;和&lt;strong&gt;播放&lt;/strong&gt;人类和机器创建的几乎所有内容。它支持从最晦涩的古老格式到最前沿的格式。无论它们是由某个标准委员会、社区还是公司设计的。它还具有高度的可移植性：FFmpeg 可以在各种构建环境、机器架构和配置下在 Linux、Mac OS X、Microsoft Windows、BSD、Solaris 等平台上编译、运行并通过我们的测试基础架构 &lt;a href=&quot;http://fate.ffmpeg.org/&quot;&gt;FATE&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;more: &lt;a href=&quot;https://ffmpeg.org/about.html&quot;&gt;官网介绍&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.wangruofeng007.com/img/hexo/ffmpeg_cli.webp&quot; alt=&quot; &quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CLI" scheme="https://blog.wangruofeng007.com/categories/CLI/"/>
    
    
    <category term="音视频" scheme="https://blog.wangruofeng007.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="FFmpeg" scheme="https://blog.wangruofeng007.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>常见算法之排序算法</title>
    <link href="https://blog.wangruofeng007.com/2024/11/09/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://blog.wangruofeng007.com/2024/11/09/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2024-11-09T14:05:26.000Z</published>
    <updated>2024-11-13T08:18:44.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>收集 排序 相关的常见算法</p><p><img src="https://blog.wangruofeng007.com/img/hexo/data_structures_algo.webp" alt=" "></p><span id="more"></span><h1 id="评价维度"><a href="#评价维度" class="headerlink" title="评价维度"></a>评价维度</h1><ul><li><strong>运行效率</strong>：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。</li><li><strong>就地性</strong>：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。</li><li><strong>稳定性</strong>：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。稳定排序是多级排序场景的必要条件。假设我们有一个存储学生信息的表格，第 1 列和第 2 列分别是姓名和年龄。在这种情况下，非稳定排序可能导致输入数据的有序性丧失。</li><li><strong>自适应性</strong>：自适应排序能够利用输入数据已有的顺序信息来减少计算量，达到更优的时间效率。自适应排序算法的最佳时间复杂度通常优于平均时间复杂度。</li><li><strong>是否基于比较</strong>：基于比较的排序依赖比较运算符（&lt;、&#x3D;、&gt;）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为 O(nlog⁡n) 。而非比较排序不使用比较运算符，时间复杂度可达 O(n) ，但其通用性相对较差。</li></ul><hr><p>理想排序算法：<strong>运行快、原地、稳定、自适应、通用性好</strong>。</p><h1 id="时间复杂度-O-n-2"><a href="#时间复杂度-O-n-2" class="headerlink" title="时间复杂度 - O(n^2)"></a>时间复杂度 - O(n^2)</h1><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>原理</strong>：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。</p><p><strong>特性</strong>：</p><ul><li>时间复杂度为 O(n^2)、非自适应排序</li><li>空间复杂度为 O(1)、原地排序</li><li>非稳定排序</li></ul><p><strong>代码实现</strong>:</p><blockquote><p>两层遍历，将小的往左边交换</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>];</span><br><span class="line">  selectionSort(list);</span><br><span class="line">  <span class="built_in">print</span>(list);</span><br><span class="line">  <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> selectionSort(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums) &#123;</span><br><span class="line">  <span class="built_in">int</span> n = nums.length;</span><br><span class="line">  <span class="comment">// 外循环：未排序区间未 [i, n-1]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 内循环：找到未排序区间的最小值</span></span><br><span class="line">    <span class="built_in">int</span> k = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="comment">// 记录最小元素索引</span></span><br><span class="line">      <span class="keyword">if</span> (nums[j] &lt; nums[k]) k = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将该最小元素与未排序区间的首个元素交换</span></span><br><span class="line">    <span class="built_in">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[k];</span><br><span class="line">    nums[k] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>原理</strong>：通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。</p><p><strong>特性</strong>：</p><ul><li>时间复杂度为 O(n^2)、自适应排序</li><li>空间复杂度为 O(1)、原地排序</li><li>稳定排序</li></ul><p><strong>代码实现</strong>:</p><blockquote><p>两层遍历，将大的往左边交换</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>];</span><br><span class="line">  bubbleSort(list);</span><br><span class="line">  <span class="built_in">print</span>(list);</span><br><span class="line">  <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="keyword">void</span> bubbleSort(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums) &#123;</span><br><span class="line">  <span class="comment">// 外循环：未排序区间为 [0,i]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 内循环：将未排序区间 [0,i] 中的最大元素交换至该区间的右端</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="comment">// 交换 nums[i] 与 nums[j+1]</span></span><br><span class="line">      <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">int</span> tmp = nums[j];</span><br><span class="line">        nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">        nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>原理</strong>：我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置</p><p><strong>特性</strong>：</p><ul><li>时间复杂度为 O(n^2)、自适应排序</li><li>空间复杂度为 O(1)、原地排序</li><li>稳定排序</li></ul><p><strong>代码实现</strong>:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>];</span><br><span class="line">  insertionSort(list);</span><br><span class="line">  <span class="built_in">print</span>(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">void</span> insertionSort(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums) &#123;</span><br><span class="line">  <span class="comment">// 外循环：已排序区间为 [0,i-1]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">base</span> = nums[i], j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 内循环: 将 base 插入到已排序区间 [0,i-1] 中的正确位置</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; <span class="keyword">base</span>) &#123;</span><br><span class="line">      <span class="comment">// 将 nums[j] 向右移动一位</span></span><br><span class="line">      nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j + <span class="number">1</span>] = <span class="keyword">base</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序（插入排序）"><a href="#希尔排序（插入排序）" class="headerlink" title="希尔排序（插入排序）"></a>希尔排序（插入排序）</h2><p><strong>原理</strong>：是一种基于插入排序的排序算法，通过先比较较远的元素，再逐步减少间隔，最终转换为普通的插入排序。希尔排序通过使用间隔序列（或称步长）来对数组进行分组排序，减少逆序情况，提高排序效率。</p><p><strong>特性</strong>：</p><ul><li>时间复杂度，在最坏情况下（不良步长选择）为 **O(n^2)**，但在最佳情况下可以接近 <strong>O(nlogn)</strong></li><li>空间复杂度为 <strong>O(1)、</strong>原地排序</li><li>不稳定排序</li></ul><p><strong>代码实现</strong>:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 示例数组</span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; arr = [<span class="number">12</span>, <span class="number">34</span>, <span class="number">54</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  shellSort(arr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出排序后的数组</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;排序后的数组: <span class="subst">$arr</span>&quot;</span>);</span><br><span class="line">  <span class="comment">// 排序后的数组: [2, 3, 12, 34, 54]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="keyword">void</span> shellSort(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; arr) &#123;</span><br><span class="line">  <span class="built_in">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择步长，通常从数组长度的一半开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> gap = n ~/ <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap ~/= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用插入排序对每个间隔为 gap 的分组进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">int</span> tmp = arr[i];</span><br><span class="line">      <span class="built_in">int</span> j;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 插入排序，将 arr[i] 插入到合适的位置</span></span><br><span class="line">      <span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[i - gap] &gt; tmp; j -= gap) &#123;</span><br><span class="line">        arr[j] = arr[j - gap];</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间复杂度-O-nlogn"><a href="#时间复杂度-O-nlogn" class="headerlink" title="时间复杂度  - O(nlogn)"></a>时间复杂度  - O(nlogn)</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>原理</strong>：是一种基于分治策略的排序算法，快速排序的核心操作是“<strong>哨兵划分</strong>”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。</p><p><strong>特性</strong>：</p><ul><li>时间复杂度为 O(nlog⁡n)、非自适应排序</li><li>空间复杂度为 O(n)、原地排序</li><li>非稳定排序</li></ul><p><strong>代码实现</strong>:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>];</span><br><span class="line">  quickSort(list, <span class="number">0</span>, list.length - <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">print</span>(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素交换</span></span><br><span class="line"><span class="keyword">void</span> _swap(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums, <span class="built_in">int</span> i, <span class="built_in">int</span> j) &#123;</span><br><span class="line">  <span class="built_in">int</span> tmp = nums[i];</span><br><span class="line">  nums[i] = nums[j];</span><br><span class="line">  nums[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哨兵划分</span></span><br><span class="line"><span class="built_in">int</span> _partition(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums, <span class="built_in">int</span> left, <span class="built_in">int</span> right) &#123;</span><br><span class="line">  <span class="comment">// 以 nums[left] 为基数</span></span><br><span class="line">  <span class="built_in">int</span> i = left, j = right;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="comment">// 从右向左找首个小于基准数的元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) j--;</span><br><span class="line">    <span class="comment">// 从左向右找首个大于基准数的元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) i++;</span><br><span class="line">    <span class="comment">// 交换这两个元素</span></span><br><span class="line">    _swap(nums, i, j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将基准数交换至两个子数组的分界线</span></span><br><span class="line">  _swap(nums, i, left);</span><br><span class="line">  <span class="comment">// 返回基准数的索引</span></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="keyword">void</span> quickSort(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums, <span class="built_in">int</span> left, <span class="built_in">int</span> right) &#123;</span><br><span class="line">  <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">  <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 哨兵划分</span></span><br><span class="line">  <span class="built_in">int</span> pivot = _partition(nums, left, right);</span><br><span class="line">  <span class="comment">// 递归左子数组，右子数组</span></span><br><span class="line">  quickSort(nums, left, pivot - <span class="number">1</span>);</span><br><span class="line">  quickSort(nums, pivot + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化：</strong></p><ul><li>基数优化</li><li>尾递归优化</li></ul><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>原理</strong>：是一种基于分治策略的排序算法，包含“划分”和“合并”阶段。</p><ol><li><strong>划分阶段</strong>：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。</li><li><strong>合并阶段</strong>：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。</li></ol><p><strong>特性</strong>：</p><ul><li>时间复杂度为 O(nlog⁡n)、非自适应排序</li><li>空间复杂度为 O(n)、非原地排序</li><li>稳定排序</li></ul><p><strong>代码实现</strong>:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>];</span><br><span class="line">  mergeSort(list, <span class="number">0</span>, list.length - <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">print</span>(list);</span><br><span class="line">  <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="keyword">void</span> mergeSort(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums, <span class="built_in">int</span> left, <span class="built_in">int</span> right) &#123;</span><br><span class="line">  <span class="comment">// 终止条件</span></span><br><span class="line">  <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>; <span class="comment">// 当子数组长度为 1 时，终止递归</span></span><br><span class="line">  <span class="comment">// 划分阶段</span></span><br><span class="line">  <span class="built_in">int</span> mid = left + (right - left) ~/ <span class="number">2</span>; <span class="comment">// 计算中点</span></span><br><span class="line">  mergeSort(nums, left, mid); <span class="comment">// 递归左子数组</span></span><br><span class="line">  mergeSort(nums, mid + <span class="number">1</span>, right); <span class="comment">// 递归右子数组</span></span><br><span class="line">  <span class="comment">// 合并阶段</span></span><br><span class="line">  merge(nums, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并左子数组和右子数组</span></span><br><span class="line"><span class="keyword">void</span> merge(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums, <span class="built_in">int</span> left, <span class="built_in">int</span> mid, <span class="built_in">int</span> right) &#123;</span><br><span class="line">  <span class="comment">// 左子数组区间为 [left, mid],右子数组区间为 [mid+1, right]</span></span><br><span class="line">  <span class="comment">// 创建一个临时数组 tmp，用于存放合并后的结果</span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; tmp = <span class="built_in">List</span>.filled(right - left + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 初始化左子数组和右子数组的起始索引</span></span><br><span class="line">  <span class="built_in">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 当左右子数组还有元素时，进行比较并将较小的元素复制到临时数组中</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">      tmp[k++] = nums[i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将左子数组和右子数组的剩余元素复制到临时数组中</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">    tmp[k++] = nums[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">    tmp[k++] = nums[j++];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; tmp.length; k++) &#123;</span><br><span class="line">    nums[left + k] = tmp[k];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>原理</strong>：是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和“元素出堆操作”实现堆排序。</p><ol><li>输入数组并建立小顶堆，此时最小元素位于堆顶。</li><li>不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列。</li></ol><p><strong>特性</strong>：</p><ul><li>时间复杂度为 O(nlog⁡n)、非自适应排序</li><li>空间复杂度为 O(1)、原地排序</li><li>非稳定排序</li></ul><p><strong>代码实现</strong>:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>];</span><br><span class="line">  headSort(list);</span><br><span class="line">  <span class="built_in">print</span>(list);</span><br><span class="line">  <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="keyword">void</span> headSort(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums) &#123;</span><br><span class="line">  <span class="comment">// 建堆操作：堆化除页节点以外的其他所有节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = nums.length ~/ <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    shiftDown(nums, nums.length, i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从堆中提取最大元素，循环 n-1 轮</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 交换根节点与最右节点（交换首元素和尾元素）</span></span><br><span class="line">    <span class="built_in">int</span> tmp = nums[<span class="number">0</span>];</span><br><span class="line">    nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">    nums[i] = tmp;</span><br><span class="line">    <span class="comment">// 以根节点为起点，从顶至低进行堆化</span></span><br><span class="line">    shiftDown(nums, i, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆的长度为 n，从节点 i 开始，从顶至低堆化</span></span><br><span class="line"><span class="keyword">void</span> shiftDown(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums, <span class="built_in">int</span> n, <span class="built_in">int</span> i) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断节点 i，l，r 中值最大的节点，记为 ma</span></span><br><span class="line">    <span class="built_in">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> r = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int</span> ma = i;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; nums[l] &gt; nums[ma]) ma = l;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; nums[r] &gt; nums[ma]) ma = r;</span><br><span class="line">    <span class="comment">// 若节点 i 最大或索引 l， r 越界，则无须继续堆化，跳出</span></span><br><span class="line">    <span class="keyword">if</span> (ma == i) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 交换两节点</span></span><br><span class="line">    <span class="built_in">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[ma];</span><br><span class="line">    nums[ma] = temp;</span><br><span class="line">    <span class="comment">// 循环向下堆化</span></span><br><span class="line">    i = ma;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间复杂度-O-n"><a href="#时间复杂度-O-n" class="headerlink" title="时间复杂度  - O(n)"></a>时间复杂度  - O(n)</h1><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p><strong>原理</strong>：通过统计元素数量来实现排序，通常应用于<strong>整数数组</strong>。</p><p><strong>特性</strong>：</p><ul><li>时间复杂度为 O(n+m)、非自适应排序 </li><li>空间复杂度为 O(n+m)、非原地排序</li><li>稳定排序</li></ul><p><strong>代码实现</strong>:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序</span></span><br><span class="line"><span class="comment">// 简单实现，无法用于排序对象</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>];</span><br><span class="line">  countingSortNaive(list);</span><br><span class="line">  <span class="built_in">print</span>(list);</span><br><span class="line">  <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> countingSortNaive(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums) &#123;</span><br><span class="line">  <span class="comment">// 1. 统计数组最大元素 m</span></span><br><span class="line">  <span class="built_in">int</span> m = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _<span class="built_in">num</span> <span class="keyword">in</span> nums) &#123;</span><br><span class="line">    m = max(m, _<span class="built_in">num</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 统计各数字的出现次数</span></span><br><span class="line">  <span class="comment">// counter[_num] 代表 _num 的出现次数</span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; counter = <span class="built_in">List</span>.filled(m + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _<span class="built_in">num</span> <span class="keyword">in</span> nums) &#123;</span><br><span class="line">    counter[_<span class="built_in">num</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3. 便利 counter，将元素填入原数组 nums</span></span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _<span class="built_in">num</span> = <span class="number">0</span>; _<span class="built_in">num</span> &lt; m + <span class="number">1</span>; _<span class="built_in">num</span>++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; counter[_<span class="built_in">num</span>]; j++, i++) &#123;</span><br><span class="line">      nums[i] = _<span class="built_in">num</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p><strong>原理</strong>：核心思想与计数排序一致，也通过<strong>统计个数</strong>来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果。</p><p><strong>特性</strong>：</p><ul><li>时间复杂度为 O(nk)、非自适应排序</li><li>空间复杂度为 O(n+d)、非原地排序</li><li>稳定排序</li></ul><p><strong>代码实现</strong>:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = [<span class="number">100</span>, <span class="number">103</span>, <span class="number">106</span>, <span class="number">107</span>, <span class="number">102</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">109</span>, <span class="number">108</span>];</span><br><span class="line">  radixSort(list);</span><br><span class="line">  <span class="built_in">print</span>(list);</span><br><span class="line">  <span class="comment">// [100, 102, 103, 104, 105, 106, 107, 108, 109]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素 _num 的第 k 位，其中 exp = 10^(k-1)</span></span><br><span class="line"><span class="built_in">int</span> digit(<span class="built_in">int</span> _<span class="built_in">num</span>, <span class="built_in">int</span> exp) &#123;</span><br><span class="line">  <span class="comment">// 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span></span><br><span class="line">  <span class="keyword">return</span> (_<span class="built_in">num</span> ~/ exp) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数排序(根据 nums 第 k 位排序)</span></span><br><span class="line"><span class="keyword">void</span> countingSortDigit(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums, <span class="built_in">int</span> exp) &#123;</span><br><span class="line">  <span class="comment">// 十进制的范围位 0～9， 因此需要长度为 10 的桶数组</span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; counter = <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;.filled(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">int</span> n = nums.length;</span><br><span class="line">  <span class="comment">// 统计 0~9 各数字的出现次数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">int</span> d = digit(nums[i], exp);</span><br><span class="line">    counter[d]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 求前缀和，将“出现个数”转换为“数组索引”</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    counter[i] += counter[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 倒序遍历，根据桶内统计结果，将各元素填入 res</span></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; res = <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;.filled(n, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="built_in">int</span> d = digit(nums[i], exp);</span><br><span class="line">    <span class="built_in">int</span> j = counter[d] - <span class="number">1</span>; <span class="comment">// 获取 d 在数组中的索引 j</span></span><br><span class="line">    res[j] = nums[i]; <span class="comment">// 将当前元素填入索引 j</span></span><br><span class="line">    counter[d]--; <span class="comment">// 将 d 的数量减 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用结果覆盖原数组 nums</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) nums[i] = res[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基数排序</span></span><br><span class="line"><span class="keyword">void</span> radixSort(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums) &#123;</span><br><span class="line">  <span class="comment">// 获取数组的最大元素，用于判断最大位数</span></span><br><span class="line">  <span class="comment">// dart 中 int 的长度是 64 位的</span></span><br><span class="line">  <span class="built_in">int</span> m = <span class="number">-1</span> &lt;&lt; <span class="number">63</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _<span class="built_in">num</span> <span class="keyword">in</span> nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_<span class="built_in">num</span> &gt; m) m = _<span class="built_in">num</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按照地位到高位的顺序遍历</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> exp = <span class="number">1</span>; exp &lt;= m; exp *= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// 对数组元素的第 k 位执行计数排序</span></span><br><span class="line">    <span class="comment">// k = 1 -&gt; exp = 1</span></span><br><span class="line">    <span class="comment">// k = 2 -&gt; exp = 10</span></span><br><span class="line">    <span class="comment">// 即 exp = 10^(k-1)</span></span><br><span class="line">    countingSortDigit(nums, exp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p><strong>原理</strong>：是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。</p><p><strong>特性</strong>：</p><ul><li>时间复杂度为 O(n+k)</li><li>空间复杂度为 O(n+k)、非原地排序</li><li>桶排序是否稳定取决于排序桶内元素的算法是否稳定。</li></ul><p><strong>代码实现</strong>:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; list = [<span class="number">0.26</span>, <span class="number">0.6</span>, <span class="number">0.49</span>, <span class="number">0.1</span>, <span class="number">0.27</span>, <span class="number">0.93</span>, <span class="number">0.7</span>, <span class="number">0.76</span>, <span class="number">0.95</span>, <span class="number">0.55</span>];</span><br><span class="line">  bucketSort(list);</span><br><span class="line">  <span class="built_in">print</span>(list);</span><br><span class="line">  <span class="comment">// [0.1, 0.26, 0.27, 0.49, 0.55, 0.6, 0.7, 0.76, 0.93, 0.95]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line"><span class="keyword">void</span> bucketSort(<span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; nums) &#123;</span><br><span class="line">  <span class="built_in">int</span> k = nums.length ~/ <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt;&gt; buckets = <span class="built_in">List</span>.generate(k, (index) =&gt; []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.j将数组元素分配到各个桶中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _<span class="built_in">num</span> <span class="keyword">in</span> nums) &#123;</span><br><span class="line">    <span class="comment">// 输入数据范围为 [0,1),使用 _num * k 映射到索引范围 [0, k-1]</span></span><br><span class="line">    <span class="built_in">int</span> i = (_<span class="built_in">num</span> * k).toInt();</span><br><span class="line">    <span class="comment">// 将 _num 添加进桶 bucket_idx</span></span><br><span class="line">    buckets[i].add(_<span class="built_in">num</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 对各个桶执行排序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; bucket <span class="keyword">in</span> buckets) &#123;</span><br><span class="line">    bucket.sort();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 遍历桶合并结果</span></span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">List</span>&lt;<span class="built_in">double</span>&gt; bucket <span class="keyword">in</span> buckets) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">double</span> _<span class="built_in">num</span> <span class="keyword">in</span> bucket) &#123;</span><br><span class="line">      nums[i++] = _<span class="built_in">num</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;收集 排序 相关的常见算法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.wangruofeng007.com/img/hexo/data_structures_algo.webp&quot; alt=&quot; &quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构&amp;算法" scheme="https://blog.wangruofeng007.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://blog.wangruofeng007.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="dart" scheme="https://blog.wangruofeng007.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>常见算法之链表</title>
    <link href="https://blog.wangruofeng007.com/2024/11/08/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>https://blog.wangruofeng007.com/2024/11/08/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/</id>
    <published>2024-11-08T14:35:26.000Z</published>
    <updated>2024-11-13T08:19:02.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>收集 链表 相关的常见算法</p><p><img src="https://blog.wangruofeng007.com/img/hexo/data_structures_algo.webp" alt=" "></p><span id="more"></span><h1 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h1><h2 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h2><blockquote><p>将每个节点都逐步插入到新链表的头部</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义链表节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> value;</span><br><span class="line">  ListNode? next;</span><br><span class="line"></span><br><span class="line">  ListNode(<span class="keyword">this</span>.value, [<span class="keyword">this</span>.next]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插法反转链表函数</span></span><br><span class="line">ListNode? reverseLinkedListHeadInsert(ListNode? head) &#123;</span><br><span class="line">  ListNode? newHead = <span class="keyword">null</span>; <span class="comment">// 新的头节点</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ListNode? next = head.next; <span class="comment">// 暂存下一个节点</span></span><br><span class="line">    head.next = newHead; <span class="comment">// 当前节点指向新链表的头</span></span><br><span class="line">    newHead = head; <span class="comment">// 更新新链表的头</span></span><br><span class="line">    head = next; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newHead; <span class="comment">// 返回新的头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 构建链表 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span></span><br><span class="line">  ListNode node1 = ListNode(<span class="number">1</span>);</span><br><span class="line">  ListNode node2 = ListNode(<span class="number">2</span>);</span><br><span class="line">  ListNode node3 = ListNode(<span class="number">3</span>);</span><br><span class="line">  ListNode node4 = ListNode(<span class="number">4</span>);</span><br><span class="line">  ListNode node5 = ListNode(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  node1.next = node2;</span><br><span class="line">  node2.next = node3;</span><br><span class="line">  node3.next = node4;</span><br><span class="line">  node4.next = node5;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Original List:&quot;</span>);</span><br><span class="line">  printList(node1); <span class="comment">// 输出反转前的链表</span></span><br><span class="line"></span><br><span class="line">  ListNode? reversedHead = reverseLinkedListHeadInsert(node1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Reversed List:&quot;</span>);</span><br><span class="line">  printList(reversedHead); <span class="comment">// 输出反转后的链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：打印链表</span></span><br><span class="line"><span class="keyword">void</span> printList(ListNode? head) &#123;</span><br><span class="line">  ListNode? current = head;</span><br><span class="line">  <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(current.value);</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义链表节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> value;</span><br><span class="line">  ListNode? next;</span><br><span class="line"></span><br><span class="line">  ListNode(<span class="keyword">this</span>.value, [<span class="keyword">this</span>.next]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归法反转链表函数</span></span><br><span class="line">ListNode? reverseLinkedListRecursive(ListNode? head) &#123;</span><br><span class="line">  <span class="comment">// 基础情况：如果链表为空或只有一个节点，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归反转剩下的链表</span></span><br><span class="line">  ListNode? newHead = reverseLinkedListRecursive(head.next);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前节点链接到反转链表的尾部</span></span><br><span class="line">  head.next?.next = head;</span><br><span class="line">  head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newHead; <span class="comment">// 返回反转后的新头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 构建链表 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span></span><br><span class="line">  ListNode node1 = ListNode(<span class="number">1</span>);</span><br><span class="line">  ListNode node2 = ListNode(<span class="number">2</span>);</span><br><span class="line">  ListNode node3 = ListNode(<span class="number">3</span>);</span><br><span class="line">  ListNode node4 = ListNode(<span class="number">4</span>);</span><br><span class="line">  ListNode node5 = ListNode(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  node1.next = node2;</span><br><span class="line">  node2.next = node3;</span><br><span class="line">  node3.next = node4;</span><br><span class="line">  node4.next = node5;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Original List:&quot;</span>);</span><br><span class="line">  printList(node1); <span class="comment">// 输出反转前的链表</span></span><br><span class="line"></span><br><span class="line">  ListNode? reversedHead = reverseLinkedListRecursive(node1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Reversed List:&quot;</span>);</span><br><span class="line">  printList(reversedHead); <span class="comment">// 输出反转后的链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：打印链表</span></span><br><span class="line"><span class="keyword">void</span> printList(ListNode? head) &#123;</span><br><span class="line">  ListNode? current = head;</span><br><span class="line">  <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(current.value);</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;收集 链表 相关的常见算法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.wangruofeng007.com/img/hexo/data_structures_algo.webp&quot; alt=&quot; &quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构&amp;算法" scheme="https://blog.wangruofeng007.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://blog.wangruofeng007.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="dart" scheme="https://blog.wangruofeng007.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>常见算法之数组</title>
    <link href="https://blog.wangruofeng007.com/2024/11/07/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <id>https://blog.wangruofeng007.com/2024/11/07/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84/</id>
    <published>2024-11-07T14:15:26.000Z</published>
    <updated>2024-11-13T08:18:48.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>收集 数组 相关的常见算法</p><p><img src="https://blog.wangruofeng007.com/img/hexo/data_structures_algo.webp" alt=" "></p><span id="more"></span><h1 id="有序数组合并"><a href="#有序数组合并" class="headerlink" title="有序数组合并"></a>有序数组合并</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><blockquote><p>分别用两个指针指向两个数组的开始位置，每次比较指针所指向的元素，将较小的元素放入结果数组，然后移动对应的指针，直到两个数组都合并完</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; mergeSortedArrays(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; arr1, <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; arr2) &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; merged = [];</span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较两个数组中的元素，按顺序放入结果数组</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr1[i] &lt; arr2[j]) &#123;</span><br><span class="line">      merged.add(arr1[i]);</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      merged.add(arr2[j]);</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 arr1 有剩余元素，添加到结果数组</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; arr1.length) &#123;</span><br><span class="line">    merged.add(arr1[i]);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 arr2 有剩余元素，添加到结果数组</span></span><br><span class="line">  <span class="keyword">while</span> (j &lt; arr2.length) &#123;</span><br><span class="line">    merged.add(arr2[j]);</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> merged;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; arr2 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; result = mergeSortedArrays(arr1, arr2);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Merged Sorted Array: <span class="subst">$result</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求无序数组的中位数"><a href="#求无序数组的中位数" class="headerlink" title="求无序数组的中位数"></a>求无序数组的中位数</h1><h2 id="排序法"><a href="#排序法" class="headerlink" title="排序法"></a>排序法</h2><blockquote><p>先将数组排序，然后取中间的元素作为中位数。如果数组长度为奇数，则中位数为中间那个数；如果数组长度为偶数，则中位数为中间两个数的平均值。</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> findMedianWithSorting(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums) &#123;</span><br><span class="line">  nums.sort(); <span class="comment">// 对数组进行排序</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> n = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 奇数长度，返回中间元素</span></span><br><span class="line">    <span class="keyword">return</span> nums[n ~/ <span class="number">2</span>].toDouble();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 偶数长度，返回中间两个元素的平均值</span></span><br><span class="line">    <span class="keyword">return</span> (nums[n ~/ <span class="number">2</span> - <span class="number">1</span>] + nums[n ~/ <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>];</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Median is: <span class="subst">$&#123;findMedianWithSorting(nums)&#125;</span>&quot;</span>); <span class="comment">// 输出中位数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速选择法（适合大数组）"><a href="#快速选择法（适合大数组）" class="headerlink" title="快速选择法（适合大数组）"></a>快速选择法（适合大数组）</h2><blockquote><p>快速选择法基于快速排序的划分思想。它的思路是利用分治法找到数组的中位数，而不需要对整个数组进行排序。对于长度为奇数的数组，可以找到第 <code>n/2</code> 小的元素；对于长度为偶数的数组，可以找到第 <code>n/2</code> 和第 <code>n/2 - 1</code> 小的元素，并计算平均值。</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> findMedianWithQuickSelect(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums) &#123;</span><br><span class="line">  <span class="built_in">int</span> n = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 奇数长度，找到第 n/2 小的元素</span></span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, n - <span class="number">1</span>, n ~/ <span class="number">2</span>).toDouble();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 偶数长度，找到第 n/2 和第 n/2 - 1 小的元素，取平均</span></span><br><span class="line">    <span class="built_in">int</span> mid1 = quickSelect(nums, <span class="number">0</span>, n - <span class="number">1</span>, n ~/ <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">int</span> mid2 = quickSelect(nums, <span class="number">0</span>, n - <span class="number">1</span>, n ~/ <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (mid1 + mid2) / <span class="number">2.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速选择算法的实现</span></span><br><span class="line"><span class="built_in">int</span> quickSelect(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums, <span class="built_in">int</span> left, <span class="built_in">int</span> right, <span class="built_in">int</span> k) &#123;</span><br><span class="line">  <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> pivotIndex = partition(nums, left, right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (k == pivotIndex) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums[k];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; pivotIndex) &#123;</span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, pivotIndex + <span class="number">1</span>, right, k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区函数，用于划分数组</span></span><br><span class="line"><span class="built_in">int</span> partition(<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums, <span class="built_in">int</span> left, <span class="built_in">int</span> right) &#123;</span><br><span class="line">  <span class="built_in">int</span> pivot = nums[right];</span><br><span class="line">  <span class="built_in">int</span> i = left;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">      <span class="built_in">int</span> temp = nums[i];</span><br><span class="line">      nums[i] = nums[j];</span><br><span class="line">      nums[j] = temp;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> temp = nums[i];</span><br><span class="line">  nums[i] = nums[right];</span><br><span class="line">  nums[right] = temp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>];</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Median is: <span class="subst">$&#123;findMedianWithQuickSelect(nums)&#125;</span>&quot;</span>); <span class="comment">// 输出中位数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;收集 数组 相关的常见算法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.wangruofeng007.com/img/hexo/data_structures_algo.webp&quot; alt=&quot; &quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构&amp;算法" scheme="https://blog.wangruofeng007.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://blog.wangruofeng007.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="dart" scheme="https://blog.wangruofeng007.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>常见算法之字符串</title>
    <link href="https://blog.wangruofeng007.com/2024/11/06/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://blog.wangruofeng007.com/2024/11/06/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2024-11-06T14:35:26.000Z</published>
    <updated>2024-11-13T08:18:53.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>收集 字符串 相关的常见算法</p><p><img src="https://blog.wangruofeng007.com/img/hexo/data_structures_algo.webp" alt=" "></p><span id="more"></span><h1 id="字符串旋转"><a href="#字符串旋转" class="headerlink" title="字符串旋转"></a>字符串旋转</h1><h2 id="切片法"><a href="#切片法" class="headerlink" title="切片法"></a>切片法</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> rotateString(<span class="built_in">String</span> s, <span class="built_in">int</span> n) &#123;</span><br><span class="line">  <span class="built_in">int</span> length = s.length;</span><br><span class="line">  n = n % length; <span class="comment">// 防止 n 大于字符串长度</span></span><br><span class="line">  <span class="keyword">return</span> s.substring(n) + s.substring(<span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(rotateString(s, <span class="number">2</span>)); <span class="comment">// 输出 &quot;cdefab&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双重拼接"><a href="#双重拼接" class="headerlink" title="双重拼接"></a>双重拼接</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> rotateString(<span class="built_in">String</span> s, <span class="built_in">int</span> n) &#123;</span><br><span class="line">  <span class="built_in">int</span> length = s.length;</span><br><span class="line">  n = n % length;</span><br><span class="line">  <span class="built_in">String</span> sDouble = s + s; <span class="comment">// 双重拼接</span></span><br><span class="line">  <span class="keyword">return</span> sDouble.substring(n, n + length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(rotateString(s, <span class="number">2</span>)); <span class="comment">// 输出 &quot;cdefab&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环重组"><a href="#循环重组" class="headerlink" title="循环重组"></a>循环重组</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> rotateString(<span class="built_in">String</span> s, <span class="built_in">int</span> n) &#123;</span><br><span class="line">  <span class="built_in">int</span> length = s.length;</span><br><span class="line">  n = n % length;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; rotated = <span class="built_in">List</span>.generate(length, (i) =&gt; s[(i + n) % length]);</span><br><span class="line">  <span class="keyword">return</span> rotated.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(rotateString(s, <span class="number">2</span>)); <span class="comment">// 输出 &quot;cdefab&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:collection&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> rotateString(<span class="built_in">String</span> s, <span class="built_in">int</span> n) &#123;</span><br><span class="line">  Queue&lt;<span class="built_in">String</span>&gt; queue = Queue.of(s.split(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    queue.addLast(queue.removeFirst()); <span class="comment">// 左旋转</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(rotateString(s, <span class="number">2</span>)); <span class="comment">// 输出 &quot;cdefab&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h1><h2 id="切分重连"><a href="#切分重连" class="headerlink" title="切分重连"></a>切分重连</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> reverseString(<span class="built_in">String</span> s) &#123;</span><br><span class="line">  <span class="keyword">return</span> s.split(<span class="string">&#x27;&#x27;</span>).reversed.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(reverseString(s)); <span class="comment">// 输出 &quot;fedcba&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="倒序遍历"><a href="#倒序遍历" class="headerlink" title="倒序遍历"></a>倒序遍历</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> reverseString(<span class="built_in">String</span> s) &#123;</span><br><span class="line">  <span class="built_in">String</span> reversed = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = s.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    reversed += s[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> reversed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(reverseString(s)); <span class="comment">// 输出 &quot;fedcba&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针 *"></a>双指针 *</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> reverseString(<span class="built_in">String</span> s) &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; chars = s.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="built_in">int</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> right = chars.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// 交换左右字符</span></span><br><span class="line">    <span class="built_in">String</span> temp = chars[left];</span><br><span class="line">    chars[left] = chars[right];</span><br><span class="line">    chars[right] = temp;</span><br><span class="line"></span><br><span class="line">    left++;</span><br><span class="line">    right--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> chars.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(reverseString(s)); <span class="comment">// 输出 &quot;fedcba&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归翻转"><a href="#递归翻转" class="headerlink" title="递归翻转"></a>递归翻转</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> reverseString(<span class="built_in">String</span> s) &#123;</span><br><span class="line">  <span class="keyword">if</span> (s.isEmpty) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> reverseString(s.substring(<span class="number">1</span>)) + s[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(reverseString(s)); <span class="comment">// 输出 &quot;fedcba&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大回文字符串"><a href="#最大回文字符串" class="headerlink" title="最大回文字符串"></a>最大回文字符串</h1><h2 id="中心扩散法"><a href="#中心扩散法" class="headerlink" title="中心扩散法 *"></a>中心扩散法 *</h2><blockquote><p>以每个字符和每两个字符之间的位置作为中心，向外扩展寻找回文子串</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> longestPalindrome(<span class="built_in">String</span> s) &#123;</span><br><span class="line">  <span class="keyword">if</span> (s.isEmpty) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="built_in">int</span> len1 = expandAroundCenter(s, i, i); <span class="comment">// 奇数长度回文</span></span><br><span class="line">    <span class="built_in">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>); <span class="comment">// 偶数长度回文</span></span><br><span class="line">    <span class="built_in">int</span> len = len1 &gt; len2 ? len1 : len2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">      start = i - (len - <span class="number">1</span>) ~/ <span class="number">2</span>;</span><br><span class="line">      end = i + len ~/ <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：从中心向两侧扩展，返回回文的长度</span></span><br><span class="line"><span class="built_in">int</span> expandAroundCenter(<span class="built_in">String</span> s, <span class="built_in">int</span> left, <span class="built_in">int</span> right) &#123;</span><br><span class="line">  <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">    left--;</span><br><span class="line">    right++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> s = <span class="string">&quot;cbabcad&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Longest Palindromic Substring is: <span class="subst">$&#123;longestPalindrome(s)&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h2><blockquote><p>通过记录子字符串的回文性，来逐步构建和寻找最大回文子串。这个方法适合那些需要更好可读性和较好性能的场景。</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> longestPalindromeDP(<span class="built_in">String</span> s) &#123;</span><br><span class="line">  <span class="built_in">int</span> n = s.length;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">bool</span>&gt;&gt; dp = <span class="built_in">List</span>.generate(n, (_) =&gt; <span class="built_in">List</span>.filled(n, <span class="keyword">false</span>));</span><br><span class="line">  <span class="built_in">int</span> start = <span class="number">0</span>, maxLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 单个字符一定是回文</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查长度为2的回文</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      dp[i][i + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">      start = i;</span><br><span class="line">      maxLength = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 动态规划检查长度大于2的子串</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> len = <span class="number">3</span>; len &lt;= n; len++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n - len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="built_in">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        start = i;</span><br><span class="line">        maxLength = len;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.substring(start, start + maxLength);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> s = <span class="string">&quot;cbabcad&quot;</span>;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Longest Palindromic Substring is: <span class="subst">$&#123;longestPalindromeDP(s)&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h1><h2 id="Hash-算法"><a href="#Hash-算法" class="headerlink" title="Hash 算法"></a>Hash 算法</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String?</span> firstUniqueCharacter(<span class="built_in">String</span> s) &#123;</span><br><span class="line">  <span class="comment">// 创建一个 Map 来存储字符的出现次数</span></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt; charCount = &#123;&#125;;</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 统计每个字符的出现次数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="built_in">String</span> char = s[i];</span><br><span class="line">    charCount[char] = (charCount[char] ?? <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 找到第一个只出现一次的字符</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="built_in">String</span> char = s[i];</span><br><span class="line">    <span class="keyword">if</span> (charCount[char] == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> char; <span class="comment">// 返回第一个只出现一次的字符</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 如果没有只出现一次的字符，返回 null</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">String</span> testString = <span class="string">&quot;swiss&quot;</span>;</span><br><span class="line">  <span class="built_in">String?</span> result = firstUniqueCharacter(testString);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第一个只出现一次的字符是: <span class="subst">$result</span>&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;没有找到只出现一次的字符&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;收集 字符串 相关的常见算法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.wangruofeng007.com/img/hexo/data_structures_algo.webp&quot; alt=&quot; &quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构&amp;算法" scheme="https://blog.wangruofeng007.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://blog.wangruofeng007.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="dart" scheme="https://blog.wangruofeng007.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>常见算法之Hash</title>
    <link href="https://blog.wangruofeng007.com/2024/11/05/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B9%8BHash/"/>
    <id>https://blog.wangruofeng007.com/2024/11/05/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%B9%8BHash/</id>
    <published>2024-11-05T14:35:20.000Z</published>
    <updated>2024-11-13T08:20:54.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>收集 Hash 相关的常见算法</p><p><img src="https://blog.wangruofeng007.com/img/hexo/data_structures_algo.webp" alt=" "></p><span id="more"></span><h1 id="查找两个子视图的共同父视图"><a href="#查找两个子视图的共同父视图" class="headerlink" title="查找两个子视图的共同父视图"></a>查找两个子视图的共同父视图</h1><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">CommonAncestors</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">UIView</span> *&gt; *)allCommonAncestorsForView:(<span class="built_in">UIView</span> *)view1 andView:(<span class="built_in">UIView</span> *)view2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">CommonAncestors</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">UIView</span> *&gt; *)allCommonAncestorsForView:(<span class="built_in">UIView</span> *)view1 andView:(<span class="built_in">UIView</span> *)view2 &#123;</span><br><span class="line">    <span class="comment">// 获取 view1 的所有父视图</span></span><br><span class="line">    <span class="built_in">NSMutableSet</span>&lt;<span class="built_in">UIView</span> *&gt; *ancestors1 = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    <span class="built_in">UIView</span> *current = view1;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        [ancestors1 addObject:current];</span><br><span class="line">        current = current.superview;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 view2 的所有父视图，并找到共同的祖先视图</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">UIView</span> *&gt; *commonAncestors = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    current = view2;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([ancestors1 containsObject:current]) &#123;</span><br><span class="line">            [commonAncestors addObject:current];</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.superview;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [commonAncestors <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">- (<span class="type">void</span>)testAllCommonAncestors &#123;</span><br><span class="line">    <span class="comment">// 创建视图层次结构</span></span><br><span class="line">    <span class="built_in">UIView</span> *rootView = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    <span class="built_in">UIView</span> *commonParent1 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    <span class="built_in">UIView</span> *commonParent2 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    <span class="built_in">UIView</span> *parent1 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    <span class="built_in">UIView</span> *parent2 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    <span class="built_in">UIView</span> *child1 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    <span class="built_in">UIView</span> *child2 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置视图层次结构</span></span><br><span class="line">    [rootView addSubview:commonParent1];</span><br><span class="line">    [commonParent1 addSubview:commonParent2];</span><br><span class="line">    [commonParent2 addSubview:parent1];</span><br><span class="line">    [commonParent2 addSubview:parent2];</span><br><span class="line">    [parent1 addSubview:child1];</span><br><span class="line">    [parent2 addSubview:child2];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找所有共同父视图</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">UIView</span> *&gt; *commonAncestors = [<span class="built_in">UIView</span> allCommonAncestorsForView:child1 andView:child2];</span><br><span class="line">    <span class="keyword">if</span> (commonAncestors.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">UIView</span> *ancestor <span class="keyword">in</span> commonAncestors) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;共同父视图: %@&quot;</span>, ancestor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;没有找到共同父视图&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;收集 Hash 相关的常见算法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.wangruofeng007.com/img/hexo/data_structures_algo.webp&quot; alt=&quot; &quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构&amp;算法" scheme="https://blog.wangruofeng007.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://blog.wangruofeng007.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="OC" scheme="https://blog.wangruofeng007.com/tags/OC/"/>
    
  </entry>
  
  <entry>
    <title>全球主流大模型盘点：国内外AI巨头产品大揭秘</title>
    <link href="https://blog.wangruofeng007.com/2024/11/04/%E5%85%A8%E7%90%83%E4%B8%BB%E6%B5%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9B%98%E7%82%B9%EF%BC%9A%E5%9B%BD%E5%86%85%E5%A4%96AI%E5%B7%A8%E5%A4%B4%E4%BA%A7%E5%93%81%E5%A4%A7%E6%8F%AD%E7%A7%98/"/>
    <id>https://blog.wangruofeng007.com/2024/11/04/%E5%85%A8%E7%90%83%E4%B8%BB%E6%B5%81%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9B%98%E7%82%B9%EF%BC%9A%E5%9B%BD%E5%86%85%E5%A4%96AI%E5%B7%A8%E5%A4%B4%E4%BA%A7%E5%93%81%E5%A4%A7%E6%8F%AD%E7%A7%98/</id>
    <published>2024-11-04T03:04:47.000Z</published>
    <updated>2024-11-11T17:06:05.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>收集国内外的主要的大模型公司的产品，持续更新…</p><span id="more"></span><h1 id="国外"><a href="#国外" class="headerlink" title="国外"></a>国外</h1><table><thead><tr><th><strong>序号</strong></th><th><strong>公司</strong></th><th><strong>产品</strong></th><th><strong>主页链接</strong></th><th><strong>产品特点</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td>1</td><td><strong>OpenAI</strong></td><td>GPT系列 (GPT-4o, ChatGPT)</td><td><a href="https://openai.com/">OpenAI</a></td><td>强大的语言生成、理解和对话能力，支持多种任务类型</td><td>教育、智能客服、编程助手、创意写作、语言翻译等</td></tr><tr><td>2</td><td><strong>Google</strong></td><td>Bard (基于PaLM 2)</td><td><a href="https://bard.google.com/">Google Bard</a></td><td>多语言对话、多模态理解和逻辑推理能力强，适合信息检索和知识问答</td><td>Google搜索、智能助手、跨语言翻译、数据分析等</td></tr><tr><td>3</td><td><strong>Meta</strong></td><td>LLaMA系列</td><td><a href="https://ai.meta.com/llama/">Meta LLaMA</a></td><td>开源大语言模型，支持NLP任务和生成，广泛用于学术和开发社区</td><td>学术研究、NLP任务定制、开源社区工具开发</td></tr><tr><td>4</td><td><strong>Anthropic</strong></td><td>Claude系列</td><td><a href="https://www.anthropic.com/">Anthropic Claude</a></td><td>强调安全性和可控性，通过“宪法式AI”设计提升道德安全性和回答质量</td><td>智能客服、教育、内容审核等</td></tr><tr><td>5</td><td><strong>Microsoft</strong></td><td>Azure OpenAI 服务</td><td><a href="https://azure.microsoft.com/en-us/products/cognitive-services/openai-service/">Microsoft Azure OpenAI</a></td><td>集成OpenAI模型（如GPT-4, DALL-E），提供高度安全的云平台支持</td><td>企业应用、智能客服、内容生成、代码生成、图片生成等</td></tr><tr><td></td><td></td><td>Microsoft 365 Copilot</td><td><a href="https://www.microsoft.com/en-us/microsoft-365/copilot">Microsoft 365 Copilot</a></td><td>集成在Microsoft 365办公套件中，提供智能辅助，提高办公生产力</td><td>办公自动化、数据分析、文本编辑、幻灯片制作等</td></tr><tr><td></td><td></td><td>GitHub Copilot</td><td><a href="https://github.com/features/copilot">GitHub Copilot</a></td><td>基于OpenAI Codex，为开发者提供实时代码建议，提升开发效率和代码质量</td><td>软件开发、代码编写、代码补全和问题排查</td></tr><tr><td>6</td><td><strong>Cohere</strong></td><td>Command R</td><td><a href="https://cohere.com/">Cohere</a></td><td>面向企业，具有文本生成、分析和推荐系统能力，适合高负载企业场景</td><td>内容生成、客户管理、推荐系统、数据挖掘、企业知识管理等</td></tr><tr><td>7</td><td><strong>MosaicML</strong></td><td>MPT系列</td><td><a href="https://www.mosaicml.com/">MosaicML</a></td><td>强调高效性和可定制性，支持用户定制化训练和微调模型</td><td>NLP任务定制、企业应用定制化、机器学习实验</td></tr><tr><td>8</td><td><strong>Aleph Alpha</strong></td><td>Luminous</td><td><a href="https://aleph-alpha.com/">Aleph Alpha</a></td><td>专注多语言和跨领域大模型，提供隐私保护和模型可控性，主要面向欧洲市场</td><td>法律文档分析、商业报告生成、内容理解与生成</td></tr><tr><td>9</td><td><strong>Character.AI</strong></td><td>Character专用生成模型</td><td><a href="https://character.ai/">Character.AI</a></td><td>专注个性化对话体验，拟人化角色对话内容，应用于娱乐和教育</td><td>虚拟助手、个性化教育、娱乐对话体验</td></tr></tbody></table><h1 id="国内"><a href="#国内" class="headerlink" title="国内"></a>国内</h1><table><thead><tr><th><strong>序号</strong></th><th><strong>公司</strong></th><th><strong>产品</strong></th><th><strong>主页链接</strong></th><th><strong>产品特点</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td>1</td><td><strong>字节跳动</strong></td><td>豆包 (Doubao)</td><td><a href="https://www.doubao.com/chat/">豆包</a></td><td>专注于用户兴趣和个性化推荐系统，通过大数据和智能分析为用户提供高相关性的内容推荐</td><td>内容推荐、短视频个性化推荐、广告推荐、用户行为分析</td></tr><tr><td>2</td><td><strong>百度</strong></td><td>文心一言 (ERNIE Bot)</td><td><a href="https://yiyan.baidu.com/">百度文心一言</a></td><td>专注中文自然语言处理，具备语义理解、文本生成、多模态处理能力</td><td>搜索、智能助手、智能客服、内容推荐、翻译等</td></tr><tr><td>3</td><td><strong>阿里巴巴</strong></td><td>通义千问 (Tongyi Qianwen)</td><td><a href="https://tongyi.aliyun.com/">阿里巴巴通义千问</a></td><td>强大语言生成、多语言支持和文本分析能力</td><td>智能客服、知识管理、电子商务推荐、教育、内容生成等</td></tr><tr><td>4</td><td><strong>腾讯</strong></td><td>混元 (Hunyuan)</td><td><a href="https://cloud.tencent.com/product/hunyuan">腾讯混元大模型</a></td><td>在数据处理、文本生成、多模态交互上具有优势</td><td>金融、社交媒体、广告推荐、内容安全、智能客服等</td></tr><tr><td>5</td><td><strong>华为</strong></td><td>盘古 (Pangu)</td><td><a href="https://www.huaweicloud.com/product/pangu.html">华为盘古</a></td><td>注重行业应用，结合硬件和算法优势，适合垂直领域的深度数据分析</td><td>工业制造、医疗健康、科学研究、智慧城市等</td></tr><tr><td>6</td><td><strong>科大讯飞</strong></td><td>星火 (iFLYTEK Spark)</td><td><a href="https://spark.xfyun.cn/">讯飞星火</a></td><td>针对中文处理和语音识别，优化教育和医疗场景，具有高准确率和自然交互能力</td><td>教育领域智能辅导、医疗诊断辅助、病例分析等</td></tr><tr><td>7</td><td><strong>智谱AI</strong></td><td>清言 (GLM系列)</td><td><a href="https://www.zhipu.ai/">智谱AI GLM</a></td><td>支持中文和多语言处理，强调学术应用和科研辅助</td><td>教育科研、文本生成、问答系统，开源社区的技术研究</td></tr><tr><td>8</td><td><strong>月之暗面</strong></td><td>Dark Side of the Moon</td><td><a href="https://kimi.moonshot.cn/">Kimi</a></td><td>强调隐私保护和高安全性，主要针对高度敏感的文本处理和生成任务</td><td>政府和企业隐私数据处理、合规性内容生成、安全监控</td></tr><tr><td>9</td><td><strong>360 AI研究院</strong></td><td>360智脑</td><td><a href="https://ai.360.cn/">360智脑</a></td><td>聚焦安全场景和内容审核，结合360的网络安全优势</td><td>内容安全、企业安全管理、客服系统</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;收集国内外的主要的大模型公司的产品，持续更新…&lt;/p&gt;</summary>
    
    
    
    <category term="AI" scheme="https://blog.wangruofeng007.com/categories/AI/"/>
    
    
    <category term="大模型" scheme="https://blog.wangruofeng007.com/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>北上广深杭成互联网公司汇总</title>
    <link href="https://blog.wangruofeng007.com/2024/11/03/%E5%8C%97%E4%B8%8A%E5%B9%BF%E6%B7%B1%E6%9D%AD%E6%88%90%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E6%B1%87%E6%80%BB/"/>
    <id>https://blog.wangruofeng007.com/2024/11/03/%E5%8C%97%E4%B8%8A%E5%B9%BF%E6%B7%B1%E6%9D%AD%E6%88%90%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E6%B1%87%E6%80%BB/</id>
    <published>2024-11-03T14:52:11.000Z</published>
    <updated>2024-11-06T15:22:43.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>整理汇总了北京、上海、广州、深圳、杭州、成都的互联网公司，方便有需要的小伙伴快速查阅，这份 List 可以作为一个大纲，寻找合适自己的公司。。。</p><span id="more"></span><blockquote><p> 个人总结难免有所疏忽，欢迎大家在文章底部评论补充，公司好坏没有排名哈！</p></blockquote><h1 id="北京"><a href="#北京" class="headerlink" title="北京"></a>北京</h1><h2 id="一线互联网"><a href="#一线互联网" class="headerlink" title="一线互联网"></a>一线互联网</h2><ul><li>百度（总部）</li><li>阿里（北京）</li><li>腾讯（北京）</li><li>字节跳动（总部）</li></ul><h2 id="外企"><a href="#外企" class="headerlink" title="外企"></a>外企</h2><ul><li>微软（北京）微软中国主要就是北京和苏州</li><li>Hulu（北京）美国的视频网站，听说福利待遇超级棒</li><li>Airbnb（北京）房屋租赁平台</li><li>Grab（北京）东南亚第一大出行 App</li><li>印象笔记（北京）evernote在中国的独立品牌</li><li>FreeWheel（北京）美国最大的视频广告管理和投放平台</li><li>amazon（北京）全球最大的电商平台</li></ul><h2 id="二线互联网"><a href="#二线互联网" class="headerlink" title="二线互联网"></a>二线互联网</h2><ul><li>美团点评（总部）</li><li>京东（总部）</li><li>网易（北京）</li><li>滴滴出行（总部）</li><li>新浪（总部）</li><li>快手（总部）</li><li>搜狐（总部）</li><li>搜狗（总部）</li><li>360（总部）</li></ul><h2 id="硬件巨头-有软件-互联网业务"><a href="#硬件巨头-有软件-互联网业务" class="headerlink" title="硬件巨头 (有软件&#x2F;互联网业务)"></a>硬件巨头 (有软件&#x2F;互联网业务)</h2><ul><li>华为（北京）</li><li>联想（总部）</li><li>小米（总部）后序要搬到武汉，互联网业务也是小米重头</li></ul><h2 id="三线互联网"><a href="#三线互联网" class="headerlink" title="三线互联网"></a>三线互联网</h2><ul><li>爱奇艺（总部）</li><li>去哪儿网（总部）</li><li>知乎（总部）</li><li>豆瓣（总部）</li><li>当当网（总部）</li><li>完美世界（总部）游戏公司</li><li>昆仑万维（总部）游戏公司</li><li>58同城（总部）</li><li>陌陌（总部）</li><li>金山软件（北京）包括金山办公软件</li><li>用友网络科技（总部）企业服务ERP提供商</li><li>映客直播（总部）</li><li>猎豹移动（总部）</li><li>一点资讯（总部）</li><li>国双（总部）企业级大数据和人工智能解决方案提供商</li></ul><h2 id="明星创业公司"><a href="#明星创业公司" class="headerlink" title="明星创业公司"></a>明星创业公司</h2><p>可以发现北京一堆在线教育的公司，可能教育要紧盯了政策变化，所以都要在北京吧</p><ul><li>好未来（总部）在线教育</li><li>猿辅导（总部）在线教育</li><li>跟谁学（总部）在线教育</li><li>作业帮（总部）在线教育</li><li>VIPKID（总部）在线教育</li><li>雪球（总部）股市资讯</li><li>唱吧（总部）</li><li>每日优鲜（总部）让每个人随时随地享受食物的美好</li><li>微店（总部）</li><li>罗辑思维（总部）得到APP</li><li>值得买科技（总部）让每一次消费产生幸福感</li><li>拉勾网（总部）互联网招聘</li></ul><h2 id="AI独角兽公司"><a href="#AI独角兽公司" class="headerlink" title="AI独角兽公司"></a>AI独角兽公司</h2><ul><li>商汤科技（总部）专注于计算机视觉和深度学习</li><li>旷视科技（总部）人工智能产品和解决方案公司</li><li>第四范式（总部）人工智能技术与服务提供商</li><li>地平线机器人（总部）边缘人工智能芯片的全球领导者</li><li>寒武纪（总部）全球智能芯片领域的先行者</li></ul><h2 id="互联网媒体"><a href="#互联网媒体" class="headerlink" title="互联网媒体"></a>互联网媒体</h2><ul><li>央视网</li><li>搜房网</li><li>易车网</li><li>链家网</li><li>自如网</li><li>汽车之家</li></ul><h1 id="上海"><a href="#上海" class="headerlink" title="上海"></a>上海</h1><h2 id="一线互联网-1"><a href="#一线互联网-1" class="headerlink" title="一线互联网"></a>一线互联网</h2><ul><li>百度（上海）</li><li>阿里（上海）</li><li>腾讯（上海）</li><li>字节跳动（上海）</li><li>蚂蚁金服（上海）</li></ul><h2 id="外企IT-互联网-硬件"><a href="#外企IT-互联网-硬件" class="headerlink" title="外企IT&#x2F;互联网&#x2F;硬件"></a>外企IT&#x2F;互联网&#x2F;硬件</h2><ul><li>互联网<ul><li>Google（上海）</li><li>微软（上海）</li><li>LeetCode&#x2F;力扣（上海）</li><li>unity（上海）游戏引擎</li><li>SAP（上海）主要产品是ERP</li><li>PayPal（上海）在线支付鼻祖</li><li>eBay（上海）电子商务公司</li></ul></li><li>偏硬件<ul><li>IBM（上海）</li><li>Tesla（上海）特斯拉</li><li>Cisco（上海）思科</li><li>Intel（上海）</li><li>AMD（上海）半导体产品领域</li><li>EMC（上海）易安信是美国信息存储资讯科技公司</li><li>NVIDIA（上海）英伟达是GPU(图形处理器)的发明者，人工智能计算的引领者</li></ul></li></ul><h2 id="二线互联网-1"><a href="#二线互联网-1" class="headerlink" title="二线互联网"></a>二线互联网</h2><ul><li>拼多多（总部）</li><li>饿了么（总部）阿里旗下。</li><li>哈啰出行（总部）阿里旗下</li><li>盒马（总部）阿里旗下</li><li>哔哩哔哩（总部）</li><li>阅文集团（总部）腾讯旗下</li><li>爱奇艺（上海）百度旗下</li><li>携程（总部）</li><li>京东（上海）</li><li>网易（上海）</li><li>美团点评（上海）</li><li>唯品会（上海）</li></ul><h2 id="硬件巨头-有软件-互联网业务-1"><a href="#硬件巨头-有软件-互联网业务-1" class="headerlink" title="硬件巨头 (有软件&#x2F;互联网业务)"></a>硬件巨头 (有软件&#x2F;互联网业务)</h2><p>华为（上海）</p><h2 id="三线互联网-1"><a href="#三线互联网-1" class="headerlink" title="三线互联网"></a>三线互联网</h2><ul><li>PPTV（总部）</li><li>微盟（总部）企业云端商业及营销解决方案提供商</li><li>喜马拉雅（总部）</li><li>陆金所（总部）全球领先的线上财富管理平台</li><li>口碑（上海）阿里旗下。</li><li>三七互娱（上海）</li><li>趣头条（总部）</li><li>巨人网络（总部）游戏公司</li><li>盛大网络（总部）游戏公司</li><li>UCloud（总部）云服务提供商</li><li>达达集团（总部）本地即时零售与配送平台</li><li>众安保险（总部）在线财产保险</li><li>触宝（总部）触宝输入法等多款APP</li><li>平安系列</li></ul><h2 id="明星创业公司-1"><a href="#明星创业公司-1" class="headerlink" title="明星创业公司"></a>明星创业公司</h2><ul><li>小红书（总部）</li><li>叮咚买菜（总部）</li><li>蔚来汽车（总部）</li><li>七牛云（总部）</li><li>得物App（总部）品潮流尖货装备交易、球鞋潮品鉴别查验、互动潮流社区</li><li>收钱吧（总部）开创了中国移动支付市场“一站式收款”</li><li>蜻蜓FM（总部）音频内容聚合平台</li><li>流利说（总部）在线教育</li><li>Soul（总部）社交软件</li><li>美味不用等（总部）智慧餐饮服务商</li><li>微鲸科技（总部）专注于智能家居领域</li><li>途虎养车（总部）</li><li>米哈游（总部）游戏公司</li><li>莉莉丝游戏（总部）游戏公司</li><li>樊登读书（总部）在线教育</li></ul><h2 id="AI独角兽公司-1"><a href="#AI独角兽公司-1" class="headerlink" title="AI独角兽公司"></a>AI独角兽公司</h2><ul><li>依图科技（总部）和旷视，商汤对标，都是做安防视觉</li><li>深兰科技（总部）致力于人工智能基础研究和应用开发</li></ul><h2 id="其他行业，涉及互联网"><a href="#其他行业，涉及互联网" class="headerlink" title="其他行业，涉及互联网"></a>其他行业，涉及互联网</h2><ul><li>花旗、摩根大通等一些列金融巨头</li><li>百姓网</li><li>找钢网</li><li>安居客</li><li>前程无忧</li><li>东方财富</li><li>三大电信运营商：中国移动、中国电信、中国联通</li><li>沪江英语</li><li>各大银行</li></ul><h1 id="广州"><a href="#广州" class="headerlink" title="广州"></a>广州</h1><h2 id="一线互联网-2"><a href="#一线互联网-2" class="headerlink" title="一线互联网"></a>一线互联网</h2><ul><li>微信（总部） 有点难进！</li><li>字节跳动（广州）</li></ul><h2 id="二线"><a href="#二线" class="headerlink" title="二线"></a>二线</h2><ul><li>网易（总部）主要是游戏</li></ul><h2 id="三线"><a href="#三线" class="headerlink" title="三线"></a>三线</h2><ul><li>唯品会（总部）</li><li>欢聚时代（总部）旗下YY，虎牙，YY最近被浑水做空，不知百度还要不要收购了</li><li>酷狗音乐（总部）</li><li>UC浏览器（总部）现在隶属阿里创始人何小鹏现在搞小鹏汽车</li><li>荔枝FM（总部）用户可以在手机上开设自己的电台和录制节目</li><li>映客直播（总部）股票已经跌成渣了</li><li>爱范儿（总部）</li><li>三七互娱（总部）游戏公司</li><li>君海游戏（总部）游戏公司</li><li>4399游戏（总部）游戏公司</li><li>多益网络（总部）游戏公司</li></ul><h2 id="硬件巨头-有软件-互联网业务-2"><a href="#硬件巨头-有软件-互联网业务-2" class="headerlink" title="硬件巨头 (有软件&#x2F;互联网业务)"></a>硬件巨头 (有软件&#x2F;互联网业务)</h2><ul><li>小鹏汽车（总部）新能源汽车小霸王</li></ul><h2 id="创业公司"><a href="#创业公司" class="headerlink" title="创业公司"></a>创业公司</h2><ul><li>妈妈网（总部）母婴行业互联网公司</li><li>云徙科技（总部）数字商业云服务提供商</li><li>Fordeal（总部）中东领先跨境电商平台</li><li>Mobvista（总部）移动数字营销</li><li>久邦GOMO（总部）游戏</li><li>深海游戏（总部）游戏</li></ul><h2 id="国企"><a href="#国企" class="headerlink" title="国企"></a>国企</h2><ul><li>中国电信广州研发（听说没有996）</li></ul><h1 id="深圳"><a href="#深圳" class="headerlink" title="深圳"></a>深圳</h1><h2 id="一线互联网-3"><a href="#一线互联网-3" class="headerlink" title="一线互联网"></a>一线互联网</h2><ul><li>腾讯（总部深圳）</li><li>百度（深圳）</li><li>阿里（深圳）</li><li>字节跳动（深圳）</li></ul><h2 id="硬件巨头-有软件-互联网业务-3"><a href="#硬件巨头-有软件-互联网业务-3" class="headerlink" title="硬件巨头 (有软件&#x2F;互联网业务)"></a>硬件巨头 (有软件&#x2F;互联网业务)</h2><ul><li>华为（总部深圳）</li><li>中兴（总部深圳）</li><li>海能达（总部深圳）</li><li>oppo（总部深圳）</li><li>vivo（总部深圳）</li><li>深信服（总部深圳）</li><li>大疆（总部深圳，无人机巨头）</li><li>一加手机（总部深圳）</li><li>柔宇科技（最近口碑急转直下）</li></ul><h2 id="二线大厂"><a href="#二线大厂" class="headerlink" title="二线大厂"></a>二线大厂</h2><ul><li>快手（深圳）</li><li>京东（深圳）</li><li>顺丰（总部深圳）</li></ul><h2 id="三线大厂"><a href="#三线大厂" class="headerlink" title="三线大厂"></a>三线大厂</h2><ul><li>富途证券（2020年成功赴美上市，主要经营港股美股）</li><li>微众银行（总部深圳）</li><li>招银科技（总部深圳）</li><li>平安系列（平安科技、平安寿险、平安产险、平安金融、平安好医生等）</li><li>Shopee（21年有裁员风波）</li><li>有赞（深圳）</li><li>迅雷（总部深圳）</li><li>金蝶（总部深圳）</li><li>随手记（总部深圳）</li></ul><h2 id="AI独角兽公司-2"><a href="#AI独角兽公司-2" class="headerlink" title="AI独角兽公司"></a>AI独角兽公司</h2><ul><li>商汤科技（人工智能领域的独角兽）</li><li>追一科技（一家企业级智能服务AI公司）</li><li>超多维科技 （计算机视觉、裸眼3D）</li><li>优必选科技 （智能机器人、人脸识别）</li></ul><h2 id="明星创业公司-2"><a href="#明星创业公司-2" class="headerlink" title="明星创业公司"></a>明星创业公司</h2><ul><li>丰巢科技（让生活更简单）</li><li>人人都是产品经理（全球领先的产品经理和运营人 学习、交流、分享平台）</li><li>客路旅行  (东南亚非常出名的🦄 旅游公司)</li><li>大丰收（综合农业互联网服务平台）</li><li>小鹅通（专注新教育的技术服务商）</li><li>货拉拉（拉货就找货拉拉）</li><li>编程猫（少儿编程教育头部企业）</li><li>HelloTalk（全球最大的语言学习社交社区）</li><li>大宇无限（ 拥有SnapTube, Lark Player 等多款广受海外新兴市场用户欢迎的产品）</li><li>知识星球（深圳大成天下公司出品）</li><li>XMind（隶属深圳市爱思软件技术有限公司，思维导图软件）</li><li>小赢科技（以技术重塑人类的金融体验）</li></ul><h2 id="其他行业（有软件-互联网业务）"><a href="#其他行业（有软件-互联网业务）" class="headerlink" title="其他行业（有软件&#x2F;互联网业务）"></a>其他行业（有软件&#x2F;互联网业务）</h2><ul><li>三大电信运营商：中国移动、中国电信、中国联通</li><li>房产企业：恒大（暴雷）、万科</li><li>中信深圳</li><li>广发证券，深交所</li><li>珍爱网（珍爱网是国内知名的婚恋服务网站之一）</li></ul><h1 id="杭州"><a href="#杭州" class="headerlink" title="杭州"></a>杭州</h1><h2 id="一线互联网-4"><a href="#一线互联网-4" class="headerlink" title="一线互联网"></a>一线互联网</h2><ul><li>阿里巴巴（总部）</li><li>蚂蚁金服（总部）阿里旗下</li><li>阿里云（总部）阿里旗下</li><li>网易（杭州） 网易云音乐</li><li>字节跳动（杭州）抖音分部</li></ul><h2 id="外企-1"><a href="#外企-1" class="headerlink" title="外企"></a>外企</h2><ul><li>ZOOM （杭州研发中心）全球知名云视频会议服务提供商</li><li>infosys（杭州）印度公司，据说工资相对不高 </li><li>思科（杭州）</li></ul><h2 id="二线互联网-2"><a href="#二线互联网-2" class="headerlink" title="二线互联网"></a>二线互联网</h2><ul><li>滴滴（杭州）</li><li>快手（杭州）</li></ul><h2 id="硬件巨头-有软件-互联网业务-4"><a href="#硬件巨头-有软件-互联网业务-4" class="headerlink" title="硬件巨头 (有软件&#x2F;互联网业务)"></a>硬件巨头 (有软件&#x2F;互联网业务)</h2><ul><li>海康威视（总部）安防三巨头</li><li>浙江大华（总部）安防三巨头</li><li>杭州宇视（总部） 安防三巨头</li><li>萤石 </li><li>华为（杭州）</li><li>vivo（杭州）</li><li>oppo（杭州）</li><li>魅族（杭州）</li></ul><h2 id="三线互联网-2"><a href="#三线互联网-2" class="headerlink" title="三线互联网"></a>三线互联网</h2><ul><li>蘑菇街（总部）女性消费者的电子商务网站</li><li>有赞（总部）帮助商家进行网上开店、社交营销</li><li>菜鸟网络（杭州）</li><li>花瓣网（总部）图片素材领导者</li><li>兑吧（总部）用户运营服务平台</li><li>同花顺（总部）网上股票证券交易分析软件</li><li>51信用卡（总部）信用卡管理</li><li>虾米（总部）已被阿里收购</li><li>曹操出行（总部）</li><li>口碑网 （总部）</li></ul><h2 id="AI独角兽公司-3"><a href="#AI独角兽公司-3" class="headerlink" title="AI独角兽公司"></a>AI独角兽公司</h2><ul><li>旷视科技（杭州）</li><li>商汤（杭州）</li></ul><h2 id="创业公司-1"><a href="#创业公司-1" class="headerlink" title="创业公司"></a>创业公司</h2><ul><li>e签宝（总部）做电子签名</li><li>婚礼纪（总部）好多结婚的朋友都用</li><li>大搜车（总部）中国领先的汽车交易服务供应商</li><li>二更（总部）自媒体</li><li>丁香园（总部）</li></ul><h1 id="成都"><a href="#成都" class="headerlink" title="成都"></a>成都</h1><h2 id="一线互联网-5"><a href="#一线互联网-5" class="headerlink" title="一线互联网"></a>一线互联网</h2><ul><li>腾讯（成都） 游戏，王者荣耀就在成都！</li><li>阿里（成都）</li><li>蚂蚁金服（成都）</li><li>字节跳动（成都）</li></ul><h2 id="硬件巨头-有软件-互联网业务-5"><a href="#硬件巨头-有软件-互联网业务-5" class="headerlink" title="硬件巨头 (有软件&#x2F;互联网业务)"></a>硬件巨头 (有软件&#x2F;互联网业务)</h2><ul><li>华为（成都）</li><li>OPPO（成都）</li></ul><h2 id="二线互联网-3"><a href="#二线互联网-3" class="headerlink" title="二线互联网"></a>二线互联网</h2><ul><li>京东（成都）</li><li>美团（成都）</li><li>滴滴（成都）</li></ul><h2 id="三线互联网-3"><a href="#三线互联网-3" class="headerlink" title="三线互联网"></a>三线互联网</h2><ul><li>完美世界 （成都）游戏</li><li>聚美优品 （成都）</li><li>陌陌 （成都）</li><li>爱奇艺（成都）</li></ul><h2 id="外企互联网"><a href="#外企互联网" class="headerlink" title="外企互联网"></a>外企互联网</h2><ul><li>NAVER China （成都）搜索引擎公司，主要针对韩国市场</li></ul><h2 id="创业公司-2"><a href="#创业公司-2" class="headerlink" title="创业公司"></a>创业公司</h2><ul><li>tap4fun（总部）游戏</li><li>趣乐多（总部）游戏</li><li>天上友嘉（总部）游戏</li><li>三七互娱（成都）游戏</li><li>咕咚（总部）智能运动</li><li>百词斩（总部）在线教育</li><li>晓多科技（总部）AI方向</li><li>萌想科技（总部）实习僧</li><li>Camera360（总部）移动影像社区</li><li>医联 （总部）医疗解决方案提供商</li><li>小明太极 （总部）原创漫画文娱内容网站以及相关APP</li><li>小鸡叫叫（总部）致力于儿童教育的智慧解决方案</li></ul><h2 id="AI独角兽公司-4"><a href="#AI独角兽公司-4" class="headerlink" title="AI独角兽公司"></a>AI独角兽公司</h2><ul><li>科大讯飞（成都）</li><li>商汤（成都）</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/youngyangyang04/leetcode-master">leetcode-master</a></li><li><a href="https://www.zhipin.com/gongsi/?ka=header_brand">Boss 直聘 - 公司</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;整理汇总了北京、上海、广州、深圳、杭州、成都的互联网公司，方便有需要的小伙伴快速查阅，这份 List 可以作为一个大纲，寻找合适自己的公司。。。&lt;/p&gt;</summary>
    
    
    
    <category term="资料收集" scheme="https://blog.wangruofeng007.com/categories/%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"/>
    
    
    <category term="互联网公司" scheme="https://blog.wangruofeng007.com/tags/%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 与 Flutter</title>
    <link href="https://blog.wangruofeng007.com/2024/11/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%8E-Flutter/"/>
    <id>https://blog.wangruofeng007.com/2024/11/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%8E-Flutter/</id>
    <published>2024-11-02T08:38:31.000Z</published>
    <updated>2024-11-03T05:54:13.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h1><p>比起设计模式，个人认为这 3 条原则更加重要：</p><ul><li>DRY（<strong>Don’t Repeat Yourself）</strong>：尽量在项目中减少重复的代码行，重复的方法，重复的模块。其实许多设计原则和模式最本质的思想都是在消除重复。</li><li>KISS（<strong>Keep It Simple, Stupid</strong>）：让代码简单直接，用简单的方法解决复杂的问题，保持代码可读性和可维护性，足够简单，也就意味着很容易读懂，这就让 BUG 不容易隐藏且更容易修复。</li><li>YAGNI（<strong>You aren’t gonna need it</strong>）：只有当你需要的时候才去添加额外的功能，不要过度设计。我们经常会在开发当中尽可能的迎合未来可能的需求。而为了迎合某些产生概率极低的需求而设计的成本是非常高的，这种过度设计的收益非常低。可能你深思熟虑的设计花了不少时间成本，却在未来的两三年内这个设计却完全没有派上用场。一些设计是否必要，更多的应该基于当前的情况。而不是为了应对未来的各种变化，画蛇添足的设计。</li></ul><p><img src="/images/design_pattern_flutter/design_pattern_cover.webp"></p><span id="more"></span><h1 id="设计模式历史"><a href="#设计模式历史" class="headerlink" title="设计模式历史"></a>设计模式历史</h1><p>1994 年， 埃里希·伽玛、 约翰·弗利赛德斯、 拉尔夫·约翰逊、 理查德·赫尔姆这四位作者出版了 《<a href="https://refactoringguru.cn/gof-book">设计模式： 可复用面向对象软件的基础</a>》 一书， 将设计模式的概念应用到程序开发领域中。 </p><p>该书提供了 <strong>23</strong> 个模式来解决面向对象程序设计中的各种问题， 很快便成为了畅销书。</p><p>由于书名太长， 人们将其简称为 “四人组 （Gang of Four， GoF） 的书”， 并且很快进一步简化为 “GoF 的书”。</p><h1 id="三大类设计模式"><a href="#三大类设计模式" class="headerlink" title="三大类设计模式"></a><strong>三大类设计模式</strong></h1><p>根据其意图或目的，可以分为三种主要的模式类别：</p><p><img src="/images/design_pattern_flutter/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" alt=" "></p><h1 id="六大原则（SOLID）"><a href="#六大原则（SOLID）" class="headerlink" title="六大原则（SOLID）"></a>六大原则（SOLID）</h1><p><img src="/images/design_pattern_flutter/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.png" alt=" "></p><h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><ol><li><h2 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 (Singleton)"></a>单例模式 (Singleton)</h2></li></ol><blockquote><p><strong>单例模式</strong>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/single">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/single</a></p></blockquote><p><img src="/images/design_pattern_flutter/singleton.png" alt=" "></p><ul><li><strong>单例</strong> （Sin­gle­ton） 类声明了一个名为 <code>get­Instance</code> 的静态方法来返回其所属类的一个相同实例。</li><li>单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 <code>get­Instance</code> 方法必须是获取单例对象的唯一方式。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  Singleton._();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">late</span> <span class="keyword">final</span> Singleton _instance = Singleton._();</span><br><span class="line">  <span class="keyword">static</span> Singleton <span class="keyword">get</span> instance =&gt; _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><h2 id="简单工厂模式-Simple-Factory"><a href="#简单工厂模式-Simple-Factory" class="headerlink" title="简单工厂模式 * (Simple Factory)"></a><strong>简单工厂模式 * (<strong>Simple Factory</strong>)</strong></h2></li></ol><blockquote><p><strong>简单工厂模式</strong> 不在 23 种 GoF 设计模式中，却是我们最常使用的一种编程方式。</p></blockquote><p>主要涉及到一个特殊的方法，专门用来提供我们想要的实例对象（对象工厂），我们可以将这个方法放到一个单独的类 <code>SimpleFactory</code> 中，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">工厂方法</span></span></span><br><span class="line">  <span class="keyword">static</span> Product createProduct(<span class="built_in">int</span> type) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> Product1();</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> Product2();</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> Product3();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String?</span> name;</span><br><span class="line">  <span class="built_in">String?</span> color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String?</span> name = <span class="string">&#x27;Product 1&#x27;</span>;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String?</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String?</span> name = <span class="string">&#x27;Product 2&#x27;</span>;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String?</span> color = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类 3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product3</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String?</span> name = <span class="string">&#x27;Product 3&#x27;</span>;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String?</span> color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们想要在代码中获取对应的类型对象时，只需要通过这个方法传入想要的类型值即可，我们不必关心生产如何被生产以及哪个对象被选择的具体逻辑：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Product product = SimpleFactory.createProduct(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这就是 <strong>简单工厂模式</strong>。说到这里，就不得不提到 Dart 中特有的 <strong>factory</strong> 关键词了。</p><p><strong>factory 关键词</strong> 可以用来修饰 Dart 类的构造函数，意为 <strong>工厂构造函数</strong>，它能够让 <strong>类</strong> 的构造函数天然具有工厂的功能，使用方式如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String?</span> name;</span><br><span class="line">  <span class="built_in">String?</span> color;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工厂构造函数</span></span><br><span class="line">  <span class="keyword">factory</span> Product.createProduct(<span class="built_in">int</span> type) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> Product1();</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> Product2();</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> Product3();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><h2 id="工厂模式-Factory-Method"><a href="#工厂模式-Factory-Method" class="headerlink" title="工厂模式 (Factory Method)"></a><strong>工厂模式 (Factory Method)</strong></h2></li></ol><blockquote><p><strong>工厂方法模式</strong> 是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/factory">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/factory</a></p></blockquote><p><img src="/images/design_pattern_flutter/factory_method.png" alt=" "></p><ul><li><strong>产品</strong> （Prod­uct） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。</li><li><strong>具体产品</strong> （Con­crete Prod­ucts） 是产品接口的不同实现。</li><li><strong>创建者</strong> （Cre­ator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。</li><li>你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。</li><li>注意， 尽管它的名字是创建者， 但它最主要的职责并<strong>不是</strong>创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。</li><li><strong>具体创建者</strong> （Con­crete Cre­ators） 将会重写基础工厂方法， 使其返回不同类型的产品。</li><li>注意， 并不一定每次调用工厂方法都会<strong>创建</strong>新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。</li></ul><p><strong>Flutter Demo 应用</strong> </p><p>在 Flutter 中，Widget 就属于 Product 抽象类，每一个具体实现的 Widget 都属于 Con­crete Prod­uct。</p><p>假如我们需要区分 Android 、iOS 等平台来显示不同的对话框：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDialog</span> </span>&#123;</span><br><span class="line">  Widget create(BuildContext context);</span><br><span class="line"></span><br><span class="line">  Future&lt;T?&gt; <span class="keyword">show</span>&lt;T&gt;(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> dialog = create(context);</span><br><span class="line">    <span class="keyword">return</span> showDialog(context: context, builder: (context) =&gt; dialog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidAlertDialog</span> <span class="keyword">extends</span> <span class="title">CustomDialog</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget create(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> AlertDialog();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOSAlertDialog</span> <span class="keyword">extends</span> <span class="title">CustomDialog</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget create(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> CupertinoAlertDialog();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">void</span> test(BuildContext context) &#123;</span><br><span class="line">  <span class="comment">// final dialog = AndroidAlertDialog();</span></span><br><span class="line">  <span class="keyword">final</span> dialog = IOSAlertDialog();</span><br><span class="line">  dialog.<span class="keyword">show</span>(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><h2 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式 (Abstract Factory)"></a><strong>抽象工厂模式 (Abstract Factory)</strong></h2></li></ol><blockquote><p><strong>抽象工厂模式</strong>是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/factory">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/factory</a></p></blockquote><p><img src="/images/design_pattern_flutter/abstract_factory.png" alt=" "></p><ul><li><strong>抽象产品</strong> （Abstract Prod­uct） 为构成系列产品的一组不同但相关的产品声明接口。</li><li><strong>具体产品</strong> （Con­crete Prod­uct） 是抽象产品的多种不同类型实现。 所有变体 （苹果&#x2F;小米&#x2F;…） 都必须实现相应的抽象产品 （手机&#x2F;平板&#x2F;…）。</li><li><strong>抽象工厂</strong> （Abstract Fac­to­ry） 接口声明了一组创建各种抽象产品的方法。</li><li><strong>具体工厂</strong> （Con­crete Fac­to­ry） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。</li><li>尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的<em>抽象</em>产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 <strong>客户端</strong> （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂&#x2F;产品变体交互。</li></ul><h3 id="与工厂模式的区别"><a href="#与工厂模式的区别" class="headerlink" title="与工厂模式的区别"></a><strong>与工厂模式的区别</strong></h3><p><strong>简单工厂</strong> 和 <strong>工厂方法</strong> 这两种模式只生产一种对象，</p><p>而抽象工厂<strong>生产的是一系列对象</strong>（对象族），而且生成的这一系列对象一定存在某种联系。比如 Apple 会生产 <strong>手机</strong>、<strong>平板</strong> 等多个产品，这些产品都属于 Apple 这个品牌。</p><p><strong>Flutter Demo 应用</strong> </p><ol><li>定义抽象工厂，用于生产 widget：</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IWidgetsFactory</span> </span>&#123;</span><br><span class="line">  Widget createButton(BuildContext context);</span><br><span class="line"></span><br><span class="line">  Widget createDialog(BuildContext context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>针对每一个平台，我们都可以实现对应的实现工厂</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Dart</span><br><span class="line"><span class="comment">// Material 风格组件工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaterialWidgetsFactory</span> <span class="keyword">extends</span> <span class="title">IWidgetsFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget createButton(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ElevatedButton(</span><br><span class="line">      child: <span class="keyword">const</span> Text(<span class="string">&#x27;text&#x27;</span>),</span><br><span class="line">      onPressed: () &#123;&#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget createDialog(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> AlertDialog();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cupertino 风格组件工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CupertinoWidgetsFactory</span> <span class="keyword">extends</span> <span class="title">IWidgetsFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget createButton(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> CupertinoButton(</span><br><span class="line">      child: <span class="keyword">const</span> Text(<span class="string">&#x27;text&#x27;</span>),</span><br><span class="line">      onPressed: () &#123;&#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget createDialog(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> CupertinoAlertDialog();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这样，在 Android 平台上我们使用 <code>MaterialWidgetsFactory</code> ，在 iOS 平台上使用 <code>CupertinoWidgetsFactory</code> ，就能使用对应平台的 widget，想要适配更多平台只需要再继承 <code>IWidgetsFactory</code> 实现对应平台的工厂类即可。</li></ol><p>至此，我们可以发现，作为创建型模式，这三类工厂模式主要工作就是以不同的方式创建对象，但他们各有特点：简单工厂模式抽象的是 <strong>生产对象</strong>，工厂模式抽象的是 <strong>类方法</strong>，抽象工厂模式抽象的则是 <strong>生产对象的工厂</strong>，如何使用就见仁见智了。</p><ol><li><h2 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 (Prototype)"></a><strong>原型模式 (Prototype)</strong></h2></li></ol><blockquote><p><strong>原型模式</strong>是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/proxy">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/proxy</a></p></blockquote><p><img src="/images/design_pattern_flutter/prototype.png" alt=" "></p><ul><li><strong>原型</strong> （Pro­to­type） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 <code>clone</code> 的方法。</li><li><strong>具体原型</strong> （Con­crete Pro­to­type） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。</li><li><strong>客户端</strong> （Client） 可以复制实现了原型接口的任何对象。</li></ul><ol><li><h2 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式 (Builder)"></a><strong>建造者模式 (Builder)</strong></h2></li></ol><blockquote><p><strong>建造者模式</strong>是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/builder">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/builder</a></p></blockquote><p><img src="/images/design_pattern_flutter/builder.png" alt=" "></p><p><strong>Flutter 应用</strong></p><p>Dart 语言的级联语法，就已经提供了最基础的 Builder 实现，举个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Dart</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> firstName = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="built_in">String</span> lastName = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建方法</span></span><br><span class="line"><span class="keyword">final</span> person = Person()</span><br><span class="line">  ..firstName = <span class="string">&#x27;San&#x27;</span></span><br><span class="line">  ..lastName = <span class="string">&#x27;Zhang&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h1><ol><li><h2 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 Adapter"></a>适配器模式 Adapter</h2></li></ol><blockquote><p><strong>适配器模式</strong>是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/adapter">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/adapter</a></p></blockquote><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a><strong>对象适配器</strong></h3><p><img src="/images/design_pattern_flutter/adapter_01.png" alt=" "></p><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a><strong>类适配器</strong></h3><p><img src="/images/design_pattern_flutter/adapter_02.png" alt=" "></p><p><strong>Flutter Demo 应用</strong> </p><p>在 Flutter 中，最常见的适配器实现就是 <strong>SliverToBoxAdapter</strong> </p><p>我们经常会使用到 CustomScrollView 创建拥有自定义滚动效果的组件，而 CustomScrollView 只允许包含 sliver 系列组件 (SliverAppBar、SliverList、SliverPersistentHeader 等) ，如果想包含普通的组件，必然需要使用 <strong>SliverToBoxAdapter。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Dart</span><br><span class="line">CustomScrollView(</span><br><span class="line">    slivers: &lt;Widget&gt;[</span><br><span class="line">        SliverAppBar(),</span><br><span class="line">        SliverToBoxAdapter(</span><br><span class="line">            child: Container(height: <span class="number">100.0</span>),</span><br><span class="line">        ),</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li><h2 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式 Bridge"></a>桥接模式 Bridge</h2></li></ol><blockquote><p><strong>桥接模式</strong>是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/bridge">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/bridge</a></p></blockquote><p><img src="/images/design_pattern_flutter/bridge.png" alt=" "></p><ol><li><p><strong>抽象部分</strong> （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。</p></li><li><p><strong>实现部分</strong> （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。</p></li><li><p>抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。</p></li><li><p><strong>具体实现</strong> （Concrete Implementations） 中包括特定于平台的代码。</p></li><li><p><strong>精确抽象</strong> （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。</p></li><li><p>通常情况下， <strong>客户端</strong> （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。</p></li><li><h2 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式 Composite"></a>组合模式 Composite</h2></li></ol><blockquote><p><strong>组合模式</strong>是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/combination">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/combination</a></p></blockquote><p><img src="/images/design_pattern_flutter/composite_01.png" alt=" "></p><p><img src="/images/design_pattern_flutter/composite_02.png" alt=" "></p><ol><li><p><strong>组件</strong> （Component） 接口描述了树中简单项目和复杂项目所共有的操作。</p></li><li><p><strong>叶节点</strong> （Leaf） 是树的基本结构， 它不包含子项目。</p></li><li><p>一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。</p></li><li><p><strong>容器</strong> （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。</p></li><li><p>容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。</p></li><li><p><strong>客户端</strong> （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。</p></li><li><h2 id="装饰模式-Decorator"><a href="#装饰模式-Decorator" class="headerlink" title="装饰模式 Decorator"></a>装饰模式 Decorator</h2></li></ol><blockquote><p><strong>装饰模式</strong>是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/decorator">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/decorator</a></p></blockquote><p><img src="/images/design_pattern_flutter/decorator_01.png" alt=" "></p><p><img src="/images/design_pattern_flutter/decorator_02.png" alt=" "></p><ol><li><p><strong>部件</strong> （Component） 声明封装器和被封装对象的公用接口。</p></li><li><p><strong>具体部件</strong> （Concrete Component） 类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。</p></li><li><p><strong>基础装饰</strong> （Base Decorator） 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。</p></li><li><p><strong>具体装饰类</strong> （Concrete Decorators） 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。</p></li><li><p><strong>客户端</strong> （Client） 可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。</p></li><li><h2 id="外观模式-Facades"><a href="#外观模式-Facades" class="headerlink" title="外观模式 Facades"></a>外观模式 Facades</h2></li></ol><blockquote><p><strong>外观模式</strong>是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/facade">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/facade</a></p></blockquote><p><img src="/images/design_pattern_flutter/facades_01.png" alt=" "></p><p><img src="/images/design_pattern_flutter/facades_02.png" alt=" "></p><ol><li><p><strong>外观</strong> （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。</p></li><li><p>创建<strong>附加外观</strong> （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。</p></li><li><p><strong>复杂子系统</strong> （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。</p></li><li><p>子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。</p></li><li><p><strong>客户端</strong> （Client） 使用外观代替对子系统对象的直接调用。</p></li><li><h2 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式 Flyweight"></a>享元模式 Flyweight</h2></li></ol><blockquote><p><strong>享元模式</strong>是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/flyweight">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/flyweight</a></p></blockquote><p><img src="/images/design_pattern_flutter/flyweight.png" alt=" "></p><ol><li><p>享元模式只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。</p></li><li><p><strong>享元</strong> （Flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。</p></li><li><p><strong>情景</strong> （Context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。</p></li><li><p>通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。</p></li><li><p><strong>客户端</strong> （Client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。</p></li><li><p><strong>享元工厂</strong> （Flyweight Factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。</p></li><li><h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 Proxy"></a>代理模式 Proxy</h2></li></ol><blockquote><p><strong>代理模式</strong>是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/proxy">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/proxy</a></p></blockquote><p><img src="/images/design_pattern_flutter/proxy.png" alt=" "></p><ol><li><strong>服务接口</strong> （Service Interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。</li><li><strong>服务</strong> （Service） 类提供了一些实用的业务逻辑。</li><li><strong>代理</strong> （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。</li><li>通常情况下， 代理会对其服务对象的整个生命周期进行管理。</li><li><strong>客户端</strong> （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。</li></ol><h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><ol><li><h2 id="责任链模式-Chain-of-Responsibility"><a href="#责任链模式-Chain-of-Responsibility" class="headerlink" title="责任链模式 Chain of Responsibility"></a>责任链模式 Chain of Responsibility</h2></li></ol><blockquote><p><strong>责任链模式</strong>是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/duty">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/duty</a></p></blockquote><p><img src="/images/design_pattern_flutter/chain_of_responsibility.png" alt=" "></p><ol><li><p><strong>处理者</strong> （Handler） 声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。</p></li><li><p><strong>基础处理者</strong> （Base Handler） 是一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。</p></li><li><p>通常情况下， 该类中定义了一个保存对于下个处理者引用的成员变量。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为： 确定下个处理者存在后再将请求传递给它。</p></li><li><p><strong>具体处理者</strong> （Concrete Handlers） 包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。</p></li><li><p>处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。</p></li><li><p><strong>客户端</strong> （Client） 可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的任意一个处理者， 而非必须是第一个处理者。</p></li><li><h2 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 Command"></a>命令模式 Command</h2></li></ol><blockquote><p><strong>命令模式</strong>是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/command">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/command</a></p></blockquote><p><img src="/images/design_pattern_flutter/command.png" alt=" "></p><ol><li><p><strong>发送者</strong> （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。</p></li><li><p><strong>命令</strong> （Command） 接口通常仅声明一个执行命令的方法。</p></li><li><p><strong>具体命令</strong> （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。</p></li><li><p>接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。</p></li><li><p><strong>接收者</strong> （Receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。</p></li><li><p><strong>客户端</strong> （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。</p></li><li><h2 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式 Iterator"></a>迭代器模式 Iterator</h2></li></ol><blockquote><p><strong>迭代器模式</strong>是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/iterator">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/iterator</a></p></blockquote><p><img src="/images/design_pattern_flutter/Iterator.png" alt=" "></p><ol><li><strong>迭代器</strong> （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。</li><li><strong>具体迭代器</strong> （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。</li><li><strong>集合</strong> （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。</li><li><strong>具体集合</strong> （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。</li><li><strong>客户端</strong> （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。</li></ol><p>客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。</p><ol><li><h2 id="中介者模式-Mediator"><a href="#中介者模式-Mediator" class="headerlink" title="中介者模式 Mediator"></a>中介者模式 Mediator</h2></li></ol><blockquote><p><strong>中介者模式</strong>是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/midd">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/midd</a></p></blockquote><p><img src="/images/design_pattern_flutter/mediator.png" alt=" "></p><ol><li><strong>组件</strong> （Component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。</li><li><strong>中介者</strong> （Mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。</li><li><strong>具体中介者</strong> （Concrete Mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。</li><li>组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。</li></ol><p>对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。</p><ol><li><h2 id="备忘录模式-Memento"><a href="#备忘录模式-Memento" class="headerlink" title="备忘录模式 Memento"></a>备忘录模式 Memento</h2></li></ol><blockquote><p><strong>备忘录模式</strong>是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/memory">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/memory</a></p></blockquote><p><img src="/images/design_pattern_flutter/memento.png" alt=" "></p><ol><li><strong>原发器</strong> （Originator） 类可以生成自身状态的快照， 也可以在需要时通过快照恢复自身状态。</li><li><strong>备忘录</strong> （Memento） 是原发器状态快照的值对象 （value object）。 通常做法是将备忘录设为不可变的， 并通过构造函数一次性传递数据。</li><li><strong>负责人</strong> （Caretaker） 仅知道 “何时” 和 “为何” 捕捉原发器的状态， 以及何时恢复状态。</li></ol><blockquote><p>负责人通过保存备忘录栈来记录原发器的历史状态。 当原发器需要回溯历史状态时， 负责人将从栈中获取最顶部的备忘录， 并将其传递给原发器的恢复 （restoration） 方法。</p></blockquote><ol><li><p>在该实现方法中， 备忘录类将被嵌套在原发器中。 这样原发器就可访问备忘录的成员变量和方法， 即使这些方法被声明为私有。 另一方面， 负责人对于备忘录的成员变量和方法的访问权限非常有限： 它们只能在栈中保存备忘录， 而不能修改其状态。</p></li><li><h2 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式 Observer"></a>观察者模式 Observer</h2></li></ol><blockquote><p><strong>观察者模式</strong>是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/observer">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/observer</a></p></blockquote><p><img src="/images/design_pattern_flutter/observer.png" alt=" "></p><ul><li><strong>发布者</strong> （Pub­lish­er） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。</li><li>当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。</li><li><strong>订阅者</strong> （Sub­scriber） 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 <code>update</code> 方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。</li><li><strong>具体订阅者</strong> （Con­crete Sub­scribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。</li><li>订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。</li><li><strong>客户端</strong> （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。</li></ul><p><strong>Flutter Demo 应用</strong> </p><ul><li>Stream 可以被看作是 Dart 语言原生支持的观察者模式的典型模型之一</li><li>ChangeNotifier 大概是 Flutter 中实现观察者模式最典型的例子</li><li>Flutter 中每个 Navigator 对象都接受一个 NavigatorObserver 对象的数组，在实际开发过程中，我们可以通过根组件 <code>MaterialApp</code> (或 <code>CupertinoPageRoute</code> ) 的 <code>navigatorObservers</code> 属性传递给根 Navigator 组件，用于观察根 Navigator 的路由行为，这一组 NavigatorObserver 对象就是一系列的路由观察者。</li></ul><p>更多参考： <a href="https://flutter.cn/community/tutorials/observer-pattern-in-flutter-n-dart">https://flutter.cn/community/tutorials/observer-pattern-in-flutter-n-dart</a></p><ol><li><h2 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式 State"></a>状态模式 State</h2></li></ol><blockquote><p><strong>状态模式</strong>是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</p><p><strong>Demo</strong>: <a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/state">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/state</a></p></blockquote><p><img src="/images/design_pattern_flutter/state.png" alt=" "></p><ol><li><strong>上下文</strong> （Context） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。</li><li><strong>状态</strong> （State） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。</li><li><strong>具体状态</strong> （Concrete States） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。</li></ol><blockquote><p>状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。</p></blockquote><ol><li><p>上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。</p></li><li><h2 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式 Strategy"></a>策略模式 Strategy</h2></li></ol><blockquote><p><strong>策略模式</strong>是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。</p><p><strong>Demo</strong>：<a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/strategy">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/strategy</a></p></blockquote><p><img src="/images/design_pattern_flutter/strategy.png" alt=" "></p><ol><li><p><strong>上下文</strong> （Context） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。</p></li><li><p><strong>策略</strong> （Strategy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。</p></li><li><p><strong>具体策略</strong> （Concrete Strategies） 实现了上下文所用算法的各种不同变体。</p></li><li><p>当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。</p></li><li><p><strong>客户端</strong> （Client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。</p></li><li><p>这个是最受争议的设计模式，因为策略模式在绝大部分现代编程语言中可以简单地使用匿名 （lamb­da） 函数来实现。</p></li><li><p>包括 Dart，允许在匿名函数中实现不同版本的算法。 因此使用这些函数的方式就和使用策略对象时完全相同， 无需借助额外的类和接口来保持代码简洁。如下：</p></li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> doSomething(&#123;<span class="keyword">required</span> <span class="built_in">Function</span>() strategy&#125;) &#123;</span><br><span class="line">        strategy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client</span></span><br><span class="line">Context().doSomething(</span><br><span class="line">    strategy: () &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li><h2 id="模板方法模式-Template-Method"><a href="#模板方法模式-Template-Method" class="headerlink" title="模板方法模式 Template Method"></a>模板方法模式 Template Method</h2></li></ol><blockquote><p><strong>模板方法模式</strong>是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。</p><p><strong>Demo</strong>：<a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/template">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/template</a></p></blockquote><p><img src="/images/design_pattern_flutter/template_method.png" alt=" "></p><ol><li><p><strong>抽象类</strong> （Abstract­Class） 会声明作为算法步骤的方法， 以及依次调用它们的实际模板方法。 算法步骤可以被声明为 <code>抽象</code> 类型， 也可以提供一些默认实现。</p></li><li><p><strong>具体类</strong> （Concrete­Class） 可以重写所有步骤， 但不能重写模板方法自身。</p></li><li><h2 id="访问者模式-Visitor"><a href="#访问者模式-Visitor" class="headerlink" title="访问者模式 Visitor"></a>访问者模式 Visitor</h2></li></ol><blockquote><p><strong>访问者模式</strong>是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。</p></blockquote><p><img src="/images/design_pattern_flutter/visitor.png" alt=" "></p><ol><li><p><strong>访问者</strong> （Visitor） 接口声明了一系列以对象结构的具体元素为参数的访问者方法。 如果编程语言支持重载， 这些方法的名称可以是相同的， 但是其参数一定是不同的。</p></li><li><p><strong>具体访问者</strong> （Concrete Visitor） 会为不同的具体元素类实现相同行为的几个不同版本。</p></li><li><p><strong>元素</strong> （Element） 接口声明了一个方法来 “接收” 访问者。 该方法必须有一个参数被声明为访问者接口类型。</p></li><li><p><strong>具体元素</strong> （Concrete Element） 必须实现接收方法。 该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。 请注意， 即使元素基类实现了该方法， 所有子类都必须对其进行重写并调用访问者对象中的合适方法。</p></li><li><p><strong>客户端</strong> （Client） 通常会作为集合或其他复杂对象 （例如一个<a href="https://refactoringguru.cn/design-patterns/composite">组合</a>树） 的代表。 客户端通常不知晓所有的具体元素类， 因为它们会通过抽象接口与集合中的对象进行交互。</p></li><li><h2 id="解释器模式-Interpreter"><a href="#解释器模式-Interpreter" class="headerlink" title="解释器模式 Interpreter"></a>解释器模式 Interpreter</h2></li></ol><blockquote><p><strong>Demo</strong>：<a href="https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/interpreter">https://github.com/FlutterOpen/design_patterns/tree/master/lib/page/interpreter</a></p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://refactoringguru.cn/design-patterns">https://refactoringguru.cn/design-patterns</a></li><li><a href="https://github.com/FlutterOpen/design_patterns">https://github.com/FlutterOpen/design_patterns</a></li></ol><!-- processed 2 -->]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;写在最前&quot;&gt;&lt;a href=&quot;#写在最前&quot; class=&quot;headerlink&quot; title=&quot;写在最前&quot;&gt;&lt;/a&gt;写在最前&lt;/h1&gt;&lt;p&gt;比起设计模式，个人认为这 3 条原则更加重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DRY（&lt;strong&gt;Don’t Repeat Yourself）&lt;/strong&gt;：尽量在项目中减少重复的代码行，重复的方法，重复的模块。其实许多设计原则和模式最本质的思想都是在消除重复。&lt;/li&gt;
&lt;li&gt;KISS（&lt;strong&gt;Keep It Simple, Stupid&lt;/strong&gt;）：让代码简单直接，用简单的方法解决复杂的问题，保持代码可读性和可维护性，足够简单，也就意味着很容易读懂，这就让 BUG 不容易隐藏且更容易修复。&lt;/li&gt;
&lt;li&gt;YAGNI（&lt;strong&gt;You aren’t gonna need it&lt;/strong&gt;）：只有当你需要的时候才去添加额外的功能，不要过度设计。我们经常会在开发当中尽可能的迎合未来可能的需求。而为了迎合某些产生概率极低的需求而设计的成本是非常高的，这种过度设计的收益非常低。可能你深思熟虑的设计花了不少时间成本，却在未来的两三年内这个设计却完全没有派上用场。一些设计是否必要，更多的应该基于当前的情况。而不是为了应对未来的各种变化，画蛇添足的设计。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/design_pattern_flutter/design_pattern_cover.webp&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://blog.wangruofeng007.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Flutter" scheme="https://blog.wangruofeng007.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 升级到 V7.3</title>
    <link href="https://blog.wangruofeng007.com/2024/11/01/Hexo-%E5%8D%87%E7%BA%A7%E5%88%B0-V7-3/"/>
    <id>https://blog.wangruofeng007.com/2024/11/01/Hexo-%E5%8D%87%E7%BA%A7%E5%88%B0-V7-3/</id>
    <published>2024-11-01T06:04:25.000Z</published>
    <updated>2024-11-03T10:27:16.892Z</updated>
    
    <content type="html"><![CDATA[<p>最近换了台 Apple M2 电脑，整个软件都进行重装，<strong>Hexo</strong> 年久失修，在设置的时候出现很多警告 ⚠️，看了一下日志主要原因是以前版本依赖的 node 版本太低了，还有相关依赖库因为太旧有不少安全漏洞，查了一下 Hexo 最新发布的为 <a href="https://hexo.io/news/2024/07/02/hexo-7-3-0-released/">7.3 版本 </a>，于是打算整体迁移一下。</p><p><img src="/images/hexo_update/hexo.webp"></p><span id="more"></span><h1 id="安装-Hexo-7-3"><a href="#安装-Hexo-7-3" class="headerlink" title="安装 Hexo 7.3"></a>安装 Hexo 7.3</h1><p>首先 Hexo 的安装可以用 brew 了。使用 <code>brew install hexo</code> 安装，安装好之后 Hexo 在 <code>/opt/homebrew/Cellar/hexo/7.3.0</code> 下。</p><p>使用 Hexo 的如下指令完成建站</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>当前环境配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo: 7.3.0</span><br><span class="line">node：v22.11.0</span><br><span class="line">npm：10.9.0</span><br><span class="line">brew：4.4.2</span><br></pre></td></tr></table></figure><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><p>资源迁移：建完站之后，把之前的文章（source&#x2F;_posts）和静态资源（例如图片 source&#x2F;images）都迁移过去。</p><p>如果博客有映射自己的域名，记得把 CNAME 文件也迁移一下</p><p>配置主题：由于我定制过 Next 主题，就直接把旧项目的主题直接拷贝到新项目的 themes&#x2F;next 目录即可。如果是第一次建站需要在 themes 目录下把 <a href="https://github.com/next-theme/hexo-theme-next">Next</a> clone 下来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next.git next</span><br></pre></td></tr></table></figure><p>配置 <code>_config.yml</code> 主题为 next：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>配置语言：在 <code>_config.yml</code> 中更新博客语言配置，默认为英语</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure><p>配置链接风格：修改 <code>_config.yml</code> 的 permalink 生成格式，这里配置成短链风格，如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认风格</span></span><br><span class="line"><span class="comment"># permalink: :year/:month/:day/:title/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文章 url 风格调整成短链风</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span></span><br></pre></td></tr></table></figure><h1 id="配置分类"><a href="#配置分类" class="headerlink" title="配置分类"></a>配置分类</h1><p>这步配置可以参考[这个帖子](<a href="https://tohugo.com/2021/01/26/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Hexo">https://tohugo.com/2021/01/26/工具配置/Hexo</a> 添加分类及标签（在 Next 主题下）&#x2F;)</p><p>打开命令行，进入博客项目所在的文件夹下，执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>成功会有提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~/path_to_blog/source/categories/index.md</span><br></pre></td></tr></table></figure><p>这样我们就创建好了分类页面了。但是这个时候主题还不会识别这个页面为分类页；所以我们需要编辑这个新建的页面，让主题识别这个页面，并自动为这个页面显示分类。</p><p>编辑 <code>index.md</code> 在文件中添加 type: “categories”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line"><span class="built_in">date</span>: 2024-11-02 13:43:56</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="配置标签"><a href="#配置标签" class="headerlink" title="配置标签"></a>配置标签</h1><p>同理 配置 tags</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>成功会有提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~/path_to_blog/source/tags/index.md</span><br></pre></td></tr></table></figure><p>编辑 <code>index.md</code> 在文件中添加 type: “tags”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line"><span class="built_in">date</span>: 2024-11-02 13:44:19</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><h2 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h2><p>安装 <code>hexo-generator-searchdb</code> 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># search</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.json</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h2><p>安装 <code>npm install hexo-word-counter</code> 插件 , <a href="https://hexo-next.readthedocs.io/zh-cn/latest/next/advanced/%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/">参考</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-word-counter</span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h2 id="Disqus"><a href="#Disqus" class="headerlink" title="Disqus"></a>Disqus</h2><p>要在 Hexo 博客中使用 Next 主题集成 Disqus 评论系统，请按照以下步骤进行配置：</p><ol><li><p><strong>注册 Disqus 并获取短名称</strong>:</p><ul><li>前往 <a href="https://disqus.com/">Disqus</a> 官网注册一个账户，并创建一个新的站点。</li><li>创建站点后，会分配一个 <code>shortname</code>，这是你在 Next 主题中配置 Disqus 的关键。</li></ul></li><li><p><strong>配置 Next 主题</strong>:</p><ul><li>打开你的 Hexo 博客的 Next 主题配置文件，路径通常是 <code>/Users/ruofeng/Documents/git_repo/hexo_blog/themes/next/_config.yml</code>。</li><li>找到 <code>disqus</code> 设置部分并启用它。</li></ul><p>示例配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Disqus comments</span></span><br><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">shortname:</span> <span class="string">your_disqus_shortname</span></span><br></pre></td></tr></table></figure><p>将 <code>your_disqus_shortname</code> 替换为你在 Disqus 上获得的 <code>shortname</code>。</p></li><li><p><strong>重新部署博客 &amp; 集成验证</strong>:<br>确保保存配置文件后，在 Hexo 根目录中执行以下命令重新生成和部署博客：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -d</span><br></pre></td></tr></table></figure><p>打开你的博客页面，检查文章页底部是否显示了 Disqus 评论区域。</p></li></ol><h2 id="发布插件"><a href="#发布插件" class="headerlink" title="发布插件"></a>发布插件</h2><p>然后需要在 blog 根目录下安装以下插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>因为我在 <code>config.yml</code> 中配置好了 deploy 信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">&quot;Site updated: <span class="template-variable">&#123;&#123; now(&#x27;YYYY-MM-DD HH:mm&#x27;) &#125;&#125;</span>&quot;</span></span><br><span class="line">  <span class="attr">repo:</span> </span><br><span class="line">    <span class="attr">github:</span> <span class="string">git@github.com:wangruofeng/wangruofeng.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布新文章</span></span><br><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预览</span></span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成文件到 public 目录</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布到 Github Pages</span></span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除缓存</span></span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>需要注意，如果改了文件发布的话，要先 <code>hexo g</code> ，然后再 <code>hexo d</code> 。</p><!-- processed 2 -->]]></content>
    
    
    <summary type="html">&lt;p&gt;最近换了台 Apple M2 电脑，整个软件都进行重装，&lt;strong&gt;Hexo&lt;/strong&gt; 年久失修，在设置的时候出现很多警告 ⚠️，看了一下日志主要原因是以前版本依赖的 node 版本太低了，还有相关依赖库因为太旧有不少安全漏洞，查了一下 Hexo 最新发布的为 &lt;a href=&quot;https://hexo.io/news/2024/07/02/hexo-7-3-0-released/&quot;&gt;7.3 版本 &lt;/a&gt;，于是打算整体迁移一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/hexo_update/hexo.webp&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="博客搭建" scheme="https://blog.wangruofeng007.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="https://blog.wangruofeng007.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>如何通过 SSH 的方式向 Github 提交代码</title>
    <link href="https://blog.wangruofeng007.com/2024/10/30/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-ssh-%E6%96%B9%E5%BC%8F%E5%90%91-Github-%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/"/>
    <id>https://blog.wangruofeng007.com/2024/10/30/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-ssh-%E6%96%B9%E5%BC%8F%E5%90%91-Github-%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/</id>
    <published>2024-10-30T04:19:02.000Z</published>
    <updated>2024-11-03T05:32:35.297Z</updated>
    
    <content type="html"><![CDATA[<p>通过 SSH 提交代码到 GitHub，可以提高安全性并避免每次提交时输入用户名和密码。</p><p><img src="/images/ssh/ssh.webp"></p><span id="more"></span><p>以下是详细步骤：</p><h3 id="1-检查本地是否有-SSH-密钥"><a href="#1-检查本地是否有-SSH-密钥" class="headerlink" title="1. 检查本地是否有 SSH 密钥"></a>1. 检查本地是否有 SSH 密钥</h3><p>在终端中输入以下命令，检查是否已有 SSH 密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> ~/.ssh</span><br></pre></td></tr></table></figure><p>如果看到 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 文件，表示已有密钥；否则需要生成一个新的 SSH 密钥。</p><h3 id="2-生成新的-SSH-密钥"><a href="#2-生成新的-SSH-密钥" class="headerlink" title="2. 生成新的 SSH 密钥"></a>2. 生成新的 SSH 密钥</h3><p>如果没有现有密钥，可以生成新的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;你的邮箱@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>按回车接受默认路径，创建密钥时可选择设置密码以增加安全性。</p><h3 id="3-启动-SSH-Agent-并添加密钥"><a href="#3-启动-SSH-Agent-并添加密钥" class="headerlink" title="3. 启动 SSH Agent 并添加密钥"></a>3. 启动 SSH Agent 并添加密钥</h3><p>启动 SSH Agent 并将密钥添加到它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><h3 id="4-将-SSH-公钥添加到-GitHub"><a href="#4-将-SSH-公钥添加到-GitHub" class="headerlink" title="4. 将 SSH 公钥添加到 GitHub"></a>4. 将 SSH 公钥添加到 GitHub</h3><p>复制公钥到剪贴板：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub | pbcopy   <span class="comment"># macOS</span></span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub | clip     <span class="comment"># Windows</span></span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub            <span class="comment"># Linux，手动复制</span></span><br></pre></td></tr></table></figure><p>登录 GitHub，导航到 <strong>Settings &gt; SSH and GPG keys</strong>，点击 <strong>New SSH key</strong>，粘贴公钥并保存。</p><h3 id="5-测试-SSH-连接"><a href="#5-测试-SSH-连接" class="headerlink" title="5. 测试 SSH 连接"></a>5. 测试 SSH 连接</h3><p>使用以下命令测试与 GitHub 的 SSH 连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果连接成功，会看到类似以下消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi &lt;你的用户名&gt;! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><h3 id="6-克隆仓库或更新远程仓库-URL"><a href="#6-克隆仓库或更新远程仓库-URL" class="headerlink" title="6. 克隆仓库或更新远程仓库 URL"></a>6. 克隆仓库或更新远程仓库 URL</h3><p>如果已经克隆了仓库，更新其远程仓库 URL：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:&lt;用户名&gt;/&lt;仓库名&gt;.git</span><br></pre></td></tr></table></figure><h3 id="7-提交和推送代码"><a href="#7-提交和推送代码" class="headerlink" title="7. 提交和推送代码"></a>7. 提交和推送代码</h3><p>按照正常的 Git 工作流，提交并推送代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;提交说明&quot;</span></span><br><span class="line">git push origin main  <span class="comment"># 或者其他分支名</span></span><br></pre></td></tr></table></figure><p>这时，你应该能够通过 SSH 将代码安全地推送到 GitHub。</p><p><strong>Tips</strong></p><p>确保你的本地 Git 配置了正确的用户名和邮箱：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的邮箱@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>这样，你就可以使用 SSH 将代码提交到 GitHub，而无需输入用户名和密码了。</p><!-- processed 2 -->]]></content>
    
    
    <summary type="html">&lt;p&gt;通过 SSH 提交代码到 GitHub，可以提高安全性并避免每次提交时输入用户名和密码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ssh/ssh.webp&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CLI" scheme="https://blog.wangruofeng007.com/categories/CLI/"/>
    
    
    <category term="SSH" scheme="https://blog.wangruofeng007.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>物联网通讯协议</title>
    <link href="https://blog.wangruofeng007.com/2024/02/24/%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/"/>
    <id>https://blog.wangruofeng007.com/2024/02/24/%E7%89%A9%E8%81%94%E7%BD%91%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/</id>
    <published>2024-02-24T04:16:29.000Z</published>
    <updated>2024-11-03T05:32:35.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="物联网协议分类：-接入协议、通讯协议"><a href="#物联网协议分类：-接入协议、通讯协议" class="headerlink" title="物联网协议分类： 接入协议、通讯协议"></a>物联网协议分类： 接入协议、通讯协议</h1><ul><li>接入协议：一般负责子网内设备间的组网及通信。</li><li>通讯协议：主要是运行在传统互联网 TCP&#x2F;IP 协议之上的设备通讯协议，负责设备通过互联网进行数据交换及通信。</li></ul><p><img src="/images/common/lot.webp"></p><span id="more"></span><h1 id="一、物理层、数据链路层协议"><a href="#一、物理层、数据链路层协议" class="headerlink" title="一、物理层、数据链路层协议"></a>一、物理层、数据链路层协议</h1><h2 id="1-远距离蜂窝通讯"><a href="#1-远距离蜂窝通讯" class="headerlink" title="1. 远距离蜂窝通讯"></a>1. 远距离蜂窝通讯</h2><ul><li>2G、3G、4G 通讯协议</li><li>NB-loT (Narrow Brand Internet of Things) 窄带物联网</li><li>5G</li></ul><h2 id="2-远距离非蜂窝通讯"><a href="#2-远距离非蜂窝通讯" class="headerlink" title="2. 远距离非蜂窝通讯"></a>2. 远距离非蜂窝通讯</h2><ul><li>WiFi</li><li>ZigBee</li><li>LoRa（LongRange）</li></ul><h2 id="3-近距离通讯"><a href="#3-近距离通讯" class="headerlink" title="3. 近距离通讯"></a>3. 近距离通讯</h2><ul><li>RFID（Radio Frequency Identification）射频识别</li><li>NFC</li><li>Bluetooth（BLE）</li><li>UWB （Ultra Wideband）无载波无线通讯技术</li></ul><h2 id="4-有线通信"><a href="#4-有线通信" class="headerlink" title="4. 有线通信"></a>4. 有线通信</h2><ul><li>USB（Universal Series Bus）通用串行总线</li><li>串口通讯协议，RS-232、RS-422 和 RS-485</li><li>以太网</li><li>MBus（symphonic mbus）远程抄表系统</li></ul><h1 id="二、网络层、传输协议"><a href="#二、网络层、传输协议" class="headerlink" title="二、网络层、传输协议"></a>二、网络层、传输协议</h1><ul><li>IPv4</li><li>IPv6</li><li>TCP（Transmission Control Protocol）传输控制协议</li><li>6LowPAN</li></ul><h1 id="三、应用层协议"><a href="#三、应用层协议" class="headerlink" title="三、应用层协议"></a>三、应用层协议</h1><ul><li>MQTT（Message Queue Telemetry Transport）遥测传输协议</li><li>CoAP（Constrained Application Protocol）协议</li><li>REST &#x2F; HTTP 协议</li><li>DDS（Data Distribution Service）分布式实时数据分发服务中间件协议</li><li>AMQP（Advanced Message Queuing Protocol）高级消息队列协议</li><li>XMPP（Extensible messaging and presence protocol 基于 XML 协议）可扩展通讯和表示协议</li></ul><h1 id="四、部分协议比较"><a href="#四、部分协议比较" class="headerlink" title="四、部分协议比较"></a>四、部分协议比较</h1><h2 id="1-NB-IoT-协议和-LoRa-协议比较"><a href="#1-NB-IoT-协议和-LoRa-协议比较" class="headerlink" title="1. NB-IoT 协议和 LoRa 协议比较"></a>1. NB-IoT 协议和 LoRa 协议比较</h2><p>第一，频段。LoRa 工作在 1GHz 以下的非授权频段，在应用时不需要额外付费，NB-IoT 和蜂窝通信使用 1GHz 以下的频段是 2113 授权的，是需要收费的。</p><p>第二，电池供电寿命。LoRa 模块在处理干扰、网络 5261 重迭、可伸缩性等方面具有独特的特性，但却不能提供像蜂窝协议一样的服务质量 4102。NB-IoT 出于对服务质量的考虑，不能提供类似 LoRa 一样的电池寿命。</p><p>第三，设备成本。对终端节点来说，LoRa 协议比 NB-IoT 更简单，更容易开发并且 1653 对于微处理器的适用和兼容性更好。同时低成本、技术相对成熟的 LoRa 模块已经可以在市场上找到了，并且还会有升级版本陆续出来。</p><p>第四，网络覆盖和部署时间表。NB-IoT 标准在 2016 年公布，除回网络部署之外，相应的商业化和产业链的建立还需要更长的时间和努力去探索。LoRa 的整个产业链相对已经较为成熟了，产品也处于“蓄势待答发”的状态，同时全球很多国家正在进行或者已经完成了全国性的网络部署。</p><h2 id="2-蓝牙、WiFi、ZigBee-协议比较"><a href="#2-蓝牙、WiFi、ZigBee-协议比较" class="headerlink" title="2. 蓝牙、WiFi、ZigBee 协议比较"></a>2. 蓝牙、WiFi、ZigBee 协议比较</h2><p>目前来说，WiFi 的优势是应用广泛，已经普及到千家万户；ZigBee 的优势是低功耗和自组网；UWB 无载波无线通信技术的优势是传输速率；蓝牙的优势组网简单。然而，这 3 种技术，也都有各自的不足，没有一种技术能完全满足智能家居的全部要求。</p><p>蓝牙技术的出现使得短距离无线通信成为可能，但其协议较复杂、功耗高、成本高等特点不太适用于要求低成本、低功耗的工业控制和家庭网络。尤其蓝牙最大的障碍在于传输范围受限，一般有效的范围在 10 米左右，抗干扰能力不强、信息安全问题等问题也是制约其进一步发展和大规模应用的主要因素。</p><p>WiFi 也是是一种短距离无线传输技术，可以随时接入无线信号，移动性强，比较适合在办公室及家庭的环境下应用。当然 WiFi 也存在一个致命缺点。由于 WiFi 采用的是射频技术，通过空气发送和接收数据，使用无线电波传输数据信号，比较容易受到外界的干扰。</p><p>ZigBee 则是国际通行的无线通讯技术，它的每个网络端口可以最多接入 6.5 万多个端口，适合家居、工业、农业等多个领域使用，而蓝牙和 WiFi 网端只能接入 10 个端口，显然不能适应家庭需要。ZigBee 还具有低功耗和低成本优势。</p><h2 id="3-MQTT-协议和-CoAP-协议比较"><a href="#3-MQTT-协议和-CoAP-协议比较" class="headerlink" title="3. MQTT 协议和 CoAP 协议比较"></a>3. MQTT 协议和 CoAP 协议比较</h2><p>MQTT 是多对多通讯协议用于在不同客户端之间通过中间代理传送消息，解耦生产者与消费者，通过使得客户端发布，让代理决定路由并且拷贝消息。虽然 MQTT 支持一些持久化，最好还是作为实时数据通讯总线。</p><p>CoAP 主要是一个点对点协议，用于在客户端与服务器之间传输状态信息。虽然支持观察资源，CoAP 最好适合状态传输模型，不是完全基于事件。</p><p>MQTT 客户端建立长连接 TCP，这通常表示没有问题，CoAP 客户端与服务器都发送与接收 UDP 数据包，在 NAT 环境中，隧道或者端口转发可以用于允许 CoAP，或者像 LWM2M，设备也许会先初始化前端连接。</p><p>MQTT 不提供支持消息打类型标记或者其他元数据帮助客户端理解，MQTT 消息可用于任何目的，但是所有的客户端必须知道向上的数据格式以允许通讯，CoAP，相反地，提供内置支持内容协商与发现，允许设备相互探测以找到交换数据的方式。</p><p>两种协议各有优缺点，选择合适的取决于自己的应用。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://mp.weixin.qq.com/s/n8PnUuubTHM7ZPmmtD5jfA">【知识分享】您了解物联网通信协议 5G、NB-Iot、LoRa、ZigBee、NFC…….都是啥吗？</a></li></ul><!-- processed 2 -->]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;物联网协议分类：-接入协议、通讯协议&quot;&gt;&lt;a href=&quot;#物联网协议分类：-接入协议、通讯协议&quot; class=&quot;headerlink&quot; title=&quot;物联网协议分类： 接入协议、通讯协议&quot;&gt;&lt;/a&gt;物联网协议分类： 接入协议、通讯协议&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;接入协议：一般负责子网内设备间的组网及通信。&lt;/li&gt;
&lt;li&gt;通讯协议：主要是运行在传统互联网 TCP&amp;#x2F;IP 协议之上的设备通讯协议，负责设备通过互联网进行数据交换及通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/common/lot.webp&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://blog.wangruofeng007.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="loT" scheme="https://blog.wangruofeng007.com/tags/loT/"/>
    
  </entry>
  
  <entry>
    <title>几分钟内本地快速搭建 ChatGPT 环境</title>
    <link href="https://blog.wangruofeng007.com/2023/07/31/%E5%87%A0%E5%88%86%E9%92%9F%E5%86%85%E6%9C%AC%E5%9C%B0%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAChatGPT%E7%8E%AF%E5%A2%83/"/>
    <id>https://blog.wangruofeng007.com/2023/07/31/%E5%87%A0%E5%88%86%E9%92%9F%E5%86%85%E6%9C%AC%E5%9C%B0%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAChatGPT%E7%8E%AF%E5%A2%83/</id>
    <published>2023-07-31T15:04:59.000Z</published>
    <updated>2024-11-03T05:32:35.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>使用 Docker 虚拟机，几步在本地快速搭建 ChatGPT 环境，免 API，免翻墙，即可使用纯正 OpenAI 的全部功能，完全免费！</p><p><img src="/images/ChatGPT/ChatGPT_info.png"></p><span id="more"></span><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="下载安装-Docker"><a href="#下载安装-Docker" class="headerlink" title="下载安装 Docker"></a>下载安装 Docker</h2><p>官网下载地址：<a href="https://www.docker.com/">https://www.docker.com/</a></p><h2 id="拉取-pandora-镜像"><a href="#拉取-pandora-镜像" class="headerlink" title="拉取 pandora 镜像"></a>拉取 pandora 镜像</h2><p>pandora 源码地址：<a href="https://github.com/pengzhile/pandora">https://github.com/pengzhile/pandora</a></p><p>安装好 Docker 后，打开 Mac 终端，输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull pengzhile/pandora</span><br></pre></td></tr></table></figure><h2 id="启动-pandora-镜像"><a href="#启动-pandora-镜像" class="headerlink" title="启动 pandora 镜像"></a>启动 pandora 镜像</h2><p>等上面镜像下载完成后，输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run  -e PANDORA_CLOUD=cloud -e PANDORA_SERVER=0.0.0.0:8899 -p 8899:8899 -d pengzhile/pandora</span><br></pre></td></tr></table></figure><p>成功运行效果<br><img src="/images/ChatGPT/docker_run.png" alt="docker_run"></p><h2 id="获取-AccessToken"><a href="#获取-AccessToken" class="headerlink" title="获取 AccessToken"></a>获取 AccessToken</h2><p>通过登录 OpenAI 官方 API，登录成功后，然后访问 <a href="https://chat.openai.com/api/auth/session">这里</a> 即可拿到官方的 Access Token（ps：这一步需要翻墙才能完成）</p><p>获取成功后效果图<br><img src="/images/ChatGPT/as.jpg" alt="access_token"></p><blockquote><p>注意：Token 目前看有效期是一个月，一个月后需要重新获取</p></blockquote><h2 id="访问本地链接"><a href="#访问本地链接" class="headerlink" title="访问本地链接"></a>访问本地链接</h2><p><a href="http://127.0.0.1:8899/">http://127.0.0.1:8899</a> </p><p>使用上一步获取的 Access Token 登录即可<br><img src="/images/ChatGPT/login_with_access_token.png" alt="login_with_access_token"></p><p>登录成功后，即可使用 OpenAI 的全部功能，完全免费！🎉🎉🎉<br><img src="/images/ChatGPT/chat_gpt_demo.png" alt="chat_gpt_demo"></p><!-- processed 2 -->]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;使用 Docker 虚拟机，几步在本地快速搭建 ChatGPT 环境，免 API，免翻墙，即可使用纯正 OpenAI 的全部功能，完全免费！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ChatGPT/ChatGPT_info.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="AI" scheme="https://blog.wangruofeng007.com/categories/AI/"/>
    
    
    <category term="ChatGPT" scheme="https://blog.wangruofeng007.com/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 最佳实践整理</title>
    <link href="https://blog.wangruofeng007.com/2021/03/28/Flutter%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%95%B4%E7%90%86/"/>
    <id>https://blog.wangruofeng007.com/2021/03/28/Flutter%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%95%B4%E7%90%86/</id>
    <published>2021-03-28T04:10:21.000Z</published>
    <updated>2024-11-03T05:37:41.776Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/cover_img/johannes-andersson-v5gGwubKzEA-unsplash.jpg"></p><span id="more"></span><h2 id="Text-以字符的方式截断"><a href="#Text-以字符的方式截断" class="headerlink" title="Text 以字符的方式截断"></a>Text 以字符的方式截断</h2><p><a href="https://github.com/flutter/flutter/issues/52869">https://github.com/flutter/flutter/issues/52869</a></p><p>在 flutter 中，Text 控件默认的溢出显示模式是 <code>TextOverflow.fade</code> ,就是淡出</p><p>在 iOS 或者 Android 平台默认的文件截断模式一般是…省略，flutter 里面对应的截断模式为 <code>TextOverflow.ellipsis</code> ,不过这里的截断是英文按照单词来的，这样的模式会导致如果最后一个单词很长时，截断显示会整理省略而不是最后超出的字符省略，导致模块可能有一大块空白。</p><p>Dart 系统定义的截断模式</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">How overflowing text should be handled.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">A [TextOverflow] can be passed to [Text] and [RichText] via their</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[Text.overflow] and [RichText.overflow] properties respectively.</span></span></span><br><span class="line"><span class="keyword">enum</span> TextOverflow &#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Clip the overflowing text to fix its container.</span></span></span><br><span class="line">  clip,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Fade the overflowing text to transparent.</span></span></span><br><span class="line">  fade,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Use an ellipsis to indicate that the text has overflowed.</span></span></span><br><span class="line">  ellipsis,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Render overflowing text outside of its container.</span></span></span><br><span class="line">  visible,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何解决英文单词被整体截断呢？</p><p>将单词的每个字符切割开，插入宽度 0 的占位字符，打破系统默认的机制，这样就可以以字符为单位省略了</p><blockquote><p>需要注意。这种方式相当于修改了文本的内容，一般文本最大一行显示可以用，如果文本支持 2 行以及以上的显示的话，将会导致换行不再按照字符进行而按照单词进行</p></blockquote><p>下面是 Example 实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extension TextOverflowUtil on String &#123;</span><br><span class="line">  <span class="comment">/// 将 flutter 系统默认的单词截断模式转换成字符截断模式</span></span><br><span class="line">  <span class="comment">/// 通过向文本中插入宽度为 0 的空格实现</span></span><br><span class="line">  <span class="keyword">static</span> String toCharacterBreakStr(String word) &#123;</span><br><span class="line">    <span class="keyword">if</span> (word == null || word.isEmpty) &#123;</span><br><span class="line">      <span class="keyword">return</span> word;</span><br><span class="line">    &#125;</span><br><span class="line">    String breakWord = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    word.runes.forEach((element) &#123;</span><br><span class="line">      breakWord += String.fromCharCode(element);</span><br><span class="line">      breakWord += <span class="string">&#x27;\u200B&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> breakWord;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文本划线"><a href="#文本划线" class="headerlink" title="文本划线"></a>文本划线</h2><p>通过 Text 的 decoration 属性来实现划线</p><ul><li>TextDecoration.none 没有</li><li>TextDecoration.underline 下划线</li><li>TextDecoration.overline 上划线</li><li>TextDecoration.lineThrough 中间的线（删除线）</li></ul><p>&#x2F;&#x2F; 划线相关的属性设置<br>decorationColor decoration 划线的颜色<br>decorationStyle decoration 划线的样式</p><ul><li>TextDecorationStyle.solid 实线</li><li>TextDecorationStyle.double 画两条线</li><li>TextDecorationStyle.dotted 点线（一个点一个点的）</li><li>TextDecorationStyle.dashed 虚线（一个长方形一个长方形的线）</li><li>TextDecorationStyle.wavy 正玄曲</li></ul><p>效果图如下</p><p><img src="/images/best_practise/best_practise_01.png" alt="best_practise_01"></p><h2 id="VS-Code-实现保存时自动代码格式化"><a href="#VS-Code-实现保存时自动代码格式化" class="headerlink" title="VS Code 实现保存时自动代码格式化"></a>VS Code 实现保存时自动代码格式化</h2><p>VS Code 中代码格式化默认快捷键：【Shift】+【Alt】+ F</p><p>实现手动保存（Ctril + S）时自动触发代码格式化：</p><p>1）Code → Perference → Settting 点击右上角（Open Setting(JSON) ）</p><p><img src="/images/best_practise/best_practise_02.png" alt="best_practise_02"></p><p>2）在 settings.json 下的【工作区设置】中添加以下语句：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;editor.formatOnType&quot;</span>: <span class="keyword">true</span>,</span><br><span class="line"><span class="string">&quot;editor.formatOnSave&quot;</span>: <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><img src="/images/best_practise/best_practise_03.png" alt="best_practise_03"></p><h2 id="解决-setState-called-after-diapose"><a href="#解决-setState-called-after-diapose" class="headerlink" title="解决 setState() called after diapose()"></a>解决 setState() called after diapose()</h2><p>网络请求成功前退出了页面，该 State 被从对象树卸载掉，而这时回调了网络请求的方法，方法中带有 setState 的调用，也就导致了该问题。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mounted) &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    <span class="keyword">this</span>._books = dataModel.books;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Waiting-for-another-flutter-command-to-release-the-startup-lock…等待另一个-flutter-命令释放启动锁"><a href="#Waiting-for-another-flutter-command-to-release-the-startup-lock…等待另一个-flutter-命令释放启动锁" class="headerlink" title="Waiting for another flutter command to release the startup lock…等待另一个 flutter 命令释放启动锁"></a>Waiting for another flutter command to release the startup lock…等待另一个 flutter 命令释放启动锁</h2><ol><li>退出 VS Code。</li><li>打开 flutter 安装目录 如：…\flutter\flutter\bin\cache 删除里面的 lockfile。</li><li>重启打开 VS Code。</li></ol><p>原因：当你的项目异常关闭，下次启动就会出现上面的一行话，<br>此时需要打开 flutter&#x2F;bin&#x2F;cache&#x2F;lockfile，删除就行了，<br>或者直接用下面的命令：rm .&#x2F;flutter&#x2F;bin&#x2F;cache&#x2F;lockfile。</p><h2 id="在-Stateless-控件内部或者浮层内部刷新，可以使用-StatefullBuilder"><a href="#在-Stateless-控件内部或者浮层内部刷新，可以使用-StatefullBuilder" class="headerlink" title="在 Stateless 控件内部或者浮层内部刷新，可以使用 StatefullBuilder"></a>在 Stateless 控件内部或者浮层内部刷新，可以使用 StatefullBuilder</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">showDialog&lt;<span class="keyword">void</span>&gt;(</span><br><span class="line">  context: context,</span><br><span class="line">  builder: (BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">int</span> selectedRadio = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> AlertDialog(</span><br><span class="line">      content: StatefulBuilder(</span><br><span class="line">        builder: (BuildContext context, StateSetter setState) &#123;</span><br><span class="line">          <span class="keyword">return</span> Column(</span><br><span class="line">            mainAxisSize: MainAxisSize.min,</span><br><span class="line">            children: <span class="built_in">List</span>&lt;Widget&gt;.generate(<span class="number">4</span>, (<span class="built_in">int</span> index) &#123;</span><br><span class="line">              <span class="keyword">return</span> Radio&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">                value: index,</span><br><span class="line">                groupValue: selectedRadio,</span><br><span class="line">                onChanged: (<span class="built_in">int</span> value) &#123;</span><br><span class="line">                  setState(() =&gt; selectedRadio = value);</span><br><span class="line">                &#125;,</span><br><span class="line">              );</span><br><span class="line">            &#125;),</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里通过 selectedRadio 变量记录 Radio 的是否选中的状态</p><h2 id="平台相关的判断"><a href="#平台相关的判断" class="headerlink" title="平台相关的判断"></a>平台相关的判断</h2><p>只关心是否是 iOS 和 Android 的情况下不需要依赖 <code>context</code> ，优先使用 <code>Platform</code> &#96;&#96;&#96;json<br>Platform.isAndroid<br>Platform.isIOS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">需要详细知道具体哪个平台才使用 `TargetPlatform` 这个 API 的缺点是需要依赖 `context` 这个参数</span><br><span class="line"></span><br><span class="line">```dart</span><br><span class="line">final platform = Theme.of(context).platform;</span><br><span class="line"></span><br><span class="line">if (platform == TargetPlatform.android) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; else if (platform == TargetPlatform.iOS) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ScrollView-滑动隐藏键盘"><a href="#ScrollView-滑动隐藏键盘" class="headerlink" title="ScrollView 滑动隐藏键盘"></a>ScrollView 滑动隐藏键盘</h2><p><a href="https://stackoverflow.com/questions/55306855/hide-keyboard-on-scroll-in-flutter">https://stackoverflow.com/questions/55306855/hide-keyboard-on-scroll-in-flutter</a></p><p>使用 ScrollView 的 <code>keyboardDismissBehavior</code> 属性</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListView(</span><br><span class="line">keyboardDismissBehavior<span class="punctuation">:</span> ScrollViewKeyboardDismissBehavior.onDrag</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="回调写法"><a href="#回调写法" class="headerlink" title="回调写法"></a>回调写法</h2><h3 id="a-无参数回调"><a href="#a-无参数回调" class="headerlink" title="a.无参数回调"></a>a.无参数回调</h3><p>VoidCallback</p><h3 id="b-有一个参数回调"><a href="#b-有一个参数回调" class="headerlink" title="b.有一个参数回调"></a>b.有一个参数回调</h3><p>ValueChanged</p><h3 id="c-参数大于一个"><a href="#c-参数大于一个" class="headerlink" title="c.参数大于一个"></a>c.参数大于一个</h3><p>可以通过 <code>typedef</code> 自定义一个函数</p><p>下面是 Example 用法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> VoidCallback onPressed;</span><br><span class="line"><span class="keyword">final</span> ValueChanged&lt;T&gt; onSelectHandler;</span><br><span class="line"><span class="keyword">typedef</span> ImageSwiperOnTap = <span class="keyword">void</span> <span class="built_in">Function</span>(<span class="built_in">int</span> index, <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; imgUrls);</span><br></pre></td></tr></table></figure><h2 id="flutter-pub-get-is-stuck"><a href="#flutter-pub-get-is-stuck" class="headerlink" title="flutter pub get is stuck"></a>flutter pub get is stuck</h2><p>可以通过切换 flutter 镜像到中文站点来解决</p><p>使用系统 shell，请编辑</p><p>使用 oh_my_zsh, 需要编辑 <code>.zshrc</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line"><span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure><p>保存文件后，关闭，下次重新打开终端生效</p><p>再执行 <code>flutter pub get</code> 查看速度是否正常</p><!-- processed 2 -->]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/cover_img/johannes-andersson-v5gGwubKzEA-unsplash.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="最佳实践" scheme="https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Flutter" scheme="https://blog.wangruofeng007.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 精华资料收集</title>
    <link href="https://blog.wangruofeng007.com/2020/10/19/flutter%E7%B2%BE%E5%8D%8E%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"/>
    <id>https://blog.wangruofeng007.com/2020/10/19/flutter%E7%B2%BE%E5%8D%8E%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/</id>
    <published>2020-10-19T13:16:37.000Z</published>
    <updated>2024-11-03T05:32:35.285Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/cover_img/ray-hennessy-xUUZcpQlqpM-unsplash.jpg"></p><span id="more"></span><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>此文用于记录日常 flutter 开发中使用到或者看到的精华文章或者资源，方便日后查阅</p><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><h3 id="Flutter-进阶"><a href="#Flutter-进阶" class="headerlink" title="Flutter 进阶"></a>Flutter 进阶</h3><ul><li><a href="https://mp.weixin.qq.com/s/-vyU1JQzdGLUmLGHRImIvg">让 Flutter 真正支持 View 级别的混合开发</a></li><li><a href="https://jarontai.github.io/dart-souls/">Dart Souls -《Dart 之魂》</a></li><li><a href="https://guoshuyu.cn/home/wx/">Flutter 完整开发实战详解系列</a></li><li><a href="https://www.jianshu.com/p/39575a90e820">深入理解 Flutter Platform Channel</a></li><li><a href="https://juejin.im/post/5bab35ff5188255c3272c228">Flutter 布局控件完结篇</a></li><li><a href="https://mp.weixin.qq.com/s/xxdgoEBIC3Bg4OCOZcm-aQ">超详解析 Flutter 渲染引擎|业务想创新，不了解底层原理怎么行？</a> – from 淘系技术</li><li><a href="https://mp.weixin.qq.com/s/hZ5PUvPpMlEYBAJggGnJsw">深入理解 Flutter 引擎线程模式</a></li><li><a href="https://mp.weixin.qq.com/s/0R5UnVFlVbLKoV__s66HnA">Flutter 的性能分析、工程架构与细节处理</a> – from 有道云</li><li><a href="https://juejin.cn/post/6917081883201241101">Flutter 图片控件适配之路</a> – from 网易云音乐</li></ul><h3 id="业界动态"><a href="#业界动态" class="headerlink" title="业界动态"></a>业界动态</h3><ul><li><a href="https://juejin.im/post/5eb27cc9f265da7b9625e85c">Flutter 在哈啰出行 B 端创新业务的实践</a></li><li><a href="https://mp.weixin.qq.com/s/eJxmeAJ0ljmbPbgNVkGttQ">Flutter 在 PLUS 业务中的探索和实践</a></li><li><a href="https://mp.weixin.qq.com/s/57CprMfvTtIeq6AdgcDdcw">&quot;零&quot;学习成本：使用 Web 标准开发动态化 Flutter 应用</a></li><li><a href="https://www.infoq.cn/article/qSLsru9bEvuHgKpPlWMP">京东技术中台的 Flutter 实践之路</a></li><li><a href="https://www.infoq.cn/article/16dv4pmnghv6i1lct3r4">打破重重阻碍，Flutter 和 Web 生态如何对接？</a></li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li><a href="https://juejin.im/post/6844904153236373517">Flutter 性能优化实践 —— UI 篇</a></li></ul><h3 id="Flutter-动态"><a href="#Flutter-动态" class="headerlink" title="Flutter 动态"></a>Flutter 动态</h3><ul><li><a href="https://mp.weixin.qq.com/s/rL6FtCSyca8DsUuNVbSA_w">Dart: 健全的空安全概览</a></li><li><a href="https://mp.weixin.qq.com/s/MEL5kokoyb0CJcjrPpo12w">深入理解 Dart 空安全</a></li><li><a href="https://nullsafety.dartpad.cn/">nullsafety dartpad</a></li><li><a href="https://juejin.im/post/6879048672597213198">观摩！Flutter 1.22 正式发布</a></li></ul><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><ul><li><a href="https://flutter.io/">Flutter 官网</a></li><li><a href="https://flutterchina.club/">Flutter 中文网</a></li><li><a href="https://flutter.cn/docs">Flutter 中文开发文档</a></li><li><a href="http://book.flutterj.com/">Flutter 教程网</a></li></ul><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><ul><li><a href="https://www.youtube.com/watch?v=b_sQ9bMltGU&list=PLjxrf2q8roU23XGwz3Km7sQZFTdB996iG&index=2&t=0s">Introducing Widget of the Week!</a></li><li><a href="https://www.youtube.com/watch?v=fq4N0hgOWzU&list=PLOU2XLYxmsIJ7dsVN4iRuA7BT8XHzGtCr">Flutter by Google</a></li><li><a href="http://mudu.tv/watch/5624777mudu.tv/watch/5624777">AliFlutter 第二期直播回放</a></li><li><a href="https://www.bilibili.com/video/BV1n741117v1?from=search&seid=12211378857505011313">阿里巴巴闲鱼技术团队客户端负责人一起探讨 Flutter 的行业现状与未来</a></li></ul><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><ul><li><a href="https://www.jianshu.com/u/cf5c0e4b1111">咸鱼技术 - Flutter</a></li><li><a href="http://whysodiao.com/">Loki 的博客</a> — 目前就职于北京腾讯，博客里面有很 flutter 总结的文章</li><li><a href="http://laomengit.com/">老孟 flutter</a> — 整理了几乎所有的 widget，包含使用的例子，还有部分实战项目</li><li><a href="https://www.burkharts.net/apps/blog/">GuruMeditation</a> — 有一些关于 flutter 架构方面的文章</li></ul><h2 id="掘金博主"><a href="#掘金博主" class="headerlink" title="掘金博主"></a>掘金博主</h2><ul><li><a href="https://juejin.im/user/1767670428477015">Vadaski</a></li><li><a href="https://juejin.im/user/149189281194766">张风捷特烈</a></li><li><a href="https://juejin.im/user/483440843559406">YYDev</a></li><li><a href="https://juejin.im/user/2013961034677725">老孟 Flutter</a></li><li><a href="https://juejin.im/user/1257497031878408">闲鱼技术</a></li></ul><h2 id="电子书"><a href="#电子书" class="headerlink" title="电子书"></a>电子书</h2><ul><li><a href="https://book.flutterchina.club/">Flutter 实战</a> — 来自 duwen 是<a href="https://github.com/flutterchina/dio">dio</a>、<a href="https://github.com/wendux/fly">fly</a>、<a href="https://github.com/wendux/DSBridge-Android">dsBridge</a>等多个知名开源项目作者</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><a href="https://codepen.io/flutter">flutter 在线编辑工具 CodePen</a></li><li><a href="https://dartpad.dev/">Dart 在线编辑工具 DartPad</a></li><li><a href="https://javiercbk.github.io/json_to_dart/">在线 JSON To Dart 代码生成</a> </li><li><a href="https://charafau.github.io/json2builtvalue/">Json to Dart built_value class converter</a></li><li><a href="https://juejin.im/post/5f14e128e51d45347c1b926a">2020 年 20 个 Flutter 最漂亮的 UI 库和项目</a></li></ul><h2 id="优秀项目-App"><a href="#优秀项目-App" class="headerlink" title="优秀项目 &amp; App"></a>优秀项目 &amp; App</h2><ul><li><a href="https://github.com/CarGuo/gsy_github_app_flutter">GSYGithubAppFlutter</a> — 大型 flutter 项目， Star 10.8k</li><li><a href="https://github.com/2d-inc/developer_quest">Developer_quest</a> — Google 官方演示游戏 Demo，Star 2.6k</li><li><a href="https://flutter-go.pub/website/">Flutter Go</a> — Ali 开发的 flutter 组件 demo 演示和新闻资讯</li><li><a href="https://github.com/flutter/samples">Flutter Samples</a> — Flutter 官方 Demo，Star 7.3k</li><li><a href="https://github.com/Solido/awesome-flutter">awesome-flutter</a> — Flutter 相关的资料集合，Star 28.3k</li><li><a href="https://github.com/OpenFlutter/Flutter-Notebook">Flutter-Notebook</a> — FlutterDemo 合集, Star 5.7k</li><li><a href="https://github.com/toly1994328/FlutterUnit">FlutterUnit</a> — 组件演示项目， Star 1.8k</li><li><a href="https://github.com/diegoveloper/flutter-samples">flutter-samples</a> — Flutter 演示项目，很多动画效果 , Star 1.5k</li><li><a href="https://github.com/simplezhli/flutter_deer">flutter_deer</a> — Flutter 练手项目 ,功能很丰富， Star 4.1k</li><li><a href="https://github.com/iampawan/FlutterExampleApps">FlutterExampleApps</a> — Flutter 示例 App，包含常见流行作品（WhatsApp，Instagram 等）, Star 13.8k</li></ul><h2 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h2><ul><li><a href="https://files.alicdn.com/tpsservice/db6a840f7ac7a8e3d5bde69c401bcfd5.pdf">AliFlutter 图片解决方案与优化</a></li><li><a href="https://files.alicdn.com/tpsservice/d324c2a95852b22f1bdf2e60e55670a2.pdf">UC Flutter 技术实践分享</a></li></ul><!-- processed 2 -->]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/cover_img/ray-hennessy-xUUZcpQlqpM-unsplash.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="资料收集" scheme="https://blog.wangruofeng007.com/categories/%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/"/>
    
    
    <category term="网站" scheme="https://blog.wangruofeng007.com/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发 Tips （第二期）</title>
    <link href="https://blog.wangruofeng007.com/2020/09/17/Flutter-%E5%BC%80%E5%8F%91Tips-%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%9C%9F%EF%BC%89/"/>
    <id>https://blog.wangruofeng007.com/2020/09/17/Flutter-%E5%BC%80%E5%8F%91Tips-%EF%BC%88%E7%AC%AC%E4%BA%8C%E6%9C%9F%EF%BC%89/</id>
    <published>2020-09-16T18:51:21.000Z</published>
    <updated>2024-11-03T05:32:35.305Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/cover_img/ramon-salinero-vEE00Hx5d0Q-unsplash.jpg"></p><span id="more"></span><h2 id="提高-flutter-attach-的成功率"><a href="#提高-flutter-attach-的成功率" class="headerlink" title="提高 flutter attach 的成功率"></a>提高 flutter attach 的成功率</h2><h3 id="方案-1"><a href="#方案-1" class="headerlink" title="方案 1"></a>方案 1</h3><p>断开 wifi，执行 flutter attach，attach 成功后再链接 wifi</p><h3 id="方案-2"><a href="#方案-2" class="headerlink" title="方案 2"></a>方案 2</h3><p>通过指定设备 uuid 进行 attach</p><ol><li>通过 <code>flutter devices</code> 查找已链接设备列表，获取链接设备的 uuid</li><li><code>flutter attach -d &lt;#uuid#&gt;</code> 指定想要 attach 的设备进行连接，例如 <code>flutter attach -d AE5D772C-6D56-43AD-83F2-0554257B16C4</code> <img src="/images/flutter_tips_s2/flutter_attach.jpg" alt="Xnip2020-09-17_02-35-23"></li></ol><h3 id="方案-3"><a href="#方案-3" class="headerlink" title="方案 3"></a>方案 3</h3><p>通过指定应用的 app-id 进行 attach</p><ol><li>同一 wifi 环境下如果有多台相同项目设备连接中，找到你需要 attach 的 app-id 进行连接</li><li>执行： <code>flutter attach --app-id &lt;#app_id#&gt; </code> 例如： <code>flutter attach --app-id com.xxx.xxx</code> ## 从 package 中加载 json 文件</li></ol><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>例如我这里有一个 flutter 的 demo 项目叫 <code>flutter_demo_package_json_load</code> ，在根目录通过命令： <code>flutter create --template=package json_test_package</code> ,创建了一个名为 <code>json_test_package</code> 的 package，在 package 的 assets 中有一个为 test2.json 文件，现在需要在 package 中加载到改文件。</p><h3 id="从工程加载-json"><a href="#从工程加载-json" class="headerlink" title="从工程加载 json"></a>从工程加载 json</h3><p>对于普通项目的 json 文件，加载方式如下：</p><ol><li><p>在项目中添加 json 文件，例如项目的 assets 下有一个名为 test1.json 的文件</p></li><li><p>我们在 yaml 中添加如下依赖</p></li></ol>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只加载 assets 下的 test1.json 文件</span></span><br><span class="line"><span class="attr">assets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">assets/test1.json</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># 加载 assets 下的所有文件</span></span><br><span class="line"> <span class="attr">assets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">assets/</span></span><br></pre></td></tr></table></figure><ol start="3"><li>通过 rootBundle 加载</li></ol>  <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; _loadFromProjectAsset() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// json file in project,is ok</span></span><br><span class="line">  <span class="keyword">return</span> rootBundle.loadString(<span class="string">&quot;assets/test1.json&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于 package 下面 json 文件上面的方法失效了，使用上面的方法加载将会报错，错误信息如下：</p><p><img src="/images/flutter_tips_s2/flutter_tips_15.png" alt="image-20200917144141986"></p><p>错误原因是资源路径不对，加载不到，因为 rootBundle 类没有提供 package name 的参数，我们只能把 package name 信息放在资源路径里面。</p><h3 id="从-package-加载-json"><a href="#从-package-加载-json" class="headerlink" title="从 package 加载 json"></a>从 package 加载 json</h3><p>灵感来自 <a href="https://pub.dev/packages/lottie">https://pub.dev/packages/lottie</a> 库的 <code>Lottie.asset(&quot;assetsPath&quot;,package: &quot;package_name&quot;)</code> 方法，因为 lottie 实现动画的原理也是加载一份 json 配置，不过这个方法支持指定 package 配置。</p><p><img src="/images/flutter_tips_s2/flutter_tips_16.png" alt="image-20200917145538741"></p><p>这里的 keyName 就是我们 rootBundle 类里面需要用的资源路径，包含带 package 的情况。</p><p>正确的方式如下：</p><ol><li>第一步和上面一样，将 json 文件添加到工程中，假如这里我们 package 里面的 json 文件名为 test2.json</li><li>在 yaml 中添加如下依赖<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只加载 assets 下的 test2.json 文件</span></span><br><span class="line"><span class="attr">assets:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">assets/test2.json</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># 加载 assets 下的所有文件</span></span><br><span class="line"><span class="attr">assets:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">assets/</span></span><br></pre></td></tr></table></figure></li><li>通过 rootBundle 加载，但是 path 的格式为 <code>packages/&lt;#package_name#&gt;/&lt;#file_path#&gt;</code> 这里为</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// json file in package,this is work</span></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; _loadFromPackageAsset() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// 【importance】 packag json file need use this formate:</span></span><br><span class="line">  <span class="comment">//  `packages/$package/$assetName` </span></span><br><span class="line">  <span class="keyword">return</span> rootBundle.loadString(<span class="string">&quot;packages/json_test_package/assets/test2.json&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>DefaultAssetBundle</code> 也是一样可以</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is work too.</span></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; testLoadJsonFileByDefaultAssetBundle(BuildContext context) &#123;</span><br><span class="line">  <span class="comment">// 【importance】 packag json file need use this formate:</span></span><br><span class="line">  <span class="comment">//  `packages/$package/$assetName` </span></span><br><span class="line">  <span class="keyword">return</span> DefaultAssetBundle.of(context)</span><br><span class="line">      .loadString(<span class="string">&#x27;packages/json_test_package/assets/test2.json&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/wangruofeng/flutter_demo_package_json_load">Demo 链接</a></p></blockquote><h2 id="flutter-analyse"><a href="#flutter-analyse" class="headerlink" title="flutter analyse"></a>flutter analyse</h2><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><ul><li><p>在项目更目录添加 <code>analysis_options.yaml</code> 文件可以配置 lint 规则和 analyzer 行为</p></li><li><p>具体支持的 lint 规则参考 <a href="https://dart-lang.github.io/linter/lints/">https://dart-lang.github.io/linter/lints/</a></p></li><li><p>目前有 3 类已经定义的常用规则</p></li></ul><blockquote><p>Many lints are included in various predefined rulesets:</p></blockquote><ul><li><a href="https://github.com/dart-lang/pedantic">pedantic</a> for rules enforced internally at Google</li><li><a href="https://github.com/tenhobi/effective_dart">effective_dart</a> for rules corresponding to the <a href="https://dart.dev/guides/language/effective-dart">Effective Dart</a> style guide</li><li><a href="https://github.com/flutter/flutter/blob/master/packages/flutter/lib/analysis_options_user.yaml">flutter</a> for rules used in <code>flutter analyze</code>  * 推荐使用 google 团队内部的规则库 pedantic</li></ul><ul><li>在 yaml 里面添加依赖 <code>pedantic: ^1.8.0+1</code> * 在 <code>analysis_options.yaml</code> 里面引入使用</li></ul><blockquote><p><code>include: package:pedantic/analysis_options.1.8.0.yaml</code> ### 使用</p></blockquote><p>配置好 <code>analysis_options.yaml</code> 文件的规则后,执行 <code>flutter analyse</code> 命令将对你整个项目或者 package 的代码进行静态分析</p><h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><ul><li>根据提示修复</li></ul><p>点击提示的规则，就会跳转到需要修复位置，按照 lint 规则的说明和例子就可以修正了。<img src="/images/flutter_tips_s2/flutter_analyse_2.png" alt="flutter_analyse_1"></p><ul><li>利用 VSCode 快速修复</li></ul><p>在提示有问题的代码的地方 <code>Ctrl +.</code> , 就会自动弹出快速修复，比如图中为增加 <code>const</code> 标识。 是不是快多了。<img src="/images/flutter_tips_s2/flutter_analyse_1.png" alt="flutter_analyse_1"><img src="/images/flutter_tips_s2/flutter_analyse_2.png" alt="屏幕快照 2020-09-17 上午 2.24.55"></p><h3 id="参考配置"><a href="#参考配置" class="headerlink" title="参考配置"></a>参考配置</h3><p>当然你还可以根据你的需要定制自己的静态分析规则，下面是最近使用的一套配置，仅供你参考：</p><blockquote><p><a href="https://gist.github.com/wangruofeng/1451c04c0149fc229a726d819b3135c2">analysis_options.yaml 参考配置</a></p></blockquote><h2 id="dartfmt-命令"><a href="#dartfmt-命令" class="headerlink" title="dartfmt 命令"></a>dartfmt 命令</h2><ul><li><code>dartfmt ./ -w</code> 静态分析代码，并尝试自动修复</li><li><code>dartfmt ./ -n</code> 静态分析代码，不会修复代码</li></ul><h2 id="DevTool-介绍"><a href="#DevTool-介绍" class="headerlink" title="DevTool 介绍"></a>DevTool 介绍</h2><p>flutter 提供了一个 devTool 系列工具，方便开发者进行调试，查看日志，网络请求，性能等信息，更多信息请参考<a href="https://flutter.dev/docs/development/tools/devtools/overview">DevTools</a></p><h3 id="Install-DevTools"><a href="#Install-DevTools" class="headerlink" title="Install DevTools"></a>Install DevTools</h3><ul><li><a href="https://flutter.dev/docs/development/tools/devtools/cli">Install from command line</a></li><li><a href="https://flutter.dev/docs/development/tools/devtools/android-studio">Install and run DevTools from Android Studio</a></li><li><a href="https://flutter.dev/docs/development/tools/devtools/vscode">Install from VS Code</a></li></ul><h3 id="Launch-the-DevTools-application-server"><a href="#Launch-the-DevTools-application-server" class="headerlink" title="Launch the DevTools application server"></a>Launch the DevTools application server</h3><p>启动本地 web 服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pub global run devtools   # If you have  `pub`  on your path.</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub global run devtools   # If you have  `flutter`  on your path.</span><br></pre></td></tr></table></figure><p>在命令行，你应该看到类似下面输出，表明服务启动成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serving DevTools at http://127.0.0.1:9100</span><br></pre></td></tr></table></figure><h3 id="Start-an-application-to-debug"><a href="#Start-an-application-to-debug" class="headerlink" title="Start an application to debug"></a>Start an application to debug</h3><p>运行 app</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd path/to/flutter/app</span><br><span class="line">flutter run</span><br></pre></td></tr></table></figure><p>一旦你成功运行起来你的 app，你将在终端控制台看到如下类似的信息</p><p><img src="/images/flutter_tips_s2/flutter_tips_01.png" alt="image-20200917151951722"></p><p>用浏览器打开里面的地址，格式如下</p><blockquote><p><a href="http://127.0.0.1:59681/fVO-_3yziG8=/">http://127.0.0.1:59681/fVO-_3yziG8=/</a></p></blockquote><p>打开将会看到下面的调试面板，可以根据自己的需要进行调试</p><p><img src="/images/flutter_tips_s2/flutter_tips_02.png" alt="image-20200917152140975"></p><p>这里有一个很有用的功能，【debug】</p><p>打开页面可以查看断点的帧和控制台的日志。</p><p><img src="/images/flutter_tips_s2/flutter_tips_03.png" alt="image-20200917152456458"></p><h3 id="Open-DevTools-and-connect-to-the-target-app"><a href="#Open-DevTools-and-connect-to-the-target-app" class="headerlink" title="Open DevTools and connect to the target app"></a>Open DevTools and connect to the target app</h3><p>一旦工程运行起来了，在浏览器打开 <a href="http://localhost:9100，打开">http://localhost:9100，打开</a> DevTools 完整版本</p><p><img src="/images/flutter_tips_s2/flutter_tips_04.png" alt="image-20200917152646210"></p><p>输入上面的地址，点击 Connect，跳转到完整 devTools</p><p><img src="/images/flutter_tips_s2/flutter_tips_05.png" alt="image-20200917152806254"></p><p>这里的功能非常强大和具体使用可以参考官方文档</p><h2 id="flutter-调试"><a href="#flutter-调试" class="headerlink" title="flutter 调试"></a>flutter 调试</h2><p>这里以 VSCode 为例</p><h3 id="纯-flutter-项目"><a href="#纯-flutter-项目" class="headerlink" title="纯 flutter 项目"></a>纯 flutter 项目</h3><p>纯 flutter 项目比较简单，VSCode 支持各种 devtool，使用 debug 模式运行 app，或者直接按 F5</p><p><img src="/images/flutter_tips_s2/flutter_tips_06.png" alt="image-20200917150502934"></p><p>运行成功后会出现一下工具条</p><p><img src="/images/flutter_tips_s2/flutter_tips_07.png" alt="image-20200917150559335"></p><p>控制台输出以下内容</p><p><img src="/images/flutter_tips_s2/flutter_tips_08.png" alt="image-20200917150622481"></p><p>例如这里我们在这个文件 107 行直接下一个断点，代码执行到时会触发断点</p><p><img src="/images/flutter_tips_s2/flutter_tips_09.png" alt="image-20200917150821892"></p><p>此时工具栏变成下面的样式</p><p><img src="/images/flutter_tips_s2/flutter_tips_10.png" alt="image-20200917150846708"></p><p>可以通过相关的按钮进行断点调试</p><h3 id="混合项目-原生-flutter"><a href="#混合项目-原生-flutter" class="headerlink" title="混合项目(原生+flutter)"></a>混合项目(原生+flutter)</h3><ol><li><p>打开已经编译运行过的原生端 App</p></li><li><p>通过 VSCode 打开壳工程，进入壳工程根目录</p></li><li><p>选择 main.dart 文件</p></li><li><p>执行 cmd+shift+p,呼出 VSCode 命令面板，输入 <code>&gt;attach to flutter onDevice</code>  <img src="/images/flutter_tips_s2/flutter_tips_11.png" alt="image-20200917153401365"></p></li></ol><p> 选择下面的对应的命令执行</p><blockquote><p>如果 attach 不上请断开 wifi 重试</p></blockquote><ol start="5"><li>Attach 成功的话会显示下面一条悬浮工具栏和纯 flutter 相比里面多了一个类似插头的按钮</li></ol><p> <img src="/images/flutter_tips_s2/flutter_tips_12.png" alt="image-20200917153656732"></p><p> Debug Console 控制台也会输出下面信息</p><p> <img src="/images/flutter_tips_s2/flutter_tips_13.png" alt="image-20200917153719698"></p><ol start="5"><li><p>剩下的调试和上面 DevTool 介绍的流程一致</p></li><li><p>在这个项目里面可以直接对引用到的代码进行断点调试</p></li></ol><p> <img src="/images/flutter_tips_s2/flutter_tips_14.png" alt="image-20200917154306797"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://pub.dev/packages/analyzer">analyzer</a></p></li><li><p><a href="https://dart.dev/tools/dartfmt">dartfmt</a></p></li><li><p><a href="https://juejin.im/post/6844904176162439182#heading-11">Flutter Analysis Options</a></p></li><li><p><a href="https://dart.dev/guides/language/analysis-options">Customizing static analysis</a></p></li><li><p><a href="https://stackoverflow.com/questions/63914819/how-to-access-assets-in-package">How to access assets in package</a></p></li><li><p><a href="https://flutter.dev/docs/development/tools/devtools/overview">DevTools</a></p></li></ul><!-- processed 2 -->]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/cover_img/ramon-salinero-vEE00Hx5d0Q-unsplash.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="最佳实践" scheme="https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Flutter" scheme="https://blog.wangruofeng007.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 开发 Tips （第一期）</title>
    <link href="https://blog.wangruofeng007.com/2020/09/07/Flutter-%E5%BC%80%E5%8F%91Tips-%EF%BC%88%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%89/"/>
    <id>https://blog.wangruofeng007.com/2020/09/07/Flutter-%E5%BC%80%E5%8F%91Tips-%EF%BC%88%E7%AC%AC%E4%B8%80%E6%9C%9F%EF%BC%89/</id>
    <published>2020-09-06T17:00:18.000Z</published>
    <updated>2024-11-03T05:32:35.295Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/cover_img/markus-spiske-qjnAnF0jIGk-unsplash.jpg"></p><span id="more"></span><h2 id="…"><a href="#…" class="headerlink" title="…"></a>…</h2><p>延展操作符( <code>...</code> )可以对数组或者字典进行操作</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并数组</span></span><br><span class="line">test1() &#123;</span><br><span class="line">  <span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">var</span> list2 = [<span class="number">0</span>, ...list, <span class="number">4</span>];</span><br><span class="line">  <span class="built_in">print</span>(list2);</span><br><span class="line">  <span class="comment">// [0, 1, 2, 3, 4]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并字典</span></span><br><span class="line">test2() &#123;</span><br><span class="line">  <span class="keyword">var</span> map1 = &#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>: <span class="string">&quot;value1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key2&quot;</span>: <span class="string">&quot;value2&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> map2 = &#123;</span><br><span class="line">    <span class="string">&quot;key3&quot;</span>: <span class="string">&quot;value3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key4&quot;</span>: <span class="string">&quot;value4&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> map3 = &#123;...map1, ...map2&#125;;</span><br><span class="line">  <span class="built_in">print</span>(map3);</span><br><span class="line">  <span class="comment">// &#123;key1: value1, key2: value2, key3: value3, key4: value4&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for-…"><a href="#for-…" class="headerlink" title="for ()…[]"></a>for ()…[]</h2><p>合并 widgets 到集合中，使用 <code>for ()...[]</code> 范式，使用延展操作符( <code>...</code> )来合并一个数组的 widgets 到一个存在的集合中。例如在构造 Row 或者 Column 的 children 时，非常方便。下面是示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Food&gt; foods = [</span><br><span class="line">  Food(name: <span class="string">&#x27;apple&#x27;</span>, isVegetarian: <span class="keyword">true</span>),</span><br><span class="line">  Food(name: <span class="string">&#x27;nuts&#x27;</span>, isVegetarian: <span class="keyword">true</span>),</span><br><span class="line">  Food(name: <span class="string">&#x27;eggs&#x27;</span>, isVegetarian: <span class="keyword">true</span>),</span><br><span class="line">  Food(name: <span class="string">&#x27;chicken&#x27;</span>, isVegetarian: <span class="keyword">false</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">  Food(&#123;</span><br><span class="line">    <span class="keyword">this</span>.name,</span><br><span class="line">    <span class="keyword">this</span>.isVegetarian,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> isVegetarian;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> HomePage(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Column(</span><br><span class="line">        children: [</span><br><span class="line">          Container(),</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">final</span> food <span class="keyword">in</span> foods) ...[</span><br><span class="line">            <span class="keyword">if</span> (food.isVegetarian) ListTile(title: Text(food.name)),</span><br><span class="line">            SizedBox(height: <span class="number">50.0</span>),</span><br><span class="line">          ],</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="() {} ()"></a>() {} ()</h2><p>立即执行一个匿名函数： <code>() &#123;&#125; ()</code> ,相当于声明一个匿名函数并且里面执行，这种范式在处理一个 widget 可能有多种输出时特别有用。而不是使用镶嵌的三目运算符或者通过一个函数调用，这个代码跟内联。下面是示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">T getRandomElement&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; list) =&gt; list[Random().nextInt(list.length)];</span><br><span class="line"></span><br><span class="line">Column(</span><br><span class="line">          children: [</span><br><span class="line">            Container(</span><br><span class="line">              color: () &#123;</span><br><span class="line">                <span class="keyword">switch</span> (getRandomElement(foods).name) &#123;</span><br><span class="line">                  <span class="keyword">case</span> <span class="string">&#x27;apple&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> Colors.green;</span><br><span class="line">                  <span class="keyword">case</span> <span class="string">&#x27;nuts&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> Colors.brown;</span><br><span class="line">                  <span class="keyword">case</span> <span class="string">&#x27;eggs&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> Colors.yellow;</span><br><span class="line">                  <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> Colors.transparent;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;(),</span><br><span class="line">              child: Text(<span class="string">&#x27;Food of the Day&#x27;</span>),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h2 id="代码静态分析"><a href="#代码静态分析" class="headerlink" title="代码静态分析"></a>代码静态分析</h2><p>在提交代码时为了提高代码质量，保持团队的代码风格一致，需要进行代码静态分析，一般通过下面 2 种方法来进行</p><h3 id="flutter-analyze"><a href="#flutter-analyze" class="headerlink" title="flutter analyze"></a>flutter analyze</h3><p>使用 <code>flutter analyze</code> 进行代码静态分析,此命令会根据 <code>analysis_options.yaml</code> 定义的规则进行静态分析</p><h3 id="dartfmt"><a href="#dartfmt" class="headerlink" title="dartfmt"></a>dartfmt</h3><p>使用 <code>dartfmt ./ -w</code> 对当前目录以及子目录的 dart 代码进行代码, <code>-w</code> 选项会自动重写文件使其符合规范。</p><p>使用 <code>dartfmt ./ -n</code> 显示当前目录以及子目录的 dart 代码格式可以修改的文件但是不做修改，可以配合 ci 分析代码格式问题。</p><p>更多选项请使用 <code>dartfmt --help</code> 查看</p><h2 id="Push-present-Pop"><a href="#Push-present-Pop" class="headerlink" title="Push &amp; present &amp; Pop"></a>Push &amp; present &amp; Pop</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Push by route</span></span><br><span class="line">Navigator.pushNamed(context, <span class="string">&#x27;/b&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// push </span></span><br><span class="line">Navigator.of(context).push(MaterialPageRoute(builder: (BuildContext context) =&gt; MyPage()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// present</span></span><br><span class="line">Navigator.of(context).push(MaterialPageRoute(builder: (BuildContext context) =&gt; MyPage(),fullscreenDialog: <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// pop</span></span><br><span class="line">Navigator.pop(context)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// pop + push</span></span><br><span class="line">Navigator.of(context)</span><br><span class="line">..pop()</span><br><span class="line">..pop()</span><br><span class="line">..pushNamed(<span class="string">&#x27;/settings&#x27;</span>);</span><br></pre></td></tr></table></figure><p>API</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push</span></span><br><span class="line">Future push(BuildContext context, Route route)</span><br><span class="line"></span><br><span class="line"><span class="comment">// pop</span></span><br><span class="line"><span class="built_in">bool</span> pop(BuildContext context, [ result ])</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 下面两种是等效的</span></span><br><span class="line">Navigator.push(BuildContext context, Route route)</span><br><span class="line">Navigator.of(context).push(Route route)</span><br></pre></td></tr></table></figure><h2 id="获取-widget-的位置和宽高"><a href="#获取-widget-的位置和宽高" class="headerlink" title="获取 widget 的位置和宽高"></a>获取 widget 的位置和宽高</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> RenderBox box = keyContext.findRenderObject();</span><br><span class="line"><span class="keyword">final</span> size = box.size;</span><br><span class="line"><span class="keyword">final</span> topLeftPosition = box.localToGlobal(Offset.zero);</span><br></pre></td></tr></table></figure><p>See more</p><ul><li><p><a href="https://stackoverflow.com/questions/49307677/how-to-get-a-height-of-a-widget">How to get a height of a Widget?</a></p></li><li><p><a href="https://medium.com/@diegoveloper/flutter-widget-size-and-position-b0a9ffed9407">Flutter : Widget Size and Position</a></p></li></ul><h2 id="Model-To-JSON"><a href="#Model-To-JSON" class="headerlink" title="Model To JSON"></a>Model To JSON</h2><h3 id="json-serializable"><a href="#json-serializable" class="headerlink" title="json_serializable"></a>json_serializable</h3><ol><li><p>引入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="comment"># Your other regular dependencies here</span></span><br><span class="line">  <span class="attr">json_annotation:</span> <span class="string">^2.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line">  <span class="comment"># Your other dev_dependencies here</span></span><br><span class="line">  <span class="attr">build_runner:</span> <span class="string">^1.0.0</span></span><br><span class="line">  <span class="attr">json_serializable:</span> <span class="string">^2.0.0</span></span><br></pre></td></tr></table></figure></li><li><p>使用</p></li></ol>  <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:json_annotation/json_annotation.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user.g.dart 将在我们运行生成命令后自动生成</span></span><br><span class="line"><span class="keyword">part</span> <span class="string">&#x27;user.g.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///<span class="language-markdown">这个标注是告诉生成器，这个类是需要生成 Model 类的</span></span></span><br><span class="line"><span class="meta">@JsonSerializable</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  User(<span class="keyword">this</span>.name, <span class="keyword">this</span>.email);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">String</span> email;</span><br><span class="line">  <span class="comment">//不同的类使用不同的 mixin 即可</span></span><br><span class="line">  <span class="keyword">factory</span> User.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; json) =&gt; _$UserFromJson(json);</span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; toJson() =&gt; _$UserToJson(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>单次解析： <code>flutter packages pub run build_runner build</code> 4. 持续集成： <code>flutter packages pub run build_runner watch</code> 5. <a href="https://caijinglong.github.io/json2dart/index_ch.html">json_serializable 在线 json 转 dart model 工具</a></li></ol><h3 id="Built-value"><a href="#Built-value" class="headerlink" title="Built value"></a>Built value</h3><ol><li><p>在线 json 转 build value 模板工具 <a href="https://charafau.github.io/json2builtvalue/">https://charafau.github.io/json2builtvalue/</a></p></li><li><p><a href="https://marketplace.visualstudio.com/items?itemName=GiancarloCode.built-value-snippets">VSCode built value 插件 </a> </p></li><li><p>Sample code</p></li></ol>  <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface model</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:built_value/built_value.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">part</span> <span class="string">&#x27;user.g.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Built</span>&lt;<span class="title">User</span>, <span class="title">UserBuilder</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> name;</span><br><span class="line">  <span class="meta">@nullable</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> nickname;</span><br><span class="line">  User._();</span><br><span class="line">  <span class="keyword">factory</span> User([updates(UserBuilder b)]) = _$User;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="keyword">var</span> user1 = <span class="keyword">new</span> User((b) =&gt; b</span><br><span class="line">    ..name = <span class="string">&#x27;John Smith&#x27;</span></span><br><span class="line">    ..nickname = <span class="string">&#x27;Joe&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update</span></span><br><span class="line"><span class="keyword">var</span> user2 = user.rebuild((b) =&gt; b</span><br><span class="line">    ..nickname = <span class="string">&#x27;Jojo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update</span></span><br><span class="line"><span class="keyword">var</span> updatedStructuredData = structuredData.rebuild((b) =&gt; b</span><br><span class="line">    ..user.update((b) =&gt; b</span><br><span class="line">        ..name = <span class="string">&#x27;Johnathan Smith&#x27;</span>)</span><br><span class="line">    ..credentials.phone.update((b) =&gt; b</span><br><span class="line">        ..country = Country.switzerland</span><br><span class="line">        ..number = <span class="string">&#x27;555 01234 555&#x27;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// nested builders</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Built</span>&lt;<span class="title">Node</span>, <span class="title">NodeBuilder</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@nullable</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> label;</span><br><span class="line">  <span class="meta">@nullable</span></span><br><span class="line">  Node <span class="keyword">get</span> left; </span><br><span class="line">  <span class="meta">@nullable</span></span><br><span class="line">  Node <span class="keyword">get</span> right;</span><br><span class="line">  Node._();</span><br><span class="line">  <span class="keyword">factory</span> Node([updates(NodeBuilder b)]) = _$Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new or update</span></span><br><span class="line"><span class="keyword">var</span> node = <span class="keyword">new</span> Node((b) =&gt; b</span><br><span class="line">  ..left.left.left.right.left.right.label = <span class="string">&#x27;I’m a leaf!&#x27;</span></span><br><span class="line">  ..left.left.right.right.label = <span class="string">&#x27;I’m also a leaf!&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> updatedNode = node.rebuild((b) =&gt; b</span><br><span class="line">  ..left.left.right.right.label = <span class="string">&#x27;I’m not a leaf any more!&#x27;</span></span><br><span class="line">  ..left.left.right.right.right.label = <span class="string">&#x27;I’m the leaf now!&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://medium.com/dartlang/3-cool-dart-patterns-6d8d9d3d8fb8">3 cool Dart patterns</a></p></li><li><p><a href="https://pub.dev/packages/built_collection">built_collection - pub.dev</a></p></li><li><p><a href="https://medium.com/dartlang/darts-built-collection-for-immutable-collections-db662f705eff">Dart’s built_collection for Immutable Collections</a></p></li><li><p><a href="https://dart.dev/tools/dartfmt">dartfmt</a></p></li><li><p><a href="https://dart.dev/guides/language/analysis-options">Customizing static analysis</a></p></li></ul><!-- processed 2 -->]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/cover_img/markus-spiske-qjnAnF0jIGk-unsplash.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="最佳实践" scheme="https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Flutter" scheme="https://blog.wangruofeng007.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>开发 Flutter 有哪些好用的 VSCode 插件</title>
    <link href="https://blog.wangruofeng007.com/2020/07/31/%E5%BC%80%E5%8F%91Flutter%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84VSCode%E6%8F%92%E4%BB%B6/"/>
    <id>https://blog.wangruofeng007.com/2020/07/31/%E5%BC%80%E5%8F%91Flutter%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84VSCode%E6%8F%92%E4%BB%B6/</id>
    <published>2020-07-31T15:18:49.000Z</published>
    <updated>2024-11-03T05:32:35.290Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/cover_img/pexels-nastyasensei-335393.jpg"></p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这里整理了日常使用 vscode 开发 flutter 相关的插件，也有部分通用类型的插件</p><h2 id="Flutter-Dart"><a href="#Flutter-Dart" class="headerlink" title="Flutter &amp; Dart"></a><a href="https://marketplace.visualstudio.com/items?itemName=Dart-Code.flutter">Flutter</a> &amp; <a href="https://marketplace.visualstudio.com/items?itemName=Dart-Code.dart-code">Dart</a></h2><p>这 2 个是 flutter 官方插件，开发 flutter 装机必备，不用多说。</p><h2 id="Awesome-Flutter-Snippets"><a href="#Awesome-Flutter-Snippets" class="headerlink" title="Awesome Flutter Snippets"></a><a href="https://marketplace.visualstudio.com/items?itemName=Nash.awesome-flutter-snippets">Awesome Flutter Snippets</a></h2><blockquote><p>Awesome Flutter Snippets is a collection snippets and shortcuts for commonly used Flutter functions and classes</p></blockquote><p>这里面包含 Flutter 中非常常用的代码片段</p><h2 id="Bracket-Pair-Colorizer-2"><a href="#Bracket-Pair-Colorizer-2" class="headerlink" title="Bracket Pair Colorizer 2"></a><a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer-2">Bracket Pair Colorizer 2</a></h2><blockquote><p>A customizable extension for colorizing matching brackets</p></blockquote><p>这个插件可以使成对的括号带上不同颜色，特别适合 dart 这种嵌套层级很深声明式语言， 这个插件可以很方便的区分括号的开始和截止位置</p><p>![Bracket _Pair_Colorizer_2](&#x2F;images&#x2F;flutter_plugin&#x2F;Bracket _Pair_Colorizer_2.jpg)</p><h2 id="GitLens"><a href="#GitLens" class="headerlink" title="GitLens"></a><a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens">GitLens</a></h2><blockquote><p>Supercharge the Git capabilities built into Visual Studio Code — Visualize code authorship at a glance via Git blame annotations and code lens, seamlessly navigate and explore Git repositories, gain valuable insights via powerful comparison commands, and so much more</p></blockquote><p>最好用的 feature 是在该<a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens#current-line-blame-"><strong>行</strong></a>末尾的引人注目的<a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens#current-line-blame-"><strong>当前行责任</strong></a>注释，可通过<a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens#hovers-"><strong>悬停</strong></a>获取详细的责任信息，当然还有很多其他的 feature，请自行探索。</p><p><img src="/images/flutter_plugin/GitLens_01.png" alt="GitLens_01"></p><p>git 相关的右键菜单</p><p><img src="/images/flutter_plugin/GitLens_02.png" alt="GitLens_02"></p><h2 id="Color-Highlight"><a href="#Color-Highlight" class="headerlink" title="Color Highlight"></a><a href="https://marketplace.visualstudio.com/items?itemName=naumovs.color-highlight">Color Highlight</a></h2><blockquote><p>Highlight web colors in your editor</p></blockquote><p>web 颜色高亮，直接将颜色对应的 css 显示出来，非常直观</p><p><img src="/images/flutter_plugin/color_highlight.png" alt="color_highlight"></p><h2 id="Image-Preview"><a href="#Image-Preview" class="headerlink" title="Image Preview"></a><a href="https://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-gutter-preview">Image Preview</a></h2><blockquote><p>Shows image preview in the gutter and on hover</p></blockquote><p>单鼠标悬浮在带有图片的超链接上会显示预览图片</p><p><img src="/images/flutter_plugin/image_preview.png" alt="image_preview"></p><h2 id="pubspec-assist"><a href="#pubspec-assist" class="headerlink" title="pubspec assist"></a><a href="https://marketplace.visualstudio.com/items?itemName=jeroen-meijer.pubspec-assist">pubspec assist</a></h2><blockquote><p>Easily add and update dependencies to your Dart and Flutter project.</p></blockquote><p>下面是官方的演示效果，可以直接命令搜索 flutter 相关库</p><p><img src="https://i.imgur.com/W2cGuPL.gif" alt="img"></p><h2 id="Material-Icon-Theme"><a href="#Material-Icon-Theme" class="headerlink" title="Material Icon Theme"></a><a href="https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme">Material Icon Theme</a></h2><blockquote><p>Material Design Icons for Visual Studio Code</p></blockquote><p>针对不同的文件 icon 和文件夹 icon 设计了一套主题图标</p><p><img src="/images/flutter_plugin/file_icons.png" alt="file_icons"></p><p><img src="/images/flutter_plugin/folder_icons.png" alt="folder_icons"></p><h2 id="Error-lens"><a href="#Error-lens" class="headerlink" title="Error lens"></a><a href="https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens">Error lens</a></h2><blockquote><p>Improve highlighting of errors, warnings and other language diagnostics.</p></blockquote><p>增强了语言中的错误高亮效果，使错误提示在代码后面显示</p><p><img src="/images/flutter_plugin/error_lens.png" alt="error_lens"></p><h2 id="flutter-stylizer"><a href="#flutter-stylizer" class="headerlink" title="flutter-stylizer"></a><a href="https://marketplace.visualstudio.com/items?itemName=gmlewis-vscode.flutter-stylizer">flutter-stylizer</a></h2><blockquote><p>Flutter Stylizer organizes your Flutter classes in an opinionated and consistent manner.</p></blockquote><p>使 flutter 中的代码按照下面的方式排序，方便统一约束团队代码的结构</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;flutterStylizer.memberOrdering&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;public-constructor&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;named-constructors&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;public-static-variables&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;public-instance-variables&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;private-static-variables&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;private-instance-variables&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;public-override-methods&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;public-other-methods&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;build-method&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>当然这只是默认顺序，具体的顺序可以自行调整,插件安装完成后，通过快捷键格式化当前的文件</p><h2 id="RESTClient"><a href="#RESTClient" class="headerlink" title="RESTClient"></a><a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client">RESTClient</a></h2><blockquote><p>REST Client for Visual Studio Code</p></blockquote><p>在 VSCode 里面直接发送请求，能自动识别 <code>.http</code> 和 <code>.rest</code> 后缀的文件</p><p>点击 <code>Send Request</code> 开始发送请求。</p><p><img src="/images/flutter_plugin/RESTClient_02.png" alt="RESTClient_02"></p><p><img src="/images/flutter_plugin/RESTClient_01.png" alt="RESTClient_01"></p><!-- processed 2 -->]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/cover_img/pexels-nastyasensei-335393.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="效率" scheme="https://blog.wangruofeng007.com/categories/%E6%95%88%E7%8E%87/"/>
    
    
    <category term="插件" scheme="https://blog.wangruofeng007.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 中 Key 的作用</title>
    <link href="https://blog.wangruofeng007.com/2020/07/26/Flutter%E4%B8%ADKey%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>https://blog.wangruofeng007.com/2020/07/26/Flutter%E4%B8%ADKey%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2020-07-26T09:44:33.000Z</published>
    <updated>2024-11-03T05:32:35.301Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/cover_img/img_2-people-sitting-with-view-of-yellow-flowers-during-daytime.jpg"></p><span id="more"></span><h2 id="key-的定义"><a href="#key-的定义" class="headerlink" title="key 的定义"></a>key 的定义</h2><p>Key Class 官方介绍：</p><blockquote><p>A [Key] is an identifier for [Widget]s, [Element]s and [SemanticsNode]s.</p><p>A new widget will only be used to update an existing element if its key is</p><p>the same as the key of the current widget associated with the element.</p><p>{@youtube 560 315 <a href="https://www.youtube.com/watch?v=kn0EOS-ZiIc%7D">https://www.youtube.com/watch?v=kn0EOS-ZiIc}</a></p><p>Keys must be unique amongst the [Element]s with the same parent.</p><p>Subclasses of [Key] should either subclass [LocalKey] or [GlobalKey].</p></blockquote><p>翻译过来：</p><blockquote><p>一个 Key 是 Widget，Element 以及 SemanticsNode 的标识。</p><p>一个新 widget 将仅用来更新一个已存在的 element 假如它的 key 和当前 widget 关联的元素一致。</p><p>官方介绍视频 <a href="https://www.youtube.com/watch?v=kn0EOS-ZiIc">https://www.youtube.com/watch?v=kn0EOS-ZiIc</a></p><p>在有着相同父节点的 element 中，Key 必须是唯一的。</p><p>Key 的子类要么是 LocalKey，要么是 GlobalKey。</p></blockquote><p>Key 官方介绍：</p><blockquote><p>Controls how one widget replaces another widget in the tree.</p><p>If the <a href="https://api.flutter.dev/flutter/widgets/Widget/dart-core/Object/runtimeType.html">runtimeType</a> and <a href="https://api.flutter.dev/flutter/widgets/Widget/widgets/Widget/key.html">key</a> properties of the two widgets are <a href="https://api.flutter.dev/flutter/widgets/Widget/widgets/Widget/operator_equals.html">operator&#x3D;&#x3D;</a>, respectively, then the new widget replaces the old widget by updating the underlying element (i.e., by calling <a href="https://api.flutter.dev/flutter/widgets/Widget/widgets/Element/update.html">Element.update</a>with the new widget). Otherwise, the old element is removed from the tree, the new widget is inflated into an element, and the new element is inserted into the tree.</p><p>In addition, using a <a href="https://api.flutter.dev/flutter/widgets/Widget/widgets/GlobalKey-class.html">GlobalKey</a> as the widget’s <a href="https://api.flutter.dev/flutter/widgets/Widget/widgets/Widget/key.html">key</a> allows the element to be moved around the tree (changing parent) without losing state. When a new widget is found (its key and type do not match a previous widget in the same location), but there was a widget with that same global key elsewhere in the tree in the previous frame, then that widget’s element is moved to the new location.</p><p>Generally, a widget that is the only child of another widget does not need an explicit key.</p></blockquote><p>翻译过来：</p><blockquote><p>控制一个小部件如何替换树中的另一个小部件。</p><p>如果两个 widget 的<a href="https://api.flutter.dev/flutter/dart-core/Object/runtimeType.html">runtimeType</a>和<a href="https://api.flutter.dev/flutter/widgets/Widget/key.html">key</a>属性分别是相等的(<a href="https://api.flutter.dev/flutter/widgets/Widget/operator_equals.html">&#x3D;&#x3D;</a>)，则新 widget 通过更新基础 element（即，通过使用新的 widget 调用<a href="https://api.flutter.dev/flutter/widgets/Element/update.html">Element.update</a>）来替换旧 widget。否则，将从树中删除旧 element，将新 widget 放大为一个 element，然后将新 element 插入到树中。</p><p>另外，使用<a href="https://api.flutter.dev/flutter/widgets/GlobalKey-class.html">GlobalKey</a>作为窗口小部件的<a href="https://api.flutter.dev/flutter/widgets/Widget/key.html">key</a>允许该 element 在树上移动（更改父级）而不会丢失状态。当找到新的 widget（其键和类型与相同位置的先前 widget 不匹配），但是在前一帧的树中其他位置有一个具有相同全局键的 widget 时，该 widget 的 element 将移至新位置。</p><p>通常，作为另一个 widget 的唯一 child 的 widget 不需要显式 key。</p></blockquote><h2 id="Key-的作用"><a href="#Key-的作用" class="headerlink" title="Key 的作用"></a>Key 的作用</h2><p>大多数时候并不需要使用 key。</p><p>当需要在一个<strong>StatefulWidget</strong>集合中进行添加、删除、重排序等操作时，才是 key 登场的时候。</p><h3 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h3><p>下面这段代码在一个 Row 中展示了两个彩色方片（StatelessContainer），当点击按钮时，会交换两个方片的位置：</p><p><img src="/images/flutter_key/img_key_screen.png" alt="img_key_screen"></p><p>代码如下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatelessContainer</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Color color = Color.fromRGBO(</span><br><span class="line">      Random().nextInt(<span class="number">256</span>), Random().nextInt(<span class="number">256</span>), Random().nextInt(<span class="number">256</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      width: <span class="number">100</span>,</span><br><span class="line">      height: <span class="number">100</span>,</span><br><span class="line">      color: color,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ScreenState createState() =&gt; _ScreenState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Screen</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; widgets = [</span><br><span class="line">    StatelessContainer(),</span><br><span class="line">    StatelessContainer(),</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Row(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: widgets,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: switchWidget,</span><br><span class="line">        child: Icon(Icons.undo),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  switchWidget() &#123;</span><br><span class="line">    widgets.insert(<span class="number">0</span>, widgets.removeAt(<span class="number">1</span>));</span><br><span class="line">    setState(() &#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有状态组件"><a href="#有状态组件" class="headerlink" title="有状态组件"></a>有状态组件</h3><p>有状态组件的状态信息（如颜色）通常是存储在 state 中的，而 state 是存储在 element 树中的。</p><p>那么 Key 到底应该用到哪呢？<br>我们再来一个例子，我们把色块用 Padding 包装一下。运行之后会发现，色块并没有交换，而是以随机的形式在变换颜色。为什么呢？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  Screen(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ScreenState createState() =&gt; _ScreenState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Screen</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; widgets = [</span><br><span class="line">    Padding(</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      child: StatefulContainer(key: UniqueKey()),</span><br><span class="line">    ),</span><br><span class="line">    Padding(</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      child: StatefulContainer(key: UniqueKey()),</span><br><span class="line">    ),</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Row(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: widgets,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: switchWidget,</span><br><span class="line">        child: Icon(Icons.undo),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  switchWidget() &#123;</span><br><span class="line">    widgets.insert(<span class="number">0</span>, widgets.removeAt(<span class="number">1</span>));</span><br><span class="line">    setState(() &#123;&#125;);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;widgets[<span class="number">0</span>]&#125;</span>, <span class="subst">$&#123;widgets[<span class="number">1</span>]&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulContainer</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  StatefulContainer(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _StatefulContainerState createState() =&gt; _StatefulContainerState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_StatefulContainerState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StatefulContainer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Color color = Color.fromRGBO(</span><br><span class="line">      Random().nextInt(<span class="number">256</span>), Random().nextInt(<span class="number">256</span>), Random().nextInt(<span class="number">256</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      color: color,</span><br><span class="line">      width: <span class="number">100</span>,</span><br><span class="line">      height: <span class="number">100</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合我们上面的理论，我们分析一下这次的 Widget Tree 和 Element Tree，当我们交换元素后，Flutter element-to-widget matching algorithm,(元素-组件匹配算法)，开始进行对比，算法每次只对比一层，即 Padding 这一层。显然，Padding 并没有发生本质的变化。</p><p>于是开始进行第二层对比，在对比时 Flutter 发现元素与组件的 Key 并不匹配，于是，把它设置成不可用状态，但是这里所使用的 Key 只是本地 Key（Local Key），Flutter 并不能找到另一层里面的 Key（即另外一个 Padding Widget 中的 Key）所以，Flutter 就创建了一个新的 Widget，而这个 Widget 的颜色就成了我们看到的『随机色』。</p><p>通过上面的示例，我们能明显的看出，我们的 Key 要设置到组件树的 <strong>顶层</strong>，而这一层在改变时，才能复用或者更新状态。</p><p>修正版本：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  Screen(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ScreenState createState() =&gt; _ScreenState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Screen</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; widgets = [</span><br><span class="line">    Padding(</span><br><span class="line">      key: UniqueKey(),</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      child: StatefulContainer(),</span><br><span class="line">    ),</span><br><span class="line">    Padding(</span><br><span class="line">      key: UniqueKey(),</span><br><span class="line">      padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">      child: StatefulContainer(),</span><br><span class="line">    ),</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Row(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: widgets,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: switchWidget,</span><br><span class="line">        child: Icon(Icons.undo),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  switchWidget() &#123;</span><br><span class="line">    widgets.insert(<span class="number">0</span>, widgets.removeAt(<span class="number">1</span>));</span><br><span class="line">    setState(() &#123;&#125;);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;widgets[<span class="number">0</span>]&#125;</span>, <span class="subst">$&#123;widgets[<span class="number">1</span>]&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatelessContainer</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Color color = Color.fromRGBO(</span><br><span class="line">      Random().nextInt(<span class="number">256</span>), Random().nextInt(<span class="number">256</span>), Random().nextInt(<span class="number">256</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      color: color,</span><br><span class="line">      width: <span class="number">100</span>,</span><br><span class="line">      height: <span class="number">100</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulContainer</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  StatefulContainer(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _StatefulContainerState createState() =&gt; _StatefulContainerState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_StatefulContainerState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">StatefulContainer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Color color = Color.fromRGBO(</span><br><span class="line">      Random().nextInt(<span class="number">256</span>), Random().nextInt(<span class="number">256</span>), Random().nextInt(<span class="number">256</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      color: color,</span><br><span class="line">      width: <span class="number">100</span>,</span><br><span class="line">      height: <span class="number">100</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Key-的分类"><a href="#Key-的分类" class="headerlink" title="Key 的分类"></a>Key 的分类</h2><p><img src="/images/flutter_key/img_key.png" alt="img_key"></p><ul><li>ValueKey:以一个值为 key。</li><li>ObjectKey:以一个对象为 key。</li><li>UniqueKey:生成唯一的随机数作为 key。</li><li>PageStorageKey:专用于存储页面滚动位置的 key。</li><li>GlobalKey:见后文。</li></ul><h2 id="何时使用-key"><a href="#何时使用-key" class="headerlink" title="何时使用 key"></a>何时使用 key</h2><h3 id="ValueKey"><a href="#ValueKey" class="headerlink" title="ValueKey"></a>ValueKey</h3><p>如果您有一个 Todo List 应用程序，它将会记录你需要完成的事情。我们假设每个 Todo 事情都各不相同，而你想要对每个 Todo 进行滑动删除操作。</p><p>这时候就需要使用 ValueKey！</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> TodoItem(</span><br><span class="line">    key: ValueKey(todo.task),</span><br><span class="line">    todo: todo,</span><br><span class="line">    onDismissed: (direction)&#123;</span><br><span class="line">        _removeTodo(context, todo);</span><br><span class="line">    &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="ObjectKey"><a href="#ObjectKey" class="headerlink" title="ObjectKey"></a>ObjectKey</h3><p>如果你有一个生日应用，它可以记录某个人的生日，并用列表显示出来，同样的还是需要有一个滑动删除操作。</p><p>我们知道人名可能会重复，这时候你无法保证给 Key 的值每次都会不同。但是，当人名和生日组合起来的 Object 将具有唯一性。</p><p>这时候你需要使用 ObjectKey！</p><h3 id="UniqueKey"><a href="#UniqueKey" class="headerlink" title="UniqueKey"></a>UniqueKey</h3><p>如果组合的 Object 都无法满足唯一性的时候，你想要确保每一个 Key 都具有唯一性。那么，你可以使用 UniqueKey。它将会通过该对象生成一个具有唯一性的 hash 码。</p><p>不过这样做，每次 Widget 被构建时都会去重新生成一个新的 UniqueKey，失去了一致性。也就是说你的小部件还是会改变。（还不如不用😂）</p><h3 id="PageStorageKey"><a href="#PageStorageKey" class="headerlink" title="PageStorageKey"></a>PageStorageKey</h3><p>当你有一个滑动列表，你通过某一个 Item 跳转到了一个新的页面，当你返回之前的列表页面时，你发现滑动的距离回到了顶部。这时候，给 Sliver 一个 PageStorageKey！它将能够保持 Sliver 的滚动状态。</p><h3 id="GlobalKey"><a href="#GlobalKey" class="headerlink" title="GlobalKey"></a>GlobalKey</h3><p>每个 globalkey 都是一个在整个应用内唯一的 key。</p><p>globalkey 相对而言是比较昂贵的，如果你并不需要 globalkey 的某些特性，那么可以考虑使用 Key、ValueKey、ObjectKey 或 UniqueKey。</p><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途 1"></a>用途 1</h4><p>允许 widget 在应用程序中的任何位置更改其 parent 而不丢失其状态。应用场景：在两个不同的屏幕上显示相同的 widget，并保持状态相同。</p><h4 id="用途-2"><a href="#用途-2" class="headerlink" title="用途 2"></a>用途 2</h4><p>GlobalKey 能够跨 Widget 访问状态。 在这里我们有一个 Switcher 小部件，它可以通过 changeState 改变它的状态。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwitcherScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">SwitcherScreen</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> isActive = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Switch.adaptive(</span><br><span class="line">            value: isActive,</span><br><span class="line">            onChanged: (<span class="built_in">bool</span> currentStatus) &#123;</span><br><span class="line">              isActive = currentStatus;</span><br><span class="line">              setState(() &#123;&#125;);</span><br><span class="line">            &#125;),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeState() &#123;</span><br><span class="line">    isActive = !isActive;</span><br><span class="line">    setState(() &#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们想要在外部改变该状态，这时候就需要使用 GlobalKey。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ScreenState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Screen</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> GlobalKey&lt;SwitcherScreenState&gt; key = GlobalKey&lt;SwitcherScreenState&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SwitcherScreen(</span><br><span class="line">        key: key,</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(onPressed: () &#123;</span><br><span class="line">        key.currentState.changeState();</span><br><span class="line">      &#125;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们通过定义了一个 GlobalKey 并传递给 SwitcherScreen。然后我们便可以通过这个 key 拿到它所绑定的 SwitcherState 并在外部调用 changeState 改变状态了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.youtube.com/watch?v=kn0EOS-ZiIc&feature=youtu.be">何时使用密钥 - Flutter 小部件 101 第四集</a></p></li><li><p><a href="https://flutter.dev/docs/development/ui/widgets-intro#keys">widgets-intro#keys</a></p></li><li><p><a href="https://juejin.im/post/5ca2152f6fb9a05e1a7a9a26">Flutter | 深入浅出 Key</a></p></li><li><p><a href="https://blog.csdn.net/al4fun/article/details/95854045">Flutter 中的 Key 和 GlobalKey</a></p></li></ul><!-- processed 2 -->]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/cover_img/img_2-people-sitting-with-view-of-yellow-flowers-during-daytime.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="最佳实践" scheme="https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Key" scheme="https://blog.wangruofeng007.com/tags/Key/"/>
    
  </entry>
  
  <entry>
    <title>Flutter factory 使用总结</title>
    <link href="https://blog.wangruofeng007.com/2020/07/26/Flutter-factory-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.wangruofeng007.com/2020/07/26/Flutter-factory-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2020-07-26T08:54:39.000Z</published>
    <updated>2024-11-03T05:32:35.296Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/cover_img/img_photography-of-airplane-during-sunrise.jpg"></p><span id="more"></span><h2 id="0x01-官方描述"><a href="#0x01-官方描述" class="headerlink" title="0x01 官方描述"></a>0x01 官方描述</h2><blockquote><p>Use the <code>factory</code> keyword when implementing a constructor that doesn’t always create a new instance of its class. For example, a factory constructor might return an instance from a cache, or it might return an instance of a subtype.</p><p>当实现并非总是创建其类的新实例的构造函数时，请使用“ factory”关键字。例如，工厂构造函数可能会从缓存返回一个实例，或者可能会返回一个子类型的实例。</p></blockquote><h2 id="0x02-使用场景"><a href="#0x02-使用场景" class="headerlink" title="0x02 使用场景"></a>0x02 使用场景</h2><ol><li><p>避免创建过多的重复实例，如果该实例已创建，则直接从缓存获取。</p></li><li><p>调用子类的构造函数(工厂模式 factory pattern）</p></li><li><p>实现单例模式(singleton pattern)</p></li></ol><h2 id="0x03-Demo"><a href="#0x03-Demo" class="headerlink" title="0x03 Demo"></a>0x03 Demo</h2><h3 id="创建缓存实例"><a href="#创建缓存实例" class="headerlink" title="创建缓存实例"></a>创建缓存实例</h3><blockquote><p>引用自 <a href="https://dart.dev/guides/language/language-tour#factory-constructors">https://dart.dev/guides/language/language-tour#factory-constructors</a></p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="comment">// 缓存 Map</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache = &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="comment">// name 对应的 key 在_cache 不存在，执行 Logger._internal(name)，否则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> _cache.putIfAbsent(name, () =&gt; Logger._internal(name));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有构造函数</span></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;生成新实例:<span class="subst">$name</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> p1 = Logger(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = Logger(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> p3 = Logger(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(identical(p1, p2));</span><br><span class="line">  <span class="built_in">print</span>(identical(p1, p3));</span><br><span class="line">  <span class="comment">// 生成新实例:1</span></span><br><span class="line">  <span class="comment">// 生成新实例:2</span></span><br><span class="line">  <span class="comment">// false</span></span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用子类的构造函数"><a href="#调用子类的构造函数" class="headerlink" title="调用子类的构造函数"></a>调用子类的构造函数</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">void</span> getNoise();</span><br><span class="line">  <span class="keyword">factory</span> Animal(<span class="built_in">String</span> type, <span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;cat&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> Cat(name);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;dog&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> Dog(name);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;The &#x27;<span class="subst">$type</span>&#x27; is not an animal&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  Cat(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> getNoise() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>:mew~&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  Dog(<span class="keyword">this</span>.name);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> getNoise() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>:wang~&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> cat = Animal(<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;haha&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> dog = Animal(<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;hehe&#x27;</span>);</span><br><span class="line">  cat.getNoise();</span><br><span class="line">  dog.getNoise();</span><br><span class="line">  <span class="comment">// haha:mew~</span></span><br><span class="line">  <span class="comment">// hehe:wang~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Singleton _singleton = Singleton._internal();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Singleton() &#123;</span><br><span class="line">    <span class="keyword">return</span> _singleton;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Singleton._internal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> s1 = Singleton();</span><br><span class="line">  <span class="keyword">var</span> s2 = Singleton();</span><br><span class="line">  <span class="built_in">print</span>(identical(s1, s2));</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- processed 2 -->]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/cover_img/img_photography-of-airplane-during-sunrise.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="最佳实践" scheme="https://blog.wangruofeng007.com/categories/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Flutter" scheme="https://blog.wangruofeng007.com/tags/Flutter/"/>
    
  </entry>
  
</feed>
